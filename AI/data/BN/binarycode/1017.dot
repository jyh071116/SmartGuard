digraph G {
// Function: 1017.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_225(uint256) = a + b
c(uint256) := TMP_225(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_226(bool) = c >= a
TMP_227(None) = SOLIDITY_CALL assert(bool)(TMP_226)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1017.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_221(uint256) = a / b
c(uint256) := TMP_221(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1017.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_216(bool) = a == 0
CONDITION TMP_216"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_217(uint256) = a * b
c(uint256) := TMP_217(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_218(uint256) = c / a
TMP_219(bool) = TMP_218 == b
TMP_220(None) = SOLIDITY_CALL assert(bool)(TMP_219)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1017.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_222(bool) = b <= a
TMP_223(None) = SOLIDITY_CALL assert(bool)(TMP_222)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_224(uint256) = a - b
RETURN TMP_224"];
}
// Function: 1017.sol-ZethrBankrollBridge-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_3(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_3(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_13 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_13(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1017.sol-ZethrBankrollBridge-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_7(bool) -> ValidBankrollAddress[msg.sender]
TMP_17(None) = SOLIDITY_CALL require(bool,string)(REF_7,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-ZethrBankrollBridge-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_15(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_6(address) -> UsedBankrollAddresses[TMP_15]
TMP_16 = CONVERT REF_6 to ZethrTokenBankroll
RETURN TMP_16"];
}
// Function: 1017.sol-ZethrBankrollBridge-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_8 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_8(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_9 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_10(address[7]) = HIGH_LEVEL_CALL, dest:TMP_9(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_10(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_11(bool) = i < 7
CONDITION TMP_11"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_1(address) -> UsedBankrollAddresses[i]
REF_2(bool) -> ValidBankrollAddress[REF_1]
REF_2(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_12(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1017.sol-ZethrInterface-withdraw()
digraph{
}
// Function: 1017.sol-ZethrMainBankroll-gameGetTokenBankrollList()
digraph{
}
// Function: 1017.sol-ZethrShell-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_11(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_11(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_23 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_23(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1017.sol-ZethrShell-WithdrawAndTransferToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:Zethr(ZethrInterface), function:withdraw, arguments:[]  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WithdrawToBankroll()

IRs:
INTERNAL_CALL, ZethrShell.WithdrawToBankroll()()"];
}
// Function: 1017.sol-ZethrShell-WithdrawToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_15(address) -> UsedBankrollAddresses[0]
TMP_27 = CONVERT REF_15 to address
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
Transfer dest:TMP_27 value:TMP_29"];
}
// Function: 1017.sol-ZethrShell-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_18(bool) -> ValidBankrollAddress[msg.sender]
TMP_33(None) = SOLIDITY_CALL require(bool,string)(REF_18,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-ZethrShell-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_25(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_14(address) -> UsedBankrollAddresses[TMP_25]
TMP_26 = CONVERT REF_14 to ZethrTokenBankroll
RETURN TMP_26"];
}
// Function: 1017.sol-ZethrShell-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_18 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_18(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_19 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_20(address[7]) = HIGH_LEVEL_CALL, dest:TMP_19(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_20(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_21(bool) = i < 7
CONDITION TMP_21"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_9(address) -> UsedBankrollAddresses[i]
REF_10(bool) -> ValidBankrollAddress[REF_9]
REF_10(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_22(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1017.sol-ZethrTierLibrary-getTier(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
actualDiv = divRate

IRs:
actualDiv(uint256) := divRate(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
actualDiv >= 30

IRs:
TMP_0(bool) = actualDiv >= 30
CONDITION TMP_0"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
6

IRs:
RETURN 6"];
4[label="Node Type: IF 4

EXPRESSION:
actualDiv >= 25

IRs:
TMP_1(bool) = actualDiv >= 25
CONDITION TMP_1"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
5

IRs:
RETURN 5"];
6[label="Node Type: IF 6

EXPRESSION:
actualDiv >= 20

IRs:
TMP_2(bool) = actualDiv >= 20
CONDITION TMP_2"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
4

IRs:
RETURN 4"];
8[label="Node Type: IF 8

EXPRESSION:
actualDiv >= 15

IRs:
TMP_3(bool) = actualDiv >= 15
CONDITION TMP_3"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
3

IRs:
RETURN 3"];
10[label="Node Type: IF 10

EXPRESSION:
actualDiv >= 10

IRs:
TMP_4(bool) = actualDiv >= 10
CONDITION TMP_4"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
2

IRs:
RETURN 2"];
12[label="Node Type: IF 12

EXPRESSION:
actualDiv >= 5

IRs:
TMP_5(bool) = actualDiv >= 5
CONDITION TMP_5"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: RETURN 13

EXPRESSION:
1

IRs:
RETURN 1"];
14[label="Node Type: IF 14

EXPRESSION:
actualDiv >= 2

IRs:
TMP_6(bool) = actualDiv >= 2
CONDITION TMP_6"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: RETURN 15

EXPRESSION:
0

IRs:
RETURN 0"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
revert()()

IRs:
TMP_7(None) = SOLIDITY_CALL revert()()"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: END_IF 23
"];
}
// Function: 1017.sol-ZethrTokenBankroll-gameRequestTokens(address,uint256)
digraph{
}
// Function: 1017.sol-ZethrTokenBankroll-gameTokenAmount(address)
digraph{
}
// Function: 1017.sol-Zlots-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_25(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_25(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_45 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_45(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1017.sol-Zlots-WithdrawAndTransferToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:Zethr(ZethrInterface), function:withdraw, arguments:[]  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WithdrawToBankroll()

IRs:
INTERNAL_CALL, ZethrShell.WithdrawToBankroll()()"];
}
// Function: 1017.sol-Zlots-WithdrawToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_19(address) -> UsedBankrollAddresses[0]
TMP_34 = CONVERT REF_19 to address
TMP_35 = CONVERT this to address
TMP_36(uint256) = SOLIDITY_CALL balance(address)(TMP_35)
Transfer dest:TMP_34 value:TMP_36"];
}
// Function: 1017.sol-Zlots-_finishSpin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spin = playerSpins[target]

IRs:
REF_46(Zlots.playerSpin) -> playerSpins[target]
spin(Zlots.playerSpin) := REF_46(Zlots.playerSpin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(spin.tokenValue > 0)

IRs:
REF_47(uint200) -> spin.tokenValue
TMP_72(bool) = REF_47 > 0
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(spin.blockn != block.number)

IRs:
REF_48(uint48) -> spin.blockn
TMP_74(bool) = REF_48 != block.number
TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
profit = 0

IRs:
profit(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
category = 0

IRs:
category(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
playerDivrate = spin.divRate

IRs:
REF_49(uint256) -> spin.divRate
playerDivrate(uint256) := REF_49(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
block.number - spin.blockn > 255

IRs:
REF_50(uint48) -> spin.blockn
TMP_76(uint256) = block.number - REF_50
TMP_77(bool) = TMP_76 > 255
CONDITION TMP_77"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
result = 1000000

IRs:
result(uint256) := 1000000(uint256)"];
9->11;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
result = random(1000000,spin.blockn,target) + 1

IRs:
REF_51(uint48) -> spin.blockn
TMP_78(uint256) = INTERNAL_CALL, Zlots.random(uint256,uint256,address)(1000000,REF_51,target)
TMP_79(uint256) = TMP_78 + 1
result(uint256) := TMP_79(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
result > 506856

IRs:
TMP_80(bool) = result > 506856
CONDITION TMP_80"];
12->13[label="True"];
12->17[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
RequestBankrollPayment(zlotsJackpot,spin.tokenValue / 100,tier)

IRs:
REF_52(uint200) -> spin.tokenValue
TMP_81(uint200) = REF_52 / 100
INTERNAL_CALL, ZethrBankrollBridge.RequestBankrollPayment(address,uint256,uint256)(zlotsJackpot,TMP_81,tier)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0),uint256(0))

IRs:
REF_53(Zlots.playerSpin) -> playerSpins[target]
TMP_83 = CONVERT 0 to uint200
TMP_84 = CONVERT 0 to uint48
TMP_85 = CONVERT 0 to uint8
TMP_86 = CONVERT 0 to uint256
TMP_87(Zlots.playerSpin) = new playerSpin(TMP_83,TMP_84,TMP_85,TMP_86)
REF_53(Zlots.playerSpin) (->playerSpins) := TMP_87(Zlots.playerSpin)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Loss(target,spin.blockn)

IRs:
REF_54(uint48) -> spin.blockn
Emit Loss(target,REF_54)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,false)

IRs:
REF_55(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_55,category,False)"];
16->119;
17[label="Node Type: IF 17

EXPRESSION:
result < 2

IRs:
TMP_90(bool) = result < 2
CONDITION TMP_90"];
17->18[label="True"];
17->25[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
profit = ZlotsJackpotHoldingContract(zlotsJackpot).getJackpot()

IRs:
TMP_91 = CONVERT zlotsJackpot to ZlotsJackpotHoldingContract
TMP_92(uint256) = HIGH_LEVEL_CALL, dest:TMP_91(ZlotsJackpotHoldingContract), function:getJackpot, arguments:[]  
profit(uint256) := TMP_92(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
category = 1

IRs:
category(uint256) := 1(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
ThreeMoonJackpot(target,spin.blockn)

IRs:
REF_57(uint48) -> spin.blockn
Emit ThreeMoonJackpot(target,REF_57)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,true)

IRs:
REF_58(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_58,category,True)"];
21->22;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
tier = spin.tier

IRs:
REF_59(uint8) -> spin.tier
tier(uint8) := REF_59(uint8)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0),uint256(0))

IRs:
REF_60(Zlots.playerSpin) -> playerSpins[target]
TMP_95 = CONVERT 0 to uint200
TMP_96 = CONVERT 0 to uint48
TMP_97 = CONVERT 0 to uint8
TMP_98 = CONVERT 0 to uint256
TMP_99(Zlots.playerSpin) = new playerSpin(TMP_95,TMP_96,TMP_97,TMP_98)
REF_60(Zlots.playerSpin) (->playerSpins) := TMP_99(Zlots.playerSpin)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target)

IRs:
TMP_100 = CONVERT zlotsJackpot to ZlotsJackpotHoldingContract
HIGH_LEVEL_CALL, dest:TMP_100(ZlotsJackpotHoldingContract), function:payOutWinner, arguments:['target']  "];
24->118;
25[label="Node Type: IF 25

EXPRESSION:
result < 299

IRs:
TMP_102(bool) = result < 299
CONDITION TMP_102"];
25->26[label="True"];
25->29[label="False"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,50)

IRs:
REF_63(uint200) -> spin.tokenValue
TMP_103(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_63', '50'] 
profit(uint256) := TMP_103(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
category = 2

IRs:
category(uint256) := 2(uint256)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
TwoMoonPrize(target,spin.blockn)

IRs:
REF_64(uint48) -> spin.blockn
Emit TwoMoonPrize(target,REF_64)"];
28->112;
29[label="Node Type: IF 29

EXPRESSION:
result < 3128

IRs:
TMP_105(bool) = result < 3128
CONDITION TMP_105"];
29->30[label="True"];
29->33[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,20)

IRs:
REF_66(uint200) -> spin.tokenValue
TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_66', '20'] 
profit(uint256) := TMP_106(uint256)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
category = 3

IRs:
category(uint256) := 3(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
ZTHPrize(target,spin.blockn)

IRs:
REF_67(uint48) -> spin.blockn
Emit ZTHPrize(target,REF_67)"];
32->111;
33[label="Node Type: IF 33

EXPRESSION:
result < 16961

IRs:
TMP_108(bool) = result < 16961
CONDITION TMP_108"];
33->34[label="True"];
33->37[label="False"];
34[label="Node Type: EXPRESSION 34

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,30),10)

IRs:
REF_70(uint200) -> spin.tokenValue
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_70', '30'] 
TMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_109', '10'] 
profit(uint256) := TMP_110(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
category = 4

IRs:
category(uint256) := 4(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
ThreeZSymbols(target,spin.blockn)

IRs:
REF_71(uint48) -> spin.blockn
Emit ThreeZSymbols(target,REF_71)"];
36->110;
37[label="Node Type: IF 37

EXPRESSION:
result < 30794

IRs:
TMP_112(bool) = result < 30794
CONDITION TMP_112"];
37->38[label="True"];
37->41[label="False"];
38[label="Node Type: EXPRESSION 38

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,30),10)

IRs:
REF_74(uint200) -> spin.tokenValue
TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_74', '30'] 
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_113', '10'] 
profit(uint256) := TMP_114(uint256)"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
category = 5

IRs:
category(uint256) := 5(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
ThreeTSymbols(target,spin.blockn)

IRs:
REF_75(uint48) -> spin.blockn
Emit ThreeTSymbols(target,REF_75)"];
40->109;
41[label="Node Type: IF 41

EXPRESSION:
result < 44627

IRs:
TMP_116(bool) = result < 44627
CONDITION TMP_116"];
41->42[label="True"];
41->45[label="False"];
42[label="Node Type: EXPRESSION 42

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,30),10)

IRs:
REF_78(uint200) -> spin.tokenValue
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_78', '30'] 
TMP_118(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_117', '10'] 
profit(uint256) := TMP_118(uint256)"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
category = 6

IRs:
category(uint256) := 6(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
ThreeHSymbols(target,spin.blockn)

IRs:
REF_79(uint48) -> spin.blockn
Emit ThreeHSymbols(target,REF_79)"];
44->108;
45[label="Node Type: IF 45

EXPRESSION:
result < 46627

IRs:
TMP_120(bool) = result < 46627
CONDITION TMP_120"];
45->46[label="True"];
45->49[label="False"];
46[label="Node Type: EXPRESSION 46

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,11)

IRs:
REF_81(uint200) -> spin.tokenValue
TMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_81', '11'] 
profit(uint256) := TMP_121(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
category = 7

IRs:
category(uint256) := 7(uint256)"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
ThreeEtherIcons(target,spin.blockn)

IRs:
REF_82(uint48) -> spin.blockn
Emit ThreeEtherIcons(target,REF_82)"];
48->107;
49[label="Node Type: IF 49

EXPRESSION:
result < 49127

IRs:
TMP_123(bool) = result < 49127
CONDITION TMP_123"];
49->50[label="True"];
49->53[label="False"];
50[label="Node Type: EXPRESSION 50

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,75),10)

IRs:
REF_85(uint200) -> spin.tokenValue
TMP_124(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_85', '75'] 
TMP_125(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_124', '10'] 
profit(uint256) := TMP_125(uint256)"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
category = 8

IRs:
category(uint256) := 8(uint256)"];
51->52;
52[label="Node Type: EXPRESSION 52

EXPRESSION:
ThreePurplePyramids(target,spin.blockn)

IRs:
REF_86(uint48) -> spin.blockn
Emit ThreePurplePyramids(target,REF_86)"];
52->106;
53[label="Node Type: IF 53

EXPRESSION:
result < 51627

IRs:
TMP_127(bool) = result < 51627
CONDITION TMP_127"];
53->54[label="True"];
53->57[label="False"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,9)

IRs:
REF_88(uint200) -> spin.tokenValue
TMP_128(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_88', '9'] 
profit(uint256) := TMP_128(uint256)"];
54->55;
55[label="Node Type: EXPRESSION 55

EXPRESSION:
category = 9

IRs:
category(uint256) := 9(uint256)"];
55->56;
56[label="Node Type: EXPRESSION 56

EXPRESSION:
ThreeGoldPyramids(target,spin.blockn)

IRs:
REF_89(uint48) -> spin.blockn
Emit ThreeGoldPyramids(target,REF_89)"];
56->105;
57[label="Node Type: IF 57

EXPRESSION:
result < 53127

IRs:
TMP_130(bool) = result < 53127
CONDITION TMP_130"];
57->58[label="True"];
57->61[label="False"];
58[label="Node Type: EXPRESSION 58

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,13)

IRs:
REF_91(uint200) -> spin.tokenValue
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_91', '13'] 
profit(uint256) := TMP_131(uint256)"];
58->59;
59[label="Node Type: EXPRESSION 59

EXPRESSION:
category = 10

IRs:
category(uint256) := 10(uint256)"];
59->60;
60[label="Node Type: EXPRESSION 60

EXPRESSION:
ThreeRockets(target,spin.blockn)

IRs:
REF_92(uint48) -> spin.blockn
Emit ThreeRockets(target,REF_92)"];
60->104;
61[label="Node Type: IF 61

EXPRESSION:
result < 82530

IRs:
TMP_133(bool) = result < 82530
CONDITION TMP_133"];
61->62[label="True"];
61->65[label="False"];
62[label="Node Type: EXPRESSION 62

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,25),10)

IRs:
REF_95(uint200) -> spin.tokenValue
TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_95', '25'] 
TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_134', '10'] 
profit(uint256) := TMP_135(uint256)"];
62->63;
63[label="Node Type: EXPRESSION 63

EXPRESSION:
category = 11

IRs:
category(uint256) := 11(uint256)"];
63->64;
64[label="Node Type: EXPRESSION 64

EXPRESSION:
OneMoonPrize(target,spin.blockn)

IRs:
REF_96(uint48) -> spin.blockn
Emit OneMoonPrize(target,REF_96)"];
64->103;
65[label="Node Type: IF 65

EXPRESSION:
result < 150423

IRs:
TMP_137(bool) = result < 150423
CONDITION TMP_137"];
65->66[label="True"];
65->69[label="False"];
66[label="Node Type: EXPRESSION 66

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,15),10)

IRs:
REF_99(uint200) -> spin.tokenValue
TMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_99', '15'] 
TMP_139(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_138', '10'] 
profit(uint256) := TMP_139(uint256)"];
66->67;
67[label="Node Type: EXPRESSION 67

EXPRESSION:
category = 12

IRs:
category(uint256) := 12(uint256)"];
67->68;
68[label="Node Type: EXPRESSION 68

EXPRESSION:
OneOfEachPyramidPrize(target,spin.blockn)

IRs:
REF_100(uint48) -> spin.blockn
Emit OneOfEachPyramidPrize(target,REF_100)"];
68->102;
69[label="Node Type: IF 69

EXPRESSION:
result < 203888

IRs:
TMP_141(bool) = result < 203888
CONDITION TMP_141"];
69->70[label="True"];
69->73[label="False"];
70[label="Node Type: EXPRESSION 70

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_101(uint200) -> spin.tokenValue
profit(uint256) := REF_101(uint200)"];
70->71;
71[label="Node Type: EXPRESSION 71

EXPRESSION:
category = 13

IRs:
category(uint256) := 13(uint256)"];
71->72;
72[label="Node Type: EXPRESSION 72

EXPRESSION:
TwoZSymbols(target,spin.blockn)

IRs:
REF_102(uint48) -> spin.blockn
Emit TwoZSymbols(target,REF_102)"];
72->101;
73[label="Node Type: IF 73

EXPRESSION:
result < 257353

IRs:
TMP_143(bool) = result < 257353
CONDITION TMP_143"];
73->74[label="True"];
73->77[label="False"];
74[label="Node Type: EXPRESSION 74

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_103(uint200) -> spin.tokenValue
profit(uint256) := REF_103(uint200)"];
74->75;
75[label="Node Type: EXPRESSION 75

EXPRESSION:
category = 14

IRs:
category(uint256) := 14(uint256)"];
75->76;
76[label="Node Type: EXPRESSION 76

EXPRESSION:
TwoTSymbols(target,spin.blockn)

IRs:
REF_104(uint48) -> spin.blockn
Emit TwoTSymbols(target,REF_104)"];
76->100;
77[label="Node Type: IF 77

EXPRESSION:
result < 310818

IRs:
TMP_145(bool) = result < 310818
CONDITION TMP_145"];
77->78[label="True"];
77->81[label="False"];
78[label="Node Type: EXPRESSION 78

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_105(uint200) -> spin.tokenValue
profit(uint256) := REF_105(uint200)"];
78->79;
79[label="Node Type: EXPRESSION 79

EXPRESSION:
category = 15

IRs:
category(uint256) := 15(uint256)"];
79->80;
80[label="Node Type: EXPRESSION 80

EXPRESSION:
TwoHSymbols(target,spin.blockn)

IRs:
REF_106(uint48) -> spin.blockn
Emit TwoHSymbols(target,REF_106)"];
80->99;
81[label="Node Type: IF 81

EXPRESSION:
result < 364283

IRs:
TMP_147(bool) = result < 364283
CONDITION TMP_147"];
81->82[label="True"];
81->85[label="False"];
82[label="Node Type: EXPRESSION 82

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,2)

IRs:
REF_108(uint200) -> spin.tokenValue
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_108', '2'] 
profit(uint256) := TMP_148(uint256)"];
82->83;
83[label="Node Type: EXPRESSION 83

EXPRESSION:
category = 16

IRs:
category(uint256) := 16(uint256)"];
83->84;
84[label="Node Type: EXPRESSION 84

EXPRESSION:
TwoEtherIcons(target,spin.blockn)

IRs:
REF_109(uint48) -> spin.blockn
Emit TwoEtherIcons(target,REF_109)"];
84->98;
85[label="Node Type: IF 85

EXPRESSION:
result < 417748

IRs:
TMP_150(bool) = result < 417748
CONDITION TMP_150"];
85->86[label="True"];
85->89[label="False"];
86[label="Node Type: EXPRESSION 86

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,125),100)

IRs:
REF_112(uint200) -> spin.tokenValue
TMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_112', '125'] 
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_151', '100'] 
profit(uint256) := TMP_152(uint256)"];
86->87;
87[label="Node Type: EXPRESSION 87

EXPRESSION:
category = 17

IRs:
category(uint256) := 17(uint256)"];
87->88;
88[label="Node Type: EXPRESSION 88

EXPRESSION:
TwoPurplePyramids(target,spin.blockn)

IRs:
REF_113(uint48) -> spin.blockn
Emit TwoPurplePyramids(target,REF_113)"];
88->97;
89[label="Node Type: IF 89

EXPRESSION:
result < 471213

IRs:
TMP_154(bool) = result < 471213
CONDITION TMP_154"];
89->90[label="True"];
89->93[label="False"];
90[label="Node Type: EXPRESSION 90

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,133),100)

IRs:
REF_116(uint200) -> spin.tokenValue
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_116', '133'] 
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_155', '100'] 
profit(uint256) := TMP_156(uint256)"];
90->91;
91[label="Node Type: EXPRESSION 91

EXPRESSION:
category = 18

IRs:
category(uint256) := 18(uint256)"];
91->92;
92[label="Node Type: EXPRESSION 92

EXPRESSION:
TwoGoldPyramids(target,spin.blockn)

IRs:
REF_117(uint48) -> spin.blockn
Emit TwoGoldPyramids(target,REF_117)"];
92->96;
93[label="Node Type: EXPRESSION 93

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,25),10)

IRs:
REF_120(uint200) -> spin.tokenValue
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_120', '25'] 
TMP_159(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_158', '10'] 
profit(uint256) := TMP_159(uint256)"];
93->94;
94[label="Node Type: EXPRESSION 94

EXPRESSION:
category = 19

IRs:
category(uint256) := 19(uint256)"];
94->95;
95[label="Node Type: EXPRESSION 95

EXPRESSION:
TwoRockets(target,spin.blockn)

IRs:
REF_121(uint48) -> spin.blockn
Emit TwoRockets(target,REF_121)"];
95->96;
96[label="Node Type: END_IF 96
"];
96->97;
97[label="Node Type: END_IF 97
"];
97->98;
98[label="Node Type: END_IF 98
"];
98->99;
99[label="Node Type: END_IF 99
"];
99->100;
100[label="Node Type: END_IF 100
"];
100->101;
101[label="Node Type: END_IF 101
"];
101->102;
102[label="Node Type: END_IF 102
"];
102->103;
103[label="Node Type: END_IF 103
"];
103->104;
104[label="Node Type: END_IF 104
"];
104->105;
105[label="Node Type: END_IF 105
"];
105->106;
106[label="Node Type: END_IF 106
"];
106->107;
107[label="Node Type: END_IF 107
"];
107->108;
108[label="Node Type: END_IF 108
"];
108->109;
109[label="Node Type: END_IF 109
"];
109->110;
110[label="Node Type: END_IF 110
"];
110->111;
111[label="Node Type: END_IF 111
"];
111->112;
112[label="Node Type: END_IF 112
"];
112->113;
113[label="Node Type: EXPRESSION 113

EXPRESSION:
subContractBalance(playerDivrate,profit)

IRs:
INTERNAL_CALL, Zlots.subContractBalance(uint256,uint256)(playerDivrate,profit)"];
113->114;
114[label="Node Type: EXPRESSION 114

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,true)

IRs:
REF_122(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_122,category,True)"];
114->115;
115[label="Node Type: EXPRESSION 115

EXPRESSION:
tier = spin.tier

IRs:
REF_123(uint8) -> spin.tier
tier(uint8) := REF_123(uint8)"];
115->116;
116[label="Node Type: EXPRESSION 116

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0),uint256(0))

IRs:
REF_124(Zlots.playerSpin) -> playerSpins[target]
TMP_163 = CONVERT 0 to uint200
TMP_164 = CONVERT 0 to uint48
TMP_165 = CONVERT 0 to uint8
TMP_166 = CONVERT 0 to uint256
TMP_167(Zlots.playerSpin) = new playerSpin(TMP_163,TMP_164,TMP_165,TMP_166)
REF_124(Zlots.playerSpin) (->playerSpins) := TMP_167(Zlots.playerSpin)"];
116->117;
117[label="Node Type: EXPRESSION 117

EXPRESSION:
RequestBankrollPayment(target,profit,tier)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.RequestBankrollPayment(address,uint256,uint256)(target,profit,tier)"];
117->118;
118[label="Node Type: END_IF 118
"];
118->119;
119[label="Node Type: END_IF 119
"];
119->120;
120[label="Node Type: EXPRESSION 120

EXPRESSION:
SpinConcluded(target,spin.blockn)

IRs:
REF_125(uint48) -> spin.blockn
Emit SpinConcluded(target,REF_125)"];
120->121;
121[label="Node Type: RETURN 121

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 1017.sol-Zlots-_spinTokens(Zlots.TKN,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->19;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(gameActive)

IRs:
TMP_54(None) = SOLIDITY_CALL require(bool)(gameActive)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.number <= ((2 ** 48) - 1))

IRs:
TMP_55(uint256) = 2 ** 48
TMP_56(uint256) = TMP_55 - 1
TMP_57(bool) = block.number <= TMP_56
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_customerAddress = _tkn.sender

IRs:
REF_31(address) -> _tkn.sender
_customerAddress(address) := REF_31(address)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_wagered = _tkn.value

IRs:
REF_32(uint256) -> _tkn.value
_wagered(uint256) := REF_32(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
spin = playerSpins[_tkn.sender]

IRs:
REF_33(address) -> _tkn.sender
REF_34(Zlots.playerSpin) -> playerSpins[REF_33]
spin(Zlots.playerSpin) := REF_34(Zlots.playerSpin)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
addContractBalance(divRate,_wagered)

IRs:
INTERNAL_CALL, Zlots.addContractBalance(uint256,uint256)(divRate,_wagered)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(block.number != spin.blockn)

IRs:
REF_35(uint48) -> spin.blockn
TMP_60(bool) = block.number != REF_35
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
spin.blockn != 0

IRs:
REF_36(uint48) -> spin.blockn
TMP_62(bool) = REF_36 != 0
CONDITION TMP_62"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_finishSpin(_tkn.sender)

IRs:
REF_37(address) -> _tkn.sender
TMP_63(uint256) = INTERNAL_CALL, Zlots._finishSpin(address)(REF_37)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
spin.blockn = uint48(block.number)

IRs:
REF_38(uint48) -> spin.blockn
TMP_64 = CONVERT block.number to uint48
REF_38(uint48) (->spin) := TMP_64(uint48)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
spin.tokenValue = uint200(_wagered)

IRs:
REF_39(uint200) -> spin.tokenValue
TMP_65 = CONVERT _wagered to uint200
REF_39(uint200) (->spin) := TMP_65(uint200)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
spin.tier = uint8(ZethrTierLibrary.getTier(divRate))

IRs:
REF_40(uint8) -> spin.tier
TMP_66(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
TMP_67 = CONVERT TMP_66 to uint8
REF_40(uint8) (->spin) := TMP_67(uint8)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
spin.divRate = divRate

IRs:
REF_42(uint256) -> spin.divRate
REF_42(uint256) (->spin) := divRate(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
playerSpins[_tkn.sender] = spin

IRs:
REF_43(address) -> _tkn.sender
REF_44(Zlots.playerSpin) -> playerSpins[REF_43]
REF_44(Zlots.playerSpin) (->playerSpins) := spin(Zlots.playerSpin)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
totalSpins += 1

IRs:
totalSpins(uint256) = totalSpins + 1"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
totalZTHWagered += _wagered

IRs:
totalZTHWagered(uint256) = totalZTHWagered + _wagered"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
TokensWagered(_customerAddress,_wagered)

IRs:
Emit TokensWagered(_customerAddress,_wagered)"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
betIsValid(_tkn.value,divRate)

IRs:
REF_45(uint256) -> _tkn.value
MODIFIER_CALL, Zlots.betIsValid(uint256,uint256)(REF_45,divRate)"];
19->1;
}
// Function: 1017.sol-Zlots-_zthToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_tokenContract == ZTHTKNADDR

IRs:
TMP_200(bool) = _tokenContract == ZTHTKNADDR
RETURN TMP_200"];
}
// Function: 1017.sol-Zlots-addContractBalance(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = contractBalance[divRate].add(add)

IRs:
REF_133(uint256) -> contractBalance[divRate]
REF_134(uint256) -> contractBalance[divRate]
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_134', 'add'] 
REF_133(uint256) (->contractBalance) := TMP_181(uint256)"];
}
// Function: 1017.sol-Zlots-bankrollExternalUpdateTokens(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = newBalance

IRs:
REF_136(uint256) -> contractBalance[divRate]
REF_136(uint256) (->contractBalance) := newBalance(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
setMaxProfit(divRate)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(divRate)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fromBankroll()

IRs:
MODIFIER_CALL, ZethrBankrollBridge.fromBankroll()()"];
3->1;
}
// Function: 1017.sol-Zlots-betIsValid(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_betSize.mul(50) <= getMaxProfit(divRate))

IRs:
TMP_202(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_betSize', '50'] 
TMP_203(uint256) = INTERNAL_CALL, Zlots.getMaxProfit(uint256)(divRate)
TMP_204(bool) = TMP_202 <= TMP_203
TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-Zlots-changeBankroll(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bankroll = _newBankroll

IRs:
bankroll(address) := _newBankroll(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1017.sol-Zlots-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1017.sol-Zlots-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
setupBankrollInterface(BankrollAddress)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.setupBankrollInterface(address)(BankrollAddress)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerSetMaxProfitAsPercentOfHouse(50000)

IRs:
INTERNAL_CALL, Zlots.ownerSetMaxProfitAsPercentOfHouse(uint256)(50000)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bankroll = ZTHBANKROLL

IRs:
bankroll(address) := ZTHBANKROLL(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
gameActive = true

IRs:
gameActive(bool) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ownerSetMinBet(1e18)

IRs:
INTERNAL_CALL, Zlots.ownerSetMinBet(uint256)(1000000000000000000)"];
}
// Function: 1017.sol-Zlots-execute(address,uint256,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_tkn.sender = _from

IRs:
REF_29(address) -> _tkn.sender
REF_29(address) (->_tkn) := _from(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_tkn.value = _value

IRs:
REF_30(uint256) -> _tkn.value
REF_30(uint256) (->_tkn) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_spinTokens(_tkn,divRate)

IRs:
INTERNAL_CALL, Zlots._spinTokens(Zlots.TKN,uint256)(_tkn,divRate)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
fromBankroll()

IRs:
MODIFIER_CALL, ZethrBankrollBridge.fromBankroll()()"];
6->1;
}
// Function: 1017.sol-Zlots-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1017.sol-Zlots-finishSpin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
_finishSpin(msg.sender)

IRs:
TMP_70(uint256) = INTERNAL_CALL, Zlots._finishSpin(address)(msg.sender)
RETURN TMP_70"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
gameIsActive()

IRs:
MODIFIER_CALL, Zlots.gameIsActive()()"];
2->1;
}
// Function: 1017.sol-Zlots-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_137(bool) -> ValidBankrollAddress[msg.sender]
TMP_201(None) = SOLIDITY_CALL require(bool,string)(REF_137,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-Zlots-gameIsActive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(gamePaused == false)

IRs:
TMP_206(bool) = gamePaused == False
TMP_207(None) = SOLIDITY_CALL require(bool)(TMP_206)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-Zlots-getMaxProfit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor

IRs:
REF_129(uint256) -> contractBalance[divRate]
TMP_178(uint256) = REF_129 * maxProfitAsPercentOfHouse
TMP_179(uint256) = TMP_178 / maxProfitDivisor
RETURN TMP_179"];
}
// Function: 1017.sol-Zlots-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_28(address) -> UsedBankrollAddresses[TMP_47]
TMP_48 = CONVERT REF_28 to ZethrTokenBankroll
RETURN TMP_48"];
}
// Function: 1017.sol-Zlots-maxRandom(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint256(keccak256()(abi.encodePacked(blockhash(uint256)(blockn),entropy)))

IRs:
TMP_170(uint256) = SOLIDITY_CALL blockhash(uint256)(blockn)
TMP_171(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_170,entropy)
TMP_172(bytes32) = SOLIDITY_CALL keccak256()(TMP_171)
TMP_173 = CONVERT TMP_172 to uint256
RETURN TMP_173"];
2[label="Node Type: RETURN 2

EXPRESSION:
randomNumber

IRs:
RETURN randomNumber"];
}
// Function: 1017.sol-Zlots-onlyBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == bankroll)

IRs:
TMP_210(bool) = msg.sender == bankroll
TMP_211(None) = SOLIDITY_CALL require(bool)(TMP_210)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-Zlots-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_208(bool) = msg.sender == owner
TMP_209(None) = SOLIDITY_CALL require(bool)(TMP_208)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-Zlots-onlyOwnerOrBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == bankroll)

IRs:
TMP_212(bool) = msg.sender == owner
TMP_213(bool) = msg.sender == bankroll
TMP_214(bool) = TMP_212 || TMP_213
TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1017.sol-Zlots-ownerSetMaxProfitAsPercentOfHouse(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newMaxProfitAsPercent <= 500000)

IRs:
TMP_184(bool) = newMaxProfitAsPercent <= 500000
TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
maxProfitAsPercentOfHouse = newMaxProfitAsPercent

IRs:
maxProfitAsPercentOfHouse(uint256) := newMaxProfitAsPercent(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
setMaxProfit(2)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(2)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
setMaxProfit(5)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(5)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
setMaxProfit(10)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(10)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
setMaxProfit(15)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(15)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
setMaxProfit(20)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(20)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
setMaxProfit(25)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(25)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
setMaxProfit(33)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(33)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
10->1;
}
// Function: 1017.sol-Zlots-ownerSetMinBet(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minBet = newMinimumBet

IRs:
minBet(uint256) := newMinimumBet(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
2->1;
}
// Function: 1017.sol-Zlots-ownerSetZlotsAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
zlotsJackpot = zlotsAddress

IRs:
zlotsJackpot(address) := zlotsAddress(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
2->1;
}
// Function: 1017.sol-Zlots-pauseGame()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
gameActive = false

IRs:
gameActive(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1017.sol-Zlots-random(uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
maxRandom(blockn,entropy) % upper

IRs:
TMP_174(uint256) = INTERNAL_CALL, Zlots.maxRandom(uint256,address)(blockn,entropy)
TMP_175(uint256) = TMP_174 % upper
RETURN TMP_175"];
2[label="Node Type: RETURN 2

EXPRESSION:
randomNumber

IRs:
RETURN randomNumber"];
}
// Function: 1017.sol-Zlots-resumeGame()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
gameActive = true

IRs:
gameActive(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1017.sol-Zlots-setMaxProfit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor

IRs:
REF_127(uint256) -> maxProfit[divRate]
REF_128(uint256) -> contractBalance[divRate]
TMP_176(uint256) = REF_128 * maxProfitAsPercentOfHouse
TMP_177(uint256) = TMP_176 / maxProfitDivisor
REF_127(uint256) (->maxProfit) := TMP_177(uint256)"];
}
// Function: 1017.sol-Zlots-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_40 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_40(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_41 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_42(address[7]) = HIGH_LEVEL_CALL, dest:TMP_41(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_42(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_43(bool) = i < 7
CONDITION TMP_43"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_23(address) -> UsedBankrollAddresses[i]
REF_24(bool) -> ValidBankrollAddress[REF_23]
REF_24(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_44(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1017.sol-Zlots-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
maxProfitDivisor = 1000000

IRs:
maxProfitDivisor(uint256) := 1000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
houseEdgeDivisor = 1000

IRs:
houseEdgeDivisor(uint256) := 1000(uint256)"];
}
// Function: 1017.sol-Zlots-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
minBet = 1e18

IRs:
minBet(uint256) := 1000000000000000000(uint256)"];
}
// Function: 1017.sol-Zlots-subContractBalance(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = contractBalance[divRate].sub(sub)

IRs:
REF_130(uint256) -> contractBalance[divRate]
REF_131(uint256) -> contractBalance[divRate]
TMP_180(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_131', 'sub'] 
REF_130(uint256) (->contractBalance) := TMP_180(uint256)"];
}
// Function: 1017.sol-ZlotsJackpotHoldingContract-getJackpot()
digraph{
}
// Function: 1017.sol-ZlotsJackpotHoldingContract-payOutWinner(address)
digraph{
}
}
