digraph G {
// Function: 1096.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_220(uint256) = a + b
c(uint256) := TMP_220(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_221(bool) = c >= a
TMP_222(None) = SOLIDITY_CALL assert(bool)(TMP_221)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1096.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_216(uint256) = a / b
c(uint256) := TMP_216(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1096.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_211(bool) = a == 0
CONDITION TMP_211"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_212(uint256) = a * b
c(uint256) := TMP_212(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_213(uint256) = c / a
TMP_214(bool) = TMP_213 == b
TMP_215(None) = SOLIDITY_CALL assert(bool)(TMP_214)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1096.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_217(bool) = b <= a
TMP_218(None) = SOLIDITY_CALL assert(bool)(TMP_217)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_219(uint256) = a - b
RETURN TMP_219"];
}
// Function: 1096.sol-ZethrBankrollBridge-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_3(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_3(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_13 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_13(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1096.sol-ZethrBankrollBridge-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_7(bool) -> ValidBankrollAddress[msg.sender]
TMP_17(None) = SOLIDITY_CALL require(bool,string)(REF_7,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-ZethrBankrollBridge-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_15(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_6(address) -> UsedBankrollAddresses[TMP_15]
TMP_16 = CONVERT REF_6 to ZethrTokenBankroll
RETURN TMP_16"];
}
// Function: 1096.sol-ZethrBankrollBridge-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_8 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_8(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_9 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_10(address[7]) = HIGH_LEVEL_CALL, dest:TMP_9(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_10(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_11(bool) = i < 7
CONDITION TMP_11"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_1(address) -> UsedBankrollAddresses[i]
REF_2(bool) -> ValidBankrollAddress[REF_1]
REF_2(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_12(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1096.sol-ZethrInterface-withdraw()
digraph{
}
// Function: 1096.sol-ZethrMainBankroll-gameGetTokenBankrollList()
digraph{
}
// Function: 1096.sol-ZethrShell-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_11(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_11(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_23 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_23(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1096.sol-ZethrShell-WithdrawAndTransferToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:Zethr(ZethrInterface), function:withdraw, arguments:[]  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WithdrawToBankroll()

IRs:
INTERNAL_CALL, ZethrShell.WithdrawToBankroll()()"];
}
// Function: 1096.sol-ZethrShell-WithdrawToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_15(address) -> UsedBankrollAddresses[0]
TMP_27 = CONVERT REF_15 to address
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
Transfer dest:TMP_27 value:TMP_29"];
}
// Function: 1096.sol-ZethrShell-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_18(bool) -> ValidBankrollAddress[msg.sender]
TMP_33(None) = SOLIDITY_CALL require(bool,string)(REF_18,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-ZethrShell-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_25(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_14(address) -> UsedBankrollAddresses[TMP_25]
TMP_26 = CONVERT REF_14 to ZethrTokenBankroll
RETURN TMP_26"];
}
// Function: 1096.sol-ZethrShell-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_18 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_18(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_19 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_20(address[7]) = HIGH_LEVEL_CALL, dest:TMP_19(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_20(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_21(bool) = i < 7
CONDITION TMP_21"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_9(address) -> UsedBankrollAddresses[i]
REF_10(bool) -> ValidBankrollAddress[REF_9]
REF_10(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_22(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1096.sol-ZethrTierLibrary-getTier(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
actualDiv = divRate

IRs:
actualDiv(uint256) := divRate(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
actualDiv >= 30

IRs:
TMP_0(bool) = actualDiv >= 30
CONDITION TMP_0"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
6

IRs:
RETURN 6"];
4[label="Node Type: IF 4

EXPRESSION:
actualDiv >= 25

IRs:
TMP_1(bool) = actualDiv >= 25
CONDITION TMP_1"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
5

IRs:
RETURN 5"];
6[label="Node Type: IF 6

EXPRESSION:
actualDiv >= 20

IRs:
TMP_2(bool) = actualDiv >= 20
CONDITION TMP_2"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
4

IRs:
RETURN 4"];
8[label="Node Type: IF 8

EXPRESSION:
actualDiv >= 15

IRs:
TMP_3(bool) = actualDiv >= 15
CONDITION TMP_3"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
3

IRs:
RETURN 3"];
10[label="Node Type: IF 10

EXPRESSION:
actualDiv >= 10

IRs:
TMP_4(bool) = actualDiv >= 10
CONDITION TMP_4"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
2

IRs:
RETURN 2"];
12[label="Node Type: IF 12

EXPRESSION:
actualDiv >= 5

IRs:
TMP_5(bool) = actualDiv >= 5
CONDITION TMP_5"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: RETURN 13

EXPRESSION:
1

IRs:
RETURN 1"];
14[label="Node Type: IF 14

EXPRESSION:
actualDiv >= 2

IRs:
TMP_6(bool) = actualDiv >= 2
CONDITION TMP_6"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: RETURN 15

EXPRESSION:
0

IRs:
RETURN 0"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
revert()()

IRs:
TMP_7(None) = SOLIDITY_CALL revert()()"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: END_IF 23
"];
}
// Function: 1096.sol-ZethrTokenBankroll-gameRequestTokens(address,uint256)
digraph{
}
// Function: 1096.sol-ZethrTokenBankroll-gameTokenAmount(address)
digraph{
}
// Function: 1096.sol-Zlots-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_25(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_25(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_45 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_45(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1096.sol-Zlots-WithdrawAndTransferToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:Zethr(ZethrInterface), function:withdraw, arguments:[]  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WithdrawToBankroll()

IRs:
INTERNAL_CALL, ZethrShell.WithdrawToBankroll()()"];
}
// Function: 1096.sol-Zlots-WithdrawToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_19(address) -> UsedBankrollAddresses[0]
TMP_34 = CONVERT REF_19 to address
TMP_35 = CONVERT this to address
TMP_36(uint256) = SOLIDITY_CALL balance(address)(TMP_35)
Transfer dest:TMP_34 value:TMP_36"];
}
// Function: 1096.sol-Zlots-_finishSpin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spin = playerSpins[target]

IRs:
REF_46(Zlots.playerSpin) -> playerSpins[target]
spin(Zlots.playerSpin) := REF_46(Zlots.playerSpin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(spin.tokenValue > 0)

IRs:
REF_47(uint200) -> spin.tokenValue
TMP_74(bool) = REF_47 > 0
TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(spin.blockn != block.number)

IRs:
REF_48(uint48) -> spin.blockn
TMP_76(bool) = REF_48 != block.number
TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
profit = 0

IRs:
profit(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
category = 0

IRs:
category(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
block.number - spin.blockn > 255

IRs:
REF_49(uint48) -> spin.blockn
TMP_78(uint256) = block.number - REF_49
TMP_79(bool) = TMP_78 > 255
CONDITION TMP_79"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
result = 1000000

IRs:
result(uint256) := 1000000(uint256)"];
8->10;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
result = random(1000000,spin.blockn,target) + 1

IRs:
REF_50(uint48) -> spin.blockn
TMP_80(uint256) = INTERNAL_CALL, Zlots.random(uint256,uint256,address)(1000000,REF_50,target)
TMP_81(uint256) = TMP_80 + 1
result(uint256) := TMP_81(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
result > 476662

IRs:
TMP_82(bool) = result > 476662
CONDITION TMP_82"];
11->12[label="True"];
11->16[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
RequestBankrollPayment(zlotsJackpot,profit,tier)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.RequestBankrollPayment(address,uint256,uint256)(zlotsJackpot,profit,tier)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0))

IRs:
REF_51(Zlots.playerSpin) -> playerSpins[target]
TMP_84 = CONVERT 0 to uint200
TMP_85 = CONVERT 0 to uint48
TMP_86 = CONVERT 0 to uint8
TMP_87(Zlots.playerSpin) = new playerSpin(TMP_84,TMP_85,TMP_86)
REF_51(Zlots.playerSpin) (->playerSpins) := TMP_87(Zlots.playerSpin)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Loss(target,spin.blockn)

IRs:
REF_52(uint48) -> spin.blockn
Emit Loss(target,REF_52)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,false)

IRs:
REF_53(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_53,category,False)"];
15->117;
16[label="Node Type: IF 16

EXPRESSION:
result < 2

IRs:
TMP_90(bool) = result < 2
CONDITION TMP_90"];
16->17[label="True"];
16->24[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
profit = ZlotsJackpotHoldingContract(zlotsJackpot).getJackpot()

IRs:
TMP_91 = CONVERT zlotsJackpot to ZlotsJackpotHoldingContract
TMP_92(uint256) = HIGH_LEVEL_CALL, dest:TMP_91(ZlotsJackpotHoldingContract), function:getJackpot, arguments:[]  
profit(uint256) := TMP_92(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
category = 1

IRs:
category(uint256) := 1(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
ThreeMoonJackpot(target,spin.blockn)

IRs:
REF_55(uint48) -> spin.blockn
Emit ThreeMoonJackpot(target,REF_55)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,true)

IRs:
REF_56(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_56,category,True)"];
20->21;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
tier = spin.tier

IRs:
REF_57(uint8) -> spin.tier
tier(uint8) := REF_57(uint8)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0))

IRs:
REF_58(Zlots.playerSpin) -> playerSpins[target]
TMP_95 = CONVERT 0 to uint200
TMP_96 = CONVERT 0 to uint48
TMP_97 = CONVERT 0 to uint8
TMP_98(Zlots.playerSpin) = new playerSpin(TMP_95,TMP_96,TMP_97)
REF_58(Zlots.playerSpin) (->playerSpins) := TMP_98(Zlots.playerSpin)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target)

IRs:
TMP_99 = CONVERT zlotsJackpot to ZlotsJackpotHoldingContract
HIGH_LEVEL_CALL, dest:TMP_99(ZlotsJackpotHoldingContract), function:payOutWinner, arguments:['target']  "];
23->116;
24[label="Node Type: IF 24

EXPRESSION:
result < 299

IRs:
TMP_101(bool) = result < 299
CONDITION TMP_101"];
24->25[label="True"];
24->28[label="False"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,100)

IRs:
REF_61(uint200) -> spin.tokenValue
TMP_102(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_61', '100'] 
profit(uint256) := TMP_102(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
category = 2

IRs:
category(uint256) := 2(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
TwoMoonPrize(target,spin.blockn)

IRs:
REF_62(uint48) -> spin.blockn
Emit TwoMoonPrize(target,REF_62)"];
27->111;
28[label="Node Type: IF 28

EXPRESSION:
result < 3128

IRs:
TMP_104(bool) = result < 3128
CONDITION TMP_104"];
28->29[label="True"];
28->32[label="False"];
29[label="Node Type: EXPRESSION 29

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,20)

IRs:
REF_64(uint200) -> spin.tokenValue
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_64', '20'] 
profit(uint256) := TMP_105(uint256)"];
29->30;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
category = 3

IRs:
category(uint256) := 3(uint256)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
ZTHPrize(target,spin.blockn)

IRs:
REF_65(uint48) -> spin.blockn
Emit ZTHPrize(target,REF_65)"];
31->110;
32[label="Node Type: IF 32

EXPRESSION:
result < 5957

IRs:
TMP_107(bool) = result < 5957
CONDITION TMP_107"];
32->33[label="True"];
32->36[label="False"];
33[label="Node Type: EXPRESSION 33

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,75),10)

IRs:
REF_68(uint200) -> spin.tokenValue
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_68', '75'] 
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_108', '10'] 
profit(uint256) := TMP_109(uint256)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
category = 4

IRs:
category(uint256) := 4(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
ThreeZSymbols(target,spin.blockn)

IRs:
REF_69(uint48) -> spin.blockn
Emit ThreeZSymbols(target,REF_69)"];
35->109;
36[label="Node Type: IF 36

EXPRESSION:
result < 8786

IRs:
TMP_111(bool) = result < 8786
CONDITION TMP_111"];
36->37[label="True"];
36->40[label="False"];
37[label="Node Type: EXPRESSION 37

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,75),10)

IRs:
REF_72(uint200) -> spin.tokenValue
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_72', '75'] 
TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_112', '10'] 
profit(uint256) := TMP_113(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
category = 5

IRs:
category(uint256) := 5(uint256)"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
ThreeTSymbols(target,spin.blockn)

IRs:
REF_73(uint48) -> spin.blockn
Emit ThreeTSymbols(target,REF_73)"];
39->108;
40[label="Node Type: IF 40

EXPRESSION:
result < 11615

IRs:
TMP_115(bool) = result < 11615
CONDITION TMP_115"];
40->41[label="True"];
40->44[label="False"];
41[label="Node Type: EXPRESSION 41

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,75),10)

IRs:
REF_76(uint200) -> spin.tokenValue
TMP_116(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_76', '75'] 
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_116', '10'] 
profit(uint256) := TMP_117(uint256)"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
category = 6

IRs:
category(uint256) := 6(uint256)"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
ThreeHSymbols(target,spin.blockn)

IRs:
REF_77(uint48) -> spin.blockn
Emit ThreeHSymbols(target,REF_77)"];
43->107;
44[label="Node Type: IF 44

EXPRESSION:
result < 14444

IRs:
TMP_119(bool) = result < 14444
CONDITION TMP_119"];
44->45[label="True"];
44->48[label="False"];
45[label="Node Type: EXPRESSION 45

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,15)

IRs:
REF_79(uint200) -> spin.tokenValue
TMP_120(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_79', '15'] 
profit(uint256) := TMP_120(uint256)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
category = 7

IRs:
category(uint256) := 7(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
ThreeEtherIcons(target,spin.blockn)

IRs:
REF_80(uint48) -> spin.blockn
Emit ThreeEtherIcons(target,REF_80)"];
47->106;
48[label="Node Type: IF 48

EXPRESSION:
result < 17273

IRs:
TMP_122(bool) = result < 17273
CONDITION TMP_122"];
48->49[label="True"];
48->52[label="False"];
49[label="Node Type: EXPRESSION 49

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,10)

IRs:
REF_82(uint200) -> spin.tokenValue
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_82', '10'] 
profit(uint256) := TMP_123(uint256)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
category = 8

IRs:
category(uint256) := 8(uint256)"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
ThreePurplePyramids(target,spin.blockn)

IRs:
REF_83(uint48) -> spin.blockn
Emit ThreePurplePyramids(target,REF_83)"];
51->105;
52[label="Node Type: IF 52

EXPRESSION:
result < 20102

IRs:
TMP_125(bool) = result < 20102
CONDITION TMP_125"];
52->53[label="True"];
52->56[label="False"];
53[label="Node Type: EXPRESSION 53

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,10)

IRs:
REF_85(uint200) -> spin.tokenValue
TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_85', '10'] 
profit(uint256) := TMP_126(uint256)"];
53->54;
54[label="Node Type: EXPRESSION 54

EXPRESSION:
category = 9

IRs:
category(uint256) := 9(uint256)"];
54->55;
55[label="Node Type: EXPRESSION 55

EXPRESSION:
ThreeGoldPyramids(target,spin.blockn)

IRs:
REF_86(uint48) -> spin.blockn
Emit ThreeGoldPyramids(target,REF_86)"];
55->104;
56[label="Node Type: IF 56

EXPRESSION:
result < 22930

IRs:
TMP_128(bool) = result < 22930
CONDITION TMP_128"];
56->57[label="True"];
56->60[label="False"];
57[label="Node Type: EXPRESSION 57

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,12)

IRs:
REF_88(uint200) -> spin.tokenValue
TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_88', '12'] 
profit(uint256) := TMP_129(uint256)"];
57->58;
58[label="Node Type: EXPRESSION 58

EXPRESSION:
category = 10

IRs:
category(uint256) := 10(uint256)"];
58->59;
59[label="Node Type: EXPRESSION 59

EXPRESSION:
ThreeRockets(target,spin.blockn)

IRs:
REF_89(uint48) -> spin.blockn
Emit ThreeRockets(target,REF_89)"];
59->103;
60[label="Node Type: IF 60

EXPRESSION:
result < 52333

IRs:
TMP_131(bool) = result < 52333
CONDITION TMP_131"];
60->61[label="True"];
60->64[label="False"];
61[label="Node Type: EXPRESSION 61

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,25),10)

IRs:
REF_92(uint200) -> spin.tokenValue
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_92', '25'] 
TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_132', '10'] 
profit(uint256) := TMP_133(uint256)"];
61->62;
62[label="Node Type: EXPRESSION 62

EXPRESSION:
category = 11

IRs:
category(uint256) := 11(uint256)"];
62->63;
63[label="Node Type: EXPRESSION 63

EXPRESSION:
OneMoonPrize(target,spin.blockn)

IRs:
REF_93(uint48) -> spin.blockn
Emit OneMoonPrize(target,REF_93)"];
63->102;
64[label="Node Type: IF 64

EXPRESSION:
result < 120226

IRs:
TMP_135(bool) = result < 120226
CONDITION TMP_135"];
64->65[label="True"];
64->68[label="False"];
65[label="Node Type: EXPRESSION 65

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,15),10)

IRs:
REF_96(uint200) -> spin.tokenValue
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_96', '15'] 
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_136', '10'] 
profit(uint256) := TMP_137(uint256)"];
65->66;
66[label="Node Type: EXPRESSION 66

EXPRESSION:
category = 12

IRs:
category(uint256) := 12(uint256)"];
66->67;
67[label="Node Type: EXPRESSION 67

EXPRESSION:
OneOfEachPyramidPrize(target,spin.blockn)

IRs:
REF_97(uint48) -> spin.blockn
Emit OneOfEachPyramidPrize(target,REF_97)"];
67->101;
68[label="Node Type: IF 68

EXPRESSION:
result < 171147

IRs:
TMP_139(bool) = result < 171147
CONDITION TMP_139"];
68->69[label="True"];
68->72[label="False"];
69[label="Node Type: EXPRESSION 69

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_98(uint200) -> spin.tokenValue
profit(uint256) := REF_98(uint200)"];
69->70;
70[label="Node Type: EXPRESSION 70

EXPRESSION:
category = 13

IRs:
category(uint256) := 13(uint256)"];
70->71;
71[label="Node Type: EXPRESSION 71

EXPRESSION:
TwoZSymbols(target,spin.blockn)

IRs:
REF_99(uint48) -> spin.blockn
Emit TwoZSymbols(target,REF_99)"];
71->100;
72[label="Node Type: IF 72

EXPRESSION:
result < 222068

IRs:
TMP_141(bool) = result < 222068
CONDITION TMP_141"];
72->73[label="True"];
72->76[label="False"];
73[label="Node Type: EXPRESSION 73

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_100(uint200) -> spin.tokenValue
profit(uint256) := REF_100(uint200)"];
73->74;
74[label="Node Type: EXPRESSION 74

EXPRESSION:
category = 14

IRs:
category(uint256) := 14(uint256)"];
74->75;
75[label="Node Type: EXPRESSION 75

EXPRESSION:
TwoTSymbols(target,spin.blockn)

IRs:
REF_101(uint48) -> spin.blockn
Emit TwoTSymbols(target,REF_101)"];
75->99;
76[label="Node Type: IF 76

EXPRESSION:
result < 272989

IRs:
TMP_143(bool) = result < 272989
CONDITION TMP_143"];
76->77[label="True"];
76->80[label="False"];
77[label="Node Type: EXPRESSION 77

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_102(uint200) -> spin.tokenValue
profit(uint256) := REF_102(uint200)"];
77->78;
78[label="Node Type: EXPRESSION 78

EXPRESSION:
category = 15

IRs:
category(uint256) := 15(uint256)"];
78->79;
79[label="Node Type: EXPRESSION 79

EXPRESSION:
TwoHSymbols(target,spin.blockn)

IRs:
REF_103(uint48) -> spin.blockn
Emit TwoHSymbols(target,REF_103)"];
79->98;
80[label="Node Type: IF 80

EXPRESSION:
result < 323910

IRs:
TMP_145(bool) = result < 323910
CONDITION TMP_145"];
80->81[label="True"];
80->84[label="False"];
81[label="Node Type: EXPRESSION 81

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,2)

IRs:
REF_105(uint200) -> spin.tokenValue
TMP_146(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_105', '2'] 
profit(uint256) := TMP_146(uint256)"];
81->82;
82[label="Node Type: EXPRESSION 82

EXPRESSION:
category = 16

IRs:
category(uint256) := 16(uint256)"];
82->83;
83[label="Node Type: EXPRESSION 83

EXPRESSION:
TwoEtherIcons(target,spin.blockn)

IRs:
REF_106(uint48) -> spin.blockn
Emit TwoEtherIcons(target,REF_106)"];
83->97;
84[label="Node Type: IF 84

EXPRESSION:
result < 374831

IRs:
TMP_148(bool) = result < 374831
CONDITION TMP_148"];
84->85[label="True"];
84->88[label="False"];
85[label="Node Type: EXPRESSION 85

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,133),100)

IRs:
REF_109(uint200) -> spin.tokenValue
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_109', '133'] 
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_149', '100'] 
profit(uint256) := TMP_150(uint256)"];
85->86;
86[label="Node Type: EXPRESSION 86

EXPRESSION:
category = 17

IRs:
category(uint256) := 17(uint256)"];
86->87;
87[label="Node Type: EXPRESSION 87

EXPRESSION:
TwoPurplePyramids(target,spin.blockn)

IRs:
REF_110(uint48) -> spin.blockn
Emit TwoPurplePyramids(target,REF_110)"];
87->96;
88[label="Node Type: IF 88

EXPRESSION:
result < 425752

IRs:
TMP_152(bool) = result < 425752
CONDITION TMP_152"];
88->89[label="True"];
88->92[label="False"];
89[label="Node Type: EXPRESSION 89

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,133),100)

IRs:
REF_113(uint200) -> spin.tokenValue
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_113', '133'] 
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_153', '100'] 
profit(uint256) := TMP_154(uint256)"];
89->90;
90[label="Node Type: EXPRESSION 90

EXPRESSION:
category = 18

IRs:
category(uint256) := 18(uint256)"];
90->91;
91[label="Node Type: EXPRESSION 91

EXPRESSION:
TwoGoldPyramids(target,spin.blockn)

IRs:
REF_114(uint48) -> spin.blockn
Emit TwoGoldPyramids(target,REF_114)"];
91->95;
92[label="Node Type: EXPRESSION 92

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,2)

IRs:
REF_116(uint200) -> spin.tokenValue
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_116', '2'] 
profit(uint256) := TMP_156(uint256)"];
92->93;
93[label="Node Type: EXPRESSION 93

EXPRESSION:
category = 19

IRs:
category(uint256) := 19(uint256)"];
93->94;
94[label="Node Type: EXPRESSION 94

EXPRESSION:
TwoRockets(target,spin.blockn)

IRs:
REF_117(uint48) -> spin.blockn
Emit TwoRockets(target,REF_117)"];
94->95;
95[label="Node Type: END_IF 95
"];
95->96;
96[label="Node Type: END_IF 96
"];
96->97;
97[label="Node Type: END_IF 97
"];
97->98;
98[label="Node Type: END_IF 98
"];
98->99;
99[label="Node Type: END_IF 99
"];
99->100;
100[label="Node Type: END_IF 100
"];
100->101;
101[label="Node Type: END_IF 101
"];
101->102;
102[label="Node Type: END_IF 102
"];
102->103;
103[label="Node Type: END_IF 103
"];
103->104;
104[label="Node Type: END_IF 104
"];
104->105;
105[label="Node Type: END_IF 105
"];
105->106;
106[label="Node Type: END_IF 106
"];
106->107;
107[label="Node Type: END_IF 107
"];
107->108;
108[label="Node Type: END_IF 108
"];
108->109;
109[label="Node Type: END_IF 109
"];
109->110;
110[label="Node Type: END_IF 110
"];
110->111;
111[label="Node Type: END_IF 111
"];
111->112;
112[label="Node Type: EXPRESSION 112

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,true)

IRs:
REF_118(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_118,category,True)"];
112->113;
113[label="Node Type: EXPRESSION 113

EXPRESSION:
tier = spin.tier

IRs:
REF_119(uint8) -> spin.tier
tier(uint8) := REF_119(uint8)"];
113->114;
114[label="Node Type: EXPRESSION 114

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0))

IRs:
REF_120(Zlots.playerSpin) -> playerSpins[target]
TMP_159 = CONVERT 0 to uint200
TMP_160 = CONVERT 0 to uint48
TMP_161 = CONVERT 0 to uint8
TMP_162(Zlots.playerSpin) = new playerSpin(TMP_159,TMP_160,TMP_161)
REF_120(Zlots.playerSpin) (->playerSpins) := TMP_162(Zlots.playerSpin)"];
114->115;
115[label="Node Type: EXPRESSION 115

EXPRESSION:
RequestBankrollPayment(target,profit,tier)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.RequestBankrollPayment(address,uint256,uint256)(target,profit,tier)"];
115->116;
116[label="Node Type: END_IF 116
"];
116->117;
117[label="Node Type: END_IF 117
"];
117->118;
118[label="Node Type: EXPRESSION 118

EXPRESSION:
SpinConcluded(target,spin.blockn)

IRs:
REF_121(uint48) -> spin.blockn
Emit SpinConcluded(target,REF_121)"];
118->119;
119[label="Node Type: RETURN 119

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 1096.sol-Zlots-_spinTokens(Zlots.TKN,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->19;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(gameActive)

IRs:
TMP_54(None) = SOLIDITY_CALL require(bool)(gameActive)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(1e18 <= _tkn.value)

IRs:
REF_31(uint256) -> _tkn.value
TMP_55(bool) = 1000000000000000000 <= REF_31
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(block.number < ((2 ** 56) - 1))

IRs:
TMP_57(uint256) = 2 ** 56
TMP_58(uint256) = TMP_57 - 1
TMP_59(bool) = block.number < TMP_58
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_customerAddress = _tkn.sender

IRs:
REF_32(address) -> _tkn.sender
_customerAddress(address) := REF_32(address)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_wagered = _tkn.value

IRs:
REF_33(uint256) -> _tkn.value
_wagered(uint256) := REF_33(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
spin = playerSpins[_tkn.sender]

IRs:
REF_34(address) -> _tkn.sender
REF_35(Zlots.playerSpin) -> playerSpins[REF_34]
spin(Zlots.playerSpin) := REF_35(Zlots.playerSpin)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
addContractBalance(divRate,_wagered)

IRs:
INTERNAL_CALL, Zlots.addContractBalance(uint256,uint256)(divRate,_wagered)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(block.number != spin.blockn)

IRs:
REF_36(uint48) -> spin.blockn
TMP_62(bool) = block.number != REF_36
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
spin.blockn != 0

IRs:
REF_37(uint48) -> spin.blockn
TMP_64(bool) = REF_37 != 0
CONDITION TMP_64"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_finishSpin(_tkn.sender)

IRs:
REF_38(address) -> _tkn.sender
TMP_65(uint256) = INTERNAL_CALL, Zlots._finishSpin(address)(REF_38)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
spin.blockn = uint48(block.number)

IRs:
REF_39(uint48) -> spin.blockn
TMP_66 = CONVERT block.number to uint48
REF_39(uint48) (->spin) := TMP_66(uint48)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
spin.tokenValue = uint200(_wagered)

IRs:
REF_40(uint200) -> spin.tokenValue
TMP_67 = CONVERT _wagered to uint200
REF_40(uint200) (->spin) := TMP_67(uint200)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
spin.tier = uint8(ZethrTierLibrary.getTier(divRate))

IRs:
REF_41(uint8) -> spin.tier
TMP_68(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
TMP_69 = CONVERT TMP_68 to uint8
REF_41(uint8) (->spin) := TMP_69(uint8)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
playerSpins[_tkn.sender] = spin

IRs:
REF_43(address) -> _tkn.sender
REF_44(Zlots.playerSpin) -> playerSpins[REF_43]
REF_44(Zlots.playerSpin) (->playerSpins) := spin(Zlots.playerSpin)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
totalSpins += 1

IRs:
totalSpins(uint256) = totalSpins + 1"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
totalZTHWagered += _wagered

IRs:
totalZTHWagered(uint256) = totalZTHWagered + _wagered"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
TokensWagered(_customerAddress,_wagered)

IRs:
Emit TokensWagered(_customerAddress,_wagered)"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
betIsValid(_tkn.value,divRate)

IRs:
REF_45(uint256) -> _tkn.value
MODIFIER_CALL, Zlots.betIsValid(uint256,uint256)(REF_45,divRate)"];
19->1;
}
// Function: 1096.sol-Zlots-_zthToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_tokenContract == ZTHTKNADDR

IRs:
TMP_195(bool) = _tokenContract == ZTHTKNADDR
RETURN TMP_195"];
}
// Function: 1096.sol-Zlots-addContractBalance(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = contractBalance[divRate].add(add)

IRs:
REF_129(uint256) -> contractBalance[divRate]
REF_130(uint256) -> contractBalance[divRate]
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_130', 'add'] 
REF_129(uint256) (->contractBalance) := TMP_176(uint256)"];
}
// Function: 1096.sol-Zlots-bankrollExternalUpdateTokens(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = newBalance

IRs:
REF_132(uint256) -> contractBalance[divRate]
REF_132(uint256) (->contractBalance) := newBalance(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
setMaxProfit(divRate)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(divRate)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fromBankroll()

IRs:
MODIFIER_CALL, ZethrBankrollBridge.fromBankroll()()"];
3->1;
}
// Function: 1096.sol-Zlots-betIsValid(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_betSize.mul(100) <= getMaxProfit(divRate))

IRs:
TMP_197(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_betSize', '100'] 
TMP_198(uint256) = INTERNAL_CALL, Zlots.getMaxProfit(uint256)(divRate)
TMP_199(bool) = TMP_197 <= TMP_198
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-Zlots-changeBankroll(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bankroll = _newBankroll

IRs:
bankroll(address) := _newBankroll(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1096.sol-Zlots-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1096.sol-Zlots-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
setupBankrollInterface(BankrollAddress)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.setupBankrollInterface(address)(BankrollAddress)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerSetMaxProfitAsPercentOfHouse(50000)

IRs:
INTERNAL_CALL, Zlots.ownerSetMaxProfitAsPercentOfHouse(uint256)(50000)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bankroll = ZTHBANKROLL

IRs:
bankroll(address) := ZTHBANKROLL(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
gameActive = true

IRs:
gameActive(bool) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ownerSetMinBet(1e18)

IRs:
INTERNAL_CALL, Zlots.ownerSetMinBet(uint256)(1000000000000000000)"];
}
// Function: 1096.sol-Zlots-execute(address,uint256,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_tkn.sender = _from

IRs:
REF_29(address) -> _tkn.sender
REF_29(address) (->_tkn) := _from(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_tkn.value = _value

IRs:
REF_30(uint256) -> _tkn.value
REF_30(uint256) (->_tkn) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_spinTokens(_tkn,divRate)

IRs:
INTERNAL_CALL, Zlots._spinTokens(Zlots.TKN,uint256)(_tkn,divRate)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
fromBankroll()

IRs:
MODIFIER_CALL, ZethrBankrollBridge.fromBankroll()()"];
6->1;
}
// Function: 1096.sol-Zlots-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1096.sol-Zlots-finishSpin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
_finishSpin(msg.sender)

IRs:
TMP_72(uint256) = INTERNAL_CALL, Zlots._finishSpin(address)(msg.sender)
RETURN TMP_72"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
gameIsActive()

IRs:
MODIFIER_CALL, Zlots.gameIsActive()()"];
2->1;
}
// Function: 1096.sol-Zlots-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_133(bool) -> ValidBankrollAddress[msg.sender]
TMP_196(None) = SOLIDITY_CALL require(bool,string)(REF_133,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-Zlots-gameIsActive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(gamePaused == false)

IRs:
TMP_201(bool) = gamePaused == False
TMP_202(None) = SOLIDITY_CALL require(bool)(TMP_201)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-Zlots-getMaxProfit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor

IRs:
REF_125(uint256) -> contractBalance[divRate]
TMP_173(uint256) = REF_125 * maxProfitAsPercentOfHouse
TMP_174(uint256) = TMP_173 / maxProfitDivisor
RETURN TMP_174"];
}
// Function: 1096.sol-Zlots-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_28(address) -> UsedBankrollAddresses[TMP_47]
TMP_48 = CONVERT REF_28 to ZethrTokenBankroll
RETURN TMP_48"];
}
// Function: 1096.sol-Zlots-maxRandom(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint256(keccak256()(abi.encodePacked(blockhash(uint256)(blockn),entropy)))

IRs:
TMP_165(uint256) = SOLIDITY_CALL blockhash(uint256)(blockn)
TMP_166(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_165,entropy)
TMP_167(bytes32) = SOLIDITY_CALL keccak256()(TMP_166)
TMP_168 = CONVERT TMP_167 to uint256
RETURN TMP_168"];
2[label="Node Type: RETURN 2

EXPRESSION:
randomNumber

IRs:
RETURN randomNumber"];
}
// Function: 1096.sol-Zlots-onlyBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == bankroll)

IRs:
TMP_205(bool) = msg.sender == bankroll
TMP_206(None) = SOLIDITY_CALL require(bool)(TMP_205)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-Zlots-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_203(bool) = msg.sender == owner
TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-Zlots-onlyOwnerOrBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == bankroll)

IRs:
TMP_207(bool) = msg.sender == owner
TMP_208(bool) = msg.sender == bankroll
TMP_209(bool) = TMP_207 || TMP_208
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1096.sol-Zlots-ownerSetMaxProfitAsPercentOfHouse(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newMaxProfitAsPercent <= 200000)

IRs:
TMP_179(bool) = newMaxProfitAsPercent <= 200000
TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
maxProfitAsPercentOfHouse = newMaxProfitAsPercent

IRs:
maxProfitAsPercentOfHouse(uint256) := newMaxProfitAsPercent(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
setMaxProfit(2)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(2)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
setMaxProfit(5)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(5)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
setMaxProfit(10)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(10)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
setMaxProfit(15)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(15)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
setMaxProfit(20)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(20)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
setMaxProfit(25)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(25)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
setMaxProfit(33)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(33)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
10->1;
}
// Function: 1096.sol-Zlots-ownerSetMinBet(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minBet = newMinimumBet

IRs:
minBet(uint256) := newMinimumBet(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
2->1;
}
// Function: 1096.sol-Zlots-ownerSetZlotsAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
zlotsJackpot = zlotsAddress

IRs:
zlotsJackpot(address) := zlotsAddress(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
2->1;
}
// Function: 1096.sol-Zlots-pauseGame()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
gameActive = false

IRs:
gameActive(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1096.sol-Zlots-random(uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
maxRandom(blockn,entropy) % upper

IRs:
TMP_169(uint256) = INTERNAL_CALL, Zlots.maxRandom(uint256,address)(blockn,entropy)
TMP_170(uint256) = TMP_169 % upper
RETURN TMP_170"];
2[label="Node Type: RETURN 2

EXPRESSION:
randomNumber

IRs:
RETURN randomNumber"];
}
// Function: 1096.sol-Zlots-resumeGame()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
gameActive = true

IRs:
gameActive(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1096.sol-Zlots-setMaxProfit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor

IRs:
REF_123(uint256) -> maxProfit[divRate]
REF_124(uint256) -> contractBalance[divRate]
TMP_171(uint256) = REF_124 * maxProfitAsPercentOfHouse
TMP_172(uint256) = TMP_171 / maxProfitDivisor
REF_123(uint256) (->maxProfit) := TMP_172(uint256)"];
}
// Function: 1096.sol-Zlots-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_40 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_40(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_41 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_42(address[7]) = HIGH_LEVEL_CALL, dest:TMP_41(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_42(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_43(bool) = i < 7
CONDITION TMP_43"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_23(address) -> UsedBankrollAddresses[i]
REF_24(bool) -> ValidBankrollAddress[REF_23]
REF_24(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_44(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1096.sol-Zlots-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
maxProfitDivisor = 1000000

IRs:
maxProfitDivisor(uint256) := 1000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
houseEdgeDivisor = 1000

IRs:
houseEdgeDivisor(uint256) := 1000(uint256)"];
}
// Function: 1096.sol-Zlots-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
minBet = 1e18

IRs:
minBet(uint256) := 1000000000000000000(uint256)"];
}
// Function: 1096.sol-Zlots-subContractBalance(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = contractBalance[divRate].sub(sub)

IRs:
REF_126(uint256) -> contractBalance[divRate]
REF_127(uint256) -> contractBalance[divRate]
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_127', 'sub'] 
REF_126(uint256) (->contractBalance) := TMP_175(uint256)"];
}
// Function: 1096.sol-ZlotsJackpotHoldingContract-getJackpot()
digraph{
}
// Function: 1096.sol-ZlotsJackpotHoldingContract-payOutWinner(address)
digraph{
}
}
