digraph G {
// Function: 1101.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_224(uint256) = a + b
c(uint256) := TMP_224(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_225(bool) = c >= a
TMP_226(None) = SOLIDITY_CALL assert(bool)(TMP_225)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1101.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_220(uint256) = a / b
c(uint256) := TMP_220(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1101.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_215(bool) = a == 0
CONDITION TMP_215"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_216(uint256) = a * b
c(uint256) := TMP_216(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_217(uint256) = c / a
TMP_218(bool) = TMP_217 == b
TMP_219(None) = SOLIDITY_CALL assert(bool)(TMP_218)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1101.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_221(bool) = b <= a
TMP_222(None) = SOLIDITY_CALL assert(bool)(TMP_221)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_223(uint256) = a - b
RETURN TMP_223"];
}
// Function: 1101.sol-ZethrBankrollBridge-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_3(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_3(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_13 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_13(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1101.sol-ZethrBankrollBridge-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_7(bool) -> ValidBankrollAddress[msg.sender]
TMP_17(None) = SOLIDITY_CALL require(bool,string)(REF_7,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-ZethrBankrollBridge-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_15(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_6(address) -> UsedBankrollAddresses[TMP_15]
TMP_16 = CONVERT REF_6 to ZethrTokenBankroll
RETURN TMP_16"];
}
// Function: 1101.sol-ZethrBankrollBridge-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_8 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_8(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_9 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_10(address[7]) = HIGH_LEVEL_CALL, dest:TMP_9(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_10(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_11(bool) = i < 7
CONDITION TMP_11"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_1(address) -> UsedBankrollAddresses[i]
REF_2(bool) -> ValidBankrollAddress[REF_1]
REF_2(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_12(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1101.sol-ZethrInterface-withdraw()
digraph{
}
// Function: 1101.sol-ZethrMainBankroll-gameGetTokenBankrollList()
digraph{
}
// Function: 1101.sol-ZethrShell-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_11(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_11(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_23 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_23(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1101.sol-ZethrShell-WithdrawAndTransferToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:Zethr(ZethrInterface), function:withdraw, arguments:[]  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WithdrawToBankroll()

IRs:
INTERNAL_CALL, ZethrShell.WithdrawToBankroll()()"];
}
// Function: 1101.sol-ZethrShell-WithdrawToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_15(address) -> UsedBankrollAddresses[0]
TMP_27 = CONVERT REF_15 to address
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
Transfer dest:TMP_27 value:TMP_29"];
}
// Function: 1101.sol-ZethrShell-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_18(bool) -> ValidBankrollAddress[msg.sender]
TMP_33(None) = SOLIDITY_CALL require(bool,string)(REF_18,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-ZethrShell-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_25(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_14(address) -> UsedBankrollAddresses[TMP_25]
TMP_26 = CONVERT REF_14 to ZethrTokenBankroll
RETURN TMP_26"];
}
// Function: 1101.sol-ZethrShell-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_18 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_18(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_19 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_20(address[7]) = HIGH_LEVEL_CALL, dest:TMP_19(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_20(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_21(bool) = i < 7
CONDITION TMP_21"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_9(address) -> UsedBankrollAddresses[i]
REF_10(bool) -> ValidBankrollAddress[REF_9]
REF_10(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_22(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1101.sol-ZethrTierLibrary-getTier(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
actualDiv = divRate

IRs:
actualDiv(uint256) := divRate(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
actualDiv >= 30

IRs:
TMP_0(bool) = actualDiv >= 30
CONDITION TMP_0"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
6

IRs:
RETURN 6"];
4[label="Node Type: IF 4

EXPRESSION:
actualDiv >= 25

IRs:
TMP_1(bool) = actualDiv >= 25
CONDITION TMP_1"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
5

IRs:
RETURN 5"];
6[label="Node Type: IF 6

EXPRESSION:
actualDiv >= 20

IRs:
TMP_2(bool) = actualDiv >= 20
CONDITION TMP_2"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
4

IRs:
RETURN 4"];
8[label="Node Type: IF 8

EXPRESSION:
actualDiv >= 15

IRs:
TMP_3(bool) = actualDiv >= 15
CONDITION TMP_3"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
3

IRs:
RETURN 3"];
10[label="Node Type: IF 10

EXPRESSION:
actualDiv >= 10

IRs:
TMP_4(bool) = actualDiv >= 10
CONDITION TMP_4"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
2

IRs:
RETURN 2"];
12[label="Node Type: IF 12

EXPRESSION:
actualDiv >= 5

IRs:
TMP_5(bool) = actualDiv >= 5
CONDITION TMP_5"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: RETURN 13

EXPRESSION:
1

IRs:
RETURN 1"];
14[label="Node Type: IF 14

EXPRESSION:
actualDiv >= 2

IRs:
TMP_6(bool) = actualDiv >= 2
CONDITION TMP_6"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: RETURN 15

EXPRESSION:
0

IRs:
RETURN 0"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
revert()()

IRs:
TMP_7(None) = SOLIDITY_CALL revert()()"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: END_IF 23
"];
}
// Function: 1101.sol-ZethrTokenBankroll-gameRequestTokens(address,uint256)
digraph{
}
// Function: 1101.sol-ZethrTokenBankroll-gameTokenAmount(address)
digraph{
}
// Function: 1101.sol-Zlots-RequestBankrollPayment(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenBankrollAddress = UsedBankrollAddresses[tier]

IRs:
REF_25(address) -> UsedBankrollAddresses[tier]
tokenBankrollAddress(address) := REF_25(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to,tokens)

IRs:
TMP_45 = CONVERT tokenBankrollAddress to ZethrTokenBankroll
HIGH_LEVEL_CALL, dest:TMP_45(ZethrTokenBankroll), function:gameRequestTokens, arguments:['to', 'tokens']  "];
}
// Function: 1101.sol-Zlots-WithdrawAndTransferToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:Zethr(ZethrInterface), function:withdraw, arguments:[]  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WithdrawToBankroll()

IRs:
INTERNAL_CALL, ZethrShell.WithdrawToBankroll()()"];
}
// Function: 1101.sol-Zlots-WithdrawToBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_19(address) -> UsedBankrollAddresses[0]
TMP_34 = CONVERT REF_19 to address
TMP_35 = CONVERT this to address
TMP_36(uint256) = SOLIDITY_CALL balance(address)(TMP_35)
Transfer dest:TMP_34 value:TMP_36"];
}
// Function: 1101.sol-Zlots-_finishSpin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spin = playerSpins[target]

IRs:
REF_47(Zlots.playerSpin) -> playerSpins[target]
spin(Zlots.playerSpin) := REF_47(Zlots.playerSpin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(spin.tokenValue > 0)

IRs:
REF_48(uint200) -> spin.tokenValue
TMP_78(bool) = REF_48 > 0
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(spin.blockn != block.number)

IRs:
REF_49(uint48) -> spin.blockn
TMP_80(bool) = REF_49 != block.number
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
profit = 0

IRs:
profit(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
category = 0

IRs:
category(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
block.number - spin.blockn > 255

IRs:
REF_50(uint48) -> spin.blockn
TMP_82(uint256) = block.number - REF_50
TMP_83(bool) = TMP_82 > 255
CONDITION TMP_83"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
result = 1000000

IRs:
result(uint256) := 1000000(uint256)"];
8->10;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
result = random(1000000,spin.blockn,target) + 1

IRs:
REF_51(uint48) -> spin.blockn
TMP_84(uint256) = INTERNAL_CALL, Zlots.random(uint256,uint256,address)(1000000,REF_51,target)
TMP_85(uint256) = TMP_84 + 1
result(uint256) := TMP_85(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
result > 476662

IRs:
TMP_86(bool) = result > 476662
CONDITION TMP_86"];
11->12[label="True"];
11->16[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
RequestBankrollPayment(zlotsJackpot,profit,tier)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.RequestBankrollPayment(address,uint256,uint256)(zlotsJackpot,profit,tier)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0))

IRs:
REF_52(Zlots.playerSpin) -> playerSpins[target]
TMP_88 = CONVERT 0 to uint200
TMP_89 = CONVERT 0 to uint48
TMP_90 = CONVERT 0 to uint8
TMP_91(Zlots.playerSpin) = new playerSpin(TMP_88,TMP_89,TMP_90)
REF_52(Zlots.playerSpin) (->playerSpins) := TMP_91(Zlots.playerSpin)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Loss(target,spin.blockn)

IRs:
REF_53(uint48) -> spin.blockn
Emit Loss(target,REF_53)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,false)

IRs:
REF_54(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_54,category,False)"];
15->117;
16[label="Node Type: IF 16

EXPRESSION:
result < 2

IRs:
TMP_94(bool) = result < 2
CONDITION TMP_94"];
16->17[label="True"];
16->24[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
profit = ZlotsJackpotHoldingContract(zlotsJackpot).getJackpot()

IRs:
TMP_95 = CONVERT zlotsJackpot to ZlotsJackpotHoldingContract
TMP_96(uint256) = HIGH_LEVEL_CALL, dest:TMP_95(ZlotsJackpotHoldingContract), function:getJackpot, arguments:[]  
profit(uint256) := TMP_96(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
category = 1

IRs:
category(uint256) := 1(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
ThreeMoonJackpot(target,spin.blockn)

IRs:
REF_56(uint48) -> spin.blockn
Emit ThreeMoonJackpot(target,REF_56)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,true)

IRs:
REF_57(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_57,category,True)"];
20->21;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
tier = spin.tier

IRs:
REF_58(uint8) -> spin.tier
tier(uint8) := REF_58(uint8)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0))

IRs:
REF_59(Zlots.playerSpin) -> playerSpins[target]
TMP_99 = CONVERT 0 to uint200
TMP_100 = CONVERT 0 to uint48
TMP_101 = CONVERT 0 to uint8
TMP_102(Zlots.playerSpin) = new playerSpin(TMP_99,TMP_100,TMP_101)
REF_59(Zlots.playerSpin) (->playerSpins) := TMP_102(Zlots.playerSpin)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target)

IRs:
TMP_103 = CONVERT zlotsJackpot to ZlotsJackpotHoldingContract
HIGH_LEVEL_CALL, dest:TMP_103(ZlotsJackpotHoldingContract), function:payOutWinner, arguments:['target']  "];
23->116;
24[label="Node Type: IF 24

EXPRESSION:
result < 299

IRs:
TMP_105(bool) = result < 299
CONDITION TMP_105"];
24->25[label="True"];
24->28[label="False"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,100)

IRs:
REF_62(uint200) -> spin.tokenValue
TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_62', '100'] 
profit(uint256) := TMP_106(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
category = 2

IRs:
category(uint256) := 2(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
TwoMoonPrize(target,spin.blockn)

IRs:
REF_63(uint48) -> spin.blockn
Emit TwoMoonPrize(target,REF_63)"];
27->111;
28[label="Node Type: IF 28

EXPRESSION:
result < 3128

IRs:
TMP_108(bool) = result < 3128
CONDITION TMP_108"];
28->29[label="True"];
28->32[label="False"];
29[label="Node Type: EXPRESSION 29

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,20)

IRs:
REF_65(uint200) -> spin.tokenValue
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_65', '20'] 
profit(uint256) := TMP_109(uint256)"];
29->30;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
category = 3

IRs:
category(uint256) := 3(uint256)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
ZTHPrize(target,spin.blockn)

IRs:
REF_66(uint48) -> spin.blockn
Emit ZTHPrize(target,REF_66)"];
31->110;
32[label="Node Type: IF 32

EXPRESSION:
result < 5957

IRs:
TMP_111(bool) = result < 5957
CONDITION TMP_111"];
32->33[label="True"];
32->36[label="False"];
33[label="Node Type: EXPRESSION 33

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,75),10)

IRs:
REF_69(uint200) -> spin.tokenValue
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_69', '75'] 
TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_112', '10'] 
profit(uint256) := TMP_113(uint256)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
category = 4

IRs:
category(uint256) := 4(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
ThreeZSymbols(target,spin.blockn)

IRs:
REF_70(uint48) -> spin.blockn
Emit ThreeZSymbols(target,REF_70)"];
35->109;
36[label="Node Type: IF 36

EXPRESSION:
result < 8786

IRs:
TMP_115(bool) = result < 8786
CONDITION TMP_115"];
36->37[label="True"];
36->40[label="False"];
37[label="Node Type: EXPRESSION 37

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,75),10)

IRs:
REF_73(uint200) -> spin.tokenValue
TMP_116(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_73', '75'] 
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_116', '10'] 
profit(uint256) := TMP_117(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
category = 5

IRs:
category(uint256) := 5(uint256)"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
ThreeTSymbols(target,spin.blockn)

IRs:
REF_74(uint48) -> spin.blockn
Emit ThreeTSymbols(target,REF_74)"];
39->108;
40[label="Node Type: IF 40

EXPRESSION:
result < 11615

IRs:
TMP_119(bool) = result < 11615
CONDITION TMP_119"];
40->41[label="True"];
40->44[label="False"];
41[label="Node Type: EXPRESSION 41

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,75),10)

IRs:
REF_77(uint200) -> spin.tokenValue
TMP_120(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_77', '75'] 
TMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_120', '10'] 
profit(uint256) := TMP_121(uint256)"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
category = 6

IRs:
category(uint256) := 6(uint256)"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
ThreeHSymbols(target,spin.blockn)

IRs:
REF_78(uint48) -> spin.blockn
Emit ThreeHSymbols(target,REF_78)"];
43->107;
44[label="Node Type: IF 44

EXPRESSION:
result < 14444

IRs:
TMP_123(bool) = result < 14444
CONDITION TMP_123"];
44->45[label="True"];
44->48[label="False"];
45[label="Node Type: EXPRESSION 45

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,15)

IRs:
REF_80(uint200) -> spin.tokenValue
TMP_124(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_80', '15'] 
profit(uint256) := TMP_124(uint256)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
category = 7

IRs:
category(uint256) := 7(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
ThreeEtherIcons(target,spin.blockn)

IRs:
REF_81(uint48) -> spin.blockn
Emit ThreeEtherIcons(target,REF_81)"];
47->106;
48[label="Node Type: IF 48

EXPRESSION:
result < 17273

IRs:
TMP_126(bool) = result < 17273
CONDITION TMP_126"];
48->49[label="True"];
48->52[label="False"];
49[label="Node Type: EXPRESSION 49

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,10)

IRs:
REF_83(uint200) -> spin.tokenValue
TMP_127(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_83', '10'] 
profit(uint256) := TMP_127(uint256)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
category = 8

IRs:
category(uint256) := 8(uint256)"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
ThreePurplePyramids(target,spin.blockn)

IRs:
REF_84(uint48) -> spin.blockn
Emit ThreePurplePyramids(target,REF_84)"];
51->105;
52[label="Node Type: IF 52

EXPRESSION:
result < 20102

IRs:
TMP_129(bool) = result < 20102
CONDITION TMP_129"];
52->53[label="True"];
52->56[label="False"];
53[label="Node Type: EXPRESSION 53

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,10)

IRs:
REF_86(uint200) -> spin.tokenValue
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_86', '10'] 
profit(uint256) := TMP_130(uint256)"];
53->54;
54[label="Node Type: EXPRESSION 54

EXPRESSION:
category = 9

IRs:
category(uint256) := 9(uint256)"];
54->55;
55[label="Node Type: EXPRESSION 55

EXPRESSION:
ThreeGoldPyramids(target,spin.blockn)

IRs:
REF_87(uint48) -> spin.blockn
Emit ThreeGoldPyramids(target,REF_87)"];
55->104;
56[label="Node Type: IF 56

EXPRESSION:
result < 22930

IRs:
TMP_132(bool) = result < 22930
CONDITION TMP_132"];
56->57[label="True"];
56->60[label="False"];
57[label="Node Type: EXPRESSION 57

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,12)

IRs:
REF_89(uint200) -> spin.tokenValue
TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_89', '12'] 
profit(uint256) := TMP_133(uint256)"];
57->58;
58[label="Node Type: EXPRESSION 58

EXPRESSION:
category = 10

IRs:
category(uint256) := 10(uint256)"];
58->59;
59[label="Node Type: EXPRESSION 59

EXPRESSION:
ThreeRockets(target,spin.blockn)

IRs:
REF_90(uint48) -> spin.blockn
Emit ThreeRockets(target,REF_90)"];
59->103;
60[label="Node Type: IF 60

EXPRESSION:
result < 52333

IRs:
TMP_135(bool) = result < 52333
CONDITION TMP_135"];
60->61[label="True"];
60->64[label="False"];
61[label="Node Type: EXPRESSION 61

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,25),10)

IRs:
REF_93(uint200) -> spin.tokenValue
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_93', '25'] 
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_136', '10'] 
profit(uint256) := TMP_137(uint256)"];
61->62;
62[label="Node Type: EXPRESSION 62

EXPRESSION:
category = 11

IRs:
category(uint256) := 11(uint256)"];
62->63;
63[label="Node Type: EXPRESSION 63

EXPRESSION:
OneMoonPrize(target,spin.blockn)

IRs:
REF_94(uint48) -> spin.blockn
Emit OneMoonPrize(target,REF_94)"];
63->102;
64[label="Node Type: IF 64

EXPRESSION:
result < 120226

IRs:
TMP_139(bool) = result < 120226
CONDITION TMP_139"];
64->65[label="True"];
64->68[label="False"];
65[label="Node Type: EXPRESSION 65

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,15),10)

IRs:
REF_97(uint200) -> spin.tokenValue
TMP_140(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_97', '15'] 
TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_140', '10'] 
profit(uint256) := TMP_141(uint256)"];
65->66;
66[label="Node Type: EXPRESSION 66

EXPRESSION:
category = 12

IRs:
category(uint256) := 12(uint256)"];
66->67;
67[label="Node Type: EXPRESSION 67

EXPRESSION:
OneOfEachPyramidPrize(target,spin.blockn)

IRs:
REF_98(uint48) -> spin.blockn
Emit OneOfEachPyramidPrize(target,REF_98)"];
67->101;
68[label="Node Type: IF 68

EXPRESSION:
result < 171147

IRs:
TMP_143(bool) = result < 171147
CONDITION TMP_143"];
68->69[label="True"];
68->72[label="False"];
69[label="Node Type: EXPRESSION 69

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_99(uint200) -> spin.tokenValue
profit(uint256) := REF_99(uint200)"];
69->70;
70[label="Node Type: EXPRESSION 70

EXPRESSION:
category = 13

IRs:
category(uint256) := 13(uint256)"];
70->71;
71[label="Node Type: EXPRESSION 71

EXPRESSION:
TwoZSymbols(target,spin.blockn)

IRs:
REF_100(uint48) -> spin.blockn
Emit TwoZSymbols(target,REF_100)"];
71->100;
72[label="Node Type: IF 72

EXPRESSION:
result < 222068

IRs:
TMP_145(bool) = result < 222068
CONDITION TMP_145"];
72->73[label="True"];
72->76[label="False"];
73[label="Node Type: EXPRESSION 73

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_101(uint200) -> spin.tokenValue
profit(uint256) := REF_101(uint200)"];
73->74;
74[label="Node Type: EXPRESSION 74

EXPRESSION:
category = 14

IRs:
category(uint256) := 14(uint256)"];
74->75;
75[label="Node Type: EXPRESSION 75

EXPRESSION:
TwoTSymbols(target,spin.blockn)

IRs:
REF_102(uint48) -> spin.blockn
Emit TwoTSymbols(target,REF_102)"];
75->99;
76[label="Node Type: IF 76

EXPRESSION:
result < 272989

IRs:
TMP_147(bool) = result < 272989
CONDITION TMP_147"];
76->77[label="True"];
76->80[label="False"];
77[label="Node Type: EXPRESSION 77

EXPRESSION:
profit = spin.tokenValue

IRs:
REF_103(uint200) -> spin.tokenValue
profit(uint256) := REF_103(uint200)"];
77->78;
78[label="Node Type: EXPRESSION 78

EXPRESSION:
category = 15

IRs:
category(uint256) := 15(uint256)"];
78->79;
79[label="Node Type: EXPRESSION 79

EXPRESSION:
TwoHSymbols(target,spin.blockn)

IRs:
REF_104(uint48) -> spin.blockn
Emit TwoHSymbols(target,REF_104)"];
79->98;
80[label="Node Type: IF 80

EXPRESSION:
result < 323910

IRs:
TMP_149(bool) = result < 323910
CONDITION TMP_149"];
80->81[label="True"];
80->84[label="False"];
81[label="Node Type: EXPRESSION 81

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,2)

IRs:
REF_106(uint200) -> spin.tokenValue
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_106', '2'] 
profit(uint256) := TMP_150(uint256)"];
81->82;
82[label="Node Type: EXPRESSION 82

EXPRESSION:
category = 16

IRs:
category(uint256) := 16(uint256)"];
82->83;
83[label="Node Type: EXPRESSION 83

EXPRESSION:
TwoEtherIcons(target,spin.blockn)

IRs:
REF_107(uint48) -> spin.blockn
Emit TwoEtherIcons(target,REF_107)"];
83->97;
84[label="Node Type: IF 84

EXPRESSION:
result < 374831

IRs:
TMP_152(bool) = result < 374831
CONDITION TMP_152"];
84->85[label="True"];
84->88[label="False"];
85[label="Node Type: EXPRESSION 85

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,133),100)

IRs:
REF_110(uint200) -> spin.tokenValue
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_110', '133'] 
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_153', '100'] 
profit(uint256) := TMP_154(uint256)"];
85->86;
86[label="Node Type: EXPRESSION 86

EXPRESSION:
category = 17

IRs:
category(uint256) := 17(uint256)"];
86->87;
87[label="Node Type: EXPRESSION 87

EXPRESSION:
TwoPurplePyramids(target,spin.blockn)

IRs:
REF_111(uint48) -> spin.blockn
Emit TwoPurplePyramids(target,REF_111)"];
87->96;
88[label="Node Type: IF 88

EXPRESSION:
result < 425752

IRs:
TMP_156(bool) = result < 425752
CONDITION TMP_156"];
88->89[label="True"];
88->92[label="False"];
89[label="Node Type: EXPRESSION 89

EXPRESSION:
profit = SafeMath.div(SafeMath.mul(spin.tokenValue,133),100)

IRs:
REF_114(uint200) -> spin.tokenValue
TMP_157(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_114', '133'] 
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_157', '100'] 
profit(uint256) := TMP_158(uint256)"];
89->90;
90[label="Node Type: EXPRESSION 90

EXPRESSION:
category = 18

IRs:
category(uint256) := 18(uint256)"];
90->91;
91[label="Node Type: EXPRESSION 91

EXPRESSION:
TwoGoldPyramids(target,spin.blockn)

IRs:
REF_115(uint48) -> spin.blockn
Emit TwoGoldPyramids(target,REF_115)"];
91->95;
92[label="Node Type: EXPRESSION 92

EXPRESSION:
profit = SafeMath.mul(spin.tokenValue,2)

IRs:
REF_117(uint200) -> spin.tokenValue
TMP_160(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_117', '2'] 
profit(uint256) := TMP_160(uint256)"];
92->93;
93[label="Node Type: EXPRESSION 93

EXPRESSION:
category = 19

IRs:
category(uint256) := 19(uint256)"];
93->94;
94[label="Node Type: EXPRESSION 94

EXPRESSION:
TwoRockets(target,spin.blockn)

IRs:
REF_118(uint48) -> spin.blockn
Emit TwoRockets(target,REF_118)"];
94->95;
95[label="Node Type: END_IF 95
"];
95->96;
96[label="Node Type: END_IF 96
"];
96->97;
97[label="Node Type: END_IF 97
"];
97->98;
98[label="Node Type: END_IF 98
"];
98->99;
99[label="Node Type: END_IF 99
"];
99->100;
100[label="Node Type: END_IF 100
"];
100->101;
101[label="Node Type: END_IF 101
"];
101->102;
102[label="Node Type: END_IF 102
"];
102->103;
103[label="Node Type: END_IF 103
"];
103->104;
104[label="Node Type: END_IF 104
"];
104->105;
105[label="Node Type: END_IF 105
"];
105->106;
106[label="Node Type: END_IF 106
"];
106->107;
107[label="Node Type: END_IF 107
"];
107->108;
108[label="Node Type: END_IF 108
"];
108->109;
109[label="Node Type: END_IF 109
"];
109->110;
110[label="Node Type: END_IF 110
"];
110->111;
111[label="Node Type: END_IF 111
"];
111->112;
112[label="Node Type: EXPRESSION 112

EXPRESSION:
LogResult(target,result,profit,spin.tokenValue,category,true)

IRs:
REF_119(uint200) -> spin.tokenValue
Emit LogResult(target,result,profit,REF_119,category,True)"];
112->113;
113[label="Node Type: EXPRESSION 113

EXPRESSION:
tier = spin.tier

IRs:
REF_120(uint8) -> spin.tier
tier(uint8) := REF_120(uint8)"];
113->114;
114[label="Node Type: EXPRESSION 114

EXPRESSION:
playerSpins[target] = playerSpin(uint200(0),uint48(0),uint8(0))

IRs:
REF_121(Zlots.playerSpin) -> playerSpins[target]
TMP_163 = CONVERT 0 to uint200
TMP_164 = CONVERT 0 to uint48
TMP_165 = CONVERT 0 to uint8
TMP_166(Zlots.playerSpin) = new playerSpin(TMP_163,TMP_164,TMP_165)
REF_121(Zlots.playerSpin) (->playerSpins) := TMP_166(Zlots.playerSpin)"];
114->115;
115[label="Node Type: EXPRESSION 115

EXPRESSION:
RequestBankrollPayment(target,profit,tier)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.RequestBankrollPayment(address,uint256,uint256)(target,profit,tier)"];
115->116;
116[label="Node Type: END_IF 116
"];
116->117;
117[label="Node Type: END_IF 117
"];
117->118;
118[label="Node Type: EXPRESSION 118

EXPRESSION:
SpinConcluded(target,spin.blockn)

IRs:
REF_122(uint48) -> spin.blockn
Emit SpinConcluded(target,REF_122)"];
118->119;
119[label="Node Type: RETURN 119

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 1101.sol-Zlots-_spinTokens(Zlots.TKN,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->20;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(gameActive)

IRs:
TMP_54(None) = SOLIDITY_CALL require(bool)(gameActive)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(1e18 <= _tkn.value)

IRs:
REF_31(uint256) -> _tkn.value
TMP_55(bool) = 1000000000000000000 <= REF_31
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_tkn.value < ((2 ** 200) - 1))

IRs:
REF_32(uint256) -> _tkn.value
TMP_57(uint256) = 2 ** 200
TMP_58(uint256) = TMP_57 - 1
TMP_59(bool) = REF_32 < TMP_58
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(block.number < ((2 ** 56) - 1))

IRs:
TMP_61(uint256) = 2 ** 56
TMP_62(uint256) = TMP_61 - 1
TMP_63(bool) = block.number < TMP_62
TMP_64(None) = SOLIDITY_CALL require(bool)(TMP_63)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_customerAddress = _tkn.sender

IRs:
REF_33(address) -> _tkn.sender
_customerAddress(address) := REF_33(address)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_wagered = _tkn.value

IRs:
REF_34(uint256) -> _tkn.value
_wagered(uint256) := REF_34(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
spin = playerSpins[_tkn.sender]

IRs:
REF_35(address) -> _tkn.sender
REF_36(Zlots.playerSpin) -> playerSpins[REF_35]
spin(Zlots.playerSpin) := REF_36(Zlots.playerSpin)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
addContractBalance(divRate,_wagered)

IRs:
INTERNAL_CALL, Zlots.addContractBalance(uint256,uint256)(divRate,_wagered)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(block.number != spin.blockn)

IRs:
REF_37(uint48) -> spin.blockn
TMP_66(bool) = block.number != REF_37
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
spin.blockn != 0

IRs:
REF_38(uint48) -> spin.blockn
TMP_68(bool) = REF_38 != 0
CONDITION TMP_68"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_finishSpin(_tkn.sender)

IRs:
REF_39(address) -> _tkn.sender
TMP_69(uint256) = INTERNAL_CALL, Zlots._finishSpin(address)(REF_39)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
spin.blockn = uint48(block.number)

IRs:
REF_40(uint48) -> spin.blockn
TMP_70 = CONVERT block.number to uint48
REF_40(uint48) (->spin) := TMP_70(uint48)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
spin.tokenValue = uint200(_wagered)

IRs:
REF_41(uint200) -> spin.tokenValue
TMP_71 = CONVERT _wagered to uint200
REF_41(uint200) (->spin) := TMP_71(uint200)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
spin.tier = uint8(ZethrTierLibrary.getTier(divRate))

IRs:
REF_42(uint8) -> spin.tier
TMP_72(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
TMP_73 = CONVERT TMP_72 to uint8
REF_42(uint8) (->spin) := TMP_73(uint8)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
playerSpins[_tkn.sender] = spin

IRs:
REF_44(address) -> _tkn.sender
REF_45(Zlots.playerSpin) -> playerSpins[REF_44]
REF_45(Zlots.playerSpin) (->playerSpins) := spin(Zlots.playerSpin)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
totalSpins += 1

IRs:
totalSpins(uint256) = totalSpins + 1"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
totalZTHWagered += _wagered

IRs:
totalZTHWagered(uint256) = totalZTHWagered + _wagered"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
TokensWagered(_customerAddress,_wagered)

IRs:
Emit TokensWagered(_customerAddress,_wagered)"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
betIsValid(_tkn.value,divRate)

IRs:
REF_46(uint256) -> _tkn.value
MODIFIER_CALL, Zlots.betIsValid(uint256,uint256)(REF_46,divRate)"];
20->1;
}
// Function: 1101.sol-Zlots-_zthToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_tokenContract == ZTHTKNADDR

IRs:
TMP_199(bool) = _tokenContract == ZTHTKNADDR
RETURN TMP_199"];
}
// Function: 1101.sol-Zlots-addContractBalance(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = contractBalance[divRate].add(add)

IRs:
REF_130(uint256) -> contractBalance[divRate]
REF_131(uint256) -> contractBalance[divRate]
TMP_180(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_131', 'add'] 
REF_130(uint256) (->contractBalance) := TMP_180(uint256)"];
}
// Function: 1101.sol-Zlots-bankrollExternalUpdateTokens(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = newBalance

IRs:
REF_133(uint256) -> contractBalance[divRate]
REF_133(uint256) (->contractBalance) := newBalance(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
setMaxProfit(divRate)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(divRate)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fromBankroll()

IRs:
MODIFIER_CALL, ZethrBankrollBridge.fromBankroll()()"];
3->1;
}
// Function: 1101.sol-Zlots-betIsValid(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_betSize.mul(100) <= getMaxProfit(divRate))

IRs:
TMP_201(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_betSize', '100'] 
TMP_202(uint256) = INTERNAL_CALL, Zlots.getMaxProfit(uint256)(divRate)
TMP_203(bool) = TMP_201 <= TMP_202
TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-Zlots-changeBankroll(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bankroll = _newBankroll

IRs:
bankroll(address) := _newBankroll(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1101.sol-Zlots-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1101.sol-Zlots-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
setupBankrollInterface(BankrollAddress)

IRs:
INTERNAL_CALL, ZethrBankrollBridge.setupBankrollInterface(address)(BankrollAddress)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerSetMaxProfitAsPercentOfHouse(50000)

IRs:
INTERNAL_CALL, Zlots.ownerSetMaxProfitAsPercentOfHouse(uint256)(50000)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bankroll = ZTHBANKROLL

IRs:
bankroll(address) := ZTHBANKROLL(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
gameActive = true

IRs:
gameActive(bool) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ownerSetMinBet(1e18)

IRs:
INTERNAL_CALL, Zlots.ownerSetMinBet(uint256)(1000000000000000000)"];
}
// Function: 1101.sol-Zlots-execute(address,uint256,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_tkn.sender = _from

IRs:
REF_29(address) -> _tkn.sender
REF_29(address) (->_tkn) := _from(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_tkn.value = _value

IRs:
REF_30(uint256) -> _tkn.value
REF_30(uint256) (->_tkn) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_spinTokens(_tkn,divRate)

IRs:
INTERNAL_CALL, Zlots._spinTokens(Zlots.TKN,uint256)(_tkn,divRate)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
fromBankroll()

IRs:
MODIFIER_CALL, ZethrBankrollBridge.fromBankroll()()"];
6->1;
}
// Function: 1101.sol-Zlots-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1101.sol-Zlots-finishSpin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
_finishSpin(msg.sender)

IRs:
TMP_76(uint256) = INTERNAL_CALL, Zlots._finishSpin(address)(msg.sender)
RETURN TMP_76"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
gameIsActive()

IRs:
MODIFIER_CALL, Zlots.gameIsActive()()"];
2->1;
}
// Function: 1101.sol-Zlots-fromBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ValidBankrollAddress[msg.sender],msg.sender should be a valid bankroll)

IRs:
REF_134(bool) -> ValidBankrollAddress[msg.sender]
TMP_200(None) = SOLIDITY_CALL require(bool,string)(REF_134,msg.sender should be a valid bankroll)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-Zlots-gameIsActive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(gamePaused == false)

IRs:
TMP_205(bool) = gamePaused == False
TMP_206(None) = SOLIDITY_CALL require(bool)(TMP_205)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-Zlots-getMaxProfit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor

IRs:
REF_126(uint256) -> contractBalance[divRate]
TMP_177(uint256) = REF_126 * maxProfitAsPercentOfHouse
TMP_178(uint256) = TMP_177 / maxProfitDivisor
RETURN TMP_178"];
}
// Function: 1101.sol-Zlots-getZethrTokenBankroll(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)])

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:ZethrTierLibrary, function:ZethrTierLibrary.getTier(uint256), arguments:['divRate'] 
REF_28(address) -> UsedBankrollAddresses[TMP_47]
TMP_48 = CONVERT REF_28 to ZethrTokenBankroll
RETURN TMP_48"];
}
// Function: 1101.sol-Zlots-maxRandom(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint256(keccak256()(abi.encodePacked(blockhash(uint256)(blockn),entropy)))

IRs:
TMP_169(uint256) = SOLIDITY_CALL blockhash(uint256)(blockn)
TMP_170(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_169,entropy)
TMP_171(bytes32) = SOLIDITY_CALL keccak256()(TMP_170)
TMP_172 = CONVERT TMP_171 to uint256
RETURN TMP_172"];
2[label="Node Type: RETURN 2

EXPRESSION:
randomNumber

IRs:
RETURN randomNumber"];
}
// Function: 1101.sol-Zlots-onlyBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == bankroll)

IRs:
TMP_209(bool) = msg.sender == bankroll
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-Zlots-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_207(bool) = msg.sender == owner
TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-Zlots-onlyOwnerOrBankroll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == bankroll)

IRs:
TMP_211(bool) = msg.sender == owner
TMP_212(bool) = msg.sender == bankroll
TMP_213(bool) = TMP_211 || TMP_212
TMP_214(None) = SOLIDITY_CALL require(bool)(TMP_213)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1101.sol-Zlots-ownerSetMaxProfitAsPercentOfHouse(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newMaxProfitAsPercent <= 200000)

IRs:
TMP_183(bool) = newMaxProfitAsPercent <= 200000
TMP_184(None) = SOLIDITY_CALL require(bool)(TMP_183)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
maxProfitAsPercentOfHouse = newMaxProfitAsPercent

IRs:
maxProfitAsPercentOfHouse(uint256) := newMaxProfitAsPercent(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
setMaxProfit(2)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(2)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
setMaxProfit(5)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(5)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
setMaxProfit(10)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(10)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
setMaxProfit(15)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(15)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
setMaxProfit(20)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(20)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
setMaxProfit(25)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(25)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
setMaxProfit(33)

IRs:
INTERNAL_CALL, Zlots.setMaxProfit(uint256)(33)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
10->1;
}
// Function: 1101.sol-Zlots-ownerSetMinBet(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minBet = newMinimumBet

IRs:
minBet(uint256) := newMinimumBet(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
2->1;
}
// Function: 1101.sol-Zlots-ownerSetZlotsAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
zlotsJackpot = zlotsAddress

IRs:
zlotsJackpot(address) := zlotsAddress(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zlots.onlyOwner()()"];
2->1;
}
// Function: 1101.sol-Zlots-pauseGame()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
gameActive = false

IRs:
gameActive(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1101.sol-Zlots-random(uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
maxRandom(blockn,entropy) % upper

IRs:
TMP_173(uint256) = INTERNAL_CALL, Zlots.maxRandom(uint256,address)(blockn,entropy)
TMP_174(uint256) = TMP_173 % upper
RETURN TMP_174"];
2[label="Node Type: RETURN 2

EXPRESSION:
randomNumber

IRs:
RETURN randomNumber"];
}
// Function: 1101.sol-Zlots-resumeGame()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
gameActive = true

IRs:
gameActive(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwnerOrBankroll()

IRs:
MODIFIER_CALL, Zlots.onlyOwnerOrBankroll()()"];
2->1;
}
// Function: 1101.sol-Zlots-setMaxProfit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor

IRs:
REF_124(uint256) -> maxProfit[divRate]
REF_125(uint256) -> contractBalance[divRate]
TMP_175(uint256) = REF_125 * maxProfitAsPercentOfHouse
TMP_176(uint256) = TMP_175 / maxProfitDivisor
REF_124(uint256) (->maxProfit) := TMP_176(uint256)"];
}
// Function: 1101.sol-Zlots-setupBankrollInterface(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D)

IRs:
TMP_40 = CONVERT 1213414487539738044640291921087954998087414317581 to ZethrInterface
Zethr(ZethrInterface) := TMP_40(ZethrInterface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList()

IRs:
TMP_41 = CONVERT ZethrMainBankrollAddress to ZethrMainBankroll
TMP_42(address[7]) = HIGH_LEVEL_CALL, dest:TMP_41(ZethrMainBankroll), function:gameGetTokenBankrollList, arguments:[]  
UsedBankrollAddresses(address[7]) = ['TMP_42(address[7])']"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < 7

IRs:
TMP_43(bool) = i < 7
CONDITION TMP_43"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ValidBankrollAddress[UsedBankrollAddresses[i]] = true

IRs:
REF_23(address) -> UsedBankrollAddresses[i]
REF_24(bool) -> ValidBankrollAddress[REF_23]
REF_24(bool) (->ValidBankrollAddress) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_44(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
}
// Function: 1101.sol-Zlots-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
maxProfitDivisor = 1000000

IRs:
maxProfitDivisor(uint256) := 1000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
houseEdgeDivisor = 1000

IRs:
houseEdgeDivisor(uint256) := 1000(uint256)"];
}
// Function: 1101.sol-Zlots-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
minBet = 1e18

IRs:
minBet(uint256) := 1000000000000000000(uint256)"];
}
// Function: 1101.sol-Zlots-subContractBalance(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractBalance[divRate] = contractBalance[divRate].sub(sub)

IRs:
REF_127(uint256) -> contractBalance[divRate]
REF_128(uint256) -> contractBalance[divRate]
TMP_179(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_128', 'sub'] 
REF_127(uint256) (->contractBalance) := TMP_179(uint256)"];
}
// Function: 1101.sol-ZlotsJackpotHoldingContract-getJackpot()
digraph{
}
// Function: 1101.sol-ZlotsJackpotHoldingContract-payOutWinner(address)
digraph{
}
}
