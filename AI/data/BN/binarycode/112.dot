digraph G {
// Function: 112.sol-ERC20Interface-allowance(address,address)
digraph{
}
// Function: 112.sol-ERC20Interface-approve(address,uint256)
digraph{
}
// Function: 112.sol-ERC20Interface-balanceOf(address)
digraph{
}
// Function: 112.sol-ERC20Interface-totalSupply()
digraph{
}
// Function: 112.sol-ERC20Interface-transfer(address,uint256)
digraph{
}
// Function: 112.sol-ERC20Interface-transferFrom(address,address,uint256)
digraph{
}
// Function: 112.sol-ERC918Interface-getChallengeNumber()
digraph{
}
// Function: 112.sol-ERC918Interface-getMiningDifficulty()
digraph{
}
// Function: 112.sol-ERC918Interface-getMiningReward()
digraph{
}
// Function: 112.sol-ERC918Interface-getMiningTarget()
digraph{
}
// Function: 112.sol-ERC918Interface-mint(uint256,bytes32)
digraph{
}
// Function: 112.sol-Owned-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_16(bool) = msg.sender == newOwner
TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_19 = CONVERT 0 to address
newOwner(address) := TMP_19(address)"];
}
// Function: 112.sol-Owned-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 112.sol-Owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_20(bool) = msg.sender == owner
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 112.sol-Owned-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 112.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_0(uint256) = a + b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(c >= a)

IRs:
TMP_1(bool) = c >= a
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 112.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b > 0)

IRs:
TMP_12(bool) = b > 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a / b

IRs:
TMP_14(uint256) = a / b
c(uint256) := TMP_14(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 112.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_6(uint256) = a * b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(a == 0 || c / a == b)

IRs:
TMP_7(bool) = a == 0
TMP_8(uint256) = c / a
TMP_9(bool) = TMP_8 == b
TMP_10(bool) = TMP_7 || TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 112.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b <= a)

IRs:
TMP_3(bool) = b <= a
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_5(uint256) = a - b
c(uint256) := TMP_5(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 112.sol-ZeroGoldPOWMining-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_23(bool) = msg.sender == newOwner
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_26 = CONVERT 0 to address
newOwner(address) := TMP_26(address)"];
}
// Function: 112.sol-ZeroGoldPOWMining-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 112.sol-ZeroGoldPOWMining-constructor(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
miningLeader = ERC918Interface(_miningLeader)

IRs:
TMP_27 = CONVERT _miningLeader to ERC918Interface
miningLeader(ERC918Interface) := TMP_27(ERC918Interface)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
mintHelper = _mintHelper

IRs:
mintHelper(address) := _mintHelper(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
zeroGold = ERC20Interface(0x6ef5bca539A4A01157af842B4823F54F9f7E9968)

IRs:
TMP_28 = CONVERT 633469100697228842220630759804524568608585455976 to ERC20Interface
zeroGold(ERC20Interface) := TMP_28(ERC20Interface)"];
}
// Function: 112.sol-ZeroGoldPOWMining-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert(string)(Oops! Direct payments are NOT permitted here.)

IRs:
TMP_58(None) = SOLIDITY_CALL revert(string)(Oops! Direct payments are NOT permitted here.)"];
}
// Function: 112.sol-ZeroGoldPOWMining-getRewardAmount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
totalBalance = zeroGold.balanceOf(address(this))

IRs:
TMP_51 = CONVERT this to address
TMP_52(uint256) = HIGH_LEVEL_CALL, dest:zeroGold(ERC20Interface), function:balanceOf, arguments:['TMP_51']  
totalBalance(uint256) := TMP_52(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
totalBalance.div(rewardDivisor)

IRs:
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['totalBalance', 'rewardDivisor'] 
RETURN TMP_53"];
}
// Function: 112.sol-ZeroGoldPOWMining-merge()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->26;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
futureChallengeNumber = blockhash(uint256)(block.number - 1)

IRs:
TMP_29(uint256) = block.number - 1
TMP_30(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_29)
futureChallengeNumber(bytes32) := TMP_30(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
challengeNumber = miningLeader.getChallengeNumber()

IRs:
TMP_31(bytes32) = HIGH_LEVEL_CALL, dest:miningLeader(ERC918Interface), function:getChallengeNumber, arguments:[]  
challengeNumber(bytes32) := TMP_31(bytes32)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
challengeNumber == futureChallengeNumber

IRs:
TMP_32(bool) = challengeNumber == futureChallengeNumber
CONDITION TMP_32"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
miningLeader.lastRewardTo() != msg.sender

IRs:
TMP_33(address) = HIGH_LEVEL_CALL, dest:miningLeader(ERC918Interface), function:lastRewardTo, arguments:[]  
TMP_34(bool) = TMP_33 != msg.sender
CONDITION TMP_34"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
miningLeader.lastRewardEthBlockNumber() != block.number

IRs:
TMP_35(uint256) = HIGH_LEVEL_CALL, dest:miningLeader(ERC918Interface), function:lastRewardEthBlockNumber, arguments:[]  
TMP_36(bool) = TMP_35 != block.number
CONDITION TMP_36"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
parentChallengeNumber = miningLeader.challengeNumber()

IRs:
TMP_37(bytes32) = HIGH_LEVEL_CALL, dest:miningLeader(ERC918Interface), function:challengeNumber, arguments:[]  
parentChallengeNumber(bytes32) := TMP_37(bytes32)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
solution = solutionForChallenge[parentChallengeNumber]

IRs:
REF_4(bytes32) -> solutionForChallenge[parentChallengeNumber]
solution(bytes32) := REF_4(bytes32)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
solution != 0x0

IRs:
TMP_38(bool) = solution != 0
CONDITION TMP_38"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: RETURN 15

EXPRESSION:
false

IRs:
RETURN False"];
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
digest = merge

IRs:
digest(bytes32) := merge(string)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
solutionForChallenge[parentChallengeNumber] = digest

IRs:
REF_5(bytes32) -> solutionForChallenge[parentChallengeNumber]
REF_5(bytes32) (->solutionForChallenge) := digest(bytes32)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
rewardAmount = getRewardAmount()

IRs:
TMP_39(uint256) = INTERNAL_CALL, ZeroGoldPOWMining.getRewardAmount()()
rewardAmount(uint256) := TMP_39(uint256)"];
19->20;
20[label="Node Type: NEW VARIABLE 20

EXPRESSION:
balance = zeroGold.balanceOf(address(this))

IRs:
TMP_40 = CONVERT this to address
TMP_41(uint256) = HIGH_LEVEL_CALL, dest:zeroGold(ERC20Interface), function:balanceOf, arguments:['TMP_40']  
balance(uint256) := TMP_41(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
assert(bool)(rewardAmount <= balance)

IRs:
TMP_42(bool) = rewardAmount <= balance
TMP_43(None) = SOLIDITY_CALL assert(bool)(TMP_42)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
lastRewardAmount = rewardAmount

IRs:
lastRewardAmount(uint256) := rewardAmount(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
epochCount = epochCount.add(1)

IRs:
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['epochCount', '1'] 
epochCount(uint256) := TMP_44(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
Mint(msg.sender,rewardAmount,epochCount,0)

IRs:
Emit Mint(msg.sender,rewardAmount,epochCount,0)"];
24->25;
25[label="Node Type: RETURN 25

EXPRESSION:
true

IRs:
RETURN True"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
onlyMintHelper()

IRs:
MODIFIER_CALL, ZeroGoldPOWMining.onlyMintHelper()()"];
26->1;
27[label="Node Type: RETURN 27

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 112.sol-ZeroGoldPOWMining-onlyMintHelper()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == mintHelper)

IRs:
TMP_64(bool) = msg.sender == mintHelper
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 112.sol-ZeroGoldPOWMining-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_62(bool) = msg.sender == owner
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 112.sol-ZeroGoldPOWMining-setMiningLeader(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
miningLeader = ERC918Interface(_miningLeader)

IRs:
TMP_54 = CONVERT _miningLeader to ERC918Interface
miningLeader(ERC918Interface) := TMP_54(ERC918Interface)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 112.sol-ZeroGoldPOWMining-setMintHelper(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintHelper = _mintHelper

IRs:
mintHelper(address) := _mintHelper(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 112.sol-ZeroGoldPOWMining-setRewardDivisor(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
rewardDivisor = _rewardDivisor

IRs:
rewardDivisor(uint256) := _rewardDivisor(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 112.sol-ZeroGoldPOWMining-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintHelper = 0x0

IRs:
mintHelper(address) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
rewardDivisor = 20

IRs:
rewardDivisor(uint256) := 20(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
epochCount = 0

IRs:
epochCount(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
lastRewardAmount = 0

IRs:
lastRewardAmount(uint256) := 0(uint256)"];
}
// Function: 112.sol-ZeroGoldPOWMining-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: IF 1

EXPRESSION:
_reward > lastRewardAmount

IRs:
TMP_47(bool) = _reward > lastRewardAmount
CONDITION TMP_47"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
lastRewardAmount = lastRewardAmount.sub(_reward)

IRs:
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['lastRewardAmount', '_reward'] 
lastRewardAmount(uint256) := TMP_48(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
zeroGold.transfer(_wallet,_reward)

IRs:
TMP_49(bool) = HIGH_LEVEL_CALL, dest:zeroGold(ERC20Interface), function:transfer, arguments:['_wallet', '_reward']  "];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyMintHelper()

IRs:
MODIFIER_CALL, ZeroGoldPOWMining.onlyMintHelper()()"];
6->1;
}
// Function: 112.sol-ZeroGoldPOWMining-transferAnyERC20Token(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
ERC20Interface(tokenAddress).transfer(owner,tokens)

IRs:
TMP_59 = CONVERT tokenAddress to ERC20Interface
TMP_60(bool) = HIGH_LEVEL_CALL, dest:TMP_59(ERC20Interface), function:transfer, arguments:['owner', 'tokens']  
RETURN TMP_60"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 112.sol-ZeroGoldPOWMining-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
}
