digraph G {
// Function: 2301.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)
digraph{
}
// Function: 2301.sol-Arbitrable-constructor(Arbitrator,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
arbitrator = _arbitrator

IRs:
arbitrator(Arbitrator) := _arbitrator(Arbitrator)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
arbitratorExtraData = _arbitratorExtraData

IRs:
arbitratorExtraData(bytes) := _arbitratorExtraData(bytes)"];
}
// Function: 2301.sol-Arbitrable-executeRuling(uint256,uint256)
digraph{
}
// Function: 2301.sol-Arbitrable-onlyArbitrator()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(arbitrator))

IRs:
TMP_188 = CONVERT arbitrator to address
TMP_189(bool) = msg.sender == TMP_188
TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Arbitrable-rule(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Ruling(Arbitrator(msg.sender),_disputeID,_ruling)

IRs:
TMP_184 = CONVERT msg.sender to Arbitrator
Emit Ruling(TMP_184,_disputeID,_ruling)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
executeRuling(_disputeID,_ruling)

IRs:
INTERNAL_CALL, Arbitrable.executeRuling(uint256,uint256)(_disputeID,_ruling)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyArbitrator()

IRs:
MODIFIER_CALL, Arbitrable.onlyArbitrator()()"];
3->1;
}
// Function: 2301.sol-Arbitrator-appeal(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
AppealDecision(_disputeID,Arbitrable(msg.sender))

IRs:
TMP_192 = CONVERT msg.sender to Arbitrable
Emit AppealDecision(_disputeID,TMP_192)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
requireAppealFee(_disputeID,_extraData)

IRs:
MODIFIER_CALL, Arbitrator.requireAppealFee(uint256,bytes)(_disputeID,_extraData)"];
2->1;
}
// Function: 2301.sol-Arbitrator-appealCost(uint256,bytes)
digraph{
}
// Function: 2301.sol-Arbitrator-arbitrationCost(bytes)
digraph{
}
// Function: 2301.sol-Arbitrator-createDispute(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
requireArbitrationFee(_extraData)

IRs:
MODIFIER_CALL, Arbitrator.requireArbitrationFee(bytes)(_extraData)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
disputeID

IRs:
RETURN disputeID"];
}
// Function: 2301.sol-Arbitrator-currentRuling(uint256)
digraph{
}
// Function: 2301.sol-Arbitrator-disputeStatus(uint256)
digraph{
}
// Function: 2301.sol-Arbitrator-requireAppealFee(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= appealCost(_disputeID,_extraData))

IRs:
TMP_198(uint256) = INTERNAL_CALL, Arbitrator.appealCost(uint256,bytes)(_disputeID,_extraData)
TMP_199(bool) = msg.value >= TMP_198
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Arbitrator-requireArbitrationFee(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= arbitrationCost(_extraData))

IRs:
TMP_195(uint256) = INTERNAL_CALL, Arbitrator.arbitrationCost(bytes)(_extraData)
TMP_196(bool) = msg.value >= TMP_195
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-BlockHashRNG-contribute(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
reward[_block] += msg.value

IRs:
REF_60(uint256) -> reward[_block]
REF_60(-> reward) = REF_60 + msg.value"];
}
// Function: 2301.sol-BlockHashRNG-getRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
RN = randomNumber[_block]

IRs:
REF_61(uint256) -> randomNumber[_block]
RN(uint256) := REF_61(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
RN == 0

IRs:
TMP_151(bool) = RN == 0
CONDITION TMP_151"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
saveRN(_block)

IRs:
INTERNAL_CALL, BlockHashRNG.saveRN(uint256)(_block)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
randomNumber[_block]

IRs:
REF_62(uint256) -> randomNumber[_block]
RETURN REF_62"];
5[label="Node Type: RETURN 5

EXPRESSION:
RN

IRs:
RETURN RN"];
7[label="Node Type: RETURN 7

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 2301.sol-BlockHashRNG-getUncorrelatedRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
baseRN = getRN(_block)

IRs:
TMP_147(uint256) = INTERNAL_CALL, BlockHashRNG.getRN(uint256)(_block)
baseRN(uint256) := TMP_147(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
baseRN == 0

IRs:
TMP_148(bool) = baseRN == 0
CONDITION TMP_148"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: RETURN 4

EXPRESSION:
uint256(keccak256()(msg.sender,baseRN))

IRs:
TMP_149(bytes32) = SOLIDITY_CALL keccak256()(msg.sender,baseRN)
TMP_150 = CONVERT TMP_149 to uint256
RETURN TMP_150"];
6[label="Node Type: RETURN 6

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 2301.sol-BlockHashRNG-requestRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contribute(_block)

IRs:
INTERNAL_CALL, BlockHashRNG.contribute(uint256)(_block)"];
}
// Function: 2301.sol-BlockHashRNG-saveRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
blockhash(uint256)(_block) != 0x0

IRs:
TMP_153(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_154(bool) = TMP_153 != 0
CONDITION TMP_154"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
randomNumber[_block] = uint256(blockhash(uint256)(_block))

IRs:
REF_63(uint256) -> randomNumber[_block]
TMP_155(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_156 = CONVERT TMP_155 to uint256
REF_63(uint256) (->randomNumber) := TMP_156(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
randomNumber[_block] != 0

IRs:
REF_64(uint256) -> randomNumber[_block]
TMP_157(bool) = REF_64 != 0
CONDITION TMP_157"];
4->5[label="True"];
4->8[label="False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
rewardToSend = reward[_block]

IRs:
REF_65(uint256) -> reward[_block]
rewardToSend(uint256) := REF_65(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
reward[_block] = 0

IRs:
REF_66(uint256) -> reward[_block]
REF_66(uint256) (->reward) := 0(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.send(rewardToSend)

IRs:
TMP_158 = SEND dest:msg.sender value:rewardToSend"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 2301.sol-BlockHashRNGFallback-contribute(uint256)
digraph{
}
// Function: 2301.sol-BlockHashRNGFallback-getRN(uint256)
digraph{
}
// Function: 2301.sol-BlockHashRNGFallback-getUncorrelatedRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
baseRN = getRN(_block)

IRs:
TMP_168(uint256) = INTERNAL_CALL, BlockHashRNG.getRN(uint256)(_block)
baseRN(uint256) := TMP_168(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
baseRN == 0

IRs:
TMP_169(bool) = baseRN == 0
CONDITION TMP_169"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: RETURN 4

EXPRESSION:
uint256(keccak256()(msg.sender,baseRN))

IRs:
TMP_170(bytes32) = SOLIDITY_CALL keccak256()(msg.sender,baseRN)
TMP_171 = CONVERT TMP_170 to uint256
RETURN TMP_171"];
6[label="Node Type: RETURN 6

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 2301.sol-BlockHashRNGFallback-requestRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contribute(_block)

IRs:
INTERNAL_CALL, BlockHashRNG.contribute(uint256)(_block)"];
}
// Function: 2301.sol-BlockHashRNGFallback-saveRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_block < block.number && randomNumber[_block] == 0

IRs:
TMP_172(bool) = _block < block.number
REF_76(uint256) -> randomNumber[_block]
TMP_173(bool) = REF_76 == 0
TMP_174(bool) = TMP_172 && TMP_173
CONDITION TMP_174"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
blockhash(uint256)(_block) != 0x0

IRs:
TMP_175(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_176(bool) = TMP_175 != 0
CONDITION TMP_176"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
randomNumber[_block] = uint256(blockhash(uint256)(_block))

IRs:
REF_77(uint256) -> randomNumber[_block]
TMP_177(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_178 = CONVERT TMP_177 to uint256
REF_77(uint256) (->randomNumber) := TMP_178(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
randomNumber[_block] = uint256(blockhash(uint256)(block.number - 1))

IRs:
REF_78(uint256) -> randomNumber[_block]
TMP_179(uint256) = block.number - 1
TMP_180(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_179)
TMP_181 = CONVERT TMP_180 to uint256
REF_78(uint256) (->randomNumber) := TMP_181(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
randomNumber[_block] != 0

IRs:
REF_79(uint256) -> randomNumber[_block]
TMP_182(bool) = REF_79 != 0
CONDITION TMP_182"];
7->8[label="True"];
7->11[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
rewardToSend = reward[_block]

IRs:
REF_80(uint256) -> reward[_block]
rewardToSend(uint256) := REF_80(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
reward[_block] = 0

IRs:
REF_81(uint256) -> reward[_block]
REF_81(uint256) (->reward) := 0(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
msg.sender.send(rewardToSend)

IRs:
TMP_183 = SEND dest:msg.sender value:rewardToSend"];
10->11;
11[label="Node Type: END_IF 11
"];
}
// Function: 2301.sol-Controlled-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 2301.sol-Controlled-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 2301.sol-Controlled-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_1(bool) = msg.sender == controller
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Kleros-activateTokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
juror = jurors[msg.sender]

IRs:
REF_107(Kleros.Juror) -> jurors[msg.sender]
juror(Kleros.Juror) := REF_107(Kleros.Juror)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= juror.balance)

IRs:
REF_108(uint256) -> juror.balance
TMP_232(bool) = _value <= REF_108
TMP_233(None) = SOLIDITY_CALL require(bool)(TMP_232)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value >= minActivatedToken)

IRs:
TMP_234(bool) = _value >= minActivatedToken
TMP_235(None) = SOLIDITY_CALL require(bool)(TMP_234)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(juror.lastSession != session)

IRs:
REF_109(uint256) -> juror.lastSession
TMP_236(bool) = REF_109 != session
TMP_237(None) = SOLIDITY_CALL require(bool)(TMP_236)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
juror.lastSession = session

IRs:
REF_110(uint256) -> juror.lastSession
REF_110(uint256) (->juror) := session(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
juror.segmentStart = segmentSize

IRs:
REF_111(uint256) -> juror.segmentStart
REF_111(uint256) (->juror) := segmentSize(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
segmentSize += _value

IRs:
segmentSize(uint256) = segmentSize + _value"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
juror.segmentEnd = segmentSize

IRs:
REF_112(uint256) -> juror.segmentEnd
REF_112(uint256) (->juror) := segmentSize(uint256)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyDuring(Period.Activation)

IRs:
REF_113(Kleros.Period) -> Period.Activation
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_113)"];
9->1;
}
// Function: 2301.sol-Kleros-amountJurors(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_367(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_367(Kleros.Dispute)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
(dispute.initialNumberJurors + 1) * 2 ** dispute.appeals - 1

IRs:
REF_368(uint16) -> dispute.initialNumberJurors
TMP_346(uint16) = REF_368 + 1
REF_369(uint256) -> dispute.appeals
TMP_347(uint256) = 2 ** REF_369
TMP_348(uint16) = TMP_346 * TMP_347
TMP_349(uint16) = TMP_348 - 1
RETURN TMP_349"];
3[label="Node Type: RETURN 3

EXPRESSION:
nbJurors

IRs:
RETURN nbJurors"];
}
// Function: 2301.sol-Kleros-appeal(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.appeal(_disputeID,_extraData)

IRs:
INTERNAL_CALL, Arbitrator.appeal(uint256,bytes)(_disputeID,_extraData)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_394(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_394(Kleros.Dispute)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value >= appealCost(_disputeID,_extraData))

IRs:
TMP_378(uint256) = INTERNAL_CALL, Kleros.appealCost(uint256,bytes)(_disputeID,_extraData)
TMP_379(bool) = msg.value >= TMP_378
TMP_380(None) = SOLIDITY_CALL require(bool)(TMP_379)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(dispute.session + dispute.appeals == session)

IRs:
REF_395(uint256) -> dispute.session
REF_396(uint256) -> dispute.appeals
TMP_381(uint256) = REF_395 + REF_396
TMP_382(bool) = TMP_381 == session
TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(dispute.arbitrated == msg.sender)

IRs:
REF_397(Arbitrable) -> dispute.arbitrated
TMP_384(bool) = REF_397 == msg.sender
TMP_385(None) = SOLIDITY_CALL require(bool)(TMP_384)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
dispute.appeals ++

IRs:
REF_398(uint256) -> dispute.appeals
TMP_386(uint256) := REF_398(uint256)
REF_398(-> dispute) = REF_398 + 1"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
dispute.votes.length ++

IRs:
REF_399(Kleros.Vote[][]) -> dispute.votes
REF_400 -> LENGTH REF_399
TMP_387(uint256) := REF_400(uint256)
REF_400(-> dispute) = REF_400 + 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
dispute.voteCounter.length ++

IRs:
REF_401(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_402 -> LENGTH REF_401
TMP_388(uint256) := REF_402(uint256)
REF_402(-> dispute) = REF_402 + 1"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyDuring(Period.Appeal)

IRs:
REF_403(Kleros.Period) -> Period.Appeal
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_403)"];
9->1;
}
// Function: 2301.sol-Kleros-appealCost(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_415(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_415(Kleros.Dispute)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
dispute.appeals >= maxAppeals

IRs:
REF_416(uint256) -> dispute.appeals
TMP_395(bool) = REF_416 >= maxAppeals
CONDITION TMP_395"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
NON_PAYABLE_AMOUNT

IRs:
RETURN NON_PAYABLE_AMOUNT"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
(2 * amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror

IRs:
TMP_396(uint256) = INTERNAL_CALL, Kleros.amountJurors(uint256)(_disputeID)
TMP_397(uint256) = 2 * TMP_396
TMP_398(uint256) = TMP_397 + 1
REF_417(uint256) -> dispute.arbitrationFeePerJuror
TMP_399(uint256) = TMP_398 * REF_417
RETURN TMP_399"];
6[label="Node Type: RETURN 6

EXPRESSION:
fee

IRs:
RETURN fee"];
}
// Function: 2301.sol-Kleros-arbitrationCost(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
extraDataToNbJurors(_extraData) * arbitrationFeePerJuror

IRs:
TMP_393(uint16) = INTERNAL_CALL, Kleros.extraDataToNbJurors(bytes)(_extraData)
TMP_394(uint16) = TMP_393 * arbitrationFeePerJuror
RETURN TMP_394"];
2[label="Node Type: RETURN 2

EXPRESSION:
fee

IRs:
RETURN fee"];
}
// Function: 2301.sol-Kleros-constructor(Pinakion,RNG,uint256[5],address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pinakion = _pinakion

IRs:
pinakion(Pinakion) := _pinakion(Pinakion)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
rng = _rng

IRs:
rng(RNG) := _rng(RNG)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
lastPeriodChange = now

IRs:
lastPeriodChange(uint256) := now(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
timePerPeriod = _timePerPeriod

IRs:
timePerPeriod(uint256[5]) := _timePerPeriod(uint256[5])"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
governor = _governor

IRs:
governor(address) := _governor(address)"];
}
// Function: 2301.sol-Kleros-createDispute(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nbJurors = extraDataToNbJurors(_extraData)

IRs:
TMP_365(uint16) = INTERNAL_CALL, Kleros.extraDataToNbJurors(bytes)(_extraData)
nbJurors(uint16) := TMP_365(uint16)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= arbitrationCost(_extraData))

IRs:
TMP_366(uint256) = INTERNAL_CALL, Kleros.arbitrationCost(bytes)(_extraData)
TMP_367(bool) = msg.value >= TMP_366
TMP_368(None) = SOLIDITY_CALL require(bool)(TMP_367)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
disputeID = disputes.length ++

IRs:
REF_381 -> LENGTH disputes
TMP_369(uint256) := REF_381(uint256)
REF_381(-> disputes) = REF_381 + 1
disputeID(uint256) := TMP_369(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
dispute = disputes[disputeID]

IRs:
REF_382(Kleros.Dispute) -> disputes[disputeID]
dispute(Kleros.Dispute) := REF_382(Kleros.Dispute)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
dispute.arbitrated = Arbitrable(msg.sender)

IRs:
REF_383(Arbitrable) -> dispute.arbitrated
TMP_370 = CONVERT msg.sender to Arbitrable
REF_383(Arbitrable) (->dispute) := TMP_370(Arbitrable)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
period < Period.Draw

IRs:
REF_384(Kleros.Period) -> Period.Draw
TMP_371(bool) = period < REF_384
CONDITION TMP_371"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
dispute.session = session

IRs:
REF_385(uint256) -> dispute.session
REF_385(uint256) (->dispute) := session(uint256)"];
7->9;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
dispute.session = session + 1

IRs:
REF_386(uint256) -> dispute.session
TMP_372(uint256) = session + 1
REF_386(uint256) (->dispute) := TMP_372(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
dispute.choices = _choices

IRs:
REF_387(uint256) -> dispute.choices
REF_387(uint256) (->dispute) := _choices(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
dispute.initialNumberJurors = nbJurors

IRs:
REF_388(uint16) -> dispute.initialNumberJurors
REF_388(uint16) (->dispute) := nbJurors(uint16)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
dispute.arbitrationFeePerJuror = arbitrationFeePerJuror

IRs:
REF_389(uint256) -> dispute.arbitrationFeePerJuror
REF_389(uint256) (->dispute) := arbitrationFeePerJuror(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
dispute.votes.length ++

IRs:
REF_390(Kleros.Vote[][]) -> dispute.votes
REF_391 -> LENGTH REF_390
TMP_373(uint256) := REF_391(uint256)
REF_391(-> dispute) = REF_391 + 1"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
dispute.voteCounter.length ++

IRs:
REF_392(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_393 -> LENGTH REF_392
TMP_374(uint256) := REF_393(uint256)
REF_393(-> dispute) = REF_393 + 1"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
DisputeCreation(disputeID,Arbitrable(msg.sender))

IRs:
TMP_375 = CONVERT msg.sender to Arbitrable
Emit DisputeCreation(disputeID,TMP_375)"];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
disputeID

IRs:
RETURN disputeID"];
17[label="Node Type: RETURN 17

EXPRESSION:
disputeID

IRs:
RETURN disputeID"];
}
// Function: 2301.sol-Kleros-currentRuling(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_455(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_455(Kleros.Dispute)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
dispute.voteCounter[dispute.appeals].winningChoice

IRs:
REF_456(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_457(uint256) -> dispute.appeals
REF_458(Kleros.VoteCounter) -> REF_456[REF_457]
REF_459(uint256) -> REF_458.winningChoice
RETURN REF_459"];
3[label="Node Type: RETURN 3

EXPRESSION:
ruling

IRs:
RETURN ruling"];
}
// Function: 2301.sol-Kleros-disputeStatus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_460(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_460(Kleros.Dispute)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
dispute.session + dispute.appeals < session

IRs:
REF_461(uint256) -> dispute.session
REF_462(uint256) -> dispute.appeals
TMP_426(uint256) = REF_461 + REF_462
TMP_427(bool) = TMP_426 < session
CONDITION TMP_427"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
DisputeStatus.Solved

IRs:
REF_463(Arbitrator.DisputeStatus) -> DisputeStatus.Solved
RETURN REF_463"];
4[label="Node Type: IF 4

EXPRESSION:
dispute.session + dispute.appeals == session

IRs:
REF_464(uint256) -> dispute.session
REF_465(uint256) -> dispute.appeals
TMP_428(uint256) = REF_464 + REF_465
TMP_429(bool) = TMP_428 == session
CONDITION TMP_429"];
4->5[label="True"];
4->15[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
dispute.state == DisputeState.Open

IRs:
REF_466(Kleros.DisputeState) -> dispute.state
REF_467(Kleros.DisputeState) -> DisputeState.Open
TMP_430(bool) = REF_466 == REF_467
CONDITION TMP_430"];
5->6[label="True"];
5->13[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
period < Period.Appeal

IRs:
REF_468(Kleros.Period) -> Period.Appeal
TMP_431(bool) = period < REF_468
CONDITION TMP_431"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
DisputeStatus.Waiting

IRs:
REF_469(Arbitrator.DisputeStatus) -> DisputeStatus.Waiting
RETURN REF_469"];
8[label="Node Type: IF 8

EXPRESSION:
period == Period.Appeal

IRs:
REF_470(Kleros.Period) -> Period.Appeal
TMP_432(bool) = period == REF_470
CONDITION TMP_432"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
DisputeStatus.Appealable

IRs:
REF_471(Arbitrator.DisputeStatus) -> DisputeStatus.Appealable
RETURN REF_471"];
10[label="Node Type: RETURN 10

EXPRESSION:
DisputeStatus.Solved

IRs:
REF_472(Arbitrator.DisputeStatus) -> DisputeStatus.Solved
RETURN REF_472"];
13[label="Node Type: RETURN 13

EXPRESSION:
DisputeStatus.Solved

IRs:
REF_473(Arbitrator.DisputeStatus) -> DisputeStatus.Solved
RETURN REF_473"];
15[label="Node Type: RETURN 15

EXPRESSION:
DisputeStatus.Waiting

IRs:
REF_474(Arbitrator.DisputeStatus) -> DisputeStatus.Waiting
RETURN REF_474"];
18[label="Node Type: RETURN 18

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 2301.sol-Kleros-executeOrder(bytes32,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_target.call.value(_value)(_data)

IRs:
TMP_434(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:_value "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-executeRuling(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[disputeID]

IRs:
REF_404(Kleros.Dispute) -> disputes[disputeID]
dispute(Kleros.Dispute) := REF_404(Kleros.Dispute)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(dispute.state == DisputeState.Executable)

IRs:
REF_405(Kleros.DisputeState) -> dispute.state
REF_406(Kleros.DisputeState) -> DisputeState.Executable
TMP_390(bool) = REF_405 == REF_406
TMP_391(None) = SOLIDITY_CALL require(bool)(TMP_390)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
dispute.state = DisputeState.Executed

IRs:
REF_407(Kleros.DisputeState) -> dispute.state
REF_408(Kleros.DisputeState) -> DisputeState.Executed
REF_407(Kleros.DisputeState) (->dispute) := REF_408(Kleros.DisputeState)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
dispute.arbitrated.rule(disputeID,dispute.voteCounter[dispute.appeals].winningChoice)

IRs:
REF_409(Arbitrable) -> dispute.arbitrated
REF_411(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_412(uint256) -> dispute.appeals
REF_413(Kleros.VoteCounter) -> REF_411[REF_412]
REF_414(uint256) -> REF_413.winningChoice
HIGH_LEVEL_CALL, dest:REF_409(Arbitrable), function:rule, arguments:['disputeID', 'REF_414']  "];
}
// Function: 2301.sol-Kleros-extraDataToNbJurors(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_extraData.length < 2

IRs:
REF_418 -> LENGTH _extraData
TMP_400(bool) = REF_418 < 2
CONDITION TMP_400"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
defaultNumberJuror

IRs:
RETURN defaultNumberJuror"];
3[label="Node Type: RETURN 3

EXPRESSION:
(uint16(_extraData[0]) << 8) + uint16(_extraData[1])

IRs:
REF_419(None) -> _extraData[0]
TMP_401 = CONVERT REF_419 to uint16
TMP_402(uint16) = TMP_401 << 8
REF_420(None) -> _extraData[1]
TMP_403 = CONVERT REF_420 to uint16
TMP_404(uint16) = TMP_402 + TMP_403
RETURN TMP_404"];
5[label="Node Type: RETURN 5

EXPRESSION:
nbJurors

IRs:
RETURN nbJurors"];
}
// Function: 2301.sol-Kleros-getLastSessionVote(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].lastSessionVote[_juror]

IRs:
REF_444(Kleros.Dispute) -> disputes[_disputeID]
REF_445(mapping(address => uint256)) -> REF_444.lastSessionVote
REF_446(uint256) -> REF_445[_juror]
RETURN REF_446"];
2[label="Node Type: RETURN 2

EXPRESSION:
lastSessionVote

IRs:
RETURN lastSessionVote"];
}
// Function: 2301.sol-Kleros-getStakePerDraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(alpha * minActivatedToken) / ALPHA_DIVISOR

IRs:
TMP_405(uint256) = alpha * minActivatedToken
TMP_406(uint256) = TMP_405 / ALPHA_DIVISOR
RETURN TMP_406"];
2[label="Node Type: RETURN 2

EXPRESSION:
minActivatedTokenInAlpha

IRs:
RETURN minActivatedTokenInAlpha"];
}
// Function: 2301.sol-Kleros-getVoteAccount(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].votes[_appeals][_voteID].account

IRs:
REF_421(Kleros.Dispute) -> disputes[_disputeID]
REF_422(Kleros.Vote[][]) -> REF_421.votes
REF_423(Kleros.Vote[]) -> REF_422[_appeals]
REF_424(Kleros.Vote) -> REF_423[_voteID]
REF_425(address) -> REF_424.account
RETURN REF_425"];
2[label="Node Type: RETURN 2

EXPRESSION:
account

IRs:
RETURN account"];
}
// Function: 2301.sol-Kleros-getVoteCount(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].voteCounter[_appeals].voteCount[_choice]

IRs:
REF_439(Kleros.Dispute) -> disputes[_disputeID]
REF_440(Kleros.VoteCounter[]) -> REF_439.voteCounter
REF_441(Kleros.VoteCounter) -> REF_440[_appeals]
REF_442(mapping(uint256 => uint256)) -> REF_441.voteCount
REF_443(uint256) -> REF_442[_choice]
RETURN REF_443"];
2[label="Node Type: RETURN 2

EXPRESSION:
voteCount

IRs:
RETURN voteCount"];
}
// Function: 2301.sol-Kleros-getVoteRuling(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].votes[_appeals][_voteID].ruling

IRs:
REF_426(Kleros.Dispute) -> disputes[_disputeID]
REF_427(Kleros.Vote[][]) -> REF_426.votes
REF_428(Kleros.Vote[]) -> REF_427[_appeals]
REF_429(Kleros.Vote) -> REF_428[_voteID]
REF_430(uint256) -> REF_429.ruling
RETURN REF_430"];
2[label="Node Type: RETURN 2

EXPRESSION:
ruling

IRs:
RETURN ruling"];
}
// Function: 2301.sol-Kleros-getWinningChoice(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].voteCounter[_appeals].winningChoice

IRs:
REF_431(Kleros.Dispute) -> disputes[_disputeID]
REF_432(Kleros.VoteCounter[]) -> REF_431.voteCounter
REF_433(Kleros.VoteCounter) -> REF_432[_appeals]
REF_434(uint256) -> REF_433.winningChoice
RETURN REF_434"];
2[label="Node Type: RETURN 2

EXPRESSION:
winningChoice

IRs:
RETURN winningChoice"];
}
// Function: 2301.sol-Kleros-getWinningCount(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].voteCounter[_appeals].winningCount

IRs:
REF_435(Kleros.Dispute) -> disputes[_disputeID]
REF_436(Kleros.VoteCounter[]) -> REF_435.voteCounter
REF_437(Kleros.VoteCounter) -> REF_436[_appeals]
REF_438(uint256) -> REF_437.winningCount
RETURN REF_438"];
2[label="Node Type: RETURN 2

EXPRESSION:
winningCount

IRs:
RETURN winningCount"];
}
// Function: 2301.sol-Kleros-isDrawn(uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_447(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_447(Kleros.Dispute)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
juror = jurors[_juror]

IRs:
REF_448(Kleros.Juror) -> jurors[_juror]
juror(Kleros.Juror) := REF_448(Kleros.Juror)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
juror.lastSession != session || (dispute.session + dispute.appeals != session) || period <= Period.Draw || _draw > amountJurors(_disputeID) || _draw == 0 || segmentSize == 0

IRs:
REF_449(uint256) -> juror.lastSession
TMP_407(bool) = REF_449 != session
REF_450(uint256) -> dispute.session
REF_451(uint256) -> dispute.appeals
TMP_408(uint256) = REF_450 + REF_451
TMP_409(bool) = TMP_408 != session
TMP_410(bool) = TMP_407 || TMP_409
REF_452(Kleros.Period) -> Period.Draw
TMP_411(bool) = period <= REF_452
TMP_412(bool) = TMP_410 || TMP_411
TMP_413(uint256) = INTERNAL_CALL, Kleros.amountJurors(uint256)(_disputeID)
TMP_414(bool) = _draw > TMP_413
TMP_415(bool) = TMP_412 || TMP_414
TMP_416(bool) = _draw == 0
TMP_417(bool) = TMP_415 || TMP_416
TMP_418(bool) = segmentSize == 0
TMP_419(bool) = TMP_417 || TMP_418
CONDITION TMP_419"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
position = uint256(keccak256()(randomNumber,_disputeID,_draw)) % segmentSize

IRs:
TMP_420(bytes32) = SOLIDITY_CALL keccak256()(randomNumber,_disputeID,_draw)
TMP_421 = CONVERT TMP_420 to uint256
TMP_422(uint256) = TMP_421 % segmentSize
position(uint256) := TMP_422(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
(position >= juror.segmentStart) && (position < juror.segmentEnd)

IRs:
REF_453(uint256) -> juror.segmentStart
TMP_423(bool) = position >= REF_453
REF_454(uint256) -> juror.segmentEnd
TMP_424(bool) = position < REF_454
TMP_425(bool) = TMP_423 && TMP_424
RETURN TMP_425"];
8[label="Node Type: RETURN 8

EXPRESSION:
drawn

IRs:
RETURN drawn"];
}
// Function: 2301.sol-Kleros-multipleShotTokenRepartition(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->86;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_227(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_227(Kleros.Dispute)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(dispute.state <= DisputeState.Resolving)

IRs:
REF_228(Kleros.DisputeState) -> dispute.state
REF_229(Kleros.DisputeState) -> DisputeState.Resolving
TMP_310(bool) = REF_228 <= REF_229
TMP_311(None) = SOLIDITY_CALL require(bool)(TMP_310)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(dispute.session + dispute.appeals <= session)

IRs:
REF_230(uint256) -> dispute.session
REF_231(uint256) -> dispute.appeals
TMP_312(uint256) = REF_230 + REF_231
TMP_313(bool) = TMP_312 <= session
TMP_314(None) = SOLIDITY_CALL require(bool)(TMP_313)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
dispute.state = DisputeState.Resolving

IRs:
REF_232(Kleros.DisputeState) -> dispute.state
REF_233(Kleros.DisputeState) -> DisputeState.Resolving
REF_232(Kleros.DisputeState) (->dispute) := REF_233(Kleros.DisputeState)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
winningChoice = dispute.voteCounter[dispute.appeals].winningChoice

IRs:
REF_234(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_235(uint256) -> dispute.appeals
REF_236(Kleros.VoteCounter) -> REF_234[REF_235]
REF_237(uint256) -> REF_236.winningChoice
winningChoice(uint256) := REF_237(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
amountShift = getStakePerDraw()

IRs:
TMP_315(uint256) = INTERNAL_CALL, Kleros.getStakePerDraw()()
amountShift(uint256) := TMP_315(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
currentIterations = 0

IRs:
currentIterations(uint256) := 0(uint256)"];
7->10;
8[label="Node Type: BEGIN_LOOP 8
"];
8->11;
9[label="Node Type: END_LOOP 9
"];
9->85;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
i = dispute.currentAppealToRepartition

IRs:
REF_238(uint256) -> dispute.currentAppealToRepartition
i(uint256) := REF_238(uint256)"];
10->8;
11[label="Node Type: IF_LOOP 11

EXPRESSION:
i <= dispute.appeals

IRs:
REF_239(uint256) -> dispute.appeals
TMP_316(bool) = i <= REF_239
CONDITION TMP_316"];
11->12[label="True"];
11->9[label="False"];
12[label="Node Type: IF 12

EXPRESSION:
dispute.appealsRepartitioned.length < i + 1

IRs:
REF_240(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_241 -> LENGTH REF_240
TMP_317(uint256) = i + 1
TMP_318(bool) = REF_241 < TMP_317
CONDITION TMP_318"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
dispute.appealsRepartitioned.length ++

IRs:
REF_242(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_243 -> LENGTH REF_242
TMP_319(uint256) := REF_243(uint256)
REF_243(-> dispute) = REF_243 + 1"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
winningChoice == 0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)

IRs:
TMP_320(bool) = winningChoice == 0
REF_244(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_245(uint256) -> dispute.appeals
REF_246(Kleros.VoteCounter) -> REF_244[REF_245]
REF_247(mapping(uint256 => uint256)) -> REF_246.voteCount
REF_248(uint256) -> REF_247[0]
REF_249(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_250(uint256) -> dispute.appeals
REF_251(Kleros.VoteCounter) -> REF_249[REF_250]
REF_252(uint256) -> REF_251.winningCount
TMP_321(bool) = REF_248 != REF_252
TMP_322(bool) = TMP_320 && TMP_321
CONDITION TMP_322"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake

IRs:
REF_253(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_254(Kleros.AppealsRepartitioned) -> REF_253[i]
REF_255(Kleros.RepartitionStage) -> REF_254.stage
REF_256(Kleros.RepartitionStage) -> RepartitionStage.AtStake
REF_255(Kleros.RepartitionStage) (->dispute) := REF_256(Kleros.RepartitionStage)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent

IRs:
REF_257(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_258(Kleros.AppealsRepartitioned) -> REF_257[i]
REF_259(Kleros.RepartitionStage) -> REF_258.stage
REF_260(Kleros.RepartitionStage) -> RepartitionStage.Incoherent
TMP_323(bool) = REF_259 == REF_260
CONDITION TMP_323"];
18->21[label="True"];
18->39[label="False"];
19[label="Node Type: BEGIN_LOOP 19
"];
19->22;
20[label="Node Type: END_LOOP 20
"];
20->38;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
j = dispute.appealsRepartitioned[i].currentIncoherentVote

IRs:
REF_261(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_262(Kleros.AppealsRepartitioned) -> REF_261[i]
REF_263(uint256) -> REF_262.currentIncoherentVote
j(uint256) := REF_263(uint256)"];
21->19;
22[label="Node Type: IF_LOOP 22

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_264(Kleros.Vote[][]) -> dispute.votes
REF_265(Kleros.Vote[]) -> REF_264[i]
REF_266 -> LENGTH REF_265
TMP_324(bool) = j < REF_266
CONDITION TMP_324"];
22->23[label="True"];
22->20[label="False"];
23[label="Node Type: IF 23

EXPRESSION:
currentIterations >= _maxIterations

IRs:
TMP_325(bool) = currentIterations >= _maxIterations
CONDITION TMP_325"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: RETURN 24
"];
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_267(Kleros.Vote[][]) -> dispute.votes
REF_268(Kleros.Vote[]) -> REF_267[i]
REF_269(Kleros.Vote) -> REF_268[j]
vote(Kleros.Vote) := REF_269(Kleros.Vote)"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
vote.ruling != winningChoice

IRs:
REF_270(uint256) -> vote.ruling
TMP_326(bool) = REF_270 != winningChoice
CONDITION TMP_326"];
27->28[label="True"];
27->33[label="False"];
28[label="Node Type: NEW VARIABLE 28

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_271(address) -> vote.account
REF_272(Kleros.Juror) -> jurors[REF_271]
juror(Kleros.Juror) := REF_272(Kleros.Juror)"];
28->87;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
juror.balance -= penalty

IRs:
REF_273(uint256) -> juror.balance
REF_273(-> juror) = REF_273 - penalty"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(- penalty))

IRs:
REF_274(address) -> vote.account
TMP_327(uint256) = 0 - penalty
TMP_328 = CONVERT TMP_327 to int256
Emit TokenShift(REF_274,_disputeID,TMP_328)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
dispute.appealsRepartitioned[i].totalToRedistribute += penalty

IRs:
REF_275(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_276(Kleros.AppealsRepartitioned) -> REF_275[i]
REF_277(uint256) -> REF_276.totalToRedistribute
REF_277(-> dispute) = REF_277 + penalty"];
32->34;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
++ dispute.appealsRepartitioned[i].nbCoherent

IRs:
REF_278(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_279(Kleros.AppealsRepartitioned) -> REF_278[i]
REF_280(uint256) -> REF_279.nbCoherent
REF_280(-> dispute) = REF_280 + 1"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
++ dispute.appealsRepartitioned[i].currentIncoherentVote

IRs:
REF_281(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_282(Kleros.AppealsRepartitioned) -> REF_281[i]
REF_283(uint256) -> REF_282.currentIncoherentVote
REF_283(-> dispute) = REF_283 + 1"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
++ currentIterations

IRs:
currentIterations(uint256) = currentIterations + 1"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
37->22;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent

IRs:
REF_284(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_285(Kleros.AppealsRepartitioned) -> REF_284[i]
REF_286(Kleros.RepartitionStage) -> REF_285.stage
REF_287(Kleros.RepartitionStage) -> RepartitionStage.Coherent
REF_286(Kleros.RepartitionStage) (->dispute) := REF_287(Kleros.RepartitionStage)"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: IF 40

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent

IRs:
REF_288(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_289(Kleros.AppealsRepartitioned) -> REF_288[i]
REF_290(Kleros.RepartitionStage) -> REF_289.stage
REF_291(Kleros.RepartitionStage) -> RepartitionStage.Coherent
TMP_330(bool) = REF_290 == REF_291
CONDITION TMP_330"];
40->41[label="True"];
40->64[label="False"];
41[label="Node Type: IF 41

EXPRESSION:
dispute.appealsRepartitioned[i].nbCoherent == 0

IRs:
REF_292(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_293(Kleros.AppealsRepartitioned) -> REF_292[i]
REF_294(uint256) -> REF_293.nbCoherent
TMP_331(bool) = REF_294 == 0
CONDITION TMP_331"];
41->42[label="True"];
41->45[label="False"];
42[label="Node Type: EXPRESSION 42

EXPRESSION:
jurors[governor].balance += dispute.appealsRepartitioned[i].totalToRedistribute

IRs:
REF_295(Kleros.Juror) -> jurors[governor]
REF_296(uint256) -> REF_295.balance
REF_297(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_298(Kleros.AppealsRepartitioned) -> REF_297[i]
REF_299(uint256) -> REF_298.totalToRedistribute
REF_296(-> jurors) = REF_296 + REF_299"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
TokenShift(governor,_disputeID,int256(dispute.appealsRepartitioned[i].totalToRedistribute))

IRs:
REF_300(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_301(Kleros.AppealsRepartitioned) -> REF_300[i]
REF_302(uint256) -> REF_301.totalToRedistribute
TMP_332 = CONVERT REF_302 to int256
Emit TokenShift(governor,_disputeID,TMP_332)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake

IRs:
REF_303(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_304(Kleros.AppealsRepartitioned) -> REF_303[i]
REF_305(Kleros.RepartitionStage) -> REF_304.stage
REF_306(Kleros.RepartitionStage) -> RepartitionStage.AtStake
REF_305(Kleros.RepartitionStage) (->dispute) := REF_306(Kleros.RepartitionStage)"];
44->63;
45[label="Node Type: NEW VARIABLE 45

EXPRESSION:
toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent

IRs:
REF_307(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_308(Kleros.AppealsRepartitioned) -> REF_307[i]
REF_309(uint256) -> REF_308.totalToRedistribute
REF_310(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_311(Kleros.AppealsRepartitioned) -> REF_310[i]
REF_312(uint256) -> REF_311.nbCoherent
TMP_334(uint256) = REF_309 / REF_312
toRedistribute(uint256) := TMP_334(uint256)"];
45->48;
46[label="Node Type: BEGIN_LOOP 46
"];
46->49;
47[label="Node Type: END_LOOP 47
"];
47->62;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
j = dispute.appealsRepartitioned[i].currentCoherentVote

IRs:
REF_313(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_314(Kleros.AppealsRepartitioned) -> REF_313[i]
REF_315(uint256) -> REF_314.currentCoherentVote
j(uint256) := REF_315(uint256)"];
48->46;
49[label="Node Type: IF_LOOP 49

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_316(Kleros.Vote[][]) -> dispute.votes
REF_317(Kleros.Vote[]) -> REF_316[i]
REF_318 -> LENGTH REF_317
TMP_335(bool) = j < REF_318
CONDITION TMP_335"];
49->50[label="True"];
49->47[label="False"];
50[label="Node Type: IF 50

EXPRESSION:
currentIterations >= _maxIterations

IRs:
TMP_336(bool) = currentIterations >= _maxIterations
CONDITION TMP_336"];
50->51[label="True"];
50->52[label="False"];
51[label="Node Type: RETURN 51
"];
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_319(Kleros.Vote[][]) -> dispute.votes
REF_320(Kleros.Vote[]) -> REF_319[i]
REF_321(Kleros.Vote) -> REF_320[j]
vote(Kleros.Vote) := REF_321(Kleros.Vote)"];
53->54;
54[label="Node Type: IF 54

EXPRESSION:
vote.ruling == winningChoice

IRs:
REF_322(uint256) -> vote.ruling
TMP_337(bool) = REF_322 == winningChoice
CONDITION TMP_337"];
54->55[label="True"];
54->58[label="False"];
55[label="Node Type: EXPRESSION 55

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_323(address) -> vote.account
REF_324(Kleros.Juror) -> jurors[REF_323]
juror(Kleros.Juror) := REF_324(Kleros.Juror)"];
55->56;
56[label="Node Type: EXPRESSION 56

EXPRESSION:
juror.balance += toRedistribute

IRs:
REF_325(uint256) -> juror.balance
REF_325(-> juror) = REF_325 + toRedistribute"];
56->57;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(toRedistribute))

IRs:
REF_326(address) -> vote.account
TMP_338 = CONVERT toRedistribute to int256
Emit TokenShift(REF_326,_disputeID,TMP_338)"];
57->58;
58[label="Node Type: END_IF 58
"];
58->59;
59[label="Node Type: EXPRESSION 59

EXPRESSION:
++ currentIterations

IRs:
currentIterations(uint256) = currentIterations + 1"];
59->60;
60[label="Node Type: EXPRESSION 60

EXPRESSION:
++ dispute.appealsRepartitioned[i].currentCoherentVote

IRs:
REF_327(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_328(Kleros.AppealsRepartitioned) -> REF_327[i]
REF_329(uint256) -> REF_328.currentCoherentVote
REF_329(-> dispute) = REF_329 + 1"];
60->61;
61[label="Node Type: EXPRESSION 61

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
61->49;
62[label="Node Type: EXPRESSION 62

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake

IRs:
REF_330(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_331(Kleros.AppealsRepartitioned) -> REF_330[i]
REF_332(Kleros.RepartitionStage) -> REF_331.stage
REF_333(Kleros.RepartitionStage) -> RepartitionStage.AtStake
REF_332(Kleros.RepartitionStage) (->dispute) := REF_333(Kleros.RepartitionStage)"];
62->63;
63[label="Node Type: END_IF 63
"];
63->64;
64[label="Node Type: END_IF 64
"];
64->65;
65[label="Node Type: IF 65

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake

IRs:
REF_334(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_335(Kleros.AppealsRepartitioned) -> REF_334[i]
REF_336(Kleros.RepartitionStage) -> REF_335.stage
REF_337(Kleros.RepartitionStage) -> RepartitionStage.AtStake
TMP_340(bool) = REF_336 == REF_337
CONDITION TMP_340"];
65->68[label="True"];
65->80[label="False"];
66[label="Node Type: BEGIN_LOOP 66
"];
66->69;
67[label="Node Type: END_LOOP 67
"];
67->79;
68[label="Node Type: EXPRESSION 68

EXPRESSION:
j = dispute.appealsRepartitioned[i].currentAtStakeVote

IRs:
REF_338(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_339(Kleros.AppealsRepartitioned) -> REF_338[i]
REF_340(uint256) -> REF_339.currentAtStakeVote
j(uint256) := REF_340(uint256)"];
68->66;
69[label="Node Type: IF_LOOP 69

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_341(Kleros.Vote[][]) -> dispute.votes
REF_342(Kleros.Vote[]) -> REF_341[i]
REF_343 -> LENGTH REF_342
TMP_341(bool) = j < REF_343
CONDITION TMP_341"];
69->70[label="True"];
69->67[label="False"];
70[label="Node Type: IF 70

EXPRESSION:
currentIterations >= _maxIterations

IRs:
TMP_342(bool) = currentIterations >= _maxIterations
CONDITION TMP_342"];
70->71[label="True"];
70->72[label="False"];
71[label="Node Type: RETURN 71
"];
72[label="Node Type: END_IF 72
"];
72->73;
73[label="Node Type: EXPRESSION 73

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_344(Kleros.Vote[][]) -> dispute.votes
REF_345(Kleros.Vote[]) -> REF_344[i]
REF_346(Kleros.Vote) -> REF_345[j]
vote(Kleros.Vote) := REF_346(Kleros.Vote)"];
73->74;
74[label="Node Type: EXPRESSION 74

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_347(address) -> vote.account
REF_348(Kleros.Juror) -> jurors[REF_347]
juror(Kleros.Juror) := REF_348(Kleros.Juror)"];
74->75;
75[label="Node Type: EXPRESSION 75

EXPRESSION:
juror.atStake -= amountShift

IRs:
REF_349(uint256) -> juror.atStake
REF_349(-> juror) = REF_349 - amountShift"];
75->76;
76[label="Node Type: EXPRESSION 76

EXPRESSION:
++ currentIterations

IRs:
currentIterations(uint256) = currentIterations + 1"];
76->77;
77[label="Node Type: EXPRESSION 77

EXPRESSION:
++ dispute.appealsRepartitioned[i].currentAtStakeVote

IRs:
REF_350(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_351(Kleros.AppealsRepartitioned) -> REF_350[i]
REF_352(uint256) -> REF_351.currentAtStakeVote
REF_352(-> dispute) = REF_352 + 1"];
77->78;
78[label="Node Type: EXPRESSION 78

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
78->69;
79[label="Node Type: EXPRESSION 79

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete

IRs:
REF_353(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_354(Kleros.AppealsRepartitioned) -> REF_353[i]
REF_355(Kleros.RepartitionStage) -> REF_354.stage
REF_356(Kleros.RepartitionStage) -> RepartitionStage.Complete
REF_355(Kleros.RepartitionStage) (->dispute) := REF_356(Kleros.RepartitionStage)"];
79->80;
80[label="Node Type: END_IF 80
"];
80->81;
81[label="Node Type: IF 81

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete

IRs:
REF_357(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_358(Kleros.AppealsRepartitioned) -> REF_357[i]
REF_359(Kleros.RepartitionStage) -> REF_358.stage
REF_360(Kleros.RepartitionStage) -> RepartitionStage.Complete
TMP_343(bool) = REF_359 == REF_360
CONDITION TMP_343"];
81->82[label="True"];
81->83[label="False"];
82[label="Node Type: EXPRESSION 82

EXPRESSION:
++ dispute.currentAppealToRepartition

IRs:
REF_361(uint256) -> dispute.currentAppealToRepartition
REF_361(-> dispute) = REF_361 + 1"];
82->83;
83[label="Node Type: END_IF 83
"];
83->84;
84[label="Node Type: EXPRESSION 84

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
84->11;
85[label="Node Type: EXPRESSION 85

EXPRESSION:
dispute.state = DisputeState.Executable

IRs:
REF_362(Kleros.DisputeState) -> dispute.state
REF_363(Kleros.DisputeState) -> DisputeState.Executable
REF_362(Kleros.DisputeState) (->dispute) := REF_363(Kleros.DisputeState)"];
86[label="Node Type: EXPRESSION 86

EXPRESSION:
onlyDuring(Period.Execution)

IRs:
REF_364(Kleros.Period) -> Period.Execution
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_364)"];
86->1;
87[label="Node Type: IF 87

EXPRESSION:
amountShift < juror.balance

IRs:
REF_365(uint256) -> juror.balance
TMP_345(bool) = amountShift < REF_365
CONDITION TMP_345"];
87->88[label="True"];
87->89[label="False"];
88[label="Node Type: EXPRESSION 88

EXPRESSION:
penalty = amountShift

IRs:
penalty(uint256) := amountShift(uint256)"];
88->90;
89[label="Node Type: EXPRESSION 89

EXPRESSION:
penalty = juror.balance

IRs:
REF_366(uint256) -> juror.balance
penalty(uint256) := REF_366(uint256)"];
89->90;
90[label="Node Type: END_IF 90
"];
90->30;
}
// Function: 2301.sol-Kleros-oneShotTokenRepartition(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->54;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_170(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_170(Kleros.Dispute)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(dispute.state == DisputeState.Open)

IRs:
REF_171(Kleros.DisputeState) -> dispute.state
REF_172(Kleros.DisputeState) -> DisputeState.Open
TMP_284(bool) = REF_171 == REF_172
TMP_285(None) = SOLIDITY_CALL require(bool)(TMP_284)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(dispute.session + dispute.appeals <= session)

IRs:
REF_173(uint256) -> dispute.session
REF_174(uint256) -> dispute.appeals
TMP_286(uint256) = REF_173 + REF_174
TMP_287(bool) = TMP_286 <= session
TMP_288(None) = SOLIDITY_CALL require(bool)(TMP_287)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
winningChoice = dispute.voteCounter[dispute.appeals].winningChoice

IRs:
REF_175(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_176(uint256) -> dispute.appeals
REF_177(Kleros.VoteCounter) -> REF_175[REF_176]
REF_178(uint256) -> REF_177.winningChoice
winningChoice(uint256) := REF_178(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
amountShift = getStakePerDraw()

IRs:
TMP_289(uint256) = INTERNAL_CALL, Kleros.getStakePerDraw()()
amountShift(uint256) := TMP_289(uint256)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
7->53;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i <= dispute.appeals

IRs:
REF_179(uint256) -> dispute.appeals
TMP_290(bool) = i <= REF_179
CONDITION TMP_290"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: IF 10

EXPRESSION:
winningChoice != 0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)

IRs:
TMP_291(bool) = winningChoice != 0
REF_180(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_181(uint256) -> dispute.appeals
REF_182(Kleros.VoteCounter) -> REF_180[REF_181]
REF_183(mapping(uint256 => uint256)) -> REF_182.voteCount
REF_184(uint256) -> REF_183[0]
REF_185(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_186(uint256) -> dispute.appeals
REF_187(Kleros.VoteCounter) -> REF_185[REF_186]
REF_188(uint256) -> REF_187.winningCount
TMP_292(bool) = REF_184 == REF_188
TMP_293(bool) = TMP_291 || TMP_292
CONDITION TMP_293"];
10->11[label="True"];
10->43[label="False"];
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
totalToRedistribute = 0

IRs:
totalToRedistribute(uint256) := 0(uint256)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
nbCoherent = 0

IRs:
nbCoherent(uint256) := 0(uint256)"];
12->15;
13[label="Node Type: BEGIN_LOOP 13
"];
13->16;
14[label="Node Type: END_LOOP 14
"];
14->27;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
15->13;
16[label="Node Type: IF_LOOP 16

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_189(Kleros.Vote[][]) -> dispute.votes
REF_190(Kleros.Vote[]) -> REF_189[i]
REF_191 -> LENGTH REF_190
TMP_294(bool) = j < REF_191
CONDITION TMP_294"];
16->17[label="True"];
16->14[label="False"];
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_192(Kleros.Vote[][]) -> dispute.votes
REF_193(Kleros.Vote[]) -> REF_192[i]
REF_194(Kleros.Vote) -> REF_193[j]
vote(Kleros.Vote) := REF_194(Kleros.Vote)"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
vote.ruling != winningChoice

IRs:
REF_195(uint256) -> vote.ruling
TMP_295(bool) = REF_195 != winningChoice
CONDITION TMP_295"];
18->19[label="True"];
18->24[label="False"];
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_196(address) -> vote.account
REF_197(Kleros.Juror) -> jurors[REF_196]
juror(Kleros.Juror) := REF_197(Kleros.Juror)"];
19->55;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
juror.balance -= penalty

IRs:
REF_198(uint256) -> juror.balance
REF_198(-> juror) = REF_198 - penalty"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(- penalty))

IRs:
REF_199(address) -> vote.account
TMP_296(uint256) = 0 - penalty
TMP_297 = CONVERT TMP_296 to int256
Emit TokenShift(REF_199,_disputeID,TMP_297)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
totalToRedistribute += penalty

IRs:
totalToRedistribute(uint256) = totalToRedistribute + penalty"];
23->25;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
++ nbCoherent

IRs:
nbCoherent(uint256) = nbCoherent + 1"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
26->16;
27[label="Node Type: IF 27

EXPRESSION:
nbCoherent == 0

IRs:
TMP_299(bool) = nbCoherent == 0
CONDITION TMP_299"];
27->28[label="True"];
27->30[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
jurors[governor].balance += totalToRedistribute

IRs:
REF_200(Kleros.Juror) -> jurors[governor]
REF_201(uint256) -> REF_200.balance
REF_201(-> jurors) = REF_201 + totalToRedistribute"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
TokenShift(governor,_disputeID,int256(totalToRedistribute))

IRs:
TMP_300 = CONVERT totalToRedistribute to int256
Emit TokenShift(governor,_disputeID,TMP_300)"];
29->42;
30[label="Node Type: NEW VARIABLE 30

EXPRESSION:
toRedistribute = totalToRedistribute / nbCoherent

IRs:
TMP_302(uint256) = totalToRedistribute / nbCoherent
toRedistribute(uint256) := TMP_302(uint256)"];
30->33;
31[label="Node Type: BEGIN_LOOP 31
"];
31->34;
32[label="Node Type: END_LOOP 32
"];
32->42;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
33->31;
34[label="Node Type: IF_LOOP 34

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_202(Kleros.Vote[][]) -> dispute.votes
REF_203(Kleros.Vote[]) -> REF_202[i]
REF_204 -> LENGTH REF_203
TMP_303(bool) = j < REF_204
CONDITION TMP_303"];
34->35[label="True"];
34->32[label="False"];
35[label="Node Type: EXPRESSION 35

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_205(Kleros.Vote[][]) -> dispute.votes
REF_206(Kleros.Vote[]) -> REF_205[i]
REF_207(Kleros.Vote) -> REF_206[j]
vote(Kleros.Vote) := REF_207(Kleros.Vote)"];
35->36;
36[label="Node Type: IF 36

EXPRESSION:
vote.ruling == winningChoice

IRs:
REF_208(uint256) -> vote.ruling
TMP_304(bool) = REF_208 == winningChoice
CONDITION TMP_304"];
36->37[label="True"];
36->40[label="False"];
37[label="Node Type: EXPRESSION 37

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_209(address) -> vote.account
REF_210(Kleros.Juror) -> jurors[REF_209]
juror(Kleros.Juror) := REF_210(Kleros.Juror)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
juror.balance += toRedistribute

IRs:
REF_211(uint256) -> juror.balance
REF_211(-> juror) = REF_211 + toRedistribute"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(toRedistribute))

IRs:
REF_212(address) -> vote.account
TMP_305 = CONVERT toRedistribute to int256
Emit TokenShift(REF_212,_disputeID,TMP_305)"];
39->40;
40[label="Node Type: END_IF 40
"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
41->34;
42[label="Node Type: END_IF 42
"];
42->43;
43[label="Node Type: END_IF 43
"];
43->46;
44[label="Node Type: BEGIN_LOOP 44
"];
44->47;
45[label="Node Type: END_LOOP 45
"];
45->52;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
46->44;
47[label="Node Type: IF_LOOP 47

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_213(Kleros.Vote[][]) -> dispute.votes
REF_214(Kleros.Vote[]) -> REF_213[i]
REF_215 -> LENGTH REF_214
TMP_307(bool) = j < REF_215
CONDITION TMP_307"];
47->48[label="True"];
47->45[label="False"];
48[label="Node Type: EXPRESSION 48

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_216(Kleros.Vote[][]) -> dispute.votes
REF_217(Kleros.Vote[]) -> REF_216[i]
REF_218(Kleros.Vote) -> REF_217[j]
vote(Kleros.Vote) := REF_218(Kleros.Vote)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_219(address) -> vote.account
REF_220(Kleros.Juror) -> jurors[REF_219]
juror(Kleros.Juror) := REF_220(Kleros.Juror)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
juror.atStake -= amountShift

IRs:
REF_221(uint256) -> juror.atStake
REF_221(-> juror) = REF_221 - amountShift"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
51->47;
52[label="Node Type: EXPRESSION 52

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
52->9;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
dispute.state = DisputeState.Executable

IRs:
REF_222(Kleros.DisputeState) -> dispute.state
REF_223(Kleros.DisputeState) -> DisputeState.Executable
REF_222(Kleros.DisputeState) (->dispute) := REF_223(Kleros.DisputeState)"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
onlyDuring(Period.Execution)

IRs:
REF_224(Kleros.Period) -> Period.Execution
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_224)"];
54->1;
55[label="Node Type: IF 55

EXPRESSION:
amountShift < juror.balance

IRs:
REF_225(uint256) -> juror.balance
TMP_309(bool) = amountShift < REF_225
CONDITION TMP_309"];
55->56[label="True"];
55->57[label="False"];
56[label="Node Type: EXPRESSION 56

EXPRESSION:
penalty = amountShift

IRs:
penalty(uint256) := amountShift(uint256)"];
56->58;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
penalty = juror.balance

IRs:
REF_226(uint256) -> juror.balance
penalty(uint256) := REF_226(uint256)"];
57->58;
58[label="Node Type: END_IF 58
"];
58->21;
}
// Function: 2301.sol-Kleros-onlyBy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == _account)

IRs:
TMP_454(bool) = msg.sender == _account
TMP_455(None) = SOLIDITY_CALL require(bool)(TMP_454)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Kleros-onlyDuring(Kleros.Period)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(period == _period)

IRs:
TMP_456(bool) = period == _period
TMP_457(None) = SOLIDITY_CALL require(bool)(TMP_456)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Kleros-onlyGovernor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == governor)

IRs:
TMP_458(bool) = msg.sender == governor
TMP_459(None) = SOLIDITY_CALL require(bool)(TMP_458)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Kleros-passPeriod()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now - lastPeriodChange >= timePerPeriod[uint8(period)])

IRs:
TMP_217(uint256) = now - lastPeriodChange
TMP_218 = CONVERT period to uint8
REF_94(uint256) -> timePerPeriod[TMP_218]
TMP_219(bool) = TMP_217 >= REF_94
TMP_220(None) = SOLIDITY_CALL require(bool)(TMP_219)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
period == Period.Activation

IRs:
REF_95(Kleros.Period) -> Period.Activation
TMP_221(bool) = period == REF_95
CONDITION TMP_221"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
rnBlock = block.number + 1

IRs:
TMP_222(uint256) = block.number + 1
rnBlock(uint256) := TMP_222(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rng.requestRN(rnBlock)

IRs:
HIGH_LEVEL_CALL, dest:rng(RNG), function:requestRN, arguments:['rnBlock']  "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
period = Period.Draw

IRs:
REF_97(Kleros.Period) -> Period.Draw
period(Kleros.Period) := REF_97(Kleros.Period)"];
5->24;
6[label="Node Type: IF 6

EXPRESSION:
period == Period.Draw

IRs:
REF_98(Kleros.Period) -> Period.Draw
TMP_224(bool) = period == REF_98
CONDITION TMP_224"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
randomNumber = rng.getUncorrelatedRN(rnBlock)

IRs:
TMP_225(uint256) = HIGH_LEVEL_CALL, dest:rng(RNG), function:getUncorrelatedRN, arguments:['rnBlock']  
randomNumber(uint256) := TMP_225(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(randomNumber != 0)

IRs:
TMP_226(bool) = randomNumber != 0
TMP_227(None) = SOLIDITY_CALL require(bool)(TMP_226)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
period = Period.Vote

IRs:
REF_100(Kleros.Period) -> Period.Vote
period(Kleros.Period) := REF_100(Kleros.Period)"];
9->23;
10[label="Node Type: IF 10

EXPRESSION:
period == Period.Vote

IRs:
REF_101(Kleros.Period) -> Period.Vote
TMP_228(bool) = period == REF_101
CONDITION TMP_228"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
period = Period.Appeal

IRs:
REF_102(Kleros.Period) -> Period.Appeal
period(Kleros.Period) := REF_102(Kleros.Period)"];
11->22;
12[label="Node Type: IF 12

EXPRESSION:
period == Period.Appeal

IRs:
REF_103(Kleros.Period) -> Period.Appeal
TMP_229(bool) = period == REF_103
CONDITION TMP_229"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
period = Period.Execution

IRs:
REF_104(Kleros.Period) -> Period.Execution
period(Kleros.Period) := REF_104(Kleros.Period)"];
13->21;
14[label="Node Type: IF 14

EXPRESSION:
period == Period.Execution

IRs:
REF_105(Kleros.Period) -> Period.Execution
TMP_230(bool) = period == REF_105
CONDITION TMP_230"];
14->15[label="True"];
14->20[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
period = Period.Activation

IRs:
REF_106(Kleros.Period) -> Period.Activation
period(Kleros.Period) := REF_106(Kleros.Period)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
++ session

IRs:
session(uint256) = session + 1"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
segmentSize = 0

IRs:
segmentSize(uint256) := 0(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
rnBlock = 0

IRs:
rnBlock(uint256) := 0(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
randomNumber = 0

IRs:
randomNumber(uint256) := 0(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
lastPeriodChange = now

IRs:
lastPeriodChange(uint256) := now(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
NewPeriod(period,session)

IRs:
Emit NewPeriod(period,session)"];
}
// Function: 2301.sol-Kleros-penalizeInactiveJuror(address,uint256,uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_152(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_152(Kleros.Dispute)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
inactiveJuror = jurors[_jurorAddress]

IRs:
REF_153(Kleros.Juror) -> jurors[_jurorAddress]
inactiveJuror(Kleros.Juror) := REF_153(Kleros.Juror)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(period > Period.Vote)

IRs:
REF_154(Kleros.Period) -> Period.Vote
TMP_260(bool) = period > REF_154
TMP_261(None) = SOLIDITY_CALL require(bool)(TMP_260)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(dispute.lastSessionVote[_jurorAddress] != session)

IRs:
REF_155(mapping(address => uint256)) -> dispute.lastSessionVote
REF_156(uint256) -> REF_155[_jurorAddress]
TMP_262(bool) = REF_156 != session
TMP_263(None) = SOLIDITY_CALL require(bool)(TMP_262)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
dispute.lastSessionVote[_jurorAddress] = session

IRs:
REF_157(mapping(address => uint256)) -> dispute.lastSessionVote
REF_158(uint256) -> REF_157[_jurorAddress]
REF_158(uint256) (->dispute) := session(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(validDraws(_jurorAddress,_disputeID,_draws))

IRs:
TMP_264(bool) = INTERNAL_CALL, Kleros.validDraws(address,uint256,uint256[])(_jurorAddress,_disputeID,_draws)
TMP_265(None) = SOLIDITY_CALL require(bool)(TMP_264)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR

IRs:
REF_159 -> LENGTH _draws
TMP_266(uint256) = REF_159 * minActivatedToken
TMP_267(uint256) = TMP_266 * 2
TMP_268(uint256) = TMP_267 * alpha
TMP_269(uint256) = TMP_268 / ALPHA_DIVISOR
penality(uint256) := TMP_269(uint256)"];
7->16;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
inactiveJuror.balance -= penality

IRs:
REF_160(uint256) -> inactiveJuror.balance
REF_160(-> inactiveJuror) = REF_160 - penality"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
TokenShift(_jurorAddress,_disputeID,- int256(penality))

IRs:
TMP_270 = CONVERT penality to int256
TMP_271(int256) = 0 - TMP_270
Emit TokenShift(_jurorAddress,_disputeID,TMP_271)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
jurors[msg.sender].balance += penality / 2

IRs:
REF_161(Kleros.Juror) -> jurors[msg.sender]
REF_162(uint256) -> REF_161.balance
TMP_273(uint256) = penality / 2
REF_162(-> jurors) = REF_162 + TMP_273"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
TokenShift(msg.sender,_disputeID,int256(penality / 2))

IRs:
TMP_274(uint256) = penality / 2
TMP_275 = CONVERT TMP_274 to int256
Emit TokenShift(msg.sender,_disputeID,TMP_275)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
jurors[governor].balance += penality / 2

IRs:
REF_163(Kleros.Juror) -> jurors[governor]
REF_164(uint256) -> REF_163.balance
TMP_277(uint256) = penality / 2
REF_164(-> jurors) = REF_164 + TMP_277"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
TokenShift(governor,_disputeID,int256(penality / 2))

IRs:
TMP_278(uint256) = penality / 2
TMP_279 = CONVERT TMP_278 to int256
Emit TokenShift(governor,_disputeID,TMP_279)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
msg.sender.transfer(_draws.length * dispute.arbitrationFeePerJuror)

IRs:
REF_166 -> LENGTH _draws
REF_167(uint256) -> dispute.arbitrationFeePerJuror
TMP_281(uint256) = REF_166 * REF_167
Transfer dest:msg.sender value:TMP_281"];
16[label="Node Type: IF 16

EXPRESSION:
(penality < inactiveJuror.balance)

IRs:
REF_168(uint256) -> inactiveJuror.balance
TMP_283(bool) = penality < REF_168
CONDITION TMP_283"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
penality = penality

IRs:
penality(uint256) := penality(uint256)"];
17->19;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
penality = inactiveJuror.balance

IRs:
REF_169(uint256) -> inactiveJuror.balance
penality(uint256) := REF_169(uint256)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->9;
}
// Function: 2301.sol-Kleros-receiveApproval(address,uint256,address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(pinakion.transferFrom(_from,this,_amount))

IRs:
TMP_205(bool) = HIGH_LEVEL_CALL, dest:pinakion(Pinakion), function:transferFrom, arguments:['_from', 'this', '_amount']  
TMP_206(None) = SOLIDITY_CALL require(bool)(TMP_205)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
jurors[_from].balance += _amount

IRs:
REF_84(Kleros.Juror) -> jurors[_from]
REF_85(uint256) -> REF_84.balance
REF_85(-> jurors) = REF_85 + _amount"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyBy(pinakion)

IRs:
MODIFIER_CALL, Kleros.onlyBy(address)(pinakion)"];
3->1;
}
// Function: 2301.sol-Kleros-requireAppealFee(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= appealCost(_disputeID,_extraData))

IRs:
TMP_451(uint256) = INTERNAL_CALL, Kleros.appealCost(uint256,bytes)(_disputeID,_extraData)
TMP_452(bool) = msg.value >= TMP_451
TMP_453(None) = SOLIDITY_CALL require(bool)(TMP_452)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Kleros-requireArbitrationFee(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= arbitrationCost(_extraData))

IRs:
TMP_448(uint256) = INTERNAL_CALL, Kleros.arbitrationCost(bytes)(_extraData)
TMP_449(bool) = msg.value >= TMP_448
TMP_450(None) = SOLIDITY_CALL require(bool)(TMP_449)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Kleros-setAlpha(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
alpha = _alpha

IRs:
alpha(uint256) := _alpha(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-setArbitrationFeePerJuror(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
arbitrationFeePerJuror = _arbitrationFeePerJuror

IRs:
arbitrationFeePerJuror(uint256) := _arbitrationFeePerJuror(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-setDefaultNumberJuror(uint16)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
defaultNumberJuror = _defaultNumberJuror

IRs:
defaultNumberJuror(uint16) := _defaultNumberJuror(uint16)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-setGovernor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
governor = _governor

IRs:
governor(address) := _governor(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-setMaxAppeals(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
maxAppeals = _maxAppeals

IRs:
maxAppeals(uint256) := _maxAppeals(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-setMinActivatedToken(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minActivatedToken = _minActivatedToken

IRs:
minActivatedToken(uint256) := _minActivatedToken(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-setRng(RNG)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
rng = _rng

IRs:
rng(RNG) := _rng(RNG)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-setTimePerPeriod(uint256[5])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
timePerPeriod = _timePerPeriod

IRs:
timePerPeriod(uint256[5]) := _timePerPeriod(uint256[5])"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 2301.sol-Kleros-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
NON_PAYABLE_AMOUNT = (2 ** 256 - 2) / 2

IRs:
TMP_445(uint256) = 2 ** 256
TMP_446(uint256) = TMP_445 - 2
TMP_447(uint256) = TMP_446 / 2
NON_PAYABLE_AMOUNT(uint256) := TMP_447(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
ALPHA_DIVISOR = 1e4

IRs:
ALPHA_DIVISOR(uint256) := 10000(uint256)"];
}
// Function: 2301.sol-Kleros-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
arbitrationFeePerJuror = 50000000000000000

IRs:
arbitrationFeePerJuror(uint256) := 50000000000000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
defaultNumberJuror = 3

IRs:
defaultNumberJuror(uint16) := 3(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
minActivatedToken = 0.1 * 1e18

IRs:
TMP_444(uint256) = 0 * 1000000000000000000
minActivatedToken(uint256) := TMP_444(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
alpha = 2000

IRs:
alpha(uint256) := 2000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
maxAppeals = 5

IRs:
maxAppeals(uint256) := 5(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
session = 1

IRs:
session(uint256) := 1(uint256)"];
}
// Function: 2301.sol-Kleros-validDraws(address,uint256,uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
draw = 0

IRs:
draw(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
juror = jurors[_jurorAddress]

IRs:
REF_370(Kleros.Juror) -> jurors[_jurorAddress]
juror(Kleros.Juror) := REF_370(Kleros.Juror)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_371(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_371(Kleros.Dispute)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
nbJurors = amountJurors(_disputeID)

IRs:
TMP_350(uint256) = INTERNAL_CALL, Kleros.amountJurors(uint256)(_disputeID)
nbJurors(uint256) := TMP_350(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
juror.lastSession != session

IRs:
REF_372(uint256) -> juror.lastSession
TMP_351(bool) = REF_372 != session
CONDITION TMP_351"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
dispute.session + dispute.appeals != session

IRs:
REF_373(uint256) -> dispute.session
REF_374(uint256) -> dispute.appeals
TMP_352(uint256) = REF_373 + REF_374
TMP_353(bool) = TMP_352 != session
CONDITION TMP_353"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
period <= Period.Draw

IRs:
REF_375(Kleros.Period) -> Period.Draw
TMP_354(bool) = period <= REF_375
CONDITION TMP_354"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: RETURN 12

EXPRESSION:
false

IRs:
RETURN False"];
13[label="Node Type: END_IF 13
"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->29;
16[label="Node Type: NEW VARIABLE 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < _draws.length

IRs:
REF_376 -> LENGTH _draws
TMP_355(bool) = i < REF_376
CONDITION TMP_355"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: IF 18

EXPRESSION:
_draws[i] <= draw

IRs:
REF_377(uint256) -> _draws[i]
TMP_356(bool) = REF_377 <= draw
CONDITION TMP_356"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: RETURN 19

EXPRESSION:
false

IRs:
RETURN False"];
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
draw = _draws[i]

IRs:
REF_378(uint256) -> _draws[i]
draw(uint256) := REF_378(uint256)"];
21->22;
22[label="Node Type: IF 22

EXPRESSION:
draw > nbJurors

IRs:
TMP_357(bool) = draw > nbJurors
CONDITION TMP_357"];
22->23[label="True"];
22->24[label="False"];
23[label="Node Type: RETURN 23

EXPRESSION:
false

IRs:
RETURN False"];
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
position = uint256(keccak256()(randomNumber,_disputeID,draw)) % segmentSize

IRs:
TMP_358(bytes32) = SOLIDITY_CALL keccak256()(randomNumber,_disputeID,draw)
TMP_359 = CONVERT TMP_358 to uint256
TMP_360(uint256) = TMP_359 % segmentSize
position(uint256) := TMP_360(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
require(bool)(position >= juror.segmentStart)

IRs:
REF_379(uint256) -> juror.segmentStart
TMP_361(bool) = position >= REF_379
TMP_362(None) = SOLIDITY_CALL require(bool)(TMP_361)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
require(bool)(position < juror.segmentEnd)

IRs:
REF_380(uint256) -> juror.segmentEnd
TMP_363(bool) = position < REF_380
TMP_364(None) = SOLIDITY_CALL require(bool)(TMP_363)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
28->17;
29[label="Node Type: RETURN 29

EXPRESSION:
true

IRs:
RETURN True"];
30[label="Node Type: RETURN 30

EXPRESSION:
valid

IRs:
RETURN valid"];
}
// Function: 2301.sol-Kleros-voteRuling(uint256,uint256,uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->26;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_114(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_114(Kleros.Dispute)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
juror = jurors[msg.sender]

IRs:
REF_115(Kleros.Juror) -> jurors[msg.sender]
juror(Kleros.Juror) := REF_115(Kleros.Juror)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
voteCounter = dispute.voteCounter[dispute.appeals]

IRs:
REF_116(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_117(uint256) -> dispute.appeals
REF_118(Kleros.VoteCounter) -> REF_116[REF_117]
voteCounter(Kleros.VoteCounter) := REF_118(Kleros.VoteCounter)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(dispute.lastSessionVote[msg.sender] != session)

IRs:
REF_119(mapping(address => uint256)) -> dispute.lastSessionVote
REF_120(uint256) -> REF_119[msg.sender]
TMP_239(bool) = REF_120 != session
TMP_240(None) = SOLIDITY_CALL require(bool)(TMP_239)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_ruling <= dispute.choices)

IRs:
REF_121(uint256) -> dispute.choices
TMP_241(bool) = _ruling <= REF_121
TMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(validDraws(msg.sender,_disputeID,_draws))

IRs:
TMP_243(bool) = INTERNAL_CALL, Kleros.validDraws(address,uint256,uint256[])(msg.sender,_disputeID,_draws)
TMP_244(None) = SOLIDITY_CALL require(bool)(TMP_243)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
dispute.lastSessionVote[msg.sender] = session

IRs:
REF_122(mapping(address => uint256)) -> dispute.lastSessionVote
REF_123(uint256) -> REF_122[msg.sender]
REF_123(uint256) (->dispute) := session(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
voteCounter.voteCount[_ruling] += _draws.length

IRs:
REF_124(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_125(uint256) -> REF_124[_ruling]
REF_126 -> LENGTH _draws
REF_125(-> voteCounter) = REF_125 + REF_126"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
voteCounter.winningCount < voteCounter.voteCount[_ruling]

IRs:
REF_127(uint256) -> voteCounter.winningCount
REF_128(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_129(uint256) -> REF_128[_ruling]
TMP_245(bool) = REF_127 < REF_129
CONDITION TMP_245"];
9->10[label="True"];
9->12[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
voteCounter.winningCount = voteCounter.voteCount[_ruling]

IRs:
REF_130(uint256) -> voteCounter.winningCount
REF_131(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_132(uint256) -> REF_131[_ruling]
REF_130(uint256) (->voteCounter) := REF_132(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
voteCounter.winningChoice = _ruling

IRs:
REF_133(uint256) -> voteCounter.winningChoice
REF_133(uint256) (->voteCounter) := _ruling(uint256)"];
11->15;
12[label="Node Type: IF 12

EXPRESSION:
voteCounter.winningCount == voteCounter.voteCount[_ruling] && _draws.length != 0

IRs:
REF_134(uint256) -> voteCounter.winningCount
REF_135(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_136(uint256) -> REF_135[_ruling]
TMP_246(bool) = REF_134 == REF_136
REF_137 -> LENGTH _draws
TMP_247(bool) = REF_137 != 0
TMP_248(bool) = TMP_246 && TMP_247
CONDITION TMP_248"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
voteCounter.winningChoice = 0

IRs:
REF_138(uint256) -> voteCounter.winningChoice
REF_138(uint256) (->voteCounter) := 0(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: END_IF 15
"];
15->18;
16[label="Node Type: BEGIN_LOOP 16
"];
16->19;
17[label="Node Type: END_LOOP 17
"];
17->22;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
18->16;
19[label="Node Type: IF_LOOP 19

EXPRESSION:
i < _draws.length

IRs:
REF_139 -> LENGTH _draws
TMP_249(bool) = i < REF_139
CONDITION TMP_249"];
19->20[label="True"];
19->17[label="False"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
dispute.votes[dispute.appeals].push(Vote({account:msg.sender,ruling:_ruling}))

IRs:
REF_140(Kleros.Vote[][]) -> dispute.votes
REF_141(uint256) -> dispute.appeals
REF_142(Kleros.Vote[]) -> REF_140[REF_141]
TMP_250(Kleros.Vote) = new Vote(msg.sender,_ruling)
REF_144 -> LENGTH REF_142
TMP_252(uint256) := REF_144(uint256)
TMP_253(uint256) = TMP_252 + 1
REF_144(uint256) (->dispute) := TMP_253(uint256)
REF_145(Kleros.Vote) -> REF_142[TMP_252]
REF_145(Kleros.Vote) (->dispute) := TMP_250(Kleros.Vote)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
21->19;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
juror.atStake += _draws.length * getStakePerDraw()

IRs:
REF_146(uint256) -> juror.atStake
REF_147 -> LENGTH _draws
TMP_254(uint256) = INTERNAL_CALL, Kleros.getStakePerDraw()()
TMP_255(uint256) = REF_147 * TMP_254
REF_146(-> juror) = REF_146 + TMP_255"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
feeToPay = _draws.length * dispute.arbitrationFeePerJuror

IRs:
REF_148 -> LENGTH _draws
REF_149(uint256) -> dispute.arbitrationFeePerJuror
TMP_256(uint256) = REF_148 * REF_149
feeToPay(uint256) := TMP_256(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
msg.sender.transfer(feeToPay)

IRs:
Transfer dest:msg.sender value:feeToPay"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
ArbitrationReward(msg.sender,_disputeID,feeToPay)

IRs:
Emit ArbitrationReward(msg.sender,_disputeID,feeToPay)"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
onlyDuring(Period.Vote)

IRs:
REF_151(Kleros.Period) -> Period.Vote
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_151)"];
26->1;
}
// Function: 2301.sol-Kleros-withdraw(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
juror = jurors[msg.sender]

IRs:
REF_86(Kleros.Juror) -> jurors[msg.sender]
juror(Kleros.Juror) := REF_86(Kleros.Juror)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(juror.atStake <= juror.balance)

IRs:
REF_87(uint256) -> juror.atStake
REF_88(uint256) -> juror.balance
TMP_208(bool) = REF_87 <= REF_88
TMP_209(None) = SOLIDITY_CALL require(bool)(TMP_208)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= juror.balance - juror.atStake)

IRs:
REF_89(uint256) -> juror.balance
REF_90(uint256) -> juror.atStake
TMP_210(uint256) = REF_89 - REF_90
TMP_211(bool) = _value <= TMP_210
TMP_212(None) = SOLIDITY_CALL require(bool)(TMP_211)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(juror.lastSession != session)

IRs:
REF_91(uint256) -> juror.lastSession
TMP_213(bool) = REF_91 != session
TMP_214(None) = SOLIDITY_CALL require(bool)(TMP_213)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
juror.balance -= _value

IRs:
REF_92(uint256) -> juror.balance
REF_92(-> juror) = REF_92 - _value"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(pinakion.transfer(msg.sender,_value))

IRs:
TMP_215(bool) = HIGH_LEVEL_CALL, dest:pinakion(Pinakion), function:transfer, arguments:['msg.sender', '_value']  
TMP_216(None) = SOLIDITY_CALL require(bool)(TMP_215)"];
}
// Function: 2301.sol-MiniMeTokenFactory-createCloneToken(address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
newToken = new Pinakion(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled)

IRs:
TMP_139(Pinakion) = new Pinakion(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) 
newToken(Pinakion) := TMP_139(Pinakion)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:newToken(Pinakion), function:changeController, arguments:['msg.sender']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
newToken

IRs:
RETURN newToken"];
}
// Function: 2301.sol-Pinakion-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 2301.sol-Pinakion-Pinakion(address,address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenFactory = MiniMeTokenFactory(_tokenFactory)

IRs:
TMP_4 = CONVERT _tokenFactory to MiniMeTokenFactory
tokenFactory(MiniMeTokenFactory) := TMP_4(MiniMeTokenFactory)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
parentToken = Pinakion(_parentToken)

IRs:
TMP_5 = CONVERT _parentToken to Pinakion
parentToken(Pinakion) := TMP_5(Pinakion)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
parentSnapShotBlock = _parentSnapShotBlock

IRs:
parentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 2301.sol-Pinakion-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_10(mapping(address => uint256)) -> allowed[_owner]
REF_11(uint256) -> REF_10[_spender]
RETURN REF_11"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 2301.sol-Pinakion-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_39(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(controller)

IRs:
TMP_40(bool) = INTERNAL_CALL, Pinakion.isContract(address)(controller)
CONDITION TMP_40"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))

IRs:
TMP_41 = CONVERT controller to TokenController
TMP_42(bool) = HIGH_LEVEL_CALL, dest:TMP_41(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
allowed[msg.sender][_spender] = _amount

IRs:
REF_8(mapping(address => uint256)) -> allowed[msg.sender]
REF_9(uint256) -> REF_8[_spender]
REF_9(uint256) (->allowed) := _amount(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,_amount)

IRs:
Emit Approval(msg.sender,_spender,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 2301.sol-Pinakion-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approve(_spender,_amount))

IRs:
TMP_45(bool) = INTERNAL_CALL, Pinakion.approve(address,uint256)(_spender,_amount)
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)

IRs:
TMP_47 = CONVERT _spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_47(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 2301.sol-Pinakion-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOfAt(_owner,block.number)

IRs:
TMP_38(uint256) = INTERNAL_CALL, Pinakion.balanceOfAt(address,uint256)(_owner,block.number)
RETURN TMP_38"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 2301.sol-Pinakion-balanceOfAt(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)

IRs:
REF_13(Pinakion.Checkpoint[]) -> balances[_owner]
REF_14 -> LENGTH REF_13
TMP_50(bool) = REF_14 == 0
REF_15(Pinakion.Checkpoint[]) -> balances[_owner]
REF_16(Pinakion.Checkpoint) -> REF_15[0]
REF_17(uint128) -> REF_16.fromBlock
TMP_51(bool) = REF_17 > _blockNumber
TMP_52(bool) = TMP_50 || TMP_51
CONDITION TMP_52"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_53 = CONVERT parentToken to address
TMP_54(bool) = TMP_53 != 0
CONDITION TMP_54"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_55(uint256) = INTERNAL_CALL, Pinakion.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_56(uint256) = HIGH_LEVEL_CALL, dest:parentToken(Pinakion), function:balanceOfAt, arguments:['_owner', 'TMP_55']  
RETURN TMP_56"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(balances[_owner],_blockNumber)

IRs:
REF_19(Pinakion.Checkpoint[]) -> balances[_owner]
TMP_57(uint256) = INTERNAL_CALL, Pinakion.getValueAt(Pinakion.Checkpoint[],uint256)(REF_19,_blockNumber)
RETURN TMP_57"];
}
// Function: 2301.sol-Pinakion-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 2301.sol-Pinakion-claimTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_129(bool) = _token == 0
CONDITION TMP_129"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_56(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_56"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
token = Pinakion(_token)

IRs:
TMP_131 = CONVERT _token to Pinakion
token(Pinakion) := TMP_131(Pinakion)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_132(uint256) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_132(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_133(bool) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:transfer, arguments:['controller', 'balance']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 2301.sol-Pinakion-createCloneToken(string,uint8,string,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_snapshotBlock == 0

IRs:
TMP_66(bool) = _snapshotBlock == 0
CONDITION TMP_66"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_snapshotBlock = block.number

IRs:
_snapshotBlock(uint256) := block.number(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)

IRs:
TMP_67(Pinakion) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  
cloneToken(Pinakion) := TMP_67(Pinakion)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
cloneToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:cloneToken(Pinakion), function:changeController, arguments:['msg.sender']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
NewCloneToken(address(cloneToken),_snapshotBlock)

IRs:
TMP_69 = CONVERT cloneToken to address
Emit NewCloneToken(TMP_69,_snapshotBlock)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
address(cloneToken)

IRs:
TMP_71 = CONVERT cloneToken to address
RETURN TMP_71"];
}
// Function: 2301.sol-Pinakion-destroyTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_86(uint256) = INTERNAL_CALL, Pinakion.totalSupply()()
curTotalSupply(uint256) := TMP_86(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply >= _amount)

IRs:
TMP_87(bool) = curTotalSupply >= _amount
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceFrom = balanceOf(_owner)

IRs:
TMP_89(uint256) = INTERNAL_CALL, Pinakion.balanceOf(address)(_owner)
previousBalanceFrom(uint256) := TMP_89(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_90(bool) = previousBalanceFrom >= _amount
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)

IRs:
TMP_92(uint256) = curTotalSupply - _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(totalSupplyHistory,TMP_92)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceFrom - _amount)

IRs:
REF_27(Pinakion.Checkpoint[]) -> balances[_owner]
TMP_94(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_27,TMP_94)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_owner,0,_amount)

IRs:
Emit Transfer(_owner,0,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 2301.sol-Pinakion-doTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_13(bool) = _amount == 0
CONDITION TMP_13"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(parentSnapShotBlock < block.number)

IRs:
TMP_15(bool) = parentSnapShotBlock < block.number
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)((_to != 0) && (_to != address(this)))

IRs:
TMP_17(bool) = _to != 0
TMP_18 = CONVERT this to address
TMP_19(bool) = _to != TMP_18
TMP_20(bool) = TMP_17 && TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
previousBalanceFrom = balanceOfAt(_from,block.number)

IRs:
TMP_22(uint256) = INTERNAL_CALL, Pinakion.balanceOfAt(address,uint256)(_from,block.number)
previousBalanceFrom(uint256) := TMP_22(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_23(bool) = previousBalanceFrom >= _amount
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
isContract(controller)

IRs:
TMP_25(bool) = INTERNAL_CALL, Pinakion.isContract(address)(controller)
CONDITION TMP_25"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(TokenController(controller).onTransfer(_from,_to,_amount))

IRs:
TMP_26 = CONVERT controller to TokenController
TMP_27(bool) = HIGH_LEVEL_CALL, dest:TMP_26(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
updateValueAtNow(balances[_from],previousBalanceFrom - _amount)

IRs:
REF_5(Pinakion.Checkpoint[]) -> balances[_from]
TMP_29(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_5,TMP_29)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
previousBalanceTo = balanceOfAt(_to,block.number)

IRs:
TMP_31(uint256) = INTERNAL_CALL, Pinakion.balanceOfAt(address,uint256)(_to,block.number)
previousBalanceTo(uint256) := TMP_31(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_32(uint256) = previousBalanceTo + _amount
TMP_33(bool) = TMP_32 >= previousBalanceTo
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
updateValueAtNow(balances[_to],previousBalanceTo + _amount)

IRs:
REF_6(Pinakion.Checkpoint[]) -> balances[_to]
TMP_35(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_6,TMP_35)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
}
// Function: 2301.sol-Pinakion-enableTransfers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 2301.sol-Pinakion-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_123(bool) = INTERNAL_CALL, Pinakion.isContract(address)(controller)
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_125 = CONVERT controller to TokenController
TMP_127(bool) = HIGH_LEVEL_CALL, dest:TMP_125(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)"];
}
// Function: 2301.sol-Pinakion-generateTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_72(uint256) = INTERNAL_CALL, Pinakion.totalSupply()()
curTotalSupply(uint256) := TMP_72(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply + _amount >= curTotalSupply)

IRs:
TMP_73(uint256) = curTotalSupply + _amount
TMP_74(bool) = TMP_73 >= curTotalSupply
TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceTo = balanceOf(_owner)

IRs:
TMP_76(uint256) = INTERNAL_CALL, Pinakion.balanceOf(address)(_owner)
previousBalanceTo(uint256) := TMP_76(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_77(uint256) = previousBalanceTo + _amount
TMP_78(bool) = TMP_77 >= previousBalanceTo
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)

IRs:
TMP_80(uint256) = curTotalSupply + _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(totalSupplyHistory,TMP_80)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceTo + _amount)

IRs:
REF_26(Pinakion.Checkpoint[]) -> balances[_owner]
TMP_82(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_26,TMP_82)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0,_owner,_amount)

IRs:
Emit Transfer(0,_owner,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 2301.sol-Pinakion-getValueAt(Pinakion.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
checkpoints.length == 0

IRs:
REF_28 -> LENGTH checkpoints
TMP_99(bool) = REF_28 == 0
CONDITION TMP_99"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_block >= checkpoints[checkpoints.length - 1].fromBlock

IRs:
REF_29 -> LENGTH checkpoints
TMP_100(uint256) = REF_29 - 1
REF_30(Pinakion.Checkpoint) -> checkpoints[TMP_100]
REF_31(uint128) -> REF_30.fromBlock
TMP_101(bool) = _block >= REF_31
CONDITION TMP_101"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
checkpoints[checkpoints.length - 1].value

IRs:
REF_32 -> LENGTH checkpoints
TMP_102(uint256) = REF_32 - 1
REF_33(Pinakion.Checkpoint) -> checkpoints[TMP_102]
REF_34(uint128) -> REF_33.value
RETURN REF_34"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_block < checkpoints[0].fromBlock

IRs:
REF_35(Pinakion.Checkpoint) -> checkpoints[0]
REF_36(uint128) -> REF_35.fromBlock
TMP_103(bool) = _block < REF_36
CONDITION TMP_103"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
0

IRs:
RETURN 0"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
min = 0

IRs:
min(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
max = checkpoints.length - 1

IRs:
REF_37 -> LENGTH checkpoints
TMP_104(uint256) = REF_37 - 1
max(uint256) := TMP_104(uint256)"];
11->12;
12[label="Node Type: BEGIN_LOOP 12
"];
12->13;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
max > min

IRs:
TMP_105(bool) = max > min
CONDITION TMP_105"];
13->14[label="True"];
13->19[label="False"];
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
mid = (max + min + 1) / 2

IRs:
TMP_106(uint256) = max + min
TMP_107(uint256) = TMP_106 + 1
TMP_108(uint256) = TMP_107 / 2
mid(uint256) := TMP_108(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
checkpoints[mid].fromBlock <= _block

IRs:
REF_38(Pinakion.Checkpoint) -> checkpoints[mid]
REF_39(uint128) -> REF_38.fromBlock
TMP_109(bool) = REF_39 <= _block
CONDITION TMP_109"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
min = mid

IRs:
min(uint256) := mid(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
max = mid - 1

IRs:
TMP_110(uint256) = mid - 1
max(uint256) := TMP_110(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->13;
19[label="Node Type: END_LOOP 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
checkpoints[min].value

IRs:
REF_40(Pinakion.Checkpoint) -> checkpoints[min]
REF_41(uint128) -> REF_40.value
RETURN REF_41"];
}
// Function: 2301.sol-Pinakion-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_addr == 0

IRs:
TMP_120(bool) = _addr == 0
CONDITION TMP_120"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
size > 0

IRs:
TMP_121(bool) = size > 0
RETURN TMP_121"];
}
// Function: 2301.sol-Pinakion-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_122(bool) = a < b
CONDITION TMP_122"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 2301.sol-Pinakion-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_136(bool) = msg.sender == controller
TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2301.sol-Pinakion-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
version = MMT_0.2

IRs:
version(string) := MMT_0.2(string)"];
}
// Function: 2301.sol-Pinakion-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupplyAt(block.number)

IRs:
TMP_49(uint256) = INTERNAL_CALL, Pinakion.totalSupplyAt(uint256)(block.number)
RETURN TMP_49"];
}
// Function: 2301.sol-Pinakion-totalSupplyAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)

IRs:
REF_20 -> LENGTH totalSupplyHistory
TMP_58(bool) = REF_20 == 0
REF_21(Pinakion.Checkpoint) -> totalSupplyHistory[0]
REF_22(uint128) -> REF_21.fromBlock
TMP_59(bool) = REF_22 > _blockNumber
TMP_60(bool) = TMP_58 || TMP_59
CONDITION TMP_60"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_61 = CONVERT parentToken to address
TMP_62(bool) = TMP_61 != 0
CONDITION TMP_62"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_63(uint256) = INTERNAL_CALL, Pinakion.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_64(uint256) = HIGH_LEVEL_CALL, dest:parentToken(Pinakion), function:totalSupplyAt, arguments:['TMP_63']  
RETURN TMP_64"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(totalSupplyHistory,_blockNumber)

IRs:
TMP_65(uint256) = INTERNAL_CALL, Pinakion.getValueAt(Pinakion.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)
RETURN TMP_65"];
}
// Function: 2301.sol-Pinakion-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_6(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
doTransfer(msg.sender,_to,_amount)

IRs:
INTERNAL_CALL, Pinakion.doTransfer(address,address,uint256)(msg.sender,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 2301.sol-Pinakion-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != controller

IRs:
TMP_8(bool) = msg.sender != controller
CONDITION TMP_8"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_9(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowed[_from][msg.sender] >= _amount)

IRs:
REF_0(mapping(address => uint256)) -> allowed[_from]
REF_1(uint256) -> REF_0[msg.sender]
TMP_10(bool) = REF_1 >= _amount
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_2(mapping(address => uint256)) -> allowed[_from]
REF_3(uint256) -> REF_2[msg.sender]
REF_3(-> allowed) = REF_3 - _amount"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
doTransfer(_from,_to,_amount)

IRs:
INTERNAL_CALL, Pinakion.doTransfer(address,address,uint256)(_from,_to,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 2301.sol-Pinakion-updateValueAtNow(Pinakion.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)

IRs:
REF_42 -> LENGTH checkpoints
TMP_111(bool) = REF_42 == 0
REF_43 -> LENGTH checkpoints
TMP_112(uint256) = REF_43 - 1
REF_44(Pinakion.Checkpoint) -> checkpoints[TMP_112]
REF_45(uint128) -> REF_44.fromBlock
TMP_113(bool) = REF_45 < block.number
TMP_114(bool) = TMP_111 || TMP_113
CONDITION TMP_114"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newCheckPoint = checkpoints[checkpoints.length ++]

IRs:
REF_46 -> LENGTH checkpoints
TMP_115(uint256) := REF_46(uint256)
REF_46(-> checkpoints) = REF_46 + 1
REF_47(Pinakion.Checkpoint) -> checkpoints[TMP_115]
newCheckPoint(Pinakion.Checkpoint) := REF_47(Pinakion.Checkpoint)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newCheckPoint.fromBlock = uint128(block.number)

IRs:
REF_48(uint128) -> newCheckPoint.fromBlock
TMP_116 = CONVERT block.number to uint128
REF_48(uint128) (->newCheckPoint) := TMP_116(uint128)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newCheckPoint.value = uint128(_value)

IRs:
REF_49(uint128) -> newCheckPoint.value
TMP_117 = CONVERT _value to uint128
REF_49(uint128) (->newCheckPoint) := TMP_117(uint128)"];
4->7;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
oldCheckPoint = checkpoints[checkpoints.length - 1]

IRs:
REF_50 -> LENGTH checkpoints
TMP_118(uint256) = REF_50 - 1
REF_51(Pinakion.Checkpoint) -> checkpoints[TMP_118]
oldCheckPoint(Pinakion.Checkpoint) := REF_51(Pinakion.Checkpoint)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
oldCheckPoint.value = uint128(_value)

IRs:
REF_52(uint128) -> oldCheckPoint.value
TMP_119 = CONVERT _value to uint128
REF_52(uint128) (->oldCheckPoint) := TMP_119(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 2301.sol-RNG-contribute(uint256)
digraph{
}
// Function: 2301.sol-RNG-getRN(uint256)
digraph{
}
// Function: 2301.sol-RNG-getUncorrelatedRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
baseRN = getRN(_block)

IRs:
TMP_142(uint256) = INTERNAL_CALL, RNG.getRN(uint256)(_block)
baseRN(uint256) := TMP_142(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
baseRN == 0

IRs:
TMP_143(bool) = baseRN == 0
CONDITION TMP_143"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: RETURN 4

EXPRESSION:
uint256(keccak256()(msg.sender,baseRN))

IRs:
TMP_144(bytes32) = SOLIDITY_CALL keccak256()(msg.sender,baseRN)
TMP_145 = CONVERT TMP_144 to uint256
RETURN TMP_145"];
6[label="Node Type: RETURN 6

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 2301.sol-RNG-requestRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contribute(_block)

IRs:
INTERNAL_CALL, RNG.contribute(uint256)(_block)"];
}
// Function: 2301.sol-TokenController-onApprove(address,address,uint256)
digraph{
}
// Function: 2301.sol-TokenController-onTransfer(address,address,uint256)
digraph{
}
// Function: 2301.sol-TokenController-proxyPayment(address)
digraph{
}
}
