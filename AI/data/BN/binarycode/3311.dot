digraph G {
// Function: 3311.sol-AccountLevels-accountLevel(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3311.sol-AccountLevelsTest-accountLevel(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accountLevels[user]

IRs:
REF_44(uint256) -> accountLevels[user]
RETURN REF_44"];
}
// Function: 3311.sol-AccountLevelsTest-setAccountLevel(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
accountLevels[user] = level

IRs:
REF_43(uint256) -> accountLevels[user]
REF_43(uint256) (->accountLevels) := level(uint256)"];
}
// Function: 3311.sol-ReserveToken-ReserveToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minter = msg.sender

IRs:
minter(address) := msg.sender(address)"];
}
// Function: 3311.sol-ReserveToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3311.sol-ReserveToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-ReserveToken-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_42 = UnaryType.BANG assertion 
CONDITION TMP_42"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 3311.sol-ReserveToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 3311.sol-ReserveToken-create(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != minter

IRs:
TMP_56(bool) = msg.sender != minter
CONDITION TMP_56"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[account] = safeAdd(balances[account],amount)

IRs:
REF_38(uint256) -> balances[account]
REF_39(uint256) -> balances[account]
TMP_57(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_39,amount)
REF_38(uint256) (->balances) := TMP_57(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = safeAdd(totalSupply,amount)

IRs:
TMP_58(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,amount)
totalSupply(uint256) := TMP_58(uint256)"];
}
// Function: 3311.sol-ReserveToken-destroy(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != minter

IRs:
TMP_59(bool) = msg.sender != minter
CONDITION TMP_59"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
balances[account] < amount

IRs:
REF_40(uint256) -> balances[account]
TMP_60(bool) = REF_40 < amount
CONDITION TMP_60"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[account] = safeSub(balances[account],amount)

IRs:
REF_41(uint256) -> balances[account]
REF_42(uint256) -> balances[account]
TMP_61(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_42,amount)
REF_41(uint256) (->balances) := TMP_61(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
totalSupply = safeSub(totalSupply,amount)

IRs:
TMP_62(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,amount)
totalSupply(uint256) := TMP_62(uint256)"];
}
// Function: 3311.sol-ReserveToken-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_37(uint256) = a + b
c(uint256) := TMP_37(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_38(bool) = c >= a
TMP_39(bool) = c >= b
TMP_40(bool) = TMP_38 && TMP_39
INTERNAL_CALL, SafeMath.assert(bool)(TMP_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3311.sol-ReserveToken-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_28(uint256) = a * b
c(uint256) := TMP_28(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_29(bool) = a == 0
TMP_30(uint256) = c / a
TMP_31(bool) = TMP_30 == b
TMP_32(bool) = TMP_29 || TMP_31
INTERNAL_CALL, SafeMath.assert(bool)(TMP_32)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3311.sol-ReserveToken-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_34(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_34)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_36(uint256) = a - b
RETURN TMP_36"];
}
// Function: 3311.sol-ReserveToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 3311.sol-ReserveToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-ReserveToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-SafeMath-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_14 = UnaryType.BANG assertion 
CONDITION TMP_14"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 3311.sol-SafeMath-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_10(bool) = c >= a
TMP_11(bool) = c >= b
TMP_12(bool) = TMP_10 && TMP_11
INTERNAL_CALL, SafeMath.assert(bool)(TMP_12)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3311.sol-SafeMath-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
INTERNAL_CALL, SafeMath.assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3311.sol-SafeMath-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_6(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 3311.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_17(mapping(address => uint256)) -> allowed[_owner]
REF_18(uint256) -> REF_17[_spender]
RETURN REF_18"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3311.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_15(mapping(address => uint256)) -> allowed[msg.sender]
REF_16(uint256) -> REF_15[_spender]
REF_16(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-StandardToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_14(uint256) -> balances[_owner]
RETURN REF_14"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 3311.sol-StandardToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 3311.sol-StandardToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_15(bool) = REF_0 >= _value
REF_1(uint256) -> balances[_to]
TMP_16(uint256) = REF_1 + _value
REF_2(uint256) -> balances[_to]
TMP_17(bool) = TMP_16 > REF_2
TMP_18(bool) = TMP_15 && TMP_17
CONDITION TMP_18"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]

IRs:
REF_5(uint256) -> balances[_from]
TMP_20(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_21(bool) = REF_7 >= _value
TMP_22(bool) = TMP_20 && TMP_21
REF_8(uint256) -> balances[_to]
TMP_23(uint256) = REF_8 + _value
REF_9(uint256) -> balances[_to]
TMP_24(bool) = TMP_23 > REF_9
TMP_25(bool) = TMP_22 && TMP_24
CONDITION TMP_25"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_11(uint256) -> balances[_from]
REF_11(-> balances) = REF_11 - _value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_12(mapping(address => uint256)) -> allowed[_from]
REF_13(uint256) -> REF_12[msg.sender]
REF_13(-> allowed) = REF_13 - _value"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3311.sol-Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 3311.sol-Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 3311.sol-Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3311.sol-nDEX-amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_177(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_177(bytes32)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
orderFills[user][hash]

IRs:
REF_122(mapping(bytes32 => uint256)) -> orderFills[user]
REF_123(uint256) -> REF_122[hash]
RETURN REF_123"];
}
// Function: 3311.sol-nDEX-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_77 = UnaryType.BANG assertion 
CONDITION TMP_77"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 3311.sol-nDEX-availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_165(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_165(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! ((orders[user][hash] || ecrecover(bytes32,uint8,bytes32,bytes32)(sha3()(Ethereum Signed Message:
32,hash),v,r,s) == user) && block.number <= expires)

IRs:
REF_116(mapping(bytes32 => bool)) -> orders[user]
REF_117(bool) -> REF_116[hash]
TMP_166(bytes32) = SOLIDITY_CALL sha3()(Ethereum Signed Message:
32,hash)
TMP_167(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_166,v,r,s)
TMP_168(bool) = TMP_167 == user
TMP_169(bool) = REF_117 || TMP_168
TMP_170(bool) = block.number <= expires
TMP_171(bool) = TMP_169 && TMP_170
TMP_172 = UnaryType.BANG TMP_171 
CONDITION TMP_172"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
available1 = safeSub(amountGet,orderFills[user][hash])

IRs:
REF_118(mapping(bytes32 => uint256)) -> orderFills[user]
REF_119(uint256) -> REF_118[hash]
TMP_173(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(amountGet,REF_119)
available1(uint256) := TMP_173(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
available2 = safeMul(tokens[tokenGive][user],amountGet) / amountGive

IRs:
REF_120(mapping(address => uint256)) -> tokens[tokenGive]
REF_121(uint256) -> REF_120[user]
TMP_174(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(REF_121,amountGet)
TMP_175(uint256) = TMP_174 / amountGive
available2(uint256) := TMP_175(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
available1 < available2

IRs:
TMP_176(bool) = available1 < available2
CONDITION TMP_176"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
available1

IRs:
RETURN available1"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
available2

IRs:
RETURN available2"];
}
// Function: 3311.sol-nDEX-balanceOf(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
tokens[token][user]

IRs:
REF_77(mapping(address => uint256)) -> tokens[token]
REF_78(uint256) -> REF_77[user]
RETURN REF_78"];
}
// Function: 3311.sol-nDEX-cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_178(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_178(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! (orders[msg.sender][hash] || ecrecover(bytes32,uint8,bytes32,bytes32)(sha3()(Ethereum Signed Message:
32,hash),v,r,s) == msg.sender)

IRs:
REF_124(mapping(bytes32 => bool)) -> orders[msg.sender]
REF_125(bool) -> REF_124[hash]
TMP_179(bytes32) = SOLIDITY_CALL sha3()(Ethereum Signed Message:
32,hash)
TMP_180(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_179,v,r,s)
TMP_181(bool) = TMP_180 == msg.sender
TMP_182(bool) = REF_125 || TMP_181
TMP_183 = UnaryType.BANG TMP_182 
CONDITION TMP_183"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
orderFills[msg.sender][hash] = amountGet

IRs:
REF_126(mapping(bytes32 => uint256)) -> orderFills[msg.sender]
REF_127(uint256) -> REF_126[hash]
REF_127(uint256) (->orderFills) := amountGet(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Cancel(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender,v,r,s)

IRs:
Emit Cancel(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender,v,r,s)"];
}
// Function: 3311.sol-nDEX-changeAccountLevelsAddr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_79(bool) = msg.sender != admin
CONDITION TMP_79"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
accountLevelsAddr = accountLevelsAddr_

IRs:
accountLevelsAddr(address) := accountLevelsAddr_(address)"];
}
// Function: 3311.sol-nDEX-changeAdmin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_78(bool) = msg.sender != admin
CONDITION TMP_78"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
admin = admin_

IRs:
admin(address) := admin_(address)"];
}
// Function: 3311.sol-nDEX-changeFeeAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_80(bool) = msg.sender != admin
CONDITION TMP_80"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
feeAccount = feeAccount_

IRs:
feeAccount(address) := feeAccount_(address)"];
}
// Function: 3311.sol-nDEX-changeFeeAccount2(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != feeAccount2

IRs:
TMP_81(bool) = msg.sender != feeAccount2
CONDITION TMP_81"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
feeAccount2 = feeAccount2_

IRs:
feeAccount2(address) := feeAccount2_(address)"];
}
// Function: 3311.sol-nDEX-changeFeeMake(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_82(bool) = msg.sender != admin
CONDITION TMP_82"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
feeMake_ > feeMake

IRs:
TMP_83(bool) = feeMake_ > feeMake
CONDITION TMP_83"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeMake = feeMake_

IRs:
feeMake(uint256) := feeMake_(uint256)"];
}
// Function: 3311.sol-nDEX-changeFeeRebate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_88(bool) = msg.sender != admin
CONDITION TMP_88"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
feeRebate_ < feeRebate || feeRebate_ > feeTake

IRs:
TMP_89(bool) = feeRebate_ < feeRebate
TMP_90(bool) = feeRebate_ > feeTake
TMP_91(bool) = TMP_89 || TMP_90
CONDITION TMP_91"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeRebate = feeRebate_

IRs:
feeRebate(uint256) := feeRebate_(uint256)"];
}
// Function: 3311.sol-nDEX-changeFeeTake(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_84(bool) = msg.sender != admin
CONDITION TMP_84"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
feeTake_ > feeTake || feeTake_ < feeRebate

IRs:
TMP_85(bool) = feeTake_ > feeTake
TMP_86(bool) = feeTake_ < feeRebate
TMP_87(bool) = TMP_85 || TMP_86
CONDITION TMP_87"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeTake = feeTake_

IRs:
feeTake(uint256) := feeTake_(uint256)"];
}
// Function: 3311.sol-nDEX-deposit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender],msg.value)

IRs:
REF_45(mapping(address => uint256)) -> tokens[0]
REF_46(uint256) -> REF_45[msg.sender]
REF_47(mapping(address => uint256)) -> tokens[0]
REF_48(uint256) -> REF_47[msg.sender]
TMP_92(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_48,msg.value)
REF_46(uint256) (->tokens) := TMP_92(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(0,msg.sender,msg.value,tokens[0][msg.sender])

IRs:
REF_49(mapping(address => uint256)) -> tokens[0]
REF_50(uint256) -> REF_49[msg.sender]
Emit Deposit(0,msg.sender,msg.value,REF_50)"];
}
// Function: 3311.sol-nDEX-depositToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
token == 0

IRs:
TMP_100(bool) = token == 0
CONDITION TMP_100"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
! Token(token).transferFrom(msg.sender,this,amount)

IRs:
TMP_101 = CONVERT token to Token
TMP_102(bool) = HIGH_LEVEL_CALL, dest:TMP_101(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_103 = UnaryType.BANG TMP_102 
CONDITION TMP_103"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount)

IRs:
REF_62(mapping(address => uint256)) -> tokens[token]
REF_63(uint256) -> REF_62[msg.sender]
REF_64(mapping(address => uint256)) -> tokens[token]
REF_65(uint256) -> REF_64[msg.sender]
TMP_104(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_65,amount)
REF_63(uint256) (->tokens) := TMP_104(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Deposit(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_66(mapping(address => uint256)) -> tokens[token]
REF_67(uint256) -> REF_66[msg.sender]
Emit Deposit(token,msg.sender,amount,REF_67)"];
}
// Function: 3311.sol-nDEX-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: THROW 1
"];
}
// Function: 3311.sol-nDEX-nDEX(address,address,address,address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
admin = admin_

IRs:
admin(address) := admin_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feeAccount = feeAccount_

IRs:
feeAccount(address) := feeAccount_(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
feeAccount2 = feeAccount2_

IRs:
feeAccount2(address) := feeAccount2_(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
accountLevelsAddr = accountLevelsAddr_

IRs:
accountLevelsAddr(address) := accountLevelsAddr_(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
feeMake = feeMake_

IRs:
feeMake(uint256) := feeMake_(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
feeTake = feeTake_

IRs:
feeTake(uint256) := feeTake_(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeRebate = feeRebate_

IRs:
feeRebate(uint256) := feeRebate_(uint256)"];
}
// Function: 3311.sol-nDEX-order(address,uint256,address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_113(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_113(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
orders[msg.sender][hash] = true

IRs:
REF_79(mapping(bytes32 => bool)) -> orders[msg.sender]
REF_80(bool) -> REF_79[hash]
REF_80(bool) (->orders) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Order(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender)

IRs:
Emit Order(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender)"];
}
// Function: 3311.sol-nDEX-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_72(uint256) = a + b
c(uint256) := TMP_72(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_73(bool) = c >= a
TMP_74(bool) = c >= b
TMP_75(bool) = TMP_73 && TMP_74
INTERNAL_CALL, SafeMath.assert(bool)(TMP_75)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3311.sol-nDEX-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_63(uint256) = a * b
c(uint256) := TMP_63(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_64(bool) = a == 0
TMP_65(uint256) = c / a
TMP_66(bool) = TMP_65 == b
TMP_67(bool) = TMP_64 || TMP_66
INTERNAL_CALL, SafeMath.assert(bool)(TMP_67)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3311.sol-nDEX-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_69(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_69)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_71(uint256) = a - b
RETURN TMP_71"];
}
// Function: 3311.sol-nDEX-testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! (tokens[tokenGet][sender] >= amount && availableVolume(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,user,v,r,s) >= amount)

IRs:
REF_114(mapping(address => uint256)) -> tokens[tokenGet]
REF_115(uint256) -> REF_114[sender]
TMP_160(bool) = REF_115 >= amount
TMP_161(uint256) = INTERNAL_CALL, nDEX.availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,user,v,r,s)
TMP_162(bool) = TMP_161 >= amount
TMP_163(bool) = TMP_160 && TMP_162
TMP_164 = UnaryType.BANG TMP_163 
CONDITION TMP_164"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3311.sol-nDEX-trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_115(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_115(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! ((orders[user][hash] || ecrecover(bytes32,uint8,bytes32,bytes32)(sha3()(Ethereum Signed Message:
32,hash),v,r,s) == user) && block.number <= expires && safeAdd(orderFills[user][hash],amount) <= amountGet)

IRs:
REF_81(mapping(bytes32 => bool)) -> orders[user]
REF_82(bool) -> REF_81[hash]
TMP_116(bytes32) = SOLIDITY_CALL sha3()(Ethereum Signed Message:
32,hash)
TMP_117(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_116,v,r,s)
TMP_118(bool) = TMP_117 == user
TMP_119(bool) = REF_82 || TMP_118
TMP_120(bool) = block.number <= expires
TMP_121(bool) = TMP_119 && TMP_120
REF_83(mapping(bytes32 => uint256)) -> orderFills[user]
REF_84(uint256) -> REF_83[hash]
TMP_122(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_84,amount)
TMP_123(bool) = TMP_122 <= amountGet
TMP_124(bool) = TMP_121 && TMP_123
TMP_125 = UnaryType.BANG TMP_124 
CONDITION TMP_125"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tradeBalances(tokenGet,amountGet,tokenGive,amountGive,user,amount)

IRs:
INTERNAL_CALL, nDEX.tradeBalances(address,uint256,address,uint256,address,uint256)(tokenGet,amountGet,tokenGive,amountGive,user,amount)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
orderFills[user][hash] = safeAdd(orderFills[user][hash],amount)

IRs:
REF_85(mapping(bytes32 => uint256)) -> orderFills[user]
REF_86(uint256) -> REF_85[hash]
REF_87(mapping(bytes32 => uint256)) -> orderFills[user]
REF_88(uint256) -> REF_87[hash]
TMP_127(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_88,amount)
REF_86(uint256) (->orderFills) := TMP_127(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Trade(tokenGet,amount,tokenGive,amountGive * amount / amountGet,user,msg.sender)

IRs:
TMP_128(uint256) = amountGive * amount
TMP_129(uint256) = TMP_128 / amountGet
Emit Trade(tokenGet,amount,tokenGive,TMP_129,user,msg.sender)"];
}
// Function: 3311.sol-nDEX-tradeBalances(address,uint256,address,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
feeMakeXfer = safeMul(amount,feeMake) / (1000000000000000000)

IRs:
TMP_131(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,feeMake)
TMP_132(uint256) = TMP_131 / 1000000000000000000
feeMakeXfer(uint256) := TMP_132(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
feeTakeXfer = safeMul(amount,feeTake) / (1000000000000000000)

IRs:
TMP_133(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,feeTake)
TMP_134(uint256) = TMP_133 / 1000000000000000000
feeTakeXfer(uint256) := TMP_134(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
feeRebateXfer = 0

IRs:
feeRebateXfer(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
accountLevelsAddr != 0x0

IRs:
TMP_135(bool) = accountLevelsAddr != 0
CONDITION TMP_135"];
4->5[label="True"];
4->12[label="False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user)

IRs:
TMP_136 = CONVERT accountLevelsAddr to AccountLevels
TMP_137(uint256) = HIGH_LEVEL_CALL, dest:TMP_136(AccountLevels), function:accountLevel, arguments:['user']  
accountLevel(uint256) := TMP_137(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
accountLevel == 1

IRs:
TMP_138(bool) = accountLevel == 1
CONDITION TMP_138"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeRebateXfer = safeMul(amount,feeRebate) / (1000000000000000000)

IRs:
TMP_139(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,feeRebate)
TMP_140(uint256) = TMP_139 / 1000000000000000000
feeRebateXfer(uint256) := TMP_140(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
accountLevel == 2

IRs:
TMP_141(bool) = accountLevel == 2
CONDITION TMP_141"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
feeRebateXfer = feeTakeXfer

IRs:
feeRebateXfer(uint256) := feeTakeXfer(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender],safeAdd(amount,feeTakeXfer))

IRs:
REF_90(mapping(address => uint256)) -> tokens[tokenGet]
REF_91(uint256) -> REF_90[msg.sender]
REF_92(mapping(address => uint256)) -> tokens[tokenGet]
REF_93(uint256) -> REF_92[msg.sender]
TMP_142(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(amount,feeTakeXfer)
TMP_143(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_93,TMP_142)
REF_91(uint256) (->tokens) := TMP_143(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user],safeSub(safeAdd(amount,feeRebateXfer),feeMakeXfer))

IRs:
REF_94(mapping(address => uint256)) -> tokens[tokenGet]
REF_95(uint256) -> REF_94[user]
REF_96(mapping(address => uint256)) -> tokens[tokenGet]
REF_97(uint256) -> REF_96[user]
TMP_144(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(amount,feeRebateXfer)
TMP_145(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_144,feeMakeXfer)
TMP_146(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_97,TMP_145)
REF_95(uint256) (->tokens) := TMP_146(uint256)"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
fee = safeSub(safeAdd(feeMakeXfer,feeTakeXfer),feeRebateXfer)

IRs:
TMP_147(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(feeMakeXfer,feeTakeXfer)
TMP_148(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_147,feeRebateXfer)
fee(uint256) := TMP_148(uint256)"];
15->16;
16[label="Node Type: NEW VARIABLE 16

EXPRESSION:
fee2 = safeMul(fee,20) / 100

IRs:
TMP_149(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(fee,20)
TMP_150(uint256) = TMP_149 / 100
fee2(uint256) := TMP_150(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount],safeSub(fee,fee2))

IRs:
REF_98(mapping(address => uint256)) -> tokens[tokenGet]
REF_99(uint256) -> REF_98[feeAccount]
REF_100(mapping(address => uint256)) -> tokens[tokenGet]
REF_101(uint256) -> REF_100[feeAccount]
TMP_151(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(fee,fee2)
TMP_152(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_101,TMP_151)
REF_99(uint256) (->tokens) := TMP_152(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
tokens[tokenGet][feeAccount2] = safeAdd(tokens[tokenGet][feeAccount2],fee2)

IRs:
REF_102(mapping(address => uint256)) -> tokens[tokenGet]
REF_103(uint256) -> REF_102[feeAccount2]
REF_104(mapping(address => uint256)) -> tokens[tokenGet]
REF_105(uint256) -> REF_104[feeAccount2]
TMP_153(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_105,fee2)
REF_103(uint256) (->tokens) := TMP_153(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
tokens[tokenGive][user] = safeSub(tokens[tokenGive][user],safeMul(amountGive,amount) / amountGet)

IRs:
REF_106(mapping(address => uint256)) -> tokens[tokenGive]
REF_107(uint256) -> REF_106[user]
REF_108(mapping(address => uint256)) -> tokens[tokenGive]
REF_109(uint256) -> REF_108[user]
TMP_154(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amountGive,amount)
TMP_155(uint256) = TMP_154 / amountGet
TMP_156(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_109,TMP_155)
REF_107(uint256) (->tokens) := TMP_156(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender],safeMul(amountGive,amount) / amountGet)

IRs:
REF_110(mapping(address => uint256)) -> tokens[tokenGive]
REF_111(uint256) -> REF_110[msg.sender]
REF_112(mapping(address => uint256)) -> tokens[tokenGive]
REF_113(uint256) -> REF_112[msg.sender]
TMP_157(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amountGive,amount)
TMP_158(uint256) = TMP_157 / amountGet
TMP_159(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_113,TMP_158)
REF_111(uint256) (->tokens) := TMP_159(uint256)"];
}
// Function: 3311.sol-nDEX-withdraw(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_51(mapping(address => uint256)) -> tokens[0]
REF_52(uint256) -> REF_51[msg.sender]
TMP_94(bool) = REF_52 < amount
CONDITION TMP_94"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_53(mapping(address => uint256)) -> tokens[0]
REF_54(uint256) -> REF_53[msg.sender]
REF_55(mapping(address => uint256)) -> tokens[0]
REF_56(uint256) -> REF_55[msg.sender]
TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount)
REF_54(uint256) (->tokens) := TMP_95(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! msg.sender.call.value(amount)()

IRs:
TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
TMP_98 = UnaryType.BANG TMP_97 
CONDITION TMP_98"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_59(mapping(address => uint256)) -> tokens[0]
REF_60(uint256) -> REF_59[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_60)"];
}
// Function: 3311.sol-nDEX-withdrawToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
token == 0

IRs:
TMP_106(bool) = token == 0
CONDITION TMP_106"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
tokens[token][msg.sender] < amount

IRs:
REF_68(mapping(address => uint256)) -> tokens[token]
REF_69(uint256) -> REF_68[msg.sender]
TMP_107(bool) = REF_69 < amount
CONDITION TMP_107"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount)

IRs:
REF_70(mapping(address => uint256)) -> tokens[token]
REF_71(uint256) -> REF_70[msg.sender]
REF_72(mapping(address => uint256)) -> tokens[token]
REF_73(uint256) -> REF_72[msg.sender]
TMP_108(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_73,amount)
REF_71(uint256) (->tokens) := TMP_108(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
! Token(token).transfer(msg.sender,amount)

IRs:
TMP_109 = CONVERT token to Token
TMP_110(bool) = HIGH_LEVEL_CALL, dest:TMP_109(Token), function:transfer, arguments:['msg.sender', 'amount']  
TMP_111 = UnaryType.BANG TMP_110 
CONDITION TMP_111"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: THROW 9
"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Withdraw(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_75(mapping(address => uint256)) -> tokens[token]
REF_76(uint256) -> REF_75[msg.sender]
Emit Withdraw(token,msg.sender,amount,REF_76)"];
}
}
