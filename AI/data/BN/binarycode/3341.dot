digraph G {
// Function: 3341.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)
digraph{
}
// Function: 3341.sol-BountyVault-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_307 = CONVERT 0 to address
TMP_308(bool) = _newOwner != TMP_307
TMP_309(None) = SOLIDITY_CALL require(bool)(TMP_308)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 3341.sol-BountyVault-allocateTokens(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_126 -> LENGTH _recipients
TMP_316(bool) = i < REF_126
CONDITION TMP_316"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_recipients[i]] = balances[_recipients[i]].add(_amounts[i])

IRs:
REF_127(address) -> _recipients[i]
REF_128(uint256) -> balances[REF_127]
REF_129(address) -> _recipients[i]
REF_130(uint256) -> balances[REF_129]
REF_132(uint256) -> _amounts[i]
TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_130', 'REF_132'] 
REF_128(uint256) (->balances) := TMP_317(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allocatedTotal = allocatedTotal.add(_amounts[i])

IRs:
REF_134(uint256) -> _amounts[i]
TMP_318(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['allocatedTotal', 'REF_134'] 
allocatedTotal(uint256) := TMP_318(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_319(uint256) := i(uint256)
i(uint256) = i + 1"];
7->4;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
8->3;
}
// Function: 3341.sol-BountyVault-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 3341.sol-BountyVault-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenContract = DTXToken(_tokenAddress)

IRs:
TMP_311 = CONVERT _tokenAddress to DTXToken
tokenContract(DTXToken) := TMP_311(DTXToken)"];
}
// Function: 3341.sol-BountyVault-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_321(bool) = msg.sender == owner
TMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3341.sol-BountyVault-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_303 = CONVERT 0 to address
owner(address) := TMP_303(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 3341.sol-BountyVault-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 3341.sol-BountyVault-withdrawTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amount = balances[msg.sender]

IRs:
REF_123(uint256) -> balances[msg.sender]
amount(uint256) := REF_123(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(amount > 0,You have no tokens left)

IRs:
TMP_312(bool) = amount > 0
TMP_313(None) = SOLIDITY_CALL require(bool,string)(TMP_312,You have no tokens left)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_124(uint256) -> balances[msg.sender]
REF_124(uint256) (->balances) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(tokenContract.transfer(msg.sender,amount),Token transfer failed)

IRs:
TMP_314(bool) = HIGH_LEVEL_CALL, dest:tokenContract(DTXToken), function:transfer, arguments:['msg.sender', 'amount']  
TMP_315(None) = SOLIDITY_CALL require(bool,string)(TMP_314,Token transfer failed)"];
}
// Function: 3341.sol-Controlled-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 3341.sol-Controlled-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 3341.sol-Controlled-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_1(bool) = msg.sender == controller
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3341.sol-DTXToken-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 3341.sol-DTXToken-DTXToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
MiniMeToken(_tokenFactory,0x0,0,DaTa eXchange Token,18,DTX,true)

IRs:
INTERNAL_CALL, MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)(_tokenFactory,0,0,DaTa eXchange Token,18,DTX,True)"];
}
// Function: 3341.sol-DTXToken-MiniMeToken(address,address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenFactory = MiniMeTokenFactory(_tokenFactory)

IRs:
TMP_142 = CONVERT _tokenFactory to MiniMeTokenFactory
tokenFactory(MiniMeTokenFactory) := TMP_142(MiniMeTokenFactory)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
parentToken = MiniMeToken(_parentToken)

IRs:
TMP_143 = CONVERT _parentToken to MiniMeToken
parentToken(MiniMeToken) := TMP_143(MiniMeToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
parentSnapShotBlock = _parentSnapShotBlock

IRs:
parentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 3341.sol-DTXToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_74(mapping(address => uint256)) -> allowed[_owner]
REF_75(uint256) -> REF_74[_spender]
RETURN REF_75"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3341.sol-DTXToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_174(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((_amount == 0) || (allowed[msg.sender][_spender] == 0))

IRs:
TMP_175(bool) = _amount == 0
REF_69(mapping(address => uint256)) -> allowed[msg.sender]
REF_70(uint256) -> REF_69[_spender]
TMP_176(bool) = REF_70 == 0
TMP_177(bool) = TMP_175 || TMP_176
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
isContract(controller)

IRs:
TMP_179(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_179"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))

IRs:
TMP_180 = CONVERT controller to TokenController
TMP_181(bool) = HIGH_LEVEL_CALL, dest:TMP_180(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[msg.sender][_spender] = _amount

IRs:
REF_72(mapping(address => uint256)) -> allowed[msg.sender]
REF_73(uint256) -> REF_72[_spender]
REF_73(uint256) (->allowed) := _amount(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Approval(msg.sender,_spender,_amount)

IRs:
Emit Approval(msg.sender,_spender,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-DTXToken-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approve(_spender,_amount))

IRs:
TMP_184(bool) = INTERNAL_CALL, MiniMeToken.approve(address,uint256)(_spender,_amount)
TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)

IRs:
TMP_186 = CONVERT _spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_186(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-DTXToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOfAt(_owner,block.number)

IRs:
TMP_173(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_owner,block.number)
RETURN TMP_173"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 3341.sol-DTXToken-balanceOfAt(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)

IRs:
REF_77(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_78 -> LENGTH REF_77
TMP_189(bool) = REF_78 == 0
REF_79(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_80(MiniMeToken.Checkpoint) -> REF_79[0]
REF_81(uint128) -> REF_80.fromBlock
TMP_190(bool) = REF_81 > _blockNumber
TMP_191(bool) = TMP_189 || TMP_190
CONDITION TMP_191"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_192 = CONVERT parentToken to address
TMP_193(bool) = TMP_192 != 0
CONDITION TMP_193"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_194(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_195(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:balanceOfAt, arguments:['_owner', 'TMP_194']  
RETURN TMP_195"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(balances[_owner],_blockNumber)

IRs:
REF_83(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_196(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(REF_83,_blockNumber)
RETURN TMP_196"];
}
// Function: 3341.sol-DTXToken-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 3341.sol-DTXToken-claimTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_268(bool) = _token == 0
CONDITION TMP_268"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_120(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_120"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_270 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_270(MiniMeToken)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_271(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_271(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_272(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 3341.sol-DTXToken-createCloneToken(string,uint8,string,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_snapshotBlock == 0

IRs:
TMP_205(bool) = _snapshotBlock == 0
CONDITION TMP_205"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_snapshotBlock = block.number

IRs:
_snapshotBlock(uint256) := block.number(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)

IRs:
TMP_206(MiniMeToken) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  
cloneToken(MiniMeToken) := TMP_206(MiniMeToken)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
cloneToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:cloneToken(MiniMeToken), function:changeController, arguments:['msg.sender']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
NewCloneToken(address(cloneToken),_snapshotBlock)

IRs:
TMP_208 = CONVERT cloneToken to address
Emit NewCloneToken(TMP_208,_snapshotBlock)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
address(cloneToken)

IRs:
TMP_210 = CONVERT cloneToken to address
RETURN TMP_210"];
}
// Function: 3341.sol-DTXToken-destroyTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_225(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_225(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply >= _amount)

IRs:
TMP_226(bool) = curTotalSupply >= _amount
TMP_227(None) = SOLIDITY_CALL require(bool)(TMP_226)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceFrom = balanceOf(_owner)

IRs:
TMP_228(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceFrom(uint256) := TMP_228(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_229(bool) = previousBalanceFrom >= _amount
TMP_230(None) = SOLIDITY_CALL require(bool)(TMP_229)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)

IRs:
TMP_231(uint256) = curTotalSupply - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_231)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceFrom - _amount)

IRs:
REF_91(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_233(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_91,TMP_233)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_owner,0,_amount)

IRs:
Emit Transfer(_owner,0,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 3341.sol-DTXToken-doTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_150(bool) = _amount == 0
CONDITION TMP_150"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(parentSnapShotBlock < block.number)

IRs:
TMP_151(bool) = parentSnapShotBlock < block.number
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)((_to != 0) && (_to != address(this)))

IRs:
TMP_153(bool) = _to != 0
TMP_154 = CONVERT this to address
TMP_155(bool) = _to != TMP_154
TMP_156(bool) = TMP_153 && TMP_155
TMP_157(None) = SOLIDITY_CALL require(bool)(TMP_156)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
previousBalanceFrom = balanceOfAt(_from,block.number)

IRs:
TMP_158(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_from,block.number)
previousBalanceFrom(uint256) := TMP_158(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
previousBalanceFrom < _amount

IRs:
TMP_159(bool) = previousBalanceFrom < _amount
CONDITION TMP_159"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
isContract(controller)

IRs:
TMP_160(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_160"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(TokenController(controller).onTransfer(_from,_to,_amount))

IRs:
TMP_161 = CONVERT controller to TokenController
TMP_162(bool) = HIGH_LEVEL_CALL, dest:TMP_161(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
updateValueAtNow(balances[_from],previousBalanceFrom - _amount)

IRs:
REF_67(MiniMeToken.Checkpoint[]) -> balances[_from]
TMP_164(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_67,TMP_164)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
previousBalanceTo = balanceOfAt(_to,block.number)

IRs:
TMP_166(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_to,block.number)
previousBalanceTo(uint256) := TMP_166(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_167(uint256) = previousBalanceTo + _amount
TMP_168(bool) = TMP_167 >= previousBalanceTo
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
updateValueAtNow(balances[_to],previousBalanceTo + _amount)

IRs:
REF_68(MiniMeToken.Checkpoint[]) -> balances[_to]
TMP_170(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_68,TMP_170)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3341.sol-DTXToken-enableTransfers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 3341.sol-DTXToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_262(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_263(None) = SOLIDITY_CALL require(bool)(TMP_262)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_264 = CONVERT controller to TokenController
TMP_266(bool) = HIGH_LEVEL_CALL, dest:TMP_264(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266)"];
}
// Function: 3341.sol-DTXToken-generateTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_211(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_211(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply + _amount >= curTotalSupply)

IRs:
TMP_212(uint256) = curTotalSupply + _amount
TMP_213(bool) = TMP_212 >= curTotalSupply
TMP_214(None) = SOLIDITY_CALL require(bool)(TMP_213)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceTo = balanceOf(_owner)

IRs:
TMP_215(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceTo(uint256) := TMP_215(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_216(uint256) = previousBalanceTo + _amount
TMP_217(bool) = TMP_216 >= previousBalanceTo
TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)

IRs:
TMP_219(uint256) = curTotalSupply + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_219)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceTo + _amount)

IRs:
REF_90(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_221(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_90,TMP_221)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0,_owner,_amount)

IRs:
Emit Transfer(0,_owner,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 3341.sol-DTXToken-getValueAt(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
checkpoints.length == 0

IRs:
REF_92 -> LENGTH checkpoints
TMP_238(bool) = REF_92 == 0
CONDITION TMP_238"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_block >= checkpoints[checkpoints.length - 1].fromBlock

IRs:
REF_93 -> LENGTH checkpoints
TMP_239(uint256) = REF_93 - 1
REF_94(MiniMeToken.Checkpoint) -> checkpoints[TMP_239]
REF_95(uint128) -> REF_94.fromBlock
TMP_240(bool) = _block >= REF_95
CONDITION TMP_240"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
checkpoints[checkpoints.length - 1].value

IRs:
REF_96 -> LENGTH checkpoints
TMP_241(uint256) = REF_96 - 1
REF_97(MiniMeToken.Checkpoint) -> checkpoints[TMP_241]
REF_98(uint128) -> REF_97.value
RETURN REF_98"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_block < checkpoints[0].fromBlock

IRs:
REF_99(MiniMeToken.Checkpoint) -> checkpoints[0]
REF_100(uint128) -> REF_99.fromBlock
TMP_242(bool) = _block < REF_100
CONDITION TMP_242"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
0

IRs:
RETURN 0"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
min = 0

IRs:
min(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
max = checkpoints.length - 1

IRs:
REF_101 -> LENGTH checkpoints
TMP_243(uint256) = REF_101 - 1
max(uint256) := TMP_243(uint256)"];
11->12;
12[label="Node Type: BEGIN_LOOP 12
"];
12->13;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
max > min

IRs:
TMP_244(bool) = max > min
CONDITION TMP_244"];
13->14[label="True"];
13->19[label="False"];
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
mid = (max + min + 1) / 2

IRs:
TMP_245(uint256) = max + min
TMP_246(uint256) = TMP_245 + 1
TMP_247(uint256) = TMP_246 / 2
mid(uint256) := TMP_247(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
checkpoints[mid].fromBlock <= _block

IRs:
REF_102(MiniMeToken.Checkpoint) -> checkpoints[mid]
REF_103(uint128) -> REF_102.fromBlock
TMP_248(bool) = REF_103 <= _block
CONDITION TMP_248"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
min = mid

IRs:
min(uint256) := mid(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
max = mid - 1

IRs:
TMP_249(uint256) = mid - 1
max(uint256) := TMP_249(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->13;
19[label="Node Type: END_LOOP 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
checkpoints[min].value

IRs:
REF_104(MiniMeToken.Checkpoint) -> checkpoints[min]
REF_105(uint128) -> REF_104.value
RETURN REF_105"];
}
// Function: 3341.sol-DTXToken-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_addr == 0

IRs:
TMP_259(bool) = _addr == 0
CONDITION TMP_259"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
size > 0

IRs:
TMP_260(bool) = size > 0
RETURN TMP_260"];
}
// Function: 3341.sol-DTXToken-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_261(bool) = a < b
CONDITION TMP_261"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 3341.sol-DTXToken-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_277(bool) = msg.sender == controller
TMP_278(None) = SOLIDITY_CALL require(bool)(TMP_277)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3341.sol-DTXToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
version = MMT_0.2

IRs:
version(string) := MMT_0.2(string)"];
}
// Function: 3341.sol-DTXToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupplyAt(block.number)

IRs:
TMP_188(uint256) = INTERNAL_CALL, MiniMeToken.totalSupplyAt(uint256)(block.number)
RETURN TMP_188"];
}
// Function: 3341.sol-DTXToken-totalSupplyAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)

IRs:
REF_84 -> LENGTH totalSupplyHistory
TMP_197(bool) = REF_84 == 0
REF_85(MiniMeToken.Checkpoint) -> totalSupplyHistory[0]
REF_86(uint128) -> REF_85.fromBlock
TMP_198(bool) = REF_86 > _blockNumber
TMP_199(bool) = TMP_197 || TMP_198
CONDITION TMP_199"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_200 = CONVERT parentToken to address
TMP_201(bool) = TMP_200 != 0
CONDITION TMP_201"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_202(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_203(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:totalSupplyAt, arguments:['TMP_202']  
RETURN TMP_203"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(totalSupplyHistory,_blockNumber)

IRs:
TMP_204(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)
RETURN TMP_204"];
}
// Function: 3341.sol-DTXToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_144(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
doTransfer(msg.sender,_to,_amount)

IRs:
TMP_145(bool) = INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(msg.sender,_to,_amount)
RETURN TMP_145"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-DTXToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != controller

IRs:
TMP_146(bool) = msg.sender != controller
CONDITION TMP_146"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_147(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
allowed[_from][msg.sender] < _amount

IRs:
REF_62(mapping(address => uint256)) -> allowed[_from]
REF_63(uint256) -> REF_62[msg.sender]
TMP_148(bool) = REF_63 < _amount
CONDITION TMP_148"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_64(mapping(address => uint256)) -> allowed[_from]
REF_65(uint256) -> REF_64[msg.sender]
REF_65(-> allowed) = REF_65 - _amount"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
doTransfer(_from,_to,_amount)

IRs:
TMP_149(bool) = INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(_from,_to,_amount)
RETURN TMP_149"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-DTXToken-updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)

IRs:
REF_106 -> LENGTH checkpoints
TMP_250(bool) = REF_106 == 0
REF_107 -> LENGTH checkpoints
TMP_251(uint256) = REF_107 - 1
REF_108(MiniMeToken.Checkpoint) -> checkpoints[TMP_251]
REF_109(uint128) -> REF_108.fromBlock
TMP_252(bool) = REF_109 < block.number
TMP_253(bool) = TMP_250 || TMP_252
CONDITION TMP_253"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newCheckPoint = checkpoints[checkpoints.length ++]

IRs:
REF_110 -> LENGTH checkpoints
TMP_254(uint256) := REF_110(uint256)
REF_110(-> checkpoints) = REF_110 + 1
REF_111(MiniMeToken.Checkpoint) -> checkpoints[TMP_254]
newCheckPoint(MiniMeToken.Checkpoint) := REF_111(MiniMeToken.Checkpoint)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newCheckPoint.fromBlock = uint128(block.number)

IRs:
REF_112(uint128) -> newCheckPoint.fromBlock
TMP_255 = CONVERT block.number to uint128
REF_112(uint128) (->newCheckPoint) := TMP_255(uint128)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newCheckPoint.value = uint128(_value)

IRs:
REF_113(uint128) -> newCheckPoint.value
TMP_256 = CONVERT _value to uint128
REF_113(uint128) (->newCheckPoint) := TMP_256(uint128)"];
4->7;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
oldCheckPoint = checkpoints[checkpoints.length - 1]

IRs:
REF_114 -> LENGTH checkpoints
TMP_257(uint256) = REF_114 - 1
REF_115(MiniMeToken.Checkpoint) -> checkpoints[TMP_257]
oldCheckPoint(MiniMeToken.Checkpoint) := REF_115(MiniMeToken.Checkpoint)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
oldCheckPoint.value = uint128(_value)

IRs:
REF_116(uint128) -> oldCheckPoint.value
TMP_258 = CONVERT _value to uint128
REF_116(uint128) (->oldCheckPoint) := TMP_258(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 3341.sol-MiniMeToken-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 3341.sol-MiniMeToken-MiniMeToken(address,address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenFactory = MiniMeTokenFactory(_tokenFactory)

IRs:
TMP_4 = CONVERT _tokenFactory to MiniMeTokenFactory
tokenFactory(MiniMeTokenFactory) := TMP_4(MiniMeTokenFactory)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
parentToken = MiniMeToken(_parentToken)

IRs:
TMP_5 = CONVERT _parentToken to MiniMeToken
parentToken(MiniMeToken) := TMP_5(MiniMeToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
parentSnapShotBlock = _parentSnapShotBlock

IRs:
parentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 3341.sol-MiniMeToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_12(mapping(address => uint256)) -> allowed[_owner]
REF_13(uint256) -> REF_12[_spender]
RETURN REF_13"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3341.sol-MiniMeToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_36(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((_amount == 0) || (allowed[msg.sender][_spender] == 0))

IRs:
TMP_37(bool) = _amount == 0
REF_7(mapping(address => uint256)) -> allowed[msg.sender]
REF_8(uint256) -> REF_7[_spender]
TMP_38(bool) = REF_8 == 0
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
isContract(controller)

IRs:
TMP_41(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_41"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))

IRs:
TMP_42 = CONVERT controller to TokenController
TMP_43(bool) = HIGH_LEVEL_CALL, dest:TMP_42(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[msg.sender][_spender] = _amount

IRs:
REF_10(mapping(address => uint256)) -> allowed[msg.sender]
REF_11(uint256) -> REF_10[_spender]
REF_11(uint256) (->allowed) := _amount(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Approval(msg.sender,_spender,_amount)

IRs:
Emit Approval(msg.sender,_spender,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-MiniMeToken-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approve(_spender,_amount))

IRs:
TMP_46(bool) = INTERNAL_CALL, MiniMeToken.approve(address,uint256)(_spender,_amount)
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)

IRs:
TMP_48 = CONVERT _spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_48(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-MiniMeToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOfAt(_owner,block.number)

IRs:
TMP_35(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_owner,block.number)
RETURN TMP_35"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 3341.sol-MiniMeToken-balanceOfAt(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)

IRs:
REF_15(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_16 -> LENGTH REF_15
TMP_51(bool) = REF_16 == 0
REF_17(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_18(MiniMeToken.Checkpoint) -> REF_17[0]
REF_19(uint128) -> REF_18.fromBlock
TMP_52(bool) = REF_19 > _blockNumber
TMP_53(bool) = TMP_51 || TMP_52
CONDITION TMP_53"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_54 = CONVERT parentToken to address
TMP_55(bool) = TMP_54 != 0
CONDITION TMP_55"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_56(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_57(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:balanceOfAt, arguments:['_owner', 'TMP_56']  
RETURN TMP_57"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(balances[_owner],_blockNumber)

IRs:
REF_21(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_58(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(REF_21,_blockNumber)
RETURN TMP_58"];
}
// Function: 3341.sol-MiniMeToken-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 3341.sol-MiniMeToken-claimTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_130(bool) = _token == 0
CONDITION TMP_130"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_132 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_132(MiniMeToken)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_133(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_133(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_134(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 3341.sol-MiniMeToken-createCloneToken(string,uint8,string,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_snapshotBlock == 0

IRs:
TMP_67(bool) = _snapshotBlock == 0
CONDITION TMP_67"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_snapshotBlock = block.number

IRs:
_snapshotBlock(uint256) := block.number(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)

IRs:
TMP_68(MiniMeToken) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  
cloneToken(MiniMeToken) := TMP_68(MiniMeToken)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
cloneToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:cloneToken(MiniMeToken), function:changeController, arguments:['msg.sender']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
NewCloneToken(address(cloneToken),_snapshotBlock)

IRs:
TMP_70 = CONVERT cloneToken to address
Emit NewCloneToken(TMP_70,_snapshotBlock)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
address(cloneToken)

IRs:
TMP_72 = CONVERT cloneToken to address
RETURN TMP_72"];
}
// Function: 3341.sol-MiniMeToken-destroyTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_87(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_87(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply >= _amount)

IRs:
TMP_88(bool) = curTotalSupply >= _amount
TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceFrom = balanceOf(_owner)

IRs:
TMP_90(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceFrom(uint256) := TMP_90(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_91(bool) = previousBalanceFrom >= _amount
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)

IRs:
TMP_93(uint256) = curTotalSupply - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_93)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceFrom - _amount)

IRs:
REF_29(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_95(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_29,TMP_95)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_owner,0,_amount)

IRs:
Emit Transfer(_owner,0,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 3341.sol-MiniMeToken-doTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_12(bool) = _amount == 0
CONDITION TMP_12"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(parentSnapShotBlock < block.number)

IRs:
TMP_13(bool) = parentSnapShotBlock < block.number
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)((_to != 0) && (_to != address(this)))

IRs:
TMP_15(bool) = _to != 0
TMP_16 = CONVERT this to address
TMP_17(bool) = _to != TMP_16
TMP_18(bool) = TMP_15 && TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
previousBalanceFrom = balanceOfAt(_from,block.number)

IRs:
TMP_20(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_from,block.number)
previousBalanceFrom(uint256) := TMP_20(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
previousBalanceFrom < _amount

IRs:
TMP_21(bool) = previousBalanceFrom < _amount
CONDITION TMP_21"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
isContract(controller)

IRs:
TMP_22(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_22"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(TokenController(controller).onTransfer(_from,_to,_amount))

IRs:
TMP_23 = CONVERT controller to TokenController
TMP_24(bool) = HIGH_LEVEL_CALL, dest:TMP_23(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
updateValueAtNow(balances[_from],previousBalanceFrom - _amount)

IRs:
REF_5(MiniMeToken.Checkpoint[]) -> balances[_from]
TMP_26(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_5,TMP_26)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
previousBalanceTo = balanceOfAt(_to,block.number)

IRs:
TMP_28(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_to,block.number)
previousBalanceTo(uint256) := TMP_28(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_29(uint256) = previousBalanceTo + _amount
TMP_30(bool) = TMP_29 >= previousBalanceTo
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
updateValueAtNow(balances[_to],previousBalanceTo + _amount)

IRs:
REF_6(MiniMeToken.Checkpoint[]) -> balances[_to]
TMP_32(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_6,TMP_32)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3341.sol-MiniMeToken-enableTransfers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 3341.sol-MiniMeToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_124(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_126 = CONVERT controller to TokenController
TMP_128(bool) = HIGH_LEVEL_CALL, dest:TMP_126(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)"];
}
// Function: 3341.sol-MiniMeToken-generateTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_73(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_73(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply + _amount >= curTotalSupply)

IRs:
TMP_74(uint256) = curTotalSupply + _amount
TMP_75(bool) = TMP_74 >= curTotalSupply
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceTo = balanceOf(_owner)

IRs:
TMP_77(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceTo(uint256) := TMP_77(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_78(uint256) = previousBalanceTo + _amount
TMP_79(bool) = TMP_78 >= previousBalanceTo
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)

IRs:
TMP_81(uint256) = curTotalSupply + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_81)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceTo + _amount)

IRs:
REF_28(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_83(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_28,TMP_83)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0,_owner,_amount)

IRs:
Emit Transfer(0,_owner,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 3341.sol-MiniMeToken-getValueAt(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
checkpoints.length == 0

IRs:
REF_30 -> LENGTH checkpoints
TMP_100(bool) = REF_30 == 0
CONDITION TMP_100"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_block >= checkpoints[checkpoints.length - 1].fromBlock

IRs:
REF_31 -> LENGTH checkpoints
TMP_101(uint256) = REF_31 - 1
REF_32(MiniMeToken.Checkpoint) -> checkpoints[TMP_101]
REF_33(uint128) -> REF_32.fromBlock
TMP_102(bool) = _block >= REF_33
CONDITION TMP_102"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
checkpoints[checkpoints.length - 1].value

IRs:
REF_34 -> LENGTH checkpoints
TMP_103(uint256) = REF_34 - 1
REF_35(MiniMeToken.Checkpoint) -> checkpoints[TMP_103]
REF_36(uint128) -> REF_35.value
RETURN REF_36"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_block < checkpoints[0].fromBlock

IRs:
REF_37(MiniMeToken.Checkpoint) -> checkpoints[0]
REF_38(uint128) -> REF_37.fromBlock
TMP_104(bool) = _block < REF_38
CONDITION TMP_104"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
0

IRs:
RETURN 0"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
min = 0

IRs:
min(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
max = checkpoints.length - 1

IRs:
REF_39 -> LENGTH checkpoints
TMP_105(uint256) = REF_39 - 1
max(uint256) := TMP_105(uint256)"];
11->12;
12[label="Node Type: BEGIN_LOOP 12
"];
12->13;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
max > min

IRs:
TMP_106(bool) = max > min
CONDITION TMP_106"];
13->14[label="True"];
13->19[label="False"];
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
mid = (max + min + 1) / 2

IRs:
TMP_107(uint256) = max + min
TMP_108(uint256) = TMP_107 + 1
TMP_109(uint256) = TMP_108 / 2
mid(uint256) := TMP_109(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
checkpoints[mid].fromBlock <= _block

IRs:
REF_40(MiniMeToken.Checkpoint) -> checkpoints[mid]
REF_41(uint128) -> REF_40.fromBlock
TMP_110(bool) = REF_41 <= _block
CONDITION TMP_110"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
min = mid

IRs:
min(uint256) := mid(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
max = mid - 1

IRs:
TMP_111(uint256) = mid - 1
max(uint256) := TMP_111(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->13;
19[label="Node Type: END_LOOP 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
checkpoints[min].value

IRs:
REF_42(MiniMeToken.Checkpoint) -> checkpoints[min]
REF_43(uint128) -> REF_42.value
RETURN REF_43"];
}
// Function: 3341.sol-MiniMeToken-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_addr == 0

IRs:
TMP_121(bool) = _addr == 0
CONDITION TMP_121"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
size > 0

IRs:
TMP_122(bool) = size > 0
RETURN TMP_122"];
}
// Function: 3341.sol-MiniMeToken-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_123(bool) = a < b
CONDITION TMP_123"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 3341.sol-MiniMeToken-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_137(bool) = msg.sender == controller
TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3341.sol-MiniMeToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
version = MMT_0.2

IRs:
version(string) := MMT_0.2(string)"];
}
// Function: 3341.sol-MiniMeToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupplyAt(block.number)

IRs:
TMP_50(uint256) = INTERNAL_CALL, MiniMeToken.totalSupplyAt(uint256)(block.number)
RETURN TMP_50"];
}
// Function: 3341.sol-MiniMeToken-totalSupplyAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)

IRs:
REF_22 -> LENGTH totalSupplyHistory
TMP_59(bool) = REF_22 == 0
REF_23(MiniMeToken.Checkpoint) -> totalSupplyHistory[0]
REF_24(uint128) -> REF_23.fromBlock
TMP_60(bool) = REF_24 > _blockNumber
TMP_61(bool) = TMP_59 || TMP_60
CONDITION TMP_61"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_62 = CONVERT parentToken to address
TMP_63(bool) = TMP_62 != 0
CONDITION TMP_63"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_64(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_65(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:totalSupplyAt, arguments:['TMP_64']  
RETURN TMP_65"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(totalSupplyHistory,_blockNumber)

IRs:
TMP_66(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)
RETURN TMP_66"];
}
// Function: 3341.sol-MiniMeToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_6(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
doTransfer(msg.sender,_to,_amount)

IRs:
TMP_7(bool) = INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(msg.sender,_to,_amount)
RETURN TMP_7"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-MiniMeToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != controller

IRs:
TMP_8(bool) = msg.sender != controller
CONDITION TMP_8"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_9(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
allowed[_from][msg.sender] < _amount

IRs:
REF_0(mapping(address => uint256)) -> allowed[_from]
REF_1(uint256) -> REF_0[msg.sender]
TMP_10(bool) = REF_1 < _amount
CONDITION TMP_10"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_2(mapping(address => uint256)) -> allowed[_from]
REF_3(uint256) -> REF_2[msg.sender]
REF_3(-> allowed) = REF_3 - _amount"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
doTransfer(_from,_to,_amount)

IRs:
TMP_11(bool) = INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(_from,_to,_amount)
RETURN TMP_11"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3341.sol-MiniMeToken-updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)

IRs:
REF_44 -> LENGTH checkpoints
TMP_112(bool) = REF_44 == 0
REF_45 -> LENGTH checkpoints
TMP_113(uint256) = REF_45 - 1
REF_46(MiniMeToken.Checkpoint) -> checkpoints[TMP_113]
REF_47(uint128) -> REF_46.fromBlock
TMP_114(bool) = REF_47 < block.number
TMP_115(bool) = TMP_112 || TMP_114
CONDITION TMP_115"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newCheckPoint = checkpoints[checkpoints.length ++]

IRs:
REF_48 -> LENGTH checkpoints
TMP_116(uint256) := REF_48(uint256)
REF_48(-> checkpoints) = REF_48 + 1
REF_49(MiniMeToken.Checkpoint) -> checkpoints[TMP_116]
newCheckPoint(MiniMeToken.Checkpoint) := REF_49(MiniMeToken.Checkpoint)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newCheckPoint.fromBlock = uint128(block.number)

IRs:
REF_50(uint128) -> newCheckPoint.fromBlock
TMP_117 = CONVERT block.number to uint128
REF_50(uint128) (->newCheckPoint) := TMP_117(uint128)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newCheckPoint.value = uint128(_value)

IRs:
REF_51(uint128) -> newCheckPoint.value
TMP_118 = CONVERT _value to uint128
REF_51(uint128) (->newCheckPoint) := TMP_118(uint128)"];
4->7;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
oldCheckPoint = checkpoints[checkpoints.length - 1]

IRs:
REF_52 -> LENGTH checkpoints
TMP_119(uint256) = REF_52 - 1
REF_53(MiniMeToken.Checkpoint) -> checkpoints[TMP_119]
oldCheckPoint(MiniMeToken.Checkpoint) := REF_53(MiniMeToken.Checkpoint)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
oldCheckPoint.value = uint128(_value)

IRs:
REF_54(uint128) -> oldCheckPoint.value
TMP_120 = CONVERT _value to uint128
REF_54(uint128) (->oldCheckPoint) := TMP_120(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 3341.sol-MiniMeTokenFactory-createCloneToken(address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
newToken = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled)

IRs:
TMP_140(MiniMeToken) = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) 
newToken(MiniMeToken) := TMP_140(MiniMeToken)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:newToken(MiniMeToken), function:changeController, arguments:['msg.sender']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
newToken

IRs:
RETURN newToken"];
}
// Function: 3341.sol-Ownable-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_284 = CONVERT 0 to address
TMP_285(bool) = _newOwner != TMP_284
TMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 3341.sol-Ownable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 3341.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_288(bool) = msg.sender == owner
TMP_289(None) = SOLIDITY_CALL require(bool)(TMP_288)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3341.sol-Ownable-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_280 = CONVERT 0 to address
owner(address) := TMP_280(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 3341.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 3341.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_299(uint256) = a + b
c(uint256) := TMP_299(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_300(bool) = c >= a
TMP_301(None) = SOLIDITY_CALL assert(bool)(TMP_300)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3341.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_295(uint256) = a / b
c(uint256) := TMP_295(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3341.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_290(bool) = a == 0
CONDITION TMP_290"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_291(uint256) = a * b
c(uint256) := TMP_291(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_292(uint256) = c / a
TMP_293(bool) = TMP_292 == b
TMP_294(None) = SOLIDITY_CALL assert(bool)(TMP_293)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3341.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_296(bool) = b <= a
TMP_297(None) = SOLIDITY_CALL assert(bool)(TMP_296)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_298(uint256) = a - b
RETURN TMP_298"];
}
// Function: 3341.sol-TokenController-onApprove(address,address,uint256)
digraph{
}
// Function: 3341.sol-TokenController-onTransfer(address,address,uint256)
digraph{
}
// Function: 3341.sol-TokenController-proxyPayment(address)
digraph{
}
}
