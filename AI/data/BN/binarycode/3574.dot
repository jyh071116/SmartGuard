digraph G {
// Function: 3574.sol-AccountLevels-accountLevel(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3574.sol-AccountLevelsTest-accountLevel(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accountLevels[user]

IRs:
REF_44(uint256) -> accountLevels[user]
RETURN REF_44"];
}
// Function: 3574.sol-AccountLevelsTest-setAccountLevel(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
accountLevels[user] = level

IRs:
REF_43(uint256) -> accountLevels[user]
REF_43(uint256) (->accountLevels) := level(uint256)"];
}
// Function: 3574.sol-BitDex-BitDex(address,address,address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
admin = admin_

IRs:
admin(address) := admin_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feeAccount = feeAccount_

IRs:
feeAccount(address) := feeAccount_(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
accountLevelsAddr = accountLevelsAddr_

IRs:
accountLevelsAddr(address) := accountLevelsAddr_(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
feeMake = feeMake_

IRs:
feeMake(uint256) := feeMake_(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
feeTake = feeTake_

IRs:
feeTake(uint256) := feeTake_(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
feeRebate = feeRebate_

IRs:
feeRebate(uint256) := feeRebate_(uint256)"];
}
// Function: 3574.sol-BitDex-amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_172(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_172(bytes32)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
orderFills[user][hash]

IRs:
REF_118(mapping(bytes32 => uint256)) -> orderFills[user]
REF_119(uint256) -> REF_118[hash]
RETURN REF_119"];
}
// Function: 3574.sol-BitDex-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_77 = UnaryType.BANG assertion 
CONDITION TMP_77"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 3574.sol-BitDex-availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_160(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_160(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! ((orders[user][hash] || ecrecover(bytes32,uint8,bytes32,bytes32)(sha3()(Ethereum Signed Message:
32,hash),v,r,s) == user) && block.number <= expires)

IRs:
REF_112(mapping(bytes32 => bool)) -> orders[user]
REF_113(bool) -> REF_112[hash]
TMP_161(bytes32) = SOLIDITY_CALL sha3()(Ethereum Signed Message:
32,hash)
TMP_162(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_161,v,r,s)
TMP_163(bool) = TMP_162 == user
TMP_164(bool) = REF_113 || TMP_163
TMP_165(bool) = block.number <= expires
TMP_166(bool) = TMP_164 && TMP_165
TMP_167 = UnaryType.BANG TMP_166 
CONDITION TMP_167"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
available1 = safeSub(amountGet,orderFills[user][hash])

IRs:
REF_114(mapping(bytes32 => uint256)) -> orderFills[user]
REF_115(uint256) -> REF_114[hash]
TMP_168(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(amountGet,REF_115)
available1(uint256) := TMP_168(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
available2 = safeMul(tokens[tokenGive][user],amountGet) / amountGive

IRs:
REF_116(mapping(address => uint256)) -> tokens[tokenGive]
REF_117(uint256) -> REF_116[user]
TMP_169(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(REF_117,amountGet)
TMP_170(uint256) = TMP_169 / amountGive
available2(uint256) := TMP_170(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
available1 < available2

IRs:
TMP_171(bool) = available1 < available2
CONDITION TMP_171"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
available1

IRs:
RETURN available1"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
available2

IRs:
RETURN available2"];
}
// Function: 3574.sol-BitDex-balanceOf(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
tokens[token][user]

IRs:
REF_77(mapping(address => uint256)) -> tokens[token]
REF_78(uint256) -> REF_77[user]
RETURN REF_78"];
}
// Function: 3574.sol-BitDex-cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_173(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_173(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! (orders[msg.sender][hash] || ecrecover(bytes32,uint8,bytes32,bytes32)(sha3()(Ethereum Signed Message:
32,hash),v,r,s) == msg.sender)

IRs:
REF_120(mapping(bytes32 => bool)) -> orders[msg.sender]
REF_121(bool) -> REF_120[hash]
TMP_174(bytes32) = SOLIDITY_CALL sha3()(Ethereum Signed Message:
32,hash)
TMP_175(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_174,v,r,s)
TMP_176(bool) = TMP_175 == msg.sender
TMP_177(bool) = REF_121 || TMP_176
TMP_178 = UnaryType.BANG TMP_177 
CONDITION TMP_178"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
orderFills[msg.sender][hash] = amountGet

IRs:
REF_122(mapping(bytes32 => uint256)) -> orderFills[msg.sender]
REF_123(uint256) -> REF_122[hash]
REF_123(uint256) (->orderFills) := amountGet(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Cancel(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender,v,r,s)

IRs:
Emit Cancel(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender,v,r,s)"];
}
// Function: 3574.sol-BitDex-changeAccountLevelsAddr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_79(bool) = msg.sender != admin
CONDITION TMP_79"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
accountLevelsAddr = accountLevelsAddr_

IRs:
accountLevelsAddr(address) := accountLevelsAddr_(address)"];
}
// Function: 3574.sol-BitDex-changeAdmin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_78(bool) = msg.sender != admin
CONDITION TMP_78"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
admin = admin_

IRs:
admin(address) := admin_(address)"];
}
// Function: 3574.sol-BitDex-changeFeeAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_80(bool) = msg.sender != admin
CONDITION TMP_80"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
feeAccount = feeAccount_

IRs:
feeAccount(address) := feeAccount_(address)"];
}
// Function: 3574.sol-BitDex-changeFeeMake(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_81(bool) = msg.sender != admin
CONDITION TMP_81"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
feeMake_ > feeMake

IRs:
TMP_82(bool) = feeMake_ > feeMake
CONDITION TMP_82"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeMake = feeMake_

IRs:
feeMake(uint256) := feeMake_(uint256)"];
}
// Function: 3574.sol-BitDex-changeFeeRebate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_87(bool) = msg.sender != admin
CONDITION TMP_87"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
feeRebate_ < feeRebate || feeRebate_ > feeTake

IRs:
TMP_88(bool) = feeRebate_ < feeRebate
TMP_89(bool) = feeRebate_ > feeTake
TMP_90(bool) = TMP_88 || TMP_89
CONDITION TMP_90"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeRebate = feeRebate_

IRs:
feeRebate(uint256) := feeRebate_(uint256)"];
}
// Function: 3574.sol-BitDex-changeFeeTake(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != admin

IRs:
TMP_83(bool) = msg.sender != admin
CONDITION TMP_83"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
feeTake_ > feeTake || feeTake_ < feeRebate

IRs:
TMP_84(bool) = feeTake_ > feeTake
TMP_85(bool) = feeTake_ < feeRebate
TMP_86(bool) = TMP_84 || TMP_85
CONDITION TMP_86"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeTake = feeTake_

IRs:
feeTake(uint256) := feeTake_(uint256)"];
}
// Function: 3574.sol-BitDex-deposit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender],msg.value)

IRs:
REF_45(mapping(address => uint256)) -> tokens[0]
REF_46(uint256) -> REF_45[msg.sender]
REF_47(mapping(address => uint256)) -> tokens[0]
REF_48(uint256) -> REF_47[msg.sender]
TMP_91(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_48,msg.value)
REF_46(uint256) (->tokens) := TMP_91(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(0,msg.sender,msg.value,tokens[0][msg.sender])

IRs:
REF_49(mapping(address => uint256)) -> tokens[0]
REF_50(uint256) -> REF_49[msg.sender]
Emit Deposit(0,msg.sender,msg.value,REF_50)"];
}
// Function: 3574.sol-BitDex-depositToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
token == 0

IRs:
TMP_99(bool) = token == 0
CONDITION TMP_99"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
! Token(token).transferFrom(msg.sender,this,amount)

IRs:
TMP_100 = CONVERT token to Token
TMP_101(bool) = HIGH_LEVEL_CALL, dest:TMP_100(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_102 = UnaryType.BANG TMP_101 
CONDITION TMP_102"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount)

IRs:
REF_62(mapping(address => uint256)) -> tokens[token]
REF_63(uint256) -> REF_62[msg.sender]
REF_64(mapping(address => uint256)) -> tokens[token]
REF_65(uint256) -> REF_64[msg.sender]
TMP_103(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_65,amount)
REF_63(uint256) (->tokens) := TMP_103(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Deposit(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_66(mapping(address => uint256)) -> tokens[token]
REF_67(uint256) -> REF_66[msg.sender]
Emit Deposit(token,msg.sender,amount,REF_67)"];
}
// Function: 3574.sol-BitDex-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: THROW 1
"];
}
// Function: 3574.sol-BitDex-order(address,uint256,address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_112(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_112(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
orders[msg.sender][hash] = true

IRs:
REF_79(mapping(bytes32 => bool)) -> orders[msg.sender]
REF_80(bool) -> REF_79[hash]
REF_80(bool) (->orders) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Order(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender)

IRs:
Emit Order(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,msg.sender)"];
}
// Function: 3574.sol-BitDex-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_72(uint256) = a + b
c(uint256) := TMP_72(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_73(bool) = c >= a
TMP_74(bool) = c >= b
TMP_75(bool) = TMP_73 && TMP_74
INTERNAL_CALL, SafeMath.assert(bool)(TMP_75)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3574.sol-BitDex-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_63(uint256) = a * b
c(uint256) := TMP_63(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_64(bool) = a == 0
TMP_65(uint256) = c / a
TMP_66(bool) = TMP_65 == b
TMP_67(bool) = TMP_64 || TMP_66
INTERNAL_CALL, SafeMath.assert(bool)(TMP_67)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3574.sol-BitDex-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_69(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_69)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_71(uint256) = a - b
RETURN TMP_71"];
}
// Function: 3574.sol-BitDex-testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! (tokens[tokenGet][sender] >= amount && availableVolume(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,user,v,r,s) >= amount)

IRs:
REF_110(mapping(address => uint256)) -> tokens[tokenGet]
REF_111(uint256) -> REF_110[sender]
TMP_155(bool) = REF_111 >= amount
TMP_156(uint256) = INTERNAL_CALL, BitDex.availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)(tokenGet,amountGet,tokenGive,amountGive,expires,nonce,user,v,r,s)
TMP_157(bool) = TMP_156 >= amount
TMP_158(bool) = TMP_155 && TMP_157
TMP_159 = UnaryType.BANG TMP_158 
CONDITION TMP_159"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3574.sol-BitDex-trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)

IRs:
TMP_114(bytes32) = SOLIDITY_CALL sha256()(this,tokenGet,amountGet,tokenGive,amountGive,expires,nonce)
hash(bytes32) := TMP_114(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! ((orders[user][hash] || ecrecover(bytes32,uint8,bytes32,bytes32)(sha3()(Ethereum Signed Message:
32,hash),v,r,s) == user) && block.number <= expires && safeAdd(orderFills[user][hash],amount) <= amountGet)

IRs:
REF_81(mapping(bytes32 => bool)) -> orders[user]
REF_82(bool) -> REF_81[hash]
TMP_115(bytes32) = SOLIDITY_CALL sha3()(Ethereum Signed Message:
32,hash)
TMP_116(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_115,v,r,s)
TMP_117(bool) = TMP_116 == user
TMP_118(bool) = REF_82 || TMP_117
TMP_119(bool) = block.number <= expires
TMP_120(bool) = TMP_118 && TMP_119
REF_83(mapping(bytes32 => uint256)) -> orderFills[user]
REF_84(uint256) -> REF_83[hash]
TMP_121(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_84,amount)
TMP_122(bool) = TMP_121 <= amountGet
TMP_123(bool) = TMP_120 && TMP_122
TMP_124 = UnaryType.BANG TMP_123 
CONDITION TMP_124"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tradeBalances(tokenGet,amountGet,tokenGive,amountGive,user,amount)

IRs:
INTERNAL_CALL, BitDex.tradeBalances(address,uint256,address,uint256,address,uint256)(tokenGet,amountGet,tokenGive,amountGive,user,amount)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
orderFills[user][hash] = safeAdd(orderFills[user][hash],amount)

IRs:
REF_85(mapping(bytes32 => uint256)) -> orderFills[user]
REF_86(uint256) -> REF_85[hash]
REF_87(mapping(bytes32 => uint256)) -> orderFills[user]
REF_88(uint256) -> REF_87[hash]
TMP_126(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_88,amount)
REF_86(uint256) (->orderFills) := TMP_126(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Trade(tokenGet,amount,tokenGive,amountGive * amount / amountGet,user,msg.sender)

IRs:
TMP_127(uint256) = amountGive * amount
TMP_128(uint256) = TMP_127 / amountGet
Emit Trade(tokenGet,amount,tokenGive,TMP_128,user,msg.sender)"];
}
// Function: 3574.sol-BitDex-tradeBalances(address,uint256,address,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
feeMakeXfer = safeMul(amount,feeMake) / (1000000000000000000)

IRs:
TMP_130(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,feeMake)
TMP_131(uint256) = TMP_130 / 1000000000000000000
feeMakeXfer(uint256) := TMP_131(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
feeTakeXfer = safeMul(amount,feeTake) / (1000000000000000000)

IRs:
TMP_132(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,feeTake)
TMP_133(uint256) = TMP_132 / 1000000000000000000
feeTakeXfer(uint256) := TMP_133(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
feeRebateXfer = 0

IRs:
feeRebateXfer(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
accountLevelsAddr != 0x0

IRs:
TMP_134(bool) = accountLevelsAddr != 0
CONDITION TMP_134"];
4->5[label="True"];
4->12[label="False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user)

IRs:
TMP_135 = CONVERT accountLevelsAddr to AccountLevels
TMP_136(uint256) = HIGH_LEVEL_CALL, dest:TMP_135(AccountLevels), function:accountLevel, arguments:['user']  
accountLevel(uint256) := TMP_136(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
accountLevel == 1

IRs:
TMP_137(bool) = accountLevel == 1
CONDITION TMP_137"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
feeRebateXfer = safeMul(amount,feeRebate) / (1000000000000000000)

IRs:
TMP_138(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,feeRebate)
TMP_139(uint256) = TMP_138 / 1000000000000000000
feeRebateXfer(uint256) := TMP_139(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
accountLevel == 2

IRs:
TMP_140(bool) = accountLevel == 2
CONDITION TMP_140"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
feeRebateXfer = feeTakeXfer

IRs:
feeRebateXfer(uint256) := feeTakeXfer(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender],safeAdd(amount,feeTakeXfer))

IRs:
REF_90(mapping(address => uint256)) -> tokens[tokenGet]
REF_91(uint256) -> REF_90[msg.sender]
REF_92(mapping(address => uint256)) -> tokens[tokenGet]
REF_93(uint256) -> REF_92[msg.sender]
TMP_141(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(amount,feeTakeXfer)
TMP_142(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_93,TMP_141)
REF_91(uint256) (->tokens) := TMP_142(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user],safeSub(safeAdd(amount,feeRebateXfer),feeMakeXfer))

IRs:
REF_94(mapping(address => uint256)) -> tokens[tokenGet]
REF_95(uint256) -> REF_94[user]
REF_96(mapping(address => uint256)) -> tokens[tokenGet]
REF_97(uint256) -> REF_96[user]
TMP_143(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(amount,feeRebateXfer)
TMP_144(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_143,feeMakeXfer)
TMP_145(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_97,TMP_144)
REF_95(uint256) (->tokens) := TMP_145(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount],safeSub(safeAdd(feeMakeXfer,feeTakeXfer),feeRebateXfer))

IRs:
REF_98(mapping(address => uint256)) -> tokens[tokenGet]
REF_99(uint256) -> REF_98[feeAccount]
REF_100(mapping(address => uint256)) -> tokens[tokenGet]
REF_101(uint256) -> REF_100[feeAccount]
TMP_146(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(feeMakeXfer,feeTakeXfer)
TMP_147(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_146,feeRebateXfer)
TMP_148(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_101,TMP_147)
REF_99(uint256) (->tokens) := TMP_148(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
tokens[tokenGive][user] = safeSub(tokens[tokenGive][user],safeMul(amountGive,amount) / amountGet)

IRs:
REF_102(mapping(address => uint256)) -> tokens[tokenGive]
REF_103(uint256) -> REF_102[user]
REF_104(mapping(address => uint256)) -> tokens[tokenGive]
REF_105(uint256) -> REF_104[user]
TMP_149(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amountGive,amount)
TMP_150(uint256) = TMP_149 / amountGet
TMP_151(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_105,TMP_150)
REF_103(uint256) (->tokens) := TMP_151(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender],safeMul(amountGive,amount) / amountGet)

IRs:
REF_106(mapping(address => uint256)) -> tokens[tokenGive]
REF_107(uint256) -> REF_106[msg.sender]
REF_108(mapping(address => uint256)) -> tokens[tokenGive]
REF_109(uint256) -> REF_108[msg.sender]
TMP_152(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amountGive,amount)
TMP_153(uint256) = TMP_152 / amountGet
TMP_154(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_109,TMP_153)
REF_107(uint256) (->tokens) := TMP_154(uint256)"];
}
// Function: 3574.sol-BitDex-withdraw(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_51(mapping(address => uint256)) -> tokens[0]
REF_52(uint256) -> REF_51[msg.sender]
TMP_93(bool) = REF_52 < amount
CONDITION TMP_93"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_53(mapping(address => uint256)) -> tokens[0]
REF_54(uint256) -> REF_53[msg.sender]
REF_55(mapping(address => uint256)) -> tokens[0]
REF_56(uint256) -> REF_55[msg.sender]
TMP_94(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount)
REF_54(uint256) (->tokens) := TMP_94(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! msg.sender.call.value(amount)()

IRs:
TMP_96(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
TMP_97 = UnaryType.BANG TMP_96 
CONDITION TMP_97"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_59(mapping(address => uint256)) -> tokens[0]
REF_60(uint256) -> REF_59[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_60)"];
}
// Function: 3574.sol-BitDex-withdrawToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
token == 0

IRs:
TMP_105(bool) = token == 0
CONDITION TMP_105"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
tokens[token][msg.sender] < amount

IRs:
REF_68(mapping(address => uint256)) -> tokens[token]
REF_69(uint256) -> REF_68[msg.sender]
TMP_106(bool) = REF_69 < amount
CONDITION TMP_106"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount)

IRs:
REF_70(mapping(address => uint256)) -> tokens[token]
REF_71(uint256) -> REF_70[msg.sender]
REF_72(mapping(address => uint256)) -> tokens[token]
REF_73(uint256) -> REF_72[msg.sender]
TMP_107(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_73,amount)
REF_71(uint256) (->tokens) := TMP_107(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
! Token(token).transfer(msg.sender,amount)

IRs:
TMP_108 = CONVERT token to Token
TMP_109(bool) = HIGH_LEVEL_CALL, dest:TMP_108(Token), function:transfer, arguments:['msg.sender', 'amount']  
TMP_110 = UnaryType.BANG TMP_109 
CONDITION TMP_110"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: THROW 9
"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Withdraw(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_75(mapping(address => uint256)) -> tokens[token]
REF_76(uint256) -> REF_75[msg.sender]
Emit Withdraw(token,msg.sender,amount,REF_76)"];
}
// Function: 3574.sol-ReserveToken-ReserveToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minter = msg.sender

IRs:
minter(address) := msg.sender(address)"];
}
// Function: 3574.sol-ReserveToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3574.sol-ReserveToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-ReserveToken-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_42 = UnaryType.BANG assertion 
CONDITION TMP_42"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 3574.sol-ReserveToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3574.sol-ReserveToken-create(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != minter

IRs:
TMP_56(bool) = msg.sender != minter
CONDITION TMP_56"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[account] = safeAdd(balances[account],amount)

IRs:
REF_38(uint256) -> balances[account]
REF_39(uint256) -> balances[account]
TMP_57(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_39,amount)
REF_38(uint256) (->balances) := TMP_57(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = safeAdd(totalSupply,amount)

IRs:
TMP_58(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,amount)
totalSupply(uint256) := TMP_58(uint256)"];
}
// Function: 3574.sol-ReserveToken-destroy(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != minter

IRs:
TMP_59(bool) = msg.sender != minter
CONDITION TMP_59"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
balances[account] < amount

IRs:
REF_40(uint256) -> balances[account]
TMP_60(bool) = REF_40 < amount
CONDITION TMP_60"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[account] = safeSub(balances[account],amount)

IRs:
REF_41(uint256) -> balances[account]
REF_42(uint256) -> balances[account]
TMP_61(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_42,amount)
REF_41(uint256) (->balances) := TMP_61(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
totalSupply = safeSub(totalSupply,amount)

IRs:
TMP_62(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,amount)
totalSupply(uint256) := TMP_62(uint256)"];
}
// Function: 3574.sol-ReserveToken-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_37(uint256) = a + b
c(uint256) := TMP_37(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_38(bool) = c >= a
TMP_39(bool) = c >= b
TMP_40(bool) = TMP_38 && TMP_39
INTERNAL_CALL, SafeMath.assert(bool)(TMP_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3574.sol-ReserveToken-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_28(uint256) = a * b
c(uint256) := TMP_28(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_29(bool) = a == 0
TMP_30(uint256) = c / a
TMP_31(bool) = TMP_30 == b
TMP_32(bool) = TMP_29 || TMP_31
INTERNAL_CALL, SafeMath.assert(bool)(TMP_32)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3574.sol-ReserveToken-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_34(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_34)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_36(uint256) = a - b
RETURN TMP_36"];
}
// Function: 3574.sol-ReserveToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3574.sol-ReserveToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-ReserveToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-SafeMath-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_14 = UnaryType.BANG assertion 
CONDITION TMP_14"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 3574.sol-SafeMath-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_10(bool) = c >= a
TMP_11(bool) = c >= b
TMP_12(bool) = TMP_10 && TMP_11
INTERNAL_CALL, SafeMath.assert(bool)(TMP_12)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3574.sol-SafeMath-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
INTERNAL_CALL, SafeMath.assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3574.sol-SafeMath-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_6(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 3574.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_17(mapping(address => uint256)) -> allowed[_owner]
REF_18(uint256) -> REF_17[_spender]
RETURN REF_18"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3574.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_15(mapping(address => uint256)) -> allowed[msg.sender]
REF_16(uint256) -> REF_15[_spender]
REF_16(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-StandardToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_14(uint256) -> balances[_owner]
RETURN REF_14"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 3574.sol-StandardToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3574.sol-StandardToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_15(bool) = REF_0 >= _value
REF_1(uint256) -> balances[_to]
TMP_16(uint256) = REF_1 + _value
REF_2(uint256) -> balances[_to]
TMP_17(bool) = TMP_16 > REF_2
TMP_18(bool) = TMP_15 && TMP_17
CONDITION TMP_18"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]

IRs:
REF_5(uint256) -> balances[_from]
TMP_20(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_21(bool) = REF_7 >= _value
TMP_22(bool) = TMP_20 && TMP_21
REF_8(uint256) -> balances[_to]
TMP_23(uint256) = REF_8 + _value
REF_9(uint256) -> balances[_to]
TMP_24(bool) = TMP_23 > REF_9
TMP_25(bool) = TMP_22 && TMP_24
CONDITION TMP_25"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_11(uint256) -> balances[_from]
REF_11(-> balances) = REF_11 - _value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_12(mapping(address => uint256)) -> allowed[_from]
REF_13(uint256) -> REF_12[msg.sender]
REF_13(-> allowed) = REF_13 - _value"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 3574.sol-Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3574.sol-Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3574.sol-Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 3574.sol-Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
}
