digraph G {
// Function: 3945.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 3945.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 3945.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = _to != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_22(bool) = _value <= REF_0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_24(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_25(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3945.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 3945.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 3945.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 3945.sol-ERC20-totalSupply()
digraph{
}
// Function: 3945.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 3945.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 3945.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 3945.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 3945.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 3945.sol-KanadeCoin-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 3945.sol-KanadeCoin-airDrop(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
distribute(addrAirDrop,_recipients,_values)

IRs:
TMP_165(bool) = INTERNAL_CALL, KanadeCoin.distribute(address,address[],uint256[])(addrAirDrop,_recipients,_values)
RETURN TMP_165"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 3945.sol-KanadeCoin-allowance(address,address)
digraph{
}
// Function: 3945.sol-KanadeCoin-approve(address,uint256)
digraph{
}
// Function: 3945.sol-KanadeCoin-balanceOf(address)
digraph{
}
// Function: 3945.sol-KanadeCoin-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 3945.sol-KanadeCoin-createQuestion(string,address,uint128,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_idByte = keccak256()(_id_max32)

IRs:
TMP_108(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
_idByte(bytes32) := TMP_108(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(questions[_idByte].isStarted == 0)

IRs:
REF_110(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_111(uint8) -> REF_110.isStarted
TMP_109(bool) = REF_111 == 0
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transfer(addrBounty,5000 * atto)

IRs:
TMP_111(uint256) = 5000 * atto
TMP_112(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(addrBounty,TMP_111)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
questions[_idByte].isStarted = 1

IRs:
REF_112(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_113(uint8) -> REF_112.isStarted
REF_113(uint8) (->questions) := 1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
questions[_idByte].recipient = _recipient

IRs:
REF_114(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_115(address) -> REF_114.recipient
REF_115(address) (->questions) := _recipient(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
questions[_idByte].finish = _finish

IRs:
REF_116(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_117(uint128) -> REF_116.finish
REF_117(uint128) (->questions) := _finish(uint128)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
questions[_idByte].under = _under

IRs:
REF_118(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_119(uint256) -> REF_118.under
REF_119(uint256) (->questions) := _under(uint256)"];
}
// Function: 3945.sol-KanadeCoin-createRandomBox(string,address,uint64,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_volume > 0)

IRs:
TMP_133(bool) = _volume > 0
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_idByte = keccak256()(_id_max32)

IRs:
TMP_135(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
_idByte(bytes32) := TMP_135(bytes32)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(randomBoxes[_idByte].isStarted == 0)

IRs:
REF_170(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_171(uint8) -> REF_170.isStarted
TMP_136(bool) = REF_171 == 0
TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
transfer(addrBounty,5000 * atto)

IRs:
TMP_138(uint256) = 5000 * atto
TMP_139(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(addrBounty,TMP_138)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
randomBoxes[_idByte].isStarted = 1

IRs:
REF_172(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_173(uint8) -> REF_172.isStarted
REF_173(uint8) (->randomBoxes) := 1(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
randomBoxes[_idByte].recipient = _recipient

IRs:
REF_174(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_175(address) -> REF_174.recipient
REF_175(address) (->randomBoxes) := _recipient(address)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
randomBoxes[_idByte].volume = _volume

IRs:
REF_176(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_177(uint64) -> REF_176.volume
REF_177(uint64) (->randomBoxes) := _volume(uint64)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
randomBoxes[_idByte].amount = _amount

IRs:
REF_178(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_179(uint256) -> REF_178.amount
REF_179(uint256) (->randomBoxes) := _amount(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
randomBoxes[_idByte].finish = _finish

IRs:
REF_180(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_181(uint128) -> REF_180.finish
REF_181(uint128) (->randomBoxes) := _finish(uint128)"];
}
// Function: 3945.sol-KanadeCoin-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
oldValue(uint256) := REF_76(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_71(bool) = _subtractedValue > oldValue
CONDITION TMP_71"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
REF_78(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_80(uint256) (->allowed) := TMP_72(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
Emit Approval(msg.sender,_spender,REF_83)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3945.sol-KanadeCoin-distribute(address,address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_recipients.length > 0 && _recipients.length == _values.length)

IRs:
REF_221 -> LENGTH _recipients
TMP_168(bool) = REF_221 > 0
REF_222 -> LENGTH _recipients
REF_223 -> LENGTH _values
TMP_169(bool) = REF_222 == REF_223
TMP_170(bool) = TMP_168 && TMP_169
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
total = 0

IRs:
total(uint256) := 0(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->9;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < _values.length

IRs:
REF_224 -> LENGTH _values
TMP_172(bool) = i < REF_224
CONDITION TMP_172"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
total = total.add(_values[i])

IRs:
REF_226(uint256) -> _values[i]
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['total', 'REF_226'] 
total(uint256) := TMP_173(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_174(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(total <= balances[_from])

IRs:
REF_227(uint256) -> balances[_from]
TMP_175(bool) = total <= REF_227
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)"];
9->12;
10[label="Node Type: BEGIN_LOOP 10
"];
10->13;
11[label="Node Type: END_LOOP 11
"];
11->17;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
12->10;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
j < _recipients.length

IRs:
REF_228 -> LENGTH _recipients
TMP_177(bool) = j < REF_228
CONDITION TMP_177"];
13->14[label="True"];
13->11[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
balances[_recipients[j]] = balances[_recipients[j]].add(_values[j])

IRs:
REF_229(address) -> _recipients[j]
REF_230(uint256) -> balances[REF_229]
REF_231(address) -> _recipients[j]
REF_232(uint256) -> balances[REF_231]
REF_234(uint256) -> _values[j]
TMP_178(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_232', 'REF_234'] 
REF_230(uint256) (->balances) := TMP_178(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_from,_recipients[j],_values[j])

IRs:
REF_235(address) -> _recipients[j]
REF_236(uint256) -> _values[j]
Emit Transfer(_from,REF_235,REF_236)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
j ++

IRs:
TMP_180(uint256) := j(uint256)
j(uint256) = j + 1"];
16->13;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
balances[_from] = balances[_from].sub(total)

IRs:
REF_237(uint256) -> balances[_from]
REF_238(uint256) -> balances[_from]
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_238', 'total'] 
REF_237(uint256) (->balances) := TMP_181(uint256)"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3945.sol-KanadeCoin-drawRandomItem(string,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_count > 0 && _count <= 1000)

IRs:
TMP_142(bool) = _count > 0
TMP_143(bool) = _count <= 1000
TMP_144(bool) = TMP_142 && TMP_143
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_idByte = keccak256()(_id_max32)

IRs:
TMP_146(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
_idByte(bytes32) := TMP_146(bytes32)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_totalAmount = randomBoxes[_idByte].amount.mul(_count)

IRs:
REF_197(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_198(uint256) -> REF_197.amount
TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_198', '_count'] 
_totalAmount(uint256) := TMP_147(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(randomBoxes[_idByte].isStarted == 1 && randomBoxes[_idByte].finish >= uint128(now))

IRs:
REF_200(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_201(uint8) -> REF_200.isStarted
TMP_148(bool) = REF_201 == 1
REF_202(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_203(uint128) -> REF_202.finish
TMP_149 = CONVERT now to uint128
TMP_150(bool) = REF_203 >= TMP_149
TMP_151(bool) = TMP_148 && TMP_150
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transfer(randomBoxes[_idByte].recipient,_totalAmount)

IRs:
REF_204(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_205(address) -> REF_204.recipient
TMP_153(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(REF_205,_totalAmount)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i < _count

IRs:
TMP_154(bool) = i < _count
CONDITION TMP_154"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
randomVal = uint256(keccak256()(blockhash(uint256)(block.number - 1),randomItems[msg.sender].values[_idByte].length)) % randomBoxes[_idByte].volume

IRs:
TMP_155(uint256) = block.number - 1
TMP_156(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_155)
REF_206(KanadeCoin.RandomItemStruct) -> randomItems[msg.sender]
REF_207(mapping(bytes32 => uint256[])) -> REF_206.values
REF_208(uint256[]) -> REF_207[_idByte]
REF_209 -> LENGTH REF_208
TMP_157(bytes32) = SOLIDITY_CALL keccak256()(TMP_156,REF_209)
TMP_158 = CONVERT TMP_157 to uint256
REF_210(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_211(uint64) -> REF_210.volume
TMP_159(uint256) = TMP_158 % REF_211
randomVal(uint256) := TMP_159(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
randomItems[msg.sender].values[_idByte].push(randomVal)

IRs:
REF_212(KanadeCoin.RandomItemStruct) -> randomItems[msg.sender]
REF_213(mapping(bytes32 => uint256[])) -> REF_212.values
REF_214(uint256[]) -> REF_213[_idByte]
REF_216 -> LENGTH REF_214
TMP_161(uint256) := REF_216(uint256)
TMP_162(uint256) = TMP_161 + 1
REF_216(uint256) (->randomItems) := TMP_162(uint256)
REF_217(uint256) -> REF_214[TMP_161]
REF_217(uint256) (->randomItems) := randomVal(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_163(uint256) := i(uint256)
i(uint256) = i + 1"];
12->9;
}
// Function: 3945.sol-KanadeCoin-getQuestion(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_idByte = keccak256()(_id_max32)

IRs:
TMP_113(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
_idByte(bytes32) := TMP_113(bytes32)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
values[0] = questions[_idByte].isStarted

IRs:
REF_120(uint256) -> values[0]
REF_121(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_122(uint8) -> REF_121.isStarted
REF_120(uint256) (->values) := REF_122(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
values[1] = uint256(questions[_idByte].recipient)

IRs:
REF_123(uint256) -> values[1]
REF_124(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_125(address) -> REF_124.recipient
TMP_114 = CONVERT REF_125 to uint256
REF_123(uint256) (->values) := TMP_114(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
values[2] = questions[_idByte].finish

IRs:
REF_126(uint256) -> values[2]
REF_127(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_128(uint128) -> REF_127.finish
REF_126(uint256) (->values) := REF_128(uint128)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
values[3] = questions[_idByte].under

IRs:
REF_129(uint256) -> values[3]
REF_130(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_131(uint256) -> REF_130.under
REF_129(uint256) (->values) := REF_131(uint256)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
values

IRs:
RETURN values"];
}
// Function: 3945.sol-KanadeCoin-getQuestionVote(string,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_idByte = keccak256()(_id_max32)

IRs:
TMP_131(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
_idByte(bytes32) := TMP_131(bytes32)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
values[0] = questions[_idByte].votes[_position].number

IRs:
REF_148(uint256) -> values[0]
REF_149(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_150(KanadeCoin.VoteStruct[]) -> REF_149.votes
REF_151(KanadeCoin.VoteStruct) -> REF_150[_position]
REF_152(uint128) -> REF_151.number
REF_148(uint256) (->values) := REF_152(uint128)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
values[1] = questions[_idByte].votes[_position].amount

IRs:
REF_153(uint256) -> values[1]
REF_154(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_155(KanadeCoin.VoteStruct[]) -> REF_154.votes
REF_156(KanadeCoin.VoteStruct) -> REF_155[_position]
REF_157(uint256) -> REF_156.amount
REF_153(uint256) (->values) := REF_157(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
values[2] = uint256(questions[_idByte].votes[_position].from)

IRs:
REF_158(uint256) -> values[2]
REF_159(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_160(KanadeCoin.VoteStruct[]) -> REF_159.votes
REF_161(KanadeCoin.VoteStruct) -> REF_160[_position]
REF_162(address) -> REF_161.from
TMP_132 = CONVERT REF_162 to uint256
REF_158(uint256) (->values) := TMP_132(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
values[3] = questions[_idByte].votes[_position].time

IRs:
REF_163(uint256) -> values[3]
REF_164(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_165(KanadeCoin.VoteStruct[]) -> REF_164.votes
REF_166(KanadeCoin.VoteStruct) -> REF_165[_position]
REF_167(uint128) -> REF_166.time
REF_163(uint256) (->values) := REF_167(uint128)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
values

IRs:
RETURN values"];
}
// Function: 3945.sol-KanadeCoin-getQuestionVotesAllCount(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
questions[keccak256()(_id_max32)].votes.length

IRs:
TMP_130(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
REF_145(KanadeCoin.QuestionStruct) -> questions[TMP_130]
REF_146(KanadeCoin.VoteStruct[]) -> REF_145.votes
REF_147 -> LENGTH REF_146
RETURN REF_147"];
}
// Function: 3945.sol-KanadeCoin-getRandomBox(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_idByte = keccak256()(_id_max32)

IRs:
TMP_140(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
_idByte(bytes32) := TMP_140(bytes32)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
values[0] = randomBoxes[_idByte].isStarted

IRs:
REF_182(uint256) -> values[0]
REF_183(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_184(uint8) -> REF_183.isStarted
REF_182(uint256) (->values) := REF_184(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
values[1] = uint256(randomBoxes[_idByte].recipient)

IRs:
REF_185(uint256) -> values[1]
REF_186(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_187(address) -> REF_186.recipient
TMP_141 = CONVERT REF_187 to uint256
REF_185(uint256) (->values) := TMP_141(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
values[2] = randomBoxes[_idByte].volume

IRs:
REF_188(uint256) -> values[2]
REF_189(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_190(uint64) -> REF_189.volume
REF_188(uint256) (->values) := REF_190(uint64)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
values[3] = randomBoxes[_idByte].amount

IRs:
REF_191(uint256) -> values[3]
REF_192(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_193(uint256) -> REF_192.amount
REF_191(uint256) (->values) := REF_193(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
values[4] = randomBoxes[_idByte].finish

IRs:
REF_194(uint256) -> values[4]
REF_195(KanadeCoin.RandomBoxStruct) -> randomBoxes[_idByte]
REF_196(uint128) -> REF_195.finish
REF_194(uint256) (->values) := REF_196(uint128)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
values

IRs:
RETURN values"];
}
// Function: 3945.sol-KanadeCoin-getRandomItems(address,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
randomItems[_addrss].values[keccak256()(_id_max32)]

IRs:
REF_218(KanadeCoin.RandomItemStruct) -> randomItems[_addrss]
REF_219(mapping(bytes32 => uint256[])) -> REF_218.values
TMP_164(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
REF_220(uint256[]) -> REF_219[TMP_164]
RETURN REF_220"];
}
// Function: 3945.sol-KanadeCoin-getSaveData(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
saveData[_address]

IRs:
REF_169(string) -> saveData[_address]
RETURN REF_169"];
}
// Function: 3945.sol-KanadeCoin-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] 
REF_69(uint256) (->allowed) := TMP_69(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_73(mapping(address => uint256)) -> allowed[msg.sender]
REF_74(uint256) -> REF_73[_spender]
Emit Approval(msg.sender,_spender,REF_74)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3945.sol-KanadeCoin-initializeContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: IF 1

EXPRESSION:
totalSupply_ != 0

IRs:
TMP_82(bool) = totalSupply_ != 0
CONDITION TMP_82"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
contractStartTime = now

IRs:
contractStartTime(uint256) := now(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[addrDevTeam] = 10000000000 * 0.01 * atto

IRs:
REF_92(uint256) -> balances[addrDevTeam]
TMP_83(uint256) = 10000000000 * 0
TMP_84(uint256) = TMP_83 * atto
REF_92(uint256) (->balances) := TMP_84(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[addrLockUp] = 10000000000 * 0.09 * atto

IRs:
REF_93(uint256) -> balances[addrLockUp]
TMP_85(uint256) = 10000000000 * 0
TMP_86(uint256) = TMP_85 * atto
REF_93(uint256) (->balances) := TMP_86(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[addrBounty] = 10000000000 * 0.25 * atto

IRs:
REF_94(uint256) -> balances[addrBounty]
TMP_87(uint256) = 10000000000 * 0
TMP_88(uint256) = TMP_87 * atto
REF_94(uint256) (->balances) := TMP_88(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
balances[addrDistribution] = 10000000000 * 0.10 * atto

IRs:
REF_95(uint256) -> balances[addrDistribution]
TMP_89(uint256) = 10000000000 * 0
TMP_90(uint256) = TMP_89 * atto
REF_95(uint256) (->balances) := TMP_90(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[addrAirDrop] = 10000000000 * 0.55 * atto

IRs:
REF_96(uint256) -> balances[addrAirDrop]
TMP_91(uint256) = 10000000000 * 0
TMP_92(uint256) = TMP_91 * atto
REF_96(uint256) (->balances) := TMP_92(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Transfer(0x0,addrDevTeam,balances[addrDevTeam])

IRs:
REF_97(uint256) -> balances[addrDevTeam]
Emit Transfer(0,addrDevTeam,REF_97)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Transfer(0x0,addrLockUp,balances[addrLockUp])

IRs:
REF_98(uint256) -> balances[addrLockUp]
Emit Transfer(0,addrLockUp,REF_98)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(0x0,addrBounty,balances[addrBounty])

IRs:
REF_99(uint256) -> balances[addrBounty]
Emit Transfer(0,addrBounty,REF_99)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
Transfer(0x0,addrDistribution,balances[addrDistribution])

IRs:
REF_100(uint256) -> balances[addrDistribution]
Emit Transfer(0,addrDistribution,REF_100)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(0x0,addrAirDrop,balances[addrAirDrop])

IRs:
REF_101(uint256) -> balances[addrAirDrop]
Emit Transfer(0,addrAirDrop,REF_101)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
totalSupply_ = 10000000000 * atto

IRs:
TMP_98(uint256) = 10000000000 * atto
totalSupply_(uint256) := TMP_98(uint256)"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
16->1;
}
// Function: 3945.sol-KanadeCoin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_186(bool) = msg.sender == owner
TMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3945.sol-KanadeCoin-putSaveData(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
saveData[msg.sender] = _text

IRs:
REF_168(string) -> saveData[msg.sender]
REF_168(string) (->saveData) := _text(string)"];
}
// Function: 3945.sol-KanadeCoin-rain(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
distribute(msg.sender,_recipients,_values)

IRs:
TMP_167(bool) = INTERNAL_CALL, KanadeCoin.distribute(address,address[],uint256[])(msg.sender,_recipients,_values)
RETURN TMP_167"];
}
// Function: 3945.sol-KanadeCoin-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
addrDevTeam = 0x4d85FCF252c02FA849258f16c5464aF529ebFA5F

IRs:
addrDevTeam(address) := 442580323219222397950461710678479529247259753055(address)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
addrLockUp = 0x0101010101010101010101010101010101010101

IRs:
addrLockUp(address) := 5731378969925109483151705226338364782964441345(address)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
addrBounty = 0x3CCDb82F43EEF681A39AE854Be37ad1C40446F0d

IRs:
addrBounty(address) := 347127143759310880481243659930412975271757246221(address)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
addrDistribution = 0x9D6FB734a716306a9575E3ce971AB8839eDcEdF3

IRs:
addrDistribution(address) := 898802893201484584314321191158983483446058085875(address)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
addrAirDrop = 0xD6A4ce07f18619Ec73f91CcDbefcCE53f048AE05

IRs:
addrAirDrop(address) := 1225399295002779431995669868022731683024343707141(address)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
atto = 100000000

IRs:
atto(uint256) := 100000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
decimals = 8

IRs:
decimals(uint256) := 8(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
name = KanadeCoin

IRs:
name(string) := KanadeCoin(string)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
symbol = KNDC

IRs:
symbol(string) := KNDC(string)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
lockupSeconds = 60 * 60 * 24 * 365 * 3

IRs:
TMP_182(uint256) = 60 * 60
TMP_183(uint256) = TMP_182 * 24
TMP_184(uint256) = TMP_183 * 365
TMP_185(uint256) = TMP_184 * 3
lockupSeconds(uint64) := TMP_185(uint256)"];
}
// Function: 3945.sol-KanadeCoin-totalSupply()
digraph{
}
// Function: 3945.sol-KanadeCoin-transfer(address,uint256)
digraph{
}
// Function: 3945.sol-KanadeCoin-transferFrom(address,address,uint256)
digraph{
}
// Function: 3945.sol-KanadeCoin-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_52 = CONVERT 0 to address
TMP_53(bool) = newOwner != TMP_52
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 3945.sol-KanadeCoin-unLockup()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(uint256(now).sub(lockupSeconds) > contractStartTime)

IRs:
TMP_100 = CONVERT now to uint256
TMP_101(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_100', 'lockupSeconds'] 
TMP_102(bool) = TMP_101 > contractStartTime
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_amount = balances[addrLockUp]

IRs:
REF_103(uint256) -> balances[addrLockUp]
_amount(uint256) := REF_103(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[addrLockUp] = balances[addrLockUp].sub(_amount)

IRs:
REF_104(uint256) -> balances[addrLockUp]
REF_105(uint256) -> balances[addrLockUp]
TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_105', '_amount'] 
REF_104(uint256) (->balances) := TMP_104(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[addrDevTeam] = balances[addrDevTeam].add(_amount)

IRs:
REF_107(uint256) -> balances[addrDevTeam]
REF_108(uint256) -> balances[addrDevTeam]
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_108', '_amount'] 
REF_107(uint256) (->balances) := TMP_105(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(addrLockUp,addrDevTeam,_amount)

IRs:
Emit Transfer(addrLockUp,addrDevTeam,_amount)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 3945.sol-KanadeCoin-vote(string,uint128,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_idByte = keccak256()(_id_max32)

IRs:
TMP_115(bytes32) = SOLIDITY_CALL keccak256()(_id_max32)
_idByte(bytes32) := TMP_115(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(questions[_idByte].isStarted == 1 && questions[_idByte].under <= _amount && questions[_idByte].finish >= uint128(now))

IRs:
REF_132(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_133(uint8) -> REF_132.isStarted
TMP_116(bool) = REF_133 == 1
REF_134(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_135(uint256) -> REF_134.under
TMP_117(bool) = REF_135 <= _amount
TMP_118(bool) = TMP_116 && TMP_117
REF_136(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_137(uint128) -> REF_136.finish
TMP_119 = CONVERT now to uint128
TMP_120(bool) = REF_137 >= TMP_119
TMP_121(bool) = TMP_118 && TMP_120
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_amount > 0

IRs:
TMP_123(bool) = _amount > 0
CONDITION TMP_123"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
transfer(questions[_idByte].recipient,_amount)

IRs:
REF_138(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_139(address) -> REF_138.recipient
TMP_124(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(REF_139,_amount)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
questions[_idByte].votes.push(VoteStruct(_number,_amount,msg.sender,uint128(now)))

IRs:
REF_140(KanadeCoin.QuestionStruct) -> questions[_idByte]
REF_141(KanadeCoin.VoteStruct[]) -> REF_140.votes
TMP_125 = CONVERT now to uint128
TMP_126(KanadeCoin.VoteStruct) = new VoteStruct(_number,_amount,msg.sender,TMP_125)
REF_143 -> LENGTH REF_141
TMP_128(uint256) := REF_143(uint256)
TMP_129(uint256) = TMP_128 + 1
REF_143(uint256) (->questions) := TMP_129(uint256)
REF_144(KanadeCoin.VoteStruct) -> REF_141[TMP_128]
REF_144(KanadeCoin.VoteStruct) (->questions) := TMP_126(KanadeCoin.VoteStruct)"];
}
// Function: 3945.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 3945.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_17(bool) = msg.sender == owner
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3945.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = newOwner != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 3945.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3945.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_5(uint256) = a / b
c(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3945.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3945.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 3945.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 3945.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3945.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 3945.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_49(bool) = _subtractedValue > oldValue
CONDITION TMP_49"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_50(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_50(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3945.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_47(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 3945.sol-StandardToken-totalSupply()
digraph{
}
// Function: 3945.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 3945.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_35 = CONVERT 0 to address
TMP_36(bool) = _to != TMP_35
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_38(bool) = _value <= REF_16
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_40(bool) = _value <= REF_18
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_42(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_43(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_44(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
}
