digraph G {
// Function: 415.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)
digraph{
}
// Function: 415.sol-Arbitrable-constructor(Arbitrator,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
arbitrator = _arbitrator

IRs:
arbitrator(Arbitrator) := _arbitrator(Arbitrator)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
arbitratorExtraData = _arbitratorExtraData

IRs:
arbitratorExtraData(bytes) := _arbitratorExtraData(bytes)"];
}
// Function: 415.sol-Arbitrable-executeRuling(uint256,uint256)
digraph{
}
// Function: 415.sol-Arbitrable-onlyArbitrator()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(arbitrator))

IRs:
TMP_245 = CONVERT arbitrator to address
TMP_246(bool) = msg.sender == TMP_245
TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Arbitrable-rule(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Ruling(Arbitrator(msg.sender),_disputeID,_ruling)

IRs:
TMP_241 = CONVERT msg.sender to Arbitrator
Emit Ruling(TMP_241,_disputeID,_ruling)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
executeRuling(_disputeID,_ruling)

IRs:
INTERNAL_CALL, Arbitrable.executeRuling(uint256,uint256)(_disputeID,_ruling)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyArbitrator()

IRs:
MODIFIER_CALL, Arbitrable.onlyArbitrator()()"];
3->1;
}
// Function: 415.sol-Arbitrator-appeal(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
AppealDecision(_disputeID,Arbitrable(msg.sender))

IRs:
TMP_249 = CONVERT msg.sender to Arbitrable
Emit AppealDecision(_disputeID,TMP_249)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
requireAppealFee(_disputeID,_extraData)

IRs:
MODIFIER_CALL, Arbitrator.requireAppealFee(uint256,bytes)(_disputeID,_extraData)"];
2->1;
}
// Function: 415.sol-Arbitrator-appealCost(uint256,bytes)
digraph{
}
// Function: 415.sol-Arbitrator-arbitrationCost(bytes)
digraph{
}
// Function: 415.sol-Arbitrator-createDispute(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
requireArbitrationFee(_extraData)

IRs:
MODIFIER_CALL, Arbitrator.requireArbitrationFee(bytes)(_extraData)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
disputeID

IRs:
RETURN disputeID"];
}
// Function: 415.sol-Arbitrator-currentRuling(uint256)
digraph{
}
// Function: 415.sol-Arbitrator-disputeStatus(uint256)
digraph{
}
// Function: 415.sol-Arbitrator-requireAppealFee(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= appealCost(_disputeID,_extraData))

IRs:
TMP_255(uint256) = INTERNAL_CALL, Arbitrator.appealCost(uint256,bytes)(_disputeID,_extraData)
TMP_256(bool) = msg.value >= TMP_255
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Arbitrator-requireArbitrationFee(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= arbitrationCost(_extraData))

IRs:
TMP_252(uint256) = INTERNAL_CALL, Arbitrator.arbitrationCost(bytes)(_extraData)
TMP_253(bool) = msg.value >= TMP_252
TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-BlockHashRNG-contribute(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
reward[_block] += msg.value

IRs:
REF_78(uint256) -> reward[_block]
REF_78(-> reward) = REF_78 + msg.value"];
}
// Function: 415.sol-BlockHashRNG-getRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
RN = randomNumber[_block]

IRs:
REF_79(uint256) -> randomNumber[_block]
RN(uint256) := REF_79(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
RN == 0

IRs:
TMP_208(bool) = RN == 0
CONDITION TMP_208"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
saveRN(_block)

IRs:
INTERNAL_CALL, BlockHashRNG.saveRN(uint256)(_block)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
randomNumber[_block]

IRs:
REF_80(uint256) -> randomNumber[_block]
RETURN REF_80"];
5[label="Node Type: RETURN 5

EXPRESSION:
RN

IRs:
RETURN RN"];
7[label="Node Type: RETURN 7

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 415.sol-BlockHashRNG-getUncorrelatedRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
baseRN = getRN(_block)

IRs:
TMP_204(uint256) = INTERNAL_CALL, BlockHashRNG.getRN(uint256)(_block)
baseRN(uint256) := TMP_204(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
baseRN == 0

IRs:
TMP_205(bool) = baseRN == 0
CONDITION TMP_205"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: RETURN 4

EXPRESSION:
uint256(keccak256()(msg.sender,baseRN))

IRs:
TMP_206(bytes32) = SOLIDITY_CALL keccak256()(msg.sender,baseRN)
TMP_207 = CONVERT TMP_206 to uint256
RETURN TMP_207"];
6[label="Node Type: RETURN 6

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 415.sol-BlockHashRNG-requestRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contribute(_block)

IRs:
INTERNAL_CALL, BlockHashRNG.contribute(uint256)(_block)"];
}
// Function: 415.sol-BlockHashRNG-saveRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
blockhash(uint256)(_block) != 0x0

IRs:
TMP_210(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_211(bool) = TMP_210 != 0
CONDITION TMP_211"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
randomNumber[_block] = uint256(blockhash(uint256)(_block))

IRs:
REF_81(uint256) -> randomNumber[_block]
TMP_212(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_213 = CONVERT TMP_212 to uint256
REF_81(uint256) (->randomNumber) := TMP_213(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
randomNumber[_block] != 0

IRs:
REF_82(uint256) -> randomNumber[_block]
TMP_214(bool) = REF_82 != 0
CONDITION TMP_214"];
4->5[label="True"];
4->8[label="False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
rewardToSend = reward[_block]

IRs:
REF_83(uint256) -> reward[_block]
rewardToSend(uint256) := REF_83(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
reward[_block] = 0

IRs:
REF_84(uint256) -> reward[_block]
REF_84(uint256) (->reward) := 0(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.send(rewardToSend)

IRs:
TMP_215 = SEND dest:msg.sender value:rewardToSend"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 415.sol-BlockHashRNGFallback-contribute(uint256)
digraph{
}
// Function: 415.sol-BlockHashRNGFallback-getRN(uint256)
digraph{
}
// Function: 415.sol-BlockHashRNGFallback-getUncorrelatedRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
baseRN = getRN(_block)

IRs:
TMP_225(uint256) = INTERNAL_CALL, BlockHashRNG.getRN(uint256)(_block)
baseRN(uint256) := TMP_225(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
baseRN == 0

IRs:
TMP_226(bool) = baseRN == 0
CONDITION TMP_226"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: RETURN 4

EXPRESSION:
uint256(keccak256()(msg.sender,baseRN))

IRs:
TMP_227(bytes32) = SOLIDITY_CALL keccak256()(msg.sender,baseRN)
TMP_228 = CONVERT TMP_227 to uint256
RETURN TMP_228"];
6[label="Node Type: RETURN 6

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 415.sol-BlockHashRNGFallback-requestRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contribute(_block)

IRs:
INTERNAL_CALL, BlockHashRNG.contribute(uint256)(_block)"];
}
// Function: 415.sol-BlockHashRNGFallback-saveRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_block < block.number && randomNumber[_block] == 0

IRs:
TMP_229(bool) = _block < block.number
REF_94(uint256) -> randomNumber[_block]
TMP_230(bool) = REF_94 == 0
TMP_231(bool) = TMP_229 && TMP_230
CONDITION TMP_231"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
blockhash(uint256)(_block) != 0x0

IRs:
TMP_232(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_233(bool) = TMP_232 != 0
CONDITION TMP_233"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
randomNumber[_block] = uint256(blockhash(uint256)(_block))

IRs:
REF_95(uint256) -> randomNumber[_block]
TMP_234(uint256) = SOLIDITY_CALL blockhash(uint256)(_block)
TMP_235 = CONVERT TMP_234 to uint256
REF_95(uint256) (->randomNumber) := TMP_235(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
randomNumber[_block] = uint256(blockhash(uint256)(block.number - 1))

IRs:
REF_96(uint256) -> randomNumber[_block]
TMP_236(uint256) = block.number - 1
TMP_237(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_236)
TMP_238 = CONVERT TMP_237 to uint256
REF_96(uint256) (->randomNumber) := TMP_238(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
randomNumber[_block] != 0

IRs:
REF_97(uint256) -> randomNumber[_block]
TMP_239(bool) = REF_97 != 0
CONDITION TMP_239"];
7->8[label="True"];
7->11[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
rewardToSend = reward[_block]

IRs:
REF_98(uint256) -> reward[_block]
rewardToSend(uint256) := REF_98(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
reward[_block] = 0

IRs:
REF_99(uint256) -> reward[_block]
REF_99(uint256) (->reward) := 0(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
msg.sender.send(rewardToSend)

IRs:
TMP_240 = SEND dest:msg.sender value:rewardToSend"];
10->11;
11[label="Node Type: END_IF 11
"];
}
// Function: 415.sol-Controlled-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 415.sol-Controlled-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 415.sol-Controlled-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_58(bool) = msg.sender == controller
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Kleros-activateTokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
juror = jurors[msg.sender]

IRs:
REF_125(Kleros.Juror) -> jurors[msg.sender]
juror(Kleros.Juror) := REF_125(Kleros.Juror)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= juror.balance)

IRs:
REF_126(uint256) -> juror.balance
TMP_289(bool) = _value <= REF_126
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value >= minActivatedToken)

IRs:
TMP_291(bool) = _value >= minActivatedToken
TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(juror.lastSession != session)

IRs:
REF_127(uint256) -> juror.lastSession
TMP_293(bool) = REF_127 != session
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
juror.lastSession = session

IRs:
REF_128(uint256) -> juror.lastSession
REF_128(uint256) (->juror) := session(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
juror.segmentStart = segmentSize

IRs:
REF_129(uint256) -> juror.segmentStart
REF_129(uint256) (->juror) := segmentSize(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
segmentSize += _value

IRs:
segmentSize(uint256) = segmentSize + _value"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
juror.segmentEnd = segmentSize

IRs:
REF_130(uint256) -> juror.segmentEnd
REF_130(uint256) (->juror) := segmentSize(uint256)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyDuring(Period.Activation)

IRs:
REF_131(Kleros.Period) -> Period.Activation
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_131)"];
9->1;
}
// Function: 415.sol-Kleros-amountJurors(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_385(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_385(Kleros.Dispute)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
(dispute.initialNumberJurors + 1) * 2 ** dispute.appeals - 1

IRs:
REF_386(uint16) -> dispute.initialNumberJurors
TMP_403(uint16) = REF_386 + 1
REF_387(uint256) -> dispute.appeals
TMP_404(uint256) = 2 ** REF_387
TMP_405(uint16) = TMP_403 * TMP_404
TMP_406(uint16) = TMP_405 - 1
RETURN TMP_406"];
3[label="Node Type: RETURN 3

EXPRESSION:
nbJurors

IRs:
RETURN nbJurors"];
}
// Function: 415.sol-Kleros-appeal(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.appeal(_disputeID,_extraData)

IRs:
INTERNAL_CALL, Arbitrator.appeal(uint256,bytes)(_disputeID,_extraData)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_412(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_412(Kleros.Dispute)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value >= appealCost(_disputeID,_extraData))

IRs:
TMP_435(uint256) = INTERNAL_CALL, Kleros.appealCost(uint256,bytes)(_disputeID,_extraData)
TMP_436(bool) = msg.value >= TMP_435
TMP_437(None) = SOLIDITY_CALL require(bool)(TMP_436)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(dispute.session + dispute.appeals == session)

IRs:
REF_413(uint256) -> dispute.session
REF_414(uint256) -> dispute.appeals
TMP_438(uint256) = REF_413 + REF_414
TMP_439(bool) = TMP_438 == session
TMP_440(None) = SOLIDITY_CALL require(bool)(TMP_439)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(dispute.arbitrated == msg.sender)

IRs:
REF_415(Arbitrable) -> dispute.arbitrated
TMP_441(bool) = REF_415 == msg.sender
TMP_442(None) = SOLIDITY_CALL require(bool)(TMP_441)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
dispute.appeals ++

IRs:
REF_416(uint256) -> dispute.appeals
TMP_443(uint256) := REF_416(uint256)
REF_416(-> dispute) = REF_416 + 1"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
dispute.votes.length ++

IRs:
REF_417(Kleros.Vote[][]) -> dispute.votes
REF_418 -> LENGTH REF_417
TMP_444(uint256) := REF_418(uint256)
REF_418(-> dispute) = REF_418 + 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
dispute.voteCounter.length ++

IRs:
REF_419(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_420 -> LENGTH REF_419
TMP_445(uint256) := REF_420(uint256)
REF_420(-> dispute) = REF_420 + 1"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyDuring(Period.Appeal)

IRs:
REF_421(Kleros.Period) -> Period.Appeal
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_421)"];
9->1;
}
// Function: 415.sol-Kleros-appealCost(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_433(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_433(Kleros.Dispute)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
dispute.appeals >= maxAppeals

IRs:
REF_434(uint256) -> dispute.appeals
TMP_452(bool) = REF_434 >= maxAppeals
CONDITION TMP_452"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
NON_PAYABLE_AMOUNT

IRs:
RETURN NON_PAYABLE_AMOUNT"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
(2 * amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror

IRs:
TMP_453(uint256) = INTERNAL_CALL, Kleros.amountJurors(uint256)(_disputeID)
TMP_454(uint256) = 2 * TMP_453
TMP_455(uint256) = TMP_454 + 1
REF_435(uint256) -> dispute.arbitrationFeePerJuror
TMP_456(uint256) = TMP_455 * REF_435
RETURN TMP_456"];
6[label="Node Type: RETURN 6

EXPRESSION:
fee

IRs:
RETURN fee"];
}
// Function: 415.sol-Kleros-arbitrationCost(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
extraDataToNbJurors(_extraData) * arbitrationFeePerJuror

IRs:
TMP_450(uint16) = INTERNAL_CALL, Kleros.extraDataToNbJurors(bytes)(_extraData)
TMP_451(uint16) = TMP_450 * arbitrationFeePerJuror
RETURN TMP_451"];
2[label="Node Type: RETURN 2

EXPRESSION:
fee

IRs:
RETURN fee"];
}
// Function: 415.sol-Kleros-constructor(Pinakion,RNG,uint256[5],address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pinakion = _pinakion

IRs:
pinakion(Pinakion) := _pinakion(Pinakion)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
rng = _rng

IRs:
rng(RNG) := _rng(RNG)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
lastPeriodChange = now

IRs:
lastPeriodChange(uint256) := now(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
timePerPeriod = _timePerPeriod

IRs:
timePerPeriod(uint256[5]) := _timePerPeriod(uint256[5])"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
governor = _governor

IRs:
governor(address) := _governor(address)"];
}
// Function: 415.sol-Kleros-createDispute(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nbJurors = extraDataToNbJurors(_extraData)

IRs:
TMP_422(uint16) = INTERNAL_CALL, Kleros.extraDataToNbJurors(bytes)(_extraData)
nbJurors(uint16) := TMP_422(uint16)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= arbitrationCost(_extraData))

IRs:
TMP_423(uint256) = INTERNAL_CALL, Kleros.arbitrationCost(bytes)(_extraData)
TMP_424(bool) = msg.value >= TMP_423
TMP_425(None) = SOLIDITY_CALL require(bool)(TMP_424)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
disputeID = disputes.length ++

IRs:
REF_399 -> LENGTH disputes
TMP_426(uint256) := REF_399(uint256)
REF_399(-> disputes) = REF_399 + 1
disputeID(uint256) := TMP_426(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
dispute = disputes[disputeID]

IRs:
REF_400(Kleros.Dispute) -> disputes[disputeID]
dispute(Kleros.Dispute) := REF_400(Kleros.Dispute)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
dispute.arbitrated = Arbitrable(msg.sender)

IRs:
REF_401(Arbitrable) -> dispute.arbitrated
TMP_427 = CONVERT msg.sender to Arbitrable
REF_401(Arbitrable) (->dispute) := TMP_427(Arbitrable)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
period < Period.Draw

IRs:
REF_402(Kleros.Period) -> Period.Draw
TMP_428(bool) = period < REF_402
CONDITION TMP_428"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
dispute.session = session

IRs:
REF_403(uint256) -> dispute.session
REF_403(uint256) (->dispute) := session(uint256)"];
7->9;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
dispute.session = session + 1

IRs:
REF_404(uint256) -> dispute.session
TMP_429(uint256) = session + 1
REF_404(uint256) (->dispute) := TMP_429(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
dispute.choices = _choices

IRs:
REF_405(uint256) -> dispute.choices
REF_405(uint256) (->dispute) := _choices(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
dispute.initialNumberJurors = nbJurors

IRs:
REF_406(uint16) -> dispute.initialNumberJurors
REF_406(uint16) (->dispute) := nbJurors(uint16)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
dispute.arbitrationFeePerJuror = arbitrationFeePerJuror

IRs:
REF_407(uint256) -> dispute.arbitrationFeePerJuror
REF_407(uint256) (->dispute) := arbitrationFeePerJuror(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
dispute.votes.length ++

IRs:
REF_408(Kleros.Vote[][]) -> dispute.votes
REF_409 -> LENGTH REF_408
TMP_430(uint256) := REF_409(uint256)
REF_409(-> dispute) = REF_409 + 1"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
dispute.voteCounter.length ++

IRs:
REF_410(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_411 -> LENGTH REF_410
TMP_431(uint256) := REF_411(uint256)
REF_411(-> dispute) = REF_411 + 1"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
DisputeCreation(disputeID,Arbitrable(msg.sender))

IRs:
TMP_432 = CONVERT msg.sender to Arbitrable
Emit DisputeCreation(disputeID,TMP_432)"];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
disputeID

IRs:
RETURN disputeID"];
17[label="Node Type: RETURN 17

EXPRESSION:
disputeID

IRs:
RETURN disputeID"];
}
// Function: 415.sol-Kleros-currentRuling(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_473(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_473(Kleros.Dispute)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
dispute.voteCounter[dispute.appeals].winningChoice

IRs:
REF_474(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_475(uint256) -> dispute.appeals
REF_476(Kleros.VoteCounter) -> REF_474[REF_475]
REF_477(uint256) -> REF_476.winningChoice
RETURN REF_477"];
3[label="Node Type: RETURN 3

EXPRESSION:
ruling

IRs:
RETURN ruling"];
}
// Function: 415.sol-Kleros-disputeStatus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_478(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_478(Kleros.Dispute)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
dispute.session + dispute.appeals < session

IRs:
REF_479(uint256) -> dispute.session
REF_480(uint256) -> dispute.appeals
TMP_483(uint256) = REF_479 + REF_480
TMP_484(bool) = TMP_483 < session
CONDITION TMP_484"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
DisputeStatus.Solved

IRs:
REF_481(Arbitrator.DisputeStatus) -> DisputeStatus.Solved
RETURN REF_481"];
4[label="Node Type: IF 4

EXPRESSION:
dispute.session + dispute.appeals == session

IRs:
REF_482(uint256) -> dispute.session
REF_483(uint256) -> dispute.appeals
TMP_485(uint256) = REF_482 + REF_483
TMP_486(bool) = TMP_485 == session
CONDITION TMP_486"];
4->5[label="True"];
4->15[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
dispute.state == DisputeState.Open

IRs:
REF_484(Kleros.DisputeState) -> dispute.state
REF_485(Kleros.DisputeState) -> DisputeState.Open
TMP_487(bool) = REF_484 == REF_485
CONDITION TMP_487"];
5->6[label="True"];
5->13[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
period < Period.Appeal

IRs:
REF_486(Kleros.Period) -> Period.Appeal
TMP_488(bool) = period < REF_486
CONDITION TMP_488"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
DisputeStatus.Waiting

IRs:
REF_487(Arbitrator.DisputeStatus) -> DisputeStatus.Waiting
RETURN REF_487"];
8[label="Node Type: IF 8

EXPRESSION:
period == Period.Appeal

IRs:
REF_488(Kleros.Period) -> Period.Appeal
TMP_489(bool) = period == REF_488
CONDITION TMP_489"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
DisputeStatus.Appealable

IRs:
REF_489(Arbitrator.DisputeStatus) -> DisputeStatus.Appealable
RETURN REF_489"];
10[label="Node Type: RETURN 10

EXPRESSION:
DisputeStatus.Solved

IRs:
REF_490(Arbitrator.DisputeStatus) -> DisputeStatus.Solved
RETURN REF_490"];
13[label="Node Type: RETURN 13

EXPRESSION:
DisputeStatus.Solved

IRs:
REF_491(Arbitrator.DisputeStatus) -> DisputeStatus.Solved
RETURN REF_491"];
15[label="Node Type: RETURN 15

EXPRESSION:
DisputeStatus.Waiting

IRs:
REF_492(Arbitrator.DisputeStatus) -> DisputeStatus.Waiting
RETURN REF_492"];
18[label="Node Type: RETURN 18

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 415.sol-Kleros-executeOrder(bytes32,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_target.call.value(_value)(_data)

IRs:
TMP_491(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:_value "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-executeRuling(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[disputeID]

IRs:
REF_422(Kleros.Dispute) -> disputes[disputeID]
dispute(Kleros.Dispute) := REF_422(Kleros.Dispute)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(dispute.state == DisputeState.Executable)

IRs:
REF_423(Kleros.DisputeState) -> dispute.state
REF_424(Kleros.DisputeState) -> DisputeState.Executable
TMP_447(bool) = REF_423 == REF_424
TMP_448(None) = SOLIDITY_CALL require(bool)(TMP_447)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
dispute.state = DisputeState.Executed

IRs:
REF_425(Kleros.DisputeState) -> dispute.state
REF_426(Kleros.DisputeState) -> DisputeState.Executed
REF_425(Kleros.DisputeState) (->dispute) := REF_426(Kleros.DisputeState)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
dispute.arbitrated.rule(disputeID,dispute.voteCounter[dispute.appeals].winningChoice)

IRs:
REF_427(Arbitrable) -> dispute.arbitrated
REF_429(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_430(uint256) -> dispute.appeals
REF_431(Kleros.VoteCounter) -> REF_429[REF_430]
REF_432(uint256) -> REF_431.winningChoice
HIGH_LEVEL_CALL, dest:REF_427(Arbitrable), function:rule, arguments:['disputeID', 'REF_432']  "];
}
// Function: 415.sol-Kleros-extraDataToNbJurors(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_extraData.length < 2

IRs:
REF_436 -> LENGTH _extraData
TMP_457(bool) = REF_436 < 2
CONDITION TMP_457"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
defaultNumberJuror

IRs:
RETURN defaultNumberJuror"];
3[label="Node Type: RETURN 3

EXPRESSION:
(uint16(_extraData[0]) << 8) + uint16(_extraData[1])

IRs:
REF_437(None) -> _extraData[0]
TMP_458 = CONVERT REF_437 to uint16
TMP_459(uint16) = TMP_458 << 8
REF_438(None) -> _extraData[1]
TMP_460 = CONVERT REF_438 to uint16
TMP_461(uint16) = TMP_459 + TMP_460
RETURN TMP_461"];
5[label="Node Type: RETURN 5

EXPRESSION:
nbJurors

IRs:
RETURN nbJurors"];
}
// Function: 415.sol-Kleros-getLastSessionVote(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].lastSessionVote[_juror]

IRs:
REF_462(Kleros.Dispute) -> disputes[_disputeID]
REF_463(mapping(address => uint256)) -> REF_462.lastSessionVote
REF_464(uint256) -> REF_463[_juror]
RETURN REF_464"];
2[label="Node Type: RETURN 2

EXPRESSION:
lastSessionVote

IRs:
RETURN lastSessionVote"];
}
// Function: 415.sol-Kleros-getStakePerDraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(alpha * minActivatedToken) / ALPHA_DIVISOR

IRs:
TMP_462(uint256) = alpha * minActivatedToken
TMP_463(uint256) = TMP_462 / ALPHA_DIVISOR
RETURN TMP_463"];
2[label="Node Type: RETURN 2

EXPRESSION:
minActivatedTokenInAlpha

IRs:
RETURN minActivatedTokenInAlpha"];
}
// Function: 415.sol-Kleros-getVoteAccount(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].votes[_appeals][_voteID].account

IRs:
REF_439(Kleros.Dispute) -> disputes[_disputeID]
REF_440(Kleros.Vote[][]) -> REF_439.votes
REF_441(Kleros.Vote[]) -> REF_440[_appeals]
REF_442(Kleros.Vote) -> REF_441[_voteID]
REF_443(address) -> REF_442.account
RETURN REF_443"];
2[label="Node Type: RETURN 2

EXPRESSION:
account

IRs:
RETURN account"];
}
// Function: 415.sol-Kleros-getVoteCount(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].voteCounter[_appeals].voteCount[_choice]

IRs:
REF_457(Kleros.Dispute) -> disputes[_disputeID]
REF_458(Kleros.VoteCounter[]) -> REF_457.voteCounter
REF_459(Kleros.VoteCounter) -> REF_458[_appeals]
REF_460(mapping(uint256 => uint256)) -> REF_459.voteCount
REF_461(uint256) -> REF_460[_choice]
RETURN REF_461"];
2[label="Node Type: RETURN 2

EXPRESSION:
voteCount

IRs:
RETURN voteCount"];
}
// Function: 415.sol-Kleros-getVoteRuling(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].votes[_appeals][_voteID].ruling

IRs:
REF_444(Kleros.Dispute) -> disputes[_disputeID]
REF_445(Kleros.Vote[][]) -> REF_444.votes
REF_446(Kleros.Vote[]) -> REF_445[_appeals]
REF_447(Kleros.Vote) -> REF_446[_voteID]
REF_448(uint256) -> REF_447.ruling
RETURN REF_448"];
2[label="Node Type: RETURN 2

EXPRESSION:
ruling

IRs:
RETURN ruling"];
}
// Function: 415.sol-Kleros-getWinningChoice(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].voteCounter[_appeals].winningChoice

IRs:
REF_449(Kleros.Dispute) -> disputes[_disputeID]
REF_450(Kleros.VoteCounter[]) -> REF_449.voteCounter
REF_451(Kleros.VoteCounter) -> REF_450[_appeals]
REF_452(uint256) -> REF_451.winningChoice
RETURN REF_452"];
2[label="Node Type: RETURN 2

EXPRESSION:
winningChoice

IRs:
RETURN winningChoice"];
}
// Function: 415.sol-Kleros-getWinningCount(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
disputes[_disputeID].voteCounter[_appeals].winningCount

IRs:
REF_453(Kleros.Dispute) -> disputes[_disputeID]
REF_454(Kleros.VoteCounter[]) -> REF_453.voteCounter
REF_455(Kleros.VoteCounter) -> REF_454[_appeals]
REF_456(uint256) -> REF_455.winningCount
RETURN REF_456"];
2[label="Node Type: RETURN 2

EXPRESSION:
winningCount

IRs:
RETURN winningCount"];
}
// Function: 415.sol-Kleros-isDrawn(uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_465(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_465(Kleros.Dispute)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
juror = jurors[_juror]

IRs:
REF_466(Kleros.Juror) -> jurors[_juror]
juror(Kleros.Juror) := REF_466(Kleros.Juror)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
juror.lastSession != session || (dispute.session + dispute.appeals != session) || period <= Period.Draw || _draw > amountJurors(_disputeID) || _draw == 0 || segmentSize == 0

IRs:
REF_467(uint256) -> juror.lastSession
TMP_464(bool) = REF_467 != session
REF_468(uint256) -> dispute.session
REF_469(uint256) -> dispute.appeals
TMP_465(uint256) = REF_468 + REF_469
TMP_466(bool) = TMP_465 != session
TMP_467(bool) = TMP_464 || TMP_466
REF_470(Kleros.Period) -> Period.Draw
TMP_468(bool) = period <= REF_470
TMP_469(bool) = TMP_467 || TMP_468
TMP_470(uint256) = INTERNAL_CALL, Kleros.amountJurors(uint256)(_disputeID)
TMP_471(bool) = _draw > TMP_470
TMP_472(bool) = TMP_469 || TMP_471
TMP_473(bool) = _draw == 0
TMP_474(bool) = TMP_472 || TMP_473
TMP_475(bool) = segmentSize == 0
TMP_476(bool) = TMP_474 || TMP_475
CONDITION TMP_476"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
position = uint256(keccak256()(randomNumber,_disputeID,_draw)) % segmentSize

IRs:
TMP_477(bytes32) = SOLIDITY_CALL keccak256()(randomNumber,_disputeID,_draw)
TMP_478 = CONVERT TMP_477 to uint256
TMP_479(uint256) = TMP_478 % segmentSize
position(uint256) := TMP_479(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
(position >= juror.segmentStart) && (position < juror.segmentEnd)

IRs:
REF_471(uint256) -> juror.segmentStart
TMP_480(bool) = position >= REF_471
REF_472(uint256) -> juror.segmentEnd
TMP_481(bool) = position < REF_472
TMP_482(bool) = TMP_480 && TMP_481
RETURN TMP_482"];
8[label="Node Type: RETURN 8

EXPRESSION:
drawn

IRs:
RETURN drawn"];
}
// Function: 415.sol-Kleros-multipleShotTokenRepartition(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->86;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_245(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_245(Kleros.Dispute)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(dispute.state <= DisputeState.Resolving)

IRs:
REF_246(Kleros.DisputeState) -> dispute.state
REF_247(Kleros.DisputeState) -> DisputeState.Resolving
TMP_367(bool) = REF_246 <= REF_247
TMP_368(None) = SOLIDITY_CALL require(bool)(TMP_367)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(dispute.session + dispute.appeals <= session)

IRs:
REF_248(uint256) -> dispute.session
REF_249(uint256) -> dispute.appeals
TMP_369(uint256) = REF_248 + REF_249
TMP_370(bool) = TMP_369 <= session
TMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
dispute.state = DisputeState.Resolving

IRs:
REF_250(Kleros.DisputeState) -> dispute.state
REF_251(Kleros.DisputeState) -> DisputeState.Resolving
REF_250(Kleros.DisputeState) (->dispute) := REF_251(Kleros.DisputeState)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
winningChoice = dispute.voteCounter[dispute.appeals].winningChoice

IRs:
REF_252(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_253(uint256) -> dispute.appeals
REF_254(Kleros.VoteCounter) -> REF_252[REF_253]
REF_255(uint256) -> REF_254.winningChoice
winningChoice(uint256) := REF_255(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
amountShift = getStakePerDraw()

IRs:
TMP_372(uint256) = INTERNAL_CALL, Kleros.getStakePerDraw()()
amountShift(uint256) := TMP_372(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
currentIterations = 0

IRs:
currentIterations(uint256) := 0(uint256)"];
7->10;
8[label="Node Type: BEGIN_LOOP 8
"];
8->11;
9[label="Node Type: END_LOOP 9
"];
9->85;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
i = dispute.currentAppealToRepartition

IRs:
REF_256(uint256) -> dispute.currentAppealToRepartition
i(uint256) := REF_256(uint256)"];
10->8;
11[label="Node Type: IF_LOOP 11

EXPRESSION:
i <= dispute.appeals

IRs:
REF_257(uint256) -> dispute.appeals
TMP_373(bool) = i <= REF_257
CONDITION TMP_373"];
11->12[label="True"];
11->9[label="False"];
12[label="Node Type: IF 12

EXPRESSION:
dispute.appealsRepartitioned.length < i + 1

IRs:
REF_258(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_259 -> LENGTH REF_258
TMP_374(uint256) = i + 1
TMP_375(bool) = REF_259 < TMP_374
CONDITION TMP_375"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
dispute.appealsRepartitioned.length ++

IRs:
REF_260(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_261 -> LENGTH REF_260
TMP_376(uint256) := REF_261(uint256)
REF_261(-> dispute) = REF_261 + 1"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
winningChoice == 0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)

IRs:
TMP_377(bool) = winningChoice == 0
REF_262(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_263(uint256) -> dispute.appeals
REF_264(Kleros.VoteCounter) -> REF_262[REF_263]
REF_265(mapping(uint256 => uint256)) -> REF_264.voteCount
REF_266(uint256) -> REF_265[0]
REF_267(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_268(uint256) -> dispute.appeals
REF_269(Kleros.VoteCounter) -> REF_267[REF_268]
REF_270(uint256) -> REF_269.winningCount
TMP_378(bool) = REF_266 != REF_270
TMP_379(bool) = TMP_377 && TMP_378
CONDITION TMP_379"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake

IRs:
REF_271(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_272(Kleros.AppealsRepartitioned) -> REF_271[i]
REF_273(Kleros.RepartitionStage) -> REF_272.stage
REF_274(Kleros.RepartitionStage) -> RepartitionStage.AtStake
REF_273(Kleros.RepartitionStage) (->dispute) := REF_274(Kleros.RepartitionStage)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent

IRs:
REF_275(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_276(Kleros.AppealsRepartitioned) -> REF_275[i]
REF_277(Kleros.RepartitionStage) -> REF_276.stage
REF_278(Kleros.RepartitionStage) -> RepartitionStage.Incoherent
TMP_380(bool) = REF_277 == REF_278
CONDITION TMP_380"];
18->21[label="True"];
18->39[label="False"];
19[label="Node Type: BEGIN_LOOP 19
"];
19->22;
20[label="Node Type: END_LOOP 20
"];
20->38;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
j = dispute.appealsRepartitioned[i].currentIncoherentVote

IRs:
REF_279(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_280(Kleros.AppealsRepartitioned) -> REF_279[i]
REF_281(uint256) -> REF_280.currentIncoherentVote
j(uint256) := REF_281(uint256)"];
21->19;
22[label="Node Type: IF_LOOP 22

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_282(Kleros.Vote[][]) -> dispute.votes
REF_283(Kleros.Vote[]) -> REF_282[i]
REF_284 -> LENGTH REF_283
TMP_381(bool) = j < REF_284
CONDITION TMP_381"];
22->23[label="True"];
22->20[label="False"];
23[label="Node Type: IF 23

EXPRESSION:
currentIterations >= _maxIterations

IRs:
TMP_382(bool) = currentIterations >= _maxIterations
CONDITION TMP_382"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: RETURN 24
"];
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_285(Kleros.Vote[][]) -> dispute.votes
REF_286(Kleros.Vote[]) -> REF_285[i]
REF_287(Kleros.Vote) -> REF_286[j]
vote(Kleros.Vote) := REF_287(Kleros.Vote)"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
vote.ruling != winningChoice

IRs:
REF_288(uint256) -> vote.ruling
TMP_383(bool) = REF_288 != winningChoice
CONDITION TMP_383"];
27->28[label="True"];
27->33[label="False"];
28[label="Node Type: NEW VARIABLE 28

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_289(address) -> vote.account
REF_290(Kleros.Juror) -> jurors[REF_289]
juror(Kleros.Juror) := REF_290(Kleros.Juror)"];
28->87;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
juror.balance -= penalty

IRs:
REF_291(uint256) -> juror.balance
REF_291(-> juror) = REF_291 - penalty"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(- penalty))

IRs:
REF_292(address) -> vote.account
TMP_384(uint256) = 0 - penalty
TMP_385 = CONVERT TMP_384 to int256
Emit TokenShift(REF_292,_disputeID,TMP_385)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
dispute.appealsRepartitioned[i].totalToRedistribute += penalty

IRs:
REF_293(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_294(Kleros.AppealsRepartitioned) -> REF_293[i]
REF_295(uint256) -> REF_294.totalToRedistribute
REF_295(-> dispute) = REF_295 + penalty"];
32->34;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
++ dispute.appealsRepartitioned[i].nbCoherent

IRs:
REF_296(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_297(Kleros.AppealsRepartitioned) -> REF_296[i]
REF_298(uint256) -> REF_297.nbCoherent
REF_298(-> dispute) = REF_298 + 1"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
++ dispute.appealsRepartitioned[i].currentIncoherentVote

IRs:
REF_299(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_300(Kleros.AppealsRepartitioned) -> REF_299[i]
REF_301(uint256) -> REF_300.currentIncoherentVote
REF_301(-> dispute) = REF_301 + 1"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
++ currentIterations

IRs:
currentIterations(uint256) = currentIterations + 1"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
37->22;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent

IRs:
REF_302(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_303(Kleros.AppealsRepartitioned) -> REF_302[i]
REF_304(Kleros.RepartitionStage) -> REF_303.stage
REF_305(Kleros.RepartitionStage) -> RepartitionStage.Coherent
REF_304(Kleros.RepartitionStage) (->dispute) := REF_305(Kleros.RepartitionStage)"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: IF 40

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent

IRs:
REF_306(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_307(Kleros.AppealsRepartitioned) -> REF_306[i]
REF_308(Kleros.RepartitionStage) -> REF_307.stage
REF_309(Kleros.RepartitionStage) -> RepartitionStage.Coherent
TMP_387(bool) = REF_308 == REF_309
CONDITION TMP_387"];
40->41[label="True"];
40->64[label="False"];
41[label="Node Type: IF 41

EXPRESSION:
dispute.appealsRepartitioned[i].nbCoherent == 0

IRs:
REF_310(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_311(Kleros.AppealsRepartitioned) -> REF_310[i]
REF_312(uint256) -> REF_311.nbCoherent
TMP_388(bool) = REF_312 == 0
CONDITION TMP_388"];
41->42[label="True"];
41->45[label="False"];
42[label="Node Type: EXPRESSION 42

EXPRESSION:
jurors[governor].balance += dispute.appealsRepartitioned[i].totalToRedistribute

IRs:
REF_313(Kleros.Juror) -> jurors[governor]
REF_314(uint256) -> REF_313.balance
REF_315(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_316(Kleros.AppealsRepartitioned) -> REF_315[i]
REF_317(uint256) -> REF_316.totalToRedistribute
REF_314(-> jurors) = REF_314 + REF_317"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
TokenShift(governor,_disputeID,int256(dispute.appealsRepartitioned[i].totalToRedistribute))

IRs:
REF_318(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_319(Kleros.AppealsRepartitioned) -> REF_318[i]
REF_320(uint256) -> REF_319.totalToRedistribute
TMP_389 = CONVERT REF_320 to int256
Emit TokenShift(governor,_disputeID,TMP_389)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake

IRs:
REF_321(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_322(Kleros.AppealsRepartitioned) -> REF_321[i]
REF_323(Kleros.RepartitionStage) -> REF_322.stage
REF_324(Kleros.RepartitionStage) -> RepartitionStage.AtStake
REF_323(Kleros.RepartitionStage) (->dispute) := REF_324(Kleros.RepartitionStage)"];
44->63;
45[label="Node Type: NEW VARIABLE 45

EXPRESSION:
toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent

IRs:
REF_325(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_326(Kleros.AppealsRepartitioned) -> REF_325[i]
REF_327(uint256) -> REF_326.totalToRedistribute
REF_328(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_329(Kleros.AppealsRepartitioned) -> REF_328[i]
REF_330(uint256) -> REF_329.nbCoherent
TMP_391(uint256) = REF_327 / REF_330
toRedistribute(uint256) := TMP_391(uint256)"];
45->48;
46[label="Node Type: BEGIN_LOOP 46
"];
46->49;
47[label="Node Type: END_LOOP 47
"];
47->62;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
j = dispute.appealsRepartitioned[i].currentCoherentVote

IRs:
REF_331(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_332(Kleros.AppealsRepartitioned) -> REF_331[i]
REF_333(uint256) -> REF_332.currentCoherentVote
j(uint256) := REF_333(uint256)"];
48->46;
49[label="Node Type: IF_LOOP 49

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_334(Kleros.Vote[][]) -> dispute.votes
REF_335(Kleros.Vote[]) -> REF_334[i]
REF_336 -> LENGTH REF_335
TMP_392(bool) = j < REF_336
CONDITION TMP_392"];
49->50[label="True"];
49->47[label="False"];
50[label="Node Type: IF 50

EXPRESSION:
currentIterations >= _maxIterations

IRs:
TMP_393(bool) = currentIterations >= _maxIterations
CONDITION TMP_393"];
50->51[label="True"];
50->52[label="False"];
51[label="Node Type: RETURN 51
"];
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_337(Kleros.Vote[][]) -> dispute.votes
REF_338(Kleros.Vote[]) -> REF_337[i]
REF_339(Kleros.Vote) -> REF_338[j]
vote(Kleros.Vote) := REF_339(Kleros.Vote)"];
53->54;
54[label="Node Type: IF 54

EXPRESSION:
vote.ruling == winningChoice

IRs:
REF_340(uint256) -> vote.ruling
TMP_394(bool) = REF_340 == winningChoice
CONDITION TMP_394"];
54->55[label="True"];
54->58[label="False"];
55[label="Node Type: EXPRESSION 55

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_341(address) -> vote.account
REF_342(Kleros.Juror) -> jurors[REF_341]
juror(Kleros.Juror) := REF_342(Kleros.Juror)"];
55->56;
56[label="Node Type: EXPRESSION 56

EXPRESSION:
juror.balance += toRedistribute

IRs:
REF_343(uint256) -> juror.balance
REF_343(-> juror) = REF_343 + toRedistribute"];
56->57;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(toRedistribute))

IRs:
REF_344(address) -> vote.account
TMP_395 = CONVERT toRedistribute to int256
Emit TokenShift(REF_344,_disputeID,TMP_395)"];
57->58;
58[label="Node Type: END_IF 58
"];
58->59;
59[label="Node Type: EXPRESSION 59

EXPRESSION:
++ currentIterations

IRs:
currentIterations(uint256) = currentIterations + 1"];
59->60;
60[label="Node Type: EXPRESSION 60

EXPRESSION:
++ dispute.appealsRepartitioned[i].currentCoherentVote

IRs:
REF_345(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_346(Kleros.AppealsRepartitioned) -> REF_345[i]
REF_347(uint256) -> REF_346.currentCoherentVote
REF_347(-> dispute) = REF_347 + 1"];
60->61;
61[label="Node Type: EXPRESSION 61

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
61->49;
62[label="Node Type: EXPRESSION 62

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake

IRs:
REF_348(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_349(Kleros.AppealsRepartitioned) -> REF_348[i]
REF_350(Kleros.RepartitionStage) -> REF_349.stage
REF_351(Kleros.RepartitionStage) -> RepartitionStage.AtStake
REF_350(Kleros.RepartitionStage) (->dispute) := REF_351(Kleros.RepartitionStage)"];
62->63;
63[label="Node Type: END_IF 63
"];
63->64;
64[label="Node Type: END_IF 64
"];
64->65;
65[label="Node Type: IF 65

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake

IRs:
REF_352(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_353(Kleros.AppealsRepartitioned) -> REF_352[i]
REF_354(Kleros.RepartitionStage) -> REF_353.stage
REF_355(Kleros.RepartitionStage) -> RepartitionStage.AtStake
TMP_397(bool) = REF_354 == REF_355
CONDITION TMP_397"];
65->68[label="True"];
65->80[label="False"];
66[label="Node Type: BEGIN_LOOP 66
"];
66->69;
67[label="Node Type: END_LOOP 67
"];
67->79;
68[label="Node Type: EXPRESSION 68

EXPRESSION:
j = dispute.appealsRepartitioned[i].currentAtStakeVote

IRs:
REF_356(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_357(Kleros.AppealsRepartitioned) -> REF_356[i]
REF_358(uint256) -> REF_357.currentAtStakeVote
j(uint256) := REF_358(uint256)"];
68->66;
69[label="Node Type: IF_LOOP 69

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_359(Kleros.Vote[][]) -> dispute.votes
REF_360(Kleros.Vote[]) -> REF_359[i]
REF_361 -> LENGTH REF_360
TMP_398(bool) = j < REF_361
CONDITION TMP_398"];
69->70[label="True"];
69->67[label="False"];
70[label="Node Type: IF 70

EXPRESSION:
currentIterations >= _maxIterations

IRs:
TMP_399(bool) = currentIterations >= _maxIterations
CONDITION TMP_399"];
70->71[label="True"];
70->72[label="False"];
71[label="Node Type: RETURN 71
"];
72[label="Node Type: END_IF 72
"];
72->73;
73[label="Node Type: EXPRESSION 73

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_362(Kleros.Vote[][]) -> dispute.votes
REF_363(Kleros.Vote[]) -> REF_362[i]
REF_364(Kleros.Vote) -> REF_363[j]
vote(Kleros.Vote) := REF_364(Kleros.Vote)"];
73->74;
74[label="Node Type: EXPRESSION 74

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_365(address) -> vote.account
REF_366(Kleros.Juror) -> jurors[REF_365]
juror(Kleros.Juror) := REF_366(Kleros.Juror)"];
74->75;
75[label="Node Type: EXPRESSION 75

EXPRESSION:
juror.atStake -= amountShift

IRs:
REF_367(uint256) -> juror.atStake
REF_367(-> juror) = REF_367 - amountShift"];
75->76;
76[label="Node Type: EXPRESSION 76

EXPRESSION:
++ currentIterations

IRs:
currentIterations(uint256) = currentIterations + 1"];
76->77;
77[label="Node Type: EXPRESSION 77

EXPRESSION:
++ dispute.appealsRepartitioned[i].currentAtStakeVote

IRs:
REF_368(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_369(Kleros.AppealsRepartitioned) -> REF_368[i]
REF_370(uint256) -> REF_369.currentAtStakeVote
REF_370(-> dispute) = REF_370 + 1"];
77->78;
78[label="Node Type: EXPRESSION 78

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
78->69;
79[label="Node Type: EXPRESSION 79

EXPRESSION:
dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete

IRs:
REF_371(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_372(Kleros.AppealsRepartitioned) -> REF_371[i]
REF_373(Kleros.RepartitionStage) -> REF_372.stage
REF_374(Kleros.RepartitionStage) -> RepartitionStage.Complete
REF_373(Kleros.RepartitionStage) (->dispute) := REF_374(Kleros.RepartitionStage)"];
79->80;
80[label="Node Type: END_IF 80
"];
80->81;
81[label="Node Type: IF 81

EXPRESSION:
dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete

IRs:
REF_375(Kleros.AppealsRepartitioned[]) -> dispute.appealsRepartitioned
REF_376(Kleros.AppealsRepartitioned) -> REF_375[i]
REF_377(Kleros.RepartitionStage) -> REF_376.stage
REF_378(Kleros.RepartitionStage) -> RepartitionStage.Complete
TMP_400(bool) = REF_377 == REF_378
CONDITION TMP_400"];
81->82[label="True"];
81->83[label="False"];
82[label="Node Type: EXPRESSION 82

EXPRESSION:
++ dispute.currentAppealToRepartition

IRs:
REF_379(uint256) -> dispute.currentAppealToRepartition
REF_379(-> dispute) = REF_379 + 1"];
82->83;
83[label="Node Type: END_IF 83
"];
83->84;
84[label="Node Type: EXPRESSION 84

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
84->11;
85[label="Node Type: EXPRESSION 85

EXPRESSION:
dispute.state = DisputeState.Executable

IRs:
REF_380(Kleros.DisputeState) -> dispute.state
REF_381(Kleros.DisputeState) -> DisputeState.Executable
REF_380(Kleros.DisputeState) (->dispute) := REF_381(Kleros.DisputeState)"];
86[label="Node Type: EXPRESSION 86

EXPRESSION:
onlyDuring(Period.Execution)

IRs:
REF_382(Kleros.Period) -> Period.Execution
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_382)"];
86->1;
87[label="Node Type: IF 87

EXPRESSION:
amountShift < juror.balance

IRs:
REF_383(uint256) -> juror.balance
TMP_402(bool) = amountShift < REF_383
CONDITION TMP_402"];
87->88[label="True"];
87->89[label="False"];
88[label="Node Type: EXPRESSION 88

EXPRESSION:
penalty = amountShift

IRs:
penalty(uint256) := amountShift(uint256)"];
88->90;
89[label="Node Type: EXPRESSION 89

EXPRESSION:
penalty = juror.balance

IRs:
REF_384(uint256) -> juror.balance
penalty(uint256) := REF_384(uint256)"];
89->90;
90[label="Node Type: END_IF 90
"];
90->30;
}
// Function: 415.sol-Kleros-oneShotTokenRepartition(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->54;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_188(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_188(Kleros.Dispute)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(dispute.state == DisputeState.Open)

IRs:
REF_189(Kleros.DisputeState) -> dispute.state
REF_190(Kleros.DisputeState) -> DisputeState.Open
TMP_341(bool) = REF_189 == REF_190
TMP_342(None) = SOLIDITY_CALL require(bool)(TMP_341)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(dispute.session + dispute.appeals <= session)

IRs:
REF_191(uint256) -> dispute.session
REF_192(uint256) -> dispute.appeals
TMP_343(uint256) = REF_191 + REF_192
TMP_344(bool) = TMP_343 <= session
TMP_345(None) = SOLIDITY_CALL require(bool)(TMP_344)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
winningChoice = dispute.voteCounter[dispute.appeals].winningChoice

IRs:
REF_193(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_194(uint256) -> dispute.appeals
REF_195(Kleros.VoteCounter) -> REF_193[REF_194]
REF_196(uint256) -> REF_195.winningChoice
winningChoice(uint256) := REF_196(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
amountShift = getStakePerDraw()

IRs:
TMP_346(uint256) = INTERNAL_CALL, Kleros.getStakePerDraw()()
amountShift(uint256) := TMP_346(uint256)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
7->53;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i <= dispute.appeals

IRs:
REF_197(uint256) -> dispute.appeals
TMP_347(bool) = i <= REF_197
CONDITION TMP_347"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: IF 10

EXPRESSION:
winningChoice != 0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)

IRs:
TMP_348(bool) = winningChoice != 0
REF_198(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_199(uint256) -> dispute.appeals
REF_200(Kleros.VoteCounter) -> REF_198[REF_199]
REF_201(mapping(uint256 => uint256)) -> REF_200.voteCount
REF_202(uint256) -> REF_201[0]
REF_203(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_204(uint256) -> dispute.appeals
REF_205(Kleros.VoteCounter) -> REF_203[REF_204]
REF_206(uint256) -> REF_205.winningCount
TMP_349(bool) = REF_202 == REF_206
TMP_350(bool) = TMP_348 || TMP_349
CONDITION TMP_350"];
10->11[label="True"];
10->43[label="False"];
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
totalToRedistribute = 0

IRs:
totalToRedistribute(uint256) := 0(uint256)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
nbCoherent = 0

IRs:
nbCoherent(uint256) := 0(uint256)"];
12->15;
13[label="Node Type: BEGIN_LOOP 13
"];
13->16;
14[label="Node Type: END_LOOP 14
"];
14->27;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
15->13;
16[label="Node Type: IF_LOOP 16

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_207(Kleros.Vote[][]) -> dispute.votes
REF_208(Kleros.Vote[]) -> REF_207[i]
REF_209 -> LENGTH REF_208
TMP_351(bool) = j < REF_209
CONDITION TMP_351"];
16->17[label="True"];
16->14[label="False"];
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_210(Kleros.Vote[][]) -> dispute.votes
REF_211(Kleros.Vote[]) -> REF_210[i]
REF_212(Kleros.Vote) -> REF_211[j]
vote(Kleros.Vote) := REF_212(Kleros.Vote)"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
vote.ruling != winningChoice

IRs:
REF_213(uint256) -> vote.ruling
TMP_352(bool) = REF_213 != winningChoice
CONDITION TMP_352"];
18->19[label="True"];
18->24[label="False"];
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_214(address) -> vote.account
REF_215(Kleros.Juror) -> jurors[REF_214]
juror(Kleros.Juror) := REF_215(Kleros.Juror)"];
19->55;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
juror.balance -= penalty

IRs:
REF_216(uint256) -> juror.balance
REF_216(-> juror) = REF_216 - penalty"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(- penalty))

IRs:
REF_217(address) -> vote.account
TMP_353(uint256) = 0 - penalty
TMP_354 = CONVERT TMP_353 to int256
Emit TokenShift(REF_217,_disputeID,TMP_354)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
totalToRedistribute += penalty

IRs:
totalToRedistribute(uint256) = totalToRedistribute + penalty"];
23->25;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
++ nbCoherent

IRs:
nbCoherent(uint256) = nbCoherent + 1"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
26->16;
27[label="Node Type: IF 27

EXPRESSION:
nbCoherent == 0

IRs:
TMP_356(bool) = nbCoherent == 0
CONDITION TMP_356"];
27->28[label="True"];
27->30[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
jurors[governor].balance += totalToRedistribute

IRs:
REF_218(Kleros.Juror) -> jurors[governor]
REF_219(uint256) -> REF_218.balance
REF_219(-> jurors) = REF_219 + totalToRedistribute"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
TokenShift(governor,_disputeID,int256(totalToRedistribute))

IRs:
TMP_357 = CONVERT totalToRedistribute to int256
Emit TokenShift(governor,_disputeID,TMP_357)"];
29->42;
30[label="Node Type: NEW VARIABLE 30

EXPRESSION:
toRedistribute = totalToRedistribute / nbCoherent

IRs:
TMP_359(uint256) = totalToRedistribute / nbCoherent
toRedistribute(uint256) := TMP_359(uint256)"];
30->33;
31[label="Node Type: BEGIN_LOOP 31
"];
31->34;
32[label="Node Type: END_LOOP 32
"];
32->42;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
33->31;
34[label="Node Type: IF_LOOP 34

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_220(Kleros.Vote[][]) -> dispute.votes
REF_221(Kleros.Vote[]) -> REF_220[i]
REF_222 -> LENGTH REF_221
TMP_360(bool) = j < REF_222
CONDITION TMP_360"];
34->35[label="True"];
34->32[label="False"];
35[label="Node Type: EXPRESSION 35

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_223(Kleros.Vote[][]) -> dispute.votes
REF_224(Kleros.Vote[]) -> REF_223[i]
REF_225(Kleros.Vote) -> REF_224[j]
vote(Kleros.Vote) := REF_225(Kleros.Vote)"];
35->36;
36[label="Node Type: IF 36

EXPRESSION:
vote.ruling == winningChoice

IRs:
REF_226(uint256) -> vote.ruling
TMP_361(bool) = REF_226 == winningChoice
CONDITION TMP_361"];
36->37[label="True"];
36->40[label="False"];
37[label="Node Type: EXPRESSION 37

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_227(address) -> vote.account
REF_228(Kleros.Juror) -> jurors[REF_227]
juror(Kleros.Juror) := REF_228(Kleros.Juror)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
juror.balance += toRedistribute

IRs:
REF_229(uint256) -> juror.balance
REF_229(-> juror) = REF_229 + toRedistribute"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
TokenShift(vote.account,_disputeID,int256(toRedistribute))

IRs:
REF_230(address) -> vote.account
TMP_362 = CONVERT toRedistribute to int256
Emit TokenShift(REF_230,_disputeID,TMP_362)"];
39->40;
40[label="Node Type: END_IF 40
"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
41->34;
42[label="Node Type: END_IF 42
"];
42->43;
43[label="Node Type: END_IF 43
"];
43->46;
44[label="Node Type: BEGIN_LOOP 44
"];
44->47;
45[label="Node Type: END_LOOP 45
"];
45->52;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
46->44;
47[label="Node Type: IF_LOOP 47

EXPRESSION:
j < dispute.votes[i].length

IRs:
REF_231(Kleros.Vote[][]) -> dispute.votes
REF_232(Kleros.Vote[]) -> REF_231[i]
REF_233 -> LENGTH REF_232
TMP_364(bool) = j < REF_233
CONDITION TMP_364"];
47->48[label="True"];
47->45[label="False"];
48[label="Node Type: EXPRESSION 48

EXPRESSION:
vote = dispute.votes[i][j]

IRs:
REF_234(Kleros.Vote[][]) -> dispute.votes
REF_235(Kleros.Vote[]) -> REF_234[i]
REF_236(Kleros.Vote) -> REF_235[j]
vote(Kleros.Vote) := REF_236(Kleros.Vote)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
juror = jurors[vote.account]

IRs:
REF_237(address) -> vote.account
REF_238(Kleros.Juror) -> jurors[REF_237]
juror(Kleros.Juror) := REF_238(Kleros.Juror)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
juror.atStake -= amountShift

IRs:
REF_239(uint256) -> juror.atStake
REF_239(-> juror) = REF_239 - amountShift"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
++ j

IRs:
j(uint256) = j + 1"];
51->47;
52[label="Node Type: EXPRESSION 52

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
52->9;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
dispute.state = DisputeState.Executable

IRs:
REF_240(Kleros.DisputeState) -> dispute.state
REF_241(Kleros.DisputeState) -> DisputeState.Executable
REF_240(Kleros.DisputeState) (->dispute) := REF_241(Kleros.DisputeState)"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
onlyDuring(Period.Execution)

IRs:
REF_242(Kleros.Period) -> Period.Execution
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_242)"];
54->1;
55[label="Node Type: IF 55

EXPRESSION:
amountShift < juror.balance

IRs:
REF_243(uint256) -> juror.balance
TMP_366(bool) = amountShift < REF_243
CONDITION TMP_366"];
55->56[label="True"];
55->57[label="False"];
56[label="Node Type: EXPRESSION 56

EXPRESSION:
penalty = amountShift

IRs:
penalty(uint256) := amountShift(uint256)"];
56->58;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
penalty = juror.balance

IRs:
REF_244(uint256) -> juror.balance
penalty(uint256) := REF_244(uint256)"];
57->58;
58[label="Node Type: END_IF 58
"];
58->21;
}
// Function: 415.sol-Kleros-onlyBy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == _account)

IRs:
TMP_511(bool) = msg.sender == _account
TMP_512(None) = SOLIDITY_CALL require(bool)(TMP_511)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Kleros-onlyDuring(Kleros.Period)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(period == _period)

IRs:
TMP_513(bool) = period == _period
TMP_514(None) = SOLIDITY_CALL require(bool)(TMP_513)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Kleros-onlyGovernor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == governor)

IRs:
TMP_515(bool) = msg.sender == governor
TMP_516(None) = SOLIDITY_CALL require(bool)(TMP_515)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Kleros-passPeriod()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now - lastPeriodChange >= timePerPeriod[uint8(period)])

IRs:
TMP_274(uint256) = now - lastPeriodChange
TMP_275 = CONVERT period to uint8
REF_112(uint256) -> timePerPeriod[TMP_275]
TMP_276(bool) = TMP_274 >= REF_112
TMP_277(None) = SOLIDITY_CALL require(bool)(TMP_276)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
period == Period.Activation

IRs:
REF_113(Kleros.Period) -> Period.Activation
TMP_278(bool) = period == REF_113
CONDITION TMP_278"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
rnBlock = block.number + 1

IRs:
TMP_279(uint256) = block.number + 1
rnBlock(uint256) := TMP_279(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rng.requestRN(rnBlock)

IRs:
HIGH_LEVEL_CALL, dest:rng(RNG), function:requestRN, arguments:['rnBlock']  "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
period = Period.Draw

IRs:
REF_115(Kleros.Period) -> Period.Draw
period(Kleros.Period) := REF_115(Kleros.Period)"];
5->24;
6[label="Node Type: IF 6

EXPRESSION:
period == Period.Draw

IRs:
REF_116(Kleros.Period) -> Period.Draw
TMP_281(bool) = period == REF_116
CONDITION TMP_281"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
randomNumber = rng.getUncorrelatedRN(rnBlock)

IRs:
TMP_282(uint256) = HIGH_LEVEL_CALL, dest:rng(RNG), function:getUncorrelatedRN, arguments:['rnBlock']  
randomNumber(uint256) := TMP_282(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(randomNumber != 0)

IRs:
TMP_283(bool) = randomNumber != 0
TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
period = Period.Vote

IRs:
REF_118(Kleros.Period) -> Period.Vote
period(Kleros.Period) := REF_118(Kleros.Period)"];
9->23;
10[label="Node Type: IF 10

EXPRESSION:
period == Period.Vote

IRs:
REF_119(Kleros.Period) -> Period.Vote
TMP_285(bool) = period == REF_119
CONDITION TMP_285"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
period = Period.Appeal

IRs:
REF_120(Kleros.Period) -> Period.Appeal
period(Kleros.Period) := REF_120(Kleros.Period)"];
11->22;
12[label="Node Type: IF 12

EXPRESSION:
period == Period.Appeal

IRs:
REF_121(Kleros.Period) -> Period.Appeal
TMP_286(bool) = period == REF_121
CONDITION TMP_286"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
period = Period.Execution

IRs:
REF_122(Kleros.Period) -> Period.Execution
period(Kleros.Period) := REF_122(Kleros.Period)"];
13->21;
14[label="Node Type: IF 14

EXPRESSION:
period == Period.Execution

IRs:
REF_123(Kleros.Period) -> Period.Execution
TMP_287(bool) = period == REF_123
CONDITION TMP_287"];
14->15[label="True"];
14->20[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
period = Period.Activation

IRs:
REF_124(Kleros.Period) -> Period.Activation
period(Kleros.Period) := REF_124(Kleros.Period)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
++ session

IRs:
session(uint256) = session + 1"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
segmentSize = 0

IRs:
segmentSize(uint256) := 0(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
rnBlock = 0

IRs:
rnBlock(uint256) := 0(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
randomNumber = 0

IRs:
randomNumber(uint256) := 0(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
lastPeriodChange = now

IRs:
lastPeriodChange(uint256) := now(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
NewPeriod(period,session)

IRs:
Emit NewPeriod(period,session)"];
}
// Function: 415.sol-Kleros-penalizeInactiveJuror(address,uint256,uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_170(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_170(Kleros.Dispute)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
inactiveJuror = jurors[_jurorAddress]

IRs:
REF_171(Kleros.Juror) -> jurors[_jurorAddress]
inactiveJuror(Kleros.Juror) := REF_171(Kleros.Juror)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(period > Period.Vote)

IRs:
REF_172(Kleros.Period) -> Period.Vote
TMP_317(bool) = period > REF_172
TMP_318(None) = SOLIDITY_CALL require(bool)(TMP_317)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(dispute.lastSessionVote[_jurorAddress] != session)

IRs:
REF_173(mapping(address => uint256)) -> dispute.lastSessionVote
REF_174(uint256) -> REF_173[_jurorAddress]
TMP_319(bool) = REF_174 != session
TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
dispute.lastSessionVote[_jurorAddress] = session

IRs:
REF_175(mapping(address => uint256)) -> dispute.lastSessionVote
REF_176(uint256) -> REF_175[_jurorAddress]
REF_176(uint256) (->dispute) := session(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(validDraws(_jurorAddress,_disputeID,_draws))

IRs:
TMP_321(bool) = INTERNAL_CALL, Kleros.validDraws(address,uint256,uint256[])(_jurorAddress,_disputeID,_draws)
TMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR

IRs:
REF_177 -> LENGTH _draws
TMP_323(uint256) = REF_177 * minActivatedToken
TMP_324(uint256) = TMP_323 * 2
TMP_325(uint256) = TMP_324 * alpha
TMP_326(uint256) = TMP_325 / ALPHA_DIVISOR
penality(uint256) := TMP_326(uint256)"];
7->16;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
inactiveJuror.balance -= penality

IRs:
REF_178(uint256) -> inactiveJuror.balance
REF_178(-> inactiveJuror) = REF_178 - penality"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
TokenShift(_jurorAddress,_disputeID,- int256(penality))

IRs:
TMP_327 = CONVERT penality to int256
TMP_328(int256) = 0 - TMP_327
Emit TokenShift(_jurorAddress,_disputeID,TMP_328)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
jurors[msg.sender].balance += penality / 2

IRs:
REF_179(Kleros.Juror) -> jurors[msg.sender]
REF_180(uint256) -> REF_179.balance
TMP_330(uint256) = penality / 2
REF_180(-> jurors) = REF_180 + TMP_330"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
TokenShift(msg.sender,_disputeID,int256(penality / 2))

IRs:
TMP_331(uint256) = penality / 2
TMP_332 = CONVERT TMP_331 to int256
Emit TokenShift(msg.sender,_disputeID,TMP_332)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
jurors[governor].balance += penality / 2

IRs:
REF_181(Kleros.Juror) -> jurors[governor]
REF_182(uint256) -> REF_181.balance
TMP_334(uint256) = penality / 2
REF_182(-> jurors) = REF_182 + TMP_334"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
TokenShift(governor,_disputeID,int256(penality / 2))

IRs:
TMP_335(uint256) = penality / 2
TMP_336 = CONVERT TMP_335 to int256
Emit TokenShift(governor,_disputeID,TMP_336)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
msg.sender.transfer(_draws.length * dispute.arbitrationFeePerJuror)

IRs:
REF_184 -> LENGTH _draws
REF_185(uint256) -> dispute.arbitrationFeePerJuror
TMP_338(uint256) = REF_184 * REF_185
Transfer dest:msg.sender value:TMP_338"];
16[label="Node Type: IF 16

EXPRESSION:
(penality < inactiveJuror.balance)

IRs:
REF_186(uint256) -> inactiveJuror.balance
TMP_340(bool) = penality < REF_186
CONDITION TMP_340"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
penality = penality

IRs:
penality(uint256) := penality(uint256)"];
17->19;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
penality = inactiveJuror.balance

IRs:
REF_187(uint256) -> inactiveJuror.balance
penality(uint256) := REF_187(uint256)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->9;
}
// Function: 415.sol-Kleros-receiveApproval(address,uint256,address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(pinakion.transferFrom(_from,this,_amount))

IRs:
TMP_262(bool) = HIGH_LEVEL_CALL, dest:pinakion(Pinakion), function:transferFrom, arguments:['_from', 'this', '_amount']  
TMP_263(None) = SOLIDITY_CALL require(bool)(TMP_262)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
jurors[_from].balance += _amount

IRs:
REF_102(Kleros.Juror) -> jurors[_from]
REF_103(uint256) -> REF_102.balance
REF_103(-> jurors) = REF_103 + _amount"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyBy(pinakion)

IRs:
MODIFIER_CALL, Kleros.onlyBy(address)(pinakion)"];
3->1;
}
// Function: 415.sol-Kleros-requireAppealFee(uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= appealCost(_disputeID,_extraData))

IRs:
TMP_508(uint256) = INTERNAL_CALL, Kleros.appealCost(uint256,bytes)(_disputeID,_extraData)
TMP_509(bool) = msg.value >= TMP_508
TMP_510(None) = SOLIDITY_CALL require(bool)(TMP_509)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Kleros-requireArbitrationFee(bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= arbitrationCost(_extraData))

IRs:
TMP_505(uint256) = INTERNAL_CALL, Kleros.arbitrationCost(bytes)(_extraData)
TMP_506(bool) = msg.value >= TMP_505
TMP_507(None) = SOLIDITY_CALL require(bool)(TMP_506)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Kleros-setAlpha(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
alpha = _alpha

IRs:
alpha(uint256) := _alpha(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-setArbitrationFeePerJuror(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
arbitrationFeePerJuror = _arbitrationFeePerJuror

IRs:
arbitrationFeePerJuror(uint256) := _arbitrationFeePerJuror(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-setDefaultNumberJuror(uint16)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
defaultNumberJuror = _defaultNumberJuror

IRs:
defaultNumberJuror(uint16) := _defaultNumberJuror(uint16)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-setGovernor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
governor = _governor

IRs:
governor(address) := _governor(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-setMaxAppeals(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
maxAppeals = _maxAppeals

IRs:
maxAppeals(uint256) := _maxAppeals(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-setMinActivatedToken(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minActivatedToken = _minActivatedToken

IRs:
minActivatedToken(uint256) := _minActivatedToken(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-setRng(RNG)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
rng = _rng

IRs:
rng(RNG) := _rng(RNG)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-setTimePerPeriod(uint256[5])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
timePerPeriod = _timePerPeriod

IRs:
timePerPeriod(uint256[5]) := _timePerPeriod(uint256[5])"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()"];
2->1;
}
// Function: 415.sol-Kleros-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
NON_PAYABLE_AMOUNT = (2 ** 256 - 2) / 2

IRs:
TMP_502(uint256) = 2 ** 256
TMP_503(uint256) = TMP_502 - 2
TMP_504(uint256) = TMP_503 / 2
NON_PAYABLE_AMOUNT(uint256) := TMP_504(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
ALPHA_DIVISOR = 1e4

IRs:
ALPHA_DIVISOR(uint256) := 10000(uint256)"];
}
// Function: 415.sol-Kleros-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
arbitrationFeePerJuror = 50000000000000000

IRs:
arbitrationFeePerJuror(uint256) := 50000000000000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
defaultNumberJuror = 3

IRs:
defaultNumberJuror(uint16) := 3(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
minActivatedToken = 0.1 * 1e18

IRs:
TMP_501(uint256) = 0 * 1000000000000000000
minActivatedToken(uint256) := TMP_501(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
alpha = 2000

IRs:
alpha(uint256) := 2000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
maxAppeals = 5

IRs:
maxAppeals(uint256) := 5(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
session = 1

IRs:
session(uint256) := 1(uint256)"];
}
// Function: 415.sol-Kleros-validDraws(address,uint256,uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
draw = 0

IRs:
draw(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
juror = jurors[_jurorAddress]

IRs:
REF_388(Kleros.Juror) -> jurors[_jurorAddress]
juror(Kleros.Juror) := REF_388(Kleros.Juror)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_389(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_389(Kleros.Dispute)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
nbJurors = amountJurors(_disputeID)

IRs:
TMP_407(uint256) = INTERNAL_CALL, Kleros.amountJurors(uint256)(_disputeID)
nbJurors(uint256) := TMP_407(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
juror.lastSession != session

IRs:
REF_390(uint256) -> juror.lastSession
TMP_408(bool) = REF_390 != session
CONDITION TMP_408"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
dispute.session + dispute.appeals != session

IRs:
REF_391(uint256) -> dispute.session
REF_392(uint256) -> dispute.appeals
TMP_409(uint256) = REF_391 + REF_392
TMP_410(bool) = TMP_409 != session
CONDITION TMP_410"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
period <= Period.Draw

IRs:
REF_393(Kleros.Period) -> Period.Draw
TMP_411(bool) = period <= REF_393
CONDITION TMP_411"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: RETURN 12

EXPRESSION:
false

IRs:
RETURN False"];
13[label="Node Type: END_IF 13
"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->29;
16[label="Node Type: NEW VARIABLE 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < _draws.length

IRs:
REF_394 -> LENGTH _draws
TMP_412(bool) = i < REF_394
CONDITION TMP_412"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: IF 18

EXPRESSION:
_draws[i] <= draw

IRs:
REF_395(uint256) -> _draws[i]
TMP_413(bool) = REF_395 <= draw
CONDITION TMP_413"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: RETURN 19

EXPRESSION:
false

IRs:
RETURN False"];
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
draw = _draws[i]

IRs:
REF_396(uint256) -> _draws[i]
draw(uint256) := REF_396(uint256)"];
21->22;
22[label="Node Type: IF 22

EXPRESSION:
draw > nbJurors

IRs:
TMP_414(bool) = draw > nbJurors
CONDITION TMP_414"];
22->23[label="True"];
22->24[label="False"];
23[label="Node Type: RETURN 23

EXPRESSION:
false

IRs:
RETURN False"];
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
position = uint256(keccak256()(randomNumber,_disputeID,draw)) % segmentSize

IRs:
TMP_415(bytes32) = SOLIDITY_CALL keccak256()(randomNumber,_disputeID,draw)
TMP_416 = CONVERT TMP_415 to uint256
TMP_417(uint256) = TMP_416 % segmentSize
position(uint256) := TMP_417(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
require(bool)(position >= juror.segmentStart)

IRs:
REF_397(uint256) -> juror.segmentStart
TMP_418(bool) = position >= REF_397
TMP_419(None) = SOLIDITY_CALL require(bool)(TMP_418)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
require(bool)(position < juror.segmentEnd)

IRs:
REF_398(uint256) -> juror.segmentEnd
TMP_420(bool) = position < REF_398
TMP_421(None) = SOLIDITY_CALL require(bool)(TMP_420)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
28->17;
29[label="Node Type: RETURN 29

EXPRESSION:
true

IRs:
RETURN True"];
30[label="Node Type: RETURN 30

EXPRESSION:
valid

IRs:
RETURN valid"];
}
// Function: 415.sol-Kleros-voteRuling(uint256,uint256,uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->26;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dispute = disputes[_disputeID]

IRs:
REF_132(Kleros.Dispute) -> disputes[_disputeID]
dispute(Kleros.Dispute) := REF_132(Kleros.Dispute)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
juror = jurors[msg.sender]

IRs:
REF_133(Kleros.Juror) -> jurors[msg.sender]
juror(Kleros.Juror) := REF_133(Kleros.Juror)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
voteCounter = dispute.voteCounter[dispute.appeals]

IRs:
REF_134(Kleros.VoteCounter[]) -> dispute.voteCounter
REF_135(uint256) -> dispute.appeals
REF_136(Kleros.VoteCounter) -> REF_134[REF_135]
voteCounter(Kleros.VoteCounter) := REF_136(Kleros.VoteCounter)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(dispute.lastSessionVote[msg.sender] != session)

IRs:
REF_137(mapping(address => uint256)) -> dispute.lastSessionVote
REF_138(uint256) -> REF_137[msg.sender]
TMP_296(bool) = REF_138 != session
TMP_297(None) = SOLIDITY_CALL require(bool)(TMP_296)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_ruling <= dispute.choices)

IRs:
REF_139(uint256) -> dispute.choices
TMP_298(bool) = _ruling <= REF_139
TMP_299(None) = SOLIDITY_CALL require(bool)(TMP_298)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(validDraws(msg.sender,_disputeID,_draws))

IRs:
TMP_300(bool) = INTERNAL_CALL, Kleros.validDraws(address,uint256,uint256[])(msg.sender,_disputeID,_draws)
TMP_301(None) = SOLIDITY_CALL require(bool)(TMP_300)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
dispute.lastSessionVote[msg.sender] = session

IRs:
REF_140(mapping(address => uint256)) -> dispute.lastSessionVote
REF_141(uint256) -> REF_140[msg.sender]
REF_141(uint256) (->dispute) := session(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
voteCounter.voteCount[_ruling] += _draws.length

IRs:
REF_142(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_143(uint256) -> REF_142[_ruling]
REF_144 -> LENGTH _draws
REF_143(-> voteCounter) = REF_143 + REF_144"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
voteCounter.winningCount < voteCounter.voteCount[_ruling]

IRs:
REF_145(uint256) -> voteCounter.winningCount
REF_146(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_147(uint256) -> REF_146[_ruling]
TMP_302(bool) = REF_145 < REF_147
CONDITION TMP_302"];
9->10[label="True"];
9->12[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
voteCounter.winningCount = voteCounter.voteCount[_ruling]

IRs:
REF_148(uint256) -> voteCounter.winningCount
REF_149(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_150(uint256) -> REF_149[_ruling]
REF_148(uint256) (->voteCounter) := REF_150(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
voteCounter.winningChoice = _ruling

IRs:
REF_151(uint256) -> voteCounter.winningChoice
REF_151(uint256) (->voteCounter) := _ruling(uint256)"];
11->15;
12[label="Node Type: IF 12

EXPRESSION:
voteCounter.winningCount == voteCounter.voteCount[_ruling] && _draws.length != 0

IRs:
REF_152(uint256) -> voteCounter.winningCount
REF_153(mapping(uint256 => uint256)) -> voteCounter.voteCount
REF_154(uint256) -> REF_153[_ruling]
TMP_303(bool) = REF_152 == REF_154
REF_155 -> LENGTH _draws
TMP_304(bool) = REF_155 != 0
TMP_305(bool) = TMP_303 && TMP_304
CONDITION TMP_305"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
voteCounter.winningChoice = 0

IRs:
REF_156(uint256) -> voteCounter.winningChoice
REF_156(uint256) (->voteCounter) := 0(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: END_IF 15
"];
15->18;
16[label="Node Type: BEGIN_LOOP 16
"];
16->19;
17[label="Node Type: END_LOOP 17
"];
17->22;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
18->16;
19[label="Node Type: IF_LOOP 19

EXPRESSION:
i < _draws.length

IRs:
REF_157 -> LENGTH _draws
TMP_306(bool) = i < REF_157
CONDITION TMP_306"];
19->20[label="True"];
19->17[label="False"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
dispute.votes[dispute.appeals].push(Vote({account:msg.sender,ruling:_ruling}))

IRs:
REF_158(Kleros.Vote[][]) -> dispute.votes
REF_159(uint256) -> dispute.appeals
REF_160(Kleros.Vote[]) -> REF_158[REF_159]
TMP_307(Kleros.Vote) = new Vote(msg.sender,_ruling)
REF_162 -> LENGTH REF_160
TMP_309(uint256) := REF_162(uint256)
TMP_310(uint256) = TMP_309 + 1
REF_162(uint256) (->dispute) := TMP_310(uint256)
REF_163(Kleros.Vote) -> REF_160[TMP_309]
REF_163(Kleros.Vote) (->dispute) := TMP_307(Kleros.Vote)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
21->19;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
juror.atStake += _draws.length * getStakePerDraw()

IRs:
REF_164(uint256) -> juror.atStake
REF_165 -> LENGTH _draws
TMP_311(uint256) = INTERNAL_CALL, Kleros.getStakePerDraw()()
TMP_312(uint256) = REF_165 * TMP_311
REF_164(-> juror) = REF_164 + TMP_312"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
feeToPay = _draws.length * dispute.arbitrationFeePerJuror

IRs:
REF_166 -> LENGTH _draws
REF_167(uint256) -> dispute.arbitrationFeePerJuror
TMP_313(uint256) = REF_166 * REF_167
feeToPay(uint256) := TMP_313(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
msg.sender.transfer(feeToPay)

IRs:
Transfer dest:msg.sender value:feeToPay"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
ArbitrationReward(msg.sender,_disputeID,feeToPay)

IRs:
Emit ArbitrationReward(msg.sender,_disputeID,feeToPay)"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
onlyDuring(Period.Vote)

IRs:
REF_169(Kleros.Period) -> Period.Vote
MODIFIER_CALL, Kleros.onlyDuring(Kleros.Period)(REF_169)"];
26->1;
}
// Function: 415.sol-Kleros-withdraw(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
juror = jurors[msg.sender]

IRs:
REF_104(Kleros.Juror) -> jurors[msg.sender]
juror(Kleros.Juror) := REF_104(Kleros.Juror)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(juror.atStake <= juror.balance)

IRs:
REF_105(uint256) -> juror.atStake
REF_106(uint256) -> juror.balance
TMP_265(bool) = REF_105 <= REF_106
TMP_266(None) = SOLIDITY_CALL require(bool)(TMP_265)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= juror.balance - juror.atStake)

IRs:
REF_107(uint256) -> juror.balance
REF_108(uint256) -> juror.atStake
TMP_267(uint256) = REF_107 - REF_108
TMP_268(bool) = _value <= TMP_267
TMP_269(None) = SOLIDITY_CALL require(bool)(TMP_268)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(juror.lastSession != session)

IRs:
REF_109(uint256) -> juror.lastSession
TMP_270(bool) = REF_109 != session
TMP_271(None) = SOLIDITY_CALL require(bool)(TMP_270)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
juror.balance -= _value

IRs:
REF_110(uint256) -> juror.balance
REF_110(-> juror) = REF_110 - _value"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(pinakion.transfer(msg.sender,_value))

IRs:
TMP_272(bool) = HIGH_LEVEL_CALL, dest:pinakion(Pinakion), function:transfer, arguments:['msg.sender', '_value']  
TMP_273(None) = SOLIDITY_CALL require(bool)(TMP_272)"];
}
// Function: 415.sol-MiniMeTokenFactory-createCloneToken(address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
newToken = new Pinakion(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled)

IRs:
TMP_196(Pinakion) = new Pinakion(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) 
newToken(Pinakion) := TMP_196(Pinakion)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:newToken(Pinakion), function:changeController, arguments:['msg.sender']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
newToken

IRs:
RETURN newToken"];
}
// Function: 415.sol-PEpsilon-constructor(Pinakion,Kleros,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pinakion = _pinakion

IRs:
pinakion(Pinakion) := _pinakion(Pinakion)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
court = _kleros

IRs:
court(Kleros) := _kleros(Kleros)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
disputeID = _disputeID

IRs:
disputeID(uint256) := _disputeID(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
desiredOutcome = _desiredOutcome

IRs:
desiredOutcome(uint256) := _desiredOutcome(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
epsilon = _epsilon

IRs:
epsilon(uint256) := _epsilon(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
attacker = msg.sender

IRs:
attacker(address) := msg.sender(address)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
maxAppeals = _maxAppeals

IRs:
maxAppeals(uint256) := _maxAppeals(uint256)"];
}
// Function: 415.sol-PEpsilon-onlyBy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == _account)

IRs:
TMP_55(bool) = msg.sender == _account
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-PEpsilon-receiveApproval(address,uint256,address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(pinakion.transferFrom(_from,this,_amount))

IRs:
TMP_0(bool) = HIGH_LEVEL_CALL, dest:pinakion(Pinakion), function:transferFrom, arguments:['_from', 'this', '_amount']  
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance += _amount

IRs:
balance(uint256) = balance + _amount"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyBy(pinakion)

IRs:
MODIFIER_CALL, PEpsilon.onlyBy(address)(pinakion)"];
3->1;
}
// Function: 415.sol-PEpsilon-settle()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(court.disputeStatus(disputeID) == Arbitrator.DisputeStatus.Solved)

IRs:
TMP_16(Arbitrator.DisputeStatus) = HIGH_LEVEL_CALL, dest:court(Kleros), function:disputeStatus, arguments:['disputeID']  
REF_6(Arbitrator.DisputeStatus) -> DisputeStatus.Solved
TMP_17(bool) = TMP_16 == REF_6
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! settled)

IRs:
TMP_19 = UnaryType.BANG settled 
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
settled = true

IRs:
settled(bool) := True(bool)"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(None,None,appeals,choices,None,None,None,None) = court.disputes(disputeID)

IRs:
TUPLE_0(Arbitrable,uint256,uint256,uint256,uint16,uint256,Kleros.DisputeState,uint256) = HIGH_LEVEL_CALL, dest:court(Kleros), function:disputes, arguments:['disputeID']  
appeals(uint256)= UNPACK TUPLE_0 index: 2 
choices(uint256)= UNPACK TUPLE_0 index: 3 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
court.currentRuling(disputeID) != desiredOutcome

IRs:
TMP_21(uint256) = HIGH_LEVEL_CALL, dest:court(Kleros), function:currentRuling, arguments:['disputeID']  
TMP_22(bool) = TMP_21 != desiredOutcome
CONDITION TMP_22"];
7->8[label="True"];
7->58[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
amountShift = court.getStakePerDraw()

IRs:
TMP_23(uint256) = HIGH_LEVEL_CALL, dest:court(Kleros), function:getStakePerDraw, arguments:[]  
amountShift(uint256) := TMP_23(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
winningChoice = court.getWinningChoice(disputeID,appeals)

IRs:
TMP_24(uint256) = HIGH_LEVEL_CALL, dest:court(Kleros), function:getWinningChoice, arguments:['disputeID', 'appeals']  
winningChoice(uint256) := TMP_24(uint256)"];
9->12;
10[label="Node Type: BEGIN_LOOP 10
"];
10->59;
11[label="Node Type: END_LOOP 11
"];
11->58;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
12->10;
14[label="Node Type: IF 14

EXPRESSION:
winningChoice != 0

IRs:
TMP_25(bool) = winningChoice != 0
CONDITION TMP_25"];
14->15[label="True"];
14->56[label="False"];
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
votesLen = 0

IRs:
votesLen(uint256) := 0(uint256)"];
15->18;
16[label="Node Type: BEGIN_LOOP 16
"];
16->19;
17[label="Node Type: END_LOOP 17
"];
17->22;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
c = 0

IRs:
c(uint256) := 0(uint256)"];
18->16;
19[label="Node Type: IF_LOOP 19

EXPRESSION:
c <= choices

IRs:
TMP_26(bool) = c <= choices
CONDITION TMP_26"];
19->20[label="True"];
19->17[label="False"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
votesLen += court.getVoteCount(disputeID,i,c)

IRs:
TMP_27(uint256) = HIGH_LEVEL_CALL, dest:court(Kleros), function:getVoteCount, arguments:['disputeID', 'i', 'c']  
votesLen(uint256) = votesLen + TMP_27"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
c ++

IRs:
TMP_28(uint256) := c(uint256)
c(uint256) = c + 1"];
21->19;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
Log(amountShift,0x0,stakePerDraw)

IRs:
Emit Log(amountShift,0,stakePerDraw)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
Log(votesLen,0x0,votesLen)

IRs:
Emit Log(votesLen,0,votesLen)"];
23->24;
24[label="Node Type: NEW VARIABLE 24

EXPRESSION:
totalToRedistribute = 0

IRs:
totalToRedistribute(uint256) := 0(uint256)"];
24->25;
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
nbCoherent = 0

IRs:
nbCoherent(uint256) := 0(uint256)"];
25->28;
26[label="Node Type: BEGIN_LOOP 26
"];
26->29;
27[label="Node Type: END_LOOP 27
"];
27->43;
28[label="Node Type: NEW VARIABLE 28

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
28->26;
29[label="Node Type: IF_LOOP 29

EXPRESSION:
j < votesLen

IRs:
TMP_31(bool) = j < votesLen
CONDITION TMP_31"];
29->30[label="True"];
29->27[label="False"];
30[label="Node Type: NEW VARIABLE 30

EXPRESSION:
voteRuling = court.getVoteRuling(disputeID,i,j)

IRs:
TMP_32(uint256) = HIGH_LEVEL_CALL, dest:court(Kleros), function:getVoteRuling, arguments:['disputeID', 'i', 'j']  
voteRuling(uint256) := TMP_32(uint256)"];
30->31;
31[label="Node Type: NEW VARIABLE 31

EXPRESSION:
voteAccount = court.getVoteAccount(disputeID,i,j)

IRs:
TMP_33(address) = HIGH_LEVEL_CALL, dest:court(Kleros), function:getVoteAccount, arguments:['disputeID', 'i', 'j']  
voteAccount(address) := TMP_33(address)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
Log(voteRuling,voteAccount,voted)

IRs:
Emit Log(voteRuling,voteAccount,voted)"];
32->33;
33[label="Node Type: IF 33

EXPRESSION:
voteRuling != winningChoice

IRs:
TMP_35(bool) = voteRuling != winningChoice
CONDITION TMP_35"];
33->34[label="True"];
33->40[label="False"];
34[label="Node Type: EXPRESSION 34

EXPRESSION:
totalToRedistribute += amountShift

IRs:
totalToRedistribute(uint256) = totalToRedistribute + amountShift"];
34->35;
35[label="Node Type: IF 35

EXPRESSION:
voteRuling == desiredOutcome

IRs:
TMP_36(bool) = voteRuling == desiredOutcome
CONDITION TMP_36"];
35->36[label="True"];
35->39[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
withdraw[voteAccount] += amountShift + epsilon

IRs:
REF_14(uint256) -> withdraw[voteAccount]
TMP_37(uint256) = amountShift + epsilon
REF_14(-> withdraw) = REF_14 + TMP_37"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
remainingWithdraw += amountShift + epsilon

IRs:
TMP_38(uint256) = amountShift + epsilon
remainingWithdraw(uint256) = remainingWithdraw + TMP_38"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
AmountShift(amountShift,epsilon,voteAccount)

IRs:
Emit AmountShift(amountShift,epsilon,voteAccount)"];
38->39;
39[label="Node Type: END_IF 39
"];
39->41;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
nbCoherent ++

IRs:
TMP_40(uint256) := nbCoherent(uint256)
nbCoherent(uint256) = nbCoherent + 1"];
40->41;
41[label="Node Type: END_IF 41
"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
j ++

IRs:
TMP_41(uint256) := j(uint256)
j(uint256) = j + 1"];
42->29;
43[label="Node Type: NEW VARIABLE 43

EXPRESSION:
toRedistribute = (totalToRedistribute - amountShift) / (nbCoherent + 1)

IRs:
TMP_42(uint256) = totalToRedistribute - amountShift
TMP_43(uint256) = nbCoherent + 1
TMP_44(uint256) = TMP_42 / TMP_43
toRedistribute(uint256) := TMP_44(uint256)"];
43->46;
44[label="Node Type: BEGIN_LOOP 44
"];
44->47;
45[label="Node Type: END_LOOP 45
"];
45->56;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
46->44;
47[label="Node Type: IF_LOOP 47

EXPRESSION:
j < votesLen

IRs:
TMP_45(bool) = j < votesLen
CONDITION TMP_45"];
47->48[label="True"];
47->45[label="False"];
48[label="Node Type: EXPRESSION 48

EXPRESSION:
voteRuling = court.getVoteRuling(disputeID,i,j)

IRs:
TMP_46(uint256) = HIGH_LEVEL_CALL, dest:court(Kleros), function:getVoteRuling, arguments:['disputeID', 'i', 'j']  
voteRuling(uint256) := TMP_46(uint256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
voteAccount = court.getVoteAccount(disputeID,i,j)

IRs:
TMP_47(address) = HIGH_LEVEL_CALL, dest:court(Kleros), function:getVoteAccount, arguments:['disputeID', 'i', 'j']  
voteAccount(address) := TMP_47(address)"];
49->50;
50[label="Node Type: IF 50

EXPRESSION:
voteRuling == desiredOutcome

IRs:
TMP_48(bool) = voteRuling == desiredOutcome
CONDITION TMP_48"];
50->51[label="True"];
50->54[label="False"];
51[label="Node Type: EXPRESSION 51

EXPRESSION:
withdraw[voteAccount] += toRedistribute

IRs:
REF_17(uint256) -> withdraw[voteAccount]
REF_17(-> withdraw) = REF_17 + toRedistribute"];
51->52;
52[label="Node Type: EXPRESSION 52

EXPRESSION:
remainingWithdraw += toRedistribute

IRs:
remainingWithdraw(uint256) = remainingWithdraw + toRedistribute"];
52->53;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
AmountShift(toRedistribute,0,voteAccount)

IRs:
Emit AmountShift(toRedistribute,0,voteAccount)"];
53->54;
54[label="Node Type: END_IF 54
"];
54->55;
55[label="Node Type: EXPRESSION 55

EXPRESSION:
j ++

IRs:
TMP_50(uint256) := j(uint256)
j(uint256) = j + 1"];
55->47;
56[label="Node Type: END_IF 56
"];
56->57;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
i ++

IRs:
TMP_51(uint256) := i(uint256)
i(uint256) = i + 1"];
57->59;
58[label="Node Type: END_IF 58
"];
59[label="Node Type: IF 59

EXPRESSION:
appeals > maxAppeals

IRs:
TMP_52(bool) = appeals > maxAppeals
CONDITION TMP_52"];
59->60[label="True"];
59->61[label="False"];
60[label="Node Type: EXPRESSION 60

EXPRESSION:
i <= maxAppeals

IRs:
TMP_53(bool) = i <= maxAppeals"];
60->62;
61[label="Node Type: EXPRESSION 61

EXPRESSION:
i <= appeals

IRs:
TMP_54(bool) = i <= appeals"];
61->62;
62[label="Node Type: END_IF 62
"];
62->14;
62->11;
}
// Function: 415.sol-PEpsilon-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(_b <= _a)

IRs:
TMP_8(bool) = _b <= _a
TMP_9(None) = SOLIDITY_CALL assert(bool)(TMP_8)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_a - _b

IRs:
TMP_10(uint256) = _a - _b
RETURN TMP_10"];
}
// Function: 415.sol-PEpsilon-withdrawAttacker()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(settled)

IRs:
TMP_11(None) = SOLIDITY_CALL require(bool)(settled)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
balance > remainingWithdraw

IRs:
TMP_12(bool) = balance > remainingWithdraw
CONDITION TMP_12"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
amount = balance - remainingWithdraw

IRs:
TMP_13(uint256) = balance - remainingWithdraw
amount(uint256) := TMP_13(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balance = remainingWithdraw

IRs:
balance(uint256) := remainingWithdraw(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(pinakion.transfer(attacker,amount))

IRs:
TMP_14(bool) = HIGH_LEVEL_CALL, dest:pinakion(Pinakion), function:transfer, arguments:['attacker', 'amount']  
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 415.sol-PEpsilon-withdrawJuror()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
withdrawSelect(msg.sender)

IRs:
INTERNAL_CALL, PEpsilon.withdrawSelect(address)(msg.sender)"];
}
// Function: 415.sol-PEpsilon-withdrawSelect(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amount = withdraw[_juror]

IRs:
REF_1(uint256) -> withdraw[_juror]
amount(uint256) := REF_1(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
withdraw[_juror] = 0

IRs:
REF_2(uint256) -> withdraw[_juror]
REF_2(uint256) (->withdraw) := 0(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balance = sub(balance,amount)

IRs:
TMP_4(uint256) = INTERNAL_CALL, PEpsilon.sub(uint256,uint256)(balance,amount)
balance(uint256) := TMP_4(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
remainingWithdraw = sub(remainingWithdraw,amount)

IRs:
TMP_5(uint256) = INTERNAL_CALL, PEpsilon.sub(uint256,uint256)(remainingWithdraw,amount)
remainingWithdraw(uint256) := TMP_5(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(pinakion.transfer(_juror,amount))

IRs:
TMP_6(bool) = HIGH_LEVEL_CALL, dest:pinakion(Pinakion), function:transfer, arguments:['_juror', 'amount']  
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)"];
}
// Function: 415.sol-Pinakion-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 415.sol-Pinakion-Pinakion(address,address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenFactory = MiniMeTokenFactory(_tokenFactory)

IRs:
TMP_61 = CONVERT _tokenFactory to MiniMeTokenFactory
tokenFactory(MiniMeTokenFactory) := TMP_61(MiniMeTokenFactory)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
parentToken = Pinakion(_parentToken)

IRs:
TMP_62 = CONVERT _parentToken to Pinakion
parentToken(Pinakion) := TMP_62(Pinakion)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
parentSnapShotBlock = _parentSnapShotBlock

IRs:
parentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 415.sol-Pinakion-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_28(mapping(address => uint256)) -> allowed[_owner]
REF_29(uint256) -> REF_28[_spender]
RETURN REF_29"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 415.sol-Pinakion-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_96(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(controller)

IRs:
TMP_97(bool) = INTERNAL_CALL, Pinakion.isContract(address)(controller)
CONDITION TMP_97"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))

IRs:
TMP_98 = CONVERT controller to TokenController
TMP_99(bool) = HIGH_LEVEL_CALL, dest:TMP_98(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  
TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
allowed[msg.sender][_spender] = _amount

IRs:
REF_26(mapping(address => uint256)) -> allowed[msg.sender]
REF_27(uint256) -> REF_26[_spender]
REF_27(uint256) (->allowed) := _amount(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,_amount)

IRs:
Emit Approval(msg.sender,_spender,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 415.sol-Pinakion-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approve(_spender,_amount))

IRs:
TMP_102(bool) = INTERNAL_CALL, Pinakion.approve(address,uint256)(_spender,_amount)
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)

IRs:
TMP_104 = CONVERT _spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_104(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 415.sol-Pinakion-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOfAt(_owner,block.number)

IRs:
TMP_95(uint256) = INTERNAL_CALL, Pinakion.balanceOfAt(address,uint256)(_owner,block.number)
RETURN TMP_95"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 415.sol-Pinakion-balanceOfAt(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)

IRs:
REF_31(Pinakion.Checkpoint[]) -> balances[_owner]
REF_32 -> LENGTH REF_31
TMP_107(bool) = REF_32 == 0
REF_33(Pinakion.Checkpoint[]) -> balances[_owner]
REF_34(Pinakion.Checkpoint) -> REF_33[0]
REF_35(uint128) -> REF_34.fromBlock
TMP_108(bool) = REF_35 > _blockNumber
TMP_109(bool) = TMP_107 || TMP_108
CONDITION TMP_109"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_110 = CONVERT parentToken to address
TMP_111(bool) = TMP_110 != 0
CONDITION TMP_111"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_112(uint256) = INTERNAL_CALL, Pinakion.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_113(uint256) = HIGH_LEVEL_CALL, dest:parentToken(Pinakion), function:balanceOfAt, arguments:['_owner', 'TMP_112']  
RETURN TMP_113"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(balances[_owner],_blockNumber)

IRs:
REF_37(Pinakion.Checkpoint[]) -> balances[_owner]
TMP_114(uint256) = INTERNAL_CALL, Pinakion.getValueAt(Pinakion.Checkpoint[],uint256)(REF_37,_blockNumber)
RETURN TMP_114"];
}
// Function: 415.sol-Pinakion-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 415.sol-Pinakion-claimTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_186(bool) = _token == 0
CONDITION TMP_186"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_74(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_74"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
token = Pinakion(_token)

IRs:
TMP_188 = CONVERT _token to Pinakion
token(Pinakion) := TMP_188(Pinakion)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_189(uint256) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_189(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_190(bool) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:transfer, arguments:['controller', 'balance']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 415.sol-Pinakion-createCloneToken(string,uint8,string,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_snapshotBlock == 0

IRs:
TMP_123(bool) = _snapshotBlock == 0
CONDITION TMP_123"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_snapshotBlock = block.number

IRs:
_snapshotBlock(uint256) := block.number(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)

IRs:
TMP_124(Pinakion) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  
cloneToken(Pinakion) := TMP_124(Pinakion)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
cloneToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:cloneToken(Pinakion), function:changeController, arguments:['msg.sender']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
NewCloneToken(address(cloneToken),_snapshotBlock)

IRs:
TMP_126 = CONVERT cloneToken to address
Emit NewCloneToken(TMP_126,_snapshotBlock)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
address(cloneToken)

IRs:
TMP_128 = CONVERT cloneToken to address
RETURN TMP_128"];
}
// Function: 415.sol-Pinakion-destroyTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_143(uint256) = INTERNAL_CALL, Pinakion.totalSupply()()
curTotalSupply(uint256) := TMP_143(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply >= _amount)

IRs:
TMP_144(bool) = curTotalSupply >= _amount
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceFrom = balanceOf(_owner)

IRs:
TMP_146(uint256) = INTERNAL_CALL, Pinakion.balanceOf(address)(_owner)
previousBalanceFrom(uint256) := TMP_146(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_147(bool) = previousBalanceFrom >= _amount
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)

IRs:
TMP_149(uint256) = curTotalSupply - _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(totalSupplyHistory,TMP_149)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceFrom - _amount)

IRs:
REF_45(Pinakion.Checkpoint[]) -> balances[_owner]
TMP_151(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_45,TMP_151)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_owner,0,_amount)

IRs:
Emit Transfer(_owner,0,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 415.sol-Pinakion-doTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_70(bool) = _amount == 0
CONDITION TMP_70"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(parentSnapShotBlock < block.number)

IRs:
TMP_72(bool) = parentSnapShotBlock < block.number
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)((_to != 0) && (_to != address(this)))

IRs:
TMP_74(bool) = _to != 0
TMP_75 = CONVERT this to address
TMP_76(bool) = _to != TMP_75
TMP_77(bool) = TMP_74 && TMP_76
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
previousBalanceFrom = balanceOfAt(_from,block.number)

IRs:
TMP_79(uint256) = INTERNAL_CALL, Pinakion.balanceOfAt(address,uint256)(_from,block.number)
previousBalanceFrom(uint256) := TMP_79(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_80(bool) = previousBalanceFrom >= _amount
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
isContract(controller)

IRs:
TMP_82(bool) = INTERNAL_CALL, Pinakion.isContract(address)(controller)
CONDITION TMP_82"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(TokenController(controller).onTransfer(_from,_to,_amount))

IRs:
TMP_83 = CONVERT controller to TokenController
TMP_84(bool) = HIGH_LEVEL_CALL, dest:TMP_83(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
updateValueAtNow(balances[_from],previousBalanceFrom - _amount)

IRs:
REF_23(Pinakion.Checkpoint[]) -> balances[_from]
TMP_86(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_23,TMP_86)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
previousBalanceTo = balanceOfAt(_to,block.number)

IRs:
TMP_88(uint256) = INTERNAL_CALL, Pinakion.balanceOfAt(address,uint256)(_to,block.number)
previousBalanceTo(uint256) := TMP_88(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_89(uint256) = previousBalanceTo + _amount
TMP_90(bool) = TMP_89 >= previousBalanceTo
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
updateValueAtNow(balances[_to],previousBalanceTo + _amount)

IRs:
REF_24(Pinakion.Checkpoint[]) -> balances[_to]
TMP_92(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_24,TMP_92)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
}
// Function: 415.sol-Pinakion-enableTransfers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 415.sol-Pinakion-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_180(bool) = INTERNAL_CALL, Pinakion.isContract(address)(controller)
TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_182 = CONVERT controller to TokenController
TMP_184(bool) = HIGH_LEVEL_CALL, dest:TMP_182(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)"];
}
// Function: 415.sol-Pinakion-generateTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_129(uint256) = INTERNAL_CALL, Pinakion.totalSupply()()
curTotalSupply(uint256) := TMP_129(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply + _amount >= curTotalSupply)

IRs:
TMP_130(uint256) = curTotalSupply + _amount
TMP_131(bool) = TMP_130 >= curTotalSupply
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceTo = balanceOf(_owner)

IRs:
TMP_133(uint256) = INTERNAL_CALL, Pinakion.balanceOf(address)(_owner)
previousBalanceTo(uint256) := TMP_133(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_134(uint256) = previousBalanceTo + _amount
TMP_135(bool) = TMP_134 >= previousBalanceTo
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)

IRs:
TMP_137(uint256) = curTotalSupply + _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(totalSupplyHistory,TMP_137)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceTo + _amount)

IRs:
REF_44(Pinakion.Checkpoint[]) -> balances[_owner]
TMP_139(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, Pinakion.updateValueAtNow(Pinakion.Checkpoint[],uint256)(REF_44,TMP_139)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0,_owner,_amount)

IRs:
Emit Transfer(0,_owner,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 415.sol-Pinakion-getValueAt(Pinakion.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
checkpoints.length == 0

IRs:
REF_46 -> LENGTH checkpoints
TMP_156(bool) = REF_46 == 0
CONDITION TMP_156"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_block >= checkpoints[checkpoints.length - 1].fromBlock

IRs:
REF_47 -> LENGTH checkpoints
TMP_157(uint256) = REF_47 - 1
REF_48(Pinakion.Checkpoint) -> checkpoints[TMP_157]
REF_49(uint128) -> REF_48.fromBlock
TMP_158(bool) = _block >= REF_49
CONDITION TMP_158"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
checkpoints[checkpoints.length - 1].value

IRs:
REF_50 -> LENGTH checkpoints
TMP_159(uint256) = REF_50 - 1
REF_51(Pinakion.Checkpoint) -> checkpoints[TMP_159]
REF_52(uint128) -> REF_51.value
RETURN REF_52"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_block < checkpoints[0].fromBlock

IRs:
REF_53(Pinakion.Checkpoint) -> checkpoints[0]
REF_54(uint128) -> REF_53.fromBlock
TMP_160(bool) = _block < REF_54
CONDITION TMP_160"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
0

IRs:
RETURN 0"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
min = 0

IRs:
min(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
max = checkpoints.length - 1

IRs:
REF_55 -> LENGTH checkpoints
TMP_161(uint256) = REF_55 - 1
max(uint256) := TMP_161(uint256)"];
11->12;
12[label="Node Type: BEGIN_LOOP 12
"];
12->13;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
max > min

IRs:
TMP_162(bool) = max > min
CONDITION TMP_162"];
13->14[label="True"];
13->19[label="False"];
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
mid = (max + min + 1) / 2

IRs:
TMP_163(uint256) = max + min
TMP_164(uint256) = TMP_163 + 1
TMP_165(uint256) = TMP_164 / 2
mid(uint256) := TMP_165(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
checkpoints[mid].fromBlock <= _block

IRs:
REF_56(Pinakion.Checkpoint) -> checkpoints[mid]
REF_57(uint128) -> REF_56.fromBlock
TMP_166(bool) = REF_57 <= _block
CONDITION TMP_166"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
min = mid

IRs:
min(uint256) := mid(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
max = mid - 1

IRs:
TMP_167(uint256) = mid - 1
max(uint256) := TMP_167(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->13;
19[label="Node Type: END_LOOP 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
checkpoints[min].value

IRs:
REF_58(Pinakion.Checkpoint) -> checkpoints[min]
REF_59(uint128) -> REF_58.value
RETURN REF_59"];
}
// Function: 415.sol-Pinakion-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_addr == 0

IRs:
TMP_177(bool) = _addr == 0
CONDITION TMP_177"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
size > 0

IRs:
TMP_178(bool) = size > 0
RETURN TMP_178"];
}
// Function: 415.sol-Pinakion-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_179(bool) = a < b
CONDITION TMP_179"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 415.sol-Pinakion-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_193(bool) = msg.sender == controller
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 415.sol-Pinakion-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
version = MMT_0.2

IRs:
version(string) := MMT_0.2(string)"];
}
// Function: 415.sol-Pinakion-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupplyAt(block.number)

IRs:
TMP_106(uint256) = INTERNAL_CALL, Pinakion.totalSupplyAt(uint256)(block.number)
RETURN TMP_106"];
}
// Function: 415.sol-Pinakion-totalSupplyAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)

IRs:
REF_38 -> LENGTH totalSupplyHistory
TMP_115(bool) = REF_38 == 0
REF_39(Pinakion.Checkpoint) -> totalSupplyHistory[0]
REF_40(uint128) -> REF_39.fromBlock
TMP_116(bool) = REF_40 > _blockNumber
TMP_117(bool) = TMP_115 || TMP_116
CONDITION TMP_117"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_118 = CONVERT parentToken to address
TMP_119(bool) = TMP_118 != 0
CONDITION TMP_119"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_120(uint256) = INTERNAL_CALL, Pinakion.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_121(uint256) = HIGH_LEVEL_CALL, dest:parentToken(Pinakion), function:totalSupplyAt, arguments:['TMP_120']  
RETURN TMP_121"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(totalSupplyHistory,_blockNumber)

IRs:
TMP_122(uint256) = INTERNAL_CALL, Pinakion.getValueAt(Pinakion.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)
RETURN TMP_122"];
}
// Function: 415.sol-Pinakion-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_63(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
doTransfer(msg.sender,_to,_amount)

IRs:
INTERNAL_CALL, Pinakion.doTransfer(address,address,uint256)(msg.sender,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 415.sol-Pinakion-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != controller

IRs:
TMP_65(bool) = msg.sender != controller
CONDITION TMP_65"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_66(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowed[_from][msg.sender] >= _amount)

IRs:
REF_18(mapping(address => uint256)) -> allowed[_from]
REF_19(uint256) -> REF_18[msg.sender]
TMP_67(bool) = REF_19 >= _amount
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_20(mapping(address => uint256)) -> allowed[_from]
REF_21(uint256) -> REF_20[msg.sender]
REF_21(-> allowed) = REF_21 - _amount"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
doTransfer(_from,_to,_amount)

IRs:
INTERNAL_CALL, Pinakion.doTransfer(address,address,uint256)(_from,_to,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 415.sol-Pinakion-updateValueAtNow(Pinakion.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)

IRs:
REF_60 -> LENGTH checkpoints
TMP_168(bool) = REF_60 == 0
REF_61 -> LENGTH checkpoints
TMP_169(uint256) = REF_61 - 1
REF_62(Pinakion.Checkpoint) -> checkpoints[TMP_169]
REF_63(uint128) -> REF_62.fromBlock
TMP_170(bool) = REF_63 < block.number
TMP_171(bool) = TMP_168 || TMP_170
CONDITION TMP_171"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newCheckPoint = checkpoints[checkpoints.length ++]

IRs:
REF_64 -> LENGTH checkpoints
TMP_172(uint256) := REF_64(uint256)
REF_64(-> checkpoints) = REF_64 + 1
REF_65(Pinakion.Checkpoint) -> checkpoints[TMP_172]
newCheckPoint(Pinakion.Checkpoint) := REF_65(Pinakion.Checkpoint)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newCheckPoint.fromBlock = uint128(block.number)

IRs:
REF_66(uint128) -> newCheckPoint.fromBlock
TMP_173 = CONVERT block.number to uint128
REF_66(uint128) (->newCheckPoint) := TMP_173(uint128)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newCheckPoint.value = uint128(_value)

IRs:
REF_67(uint128) -> newCheckPoint.value
TMP_174 = CONVERT _value to uint128
REF_67(uint128) (->newCheckPoint) := TMP_174(uint128)"];
4->7;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
oldCheckPoint = checkpoints[checkpoints.length - 1]

IRs:
REF_68 -> LENGTH checkpoints
TMP_175(uint256) = REF_68 - 1
REF_69(Pinakion.Checkpoint) -> checkpoints[TMP_175]
oldCheckPoint(Pinakion.Checkpoint) := REF_69(Pinakion.Checkpoint)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
oldCheckPoint.value = uint128(_value)

IRs:
REF_70(uint128) -> oldCheckPoint.value
TMP_176 = CONVERT _value to uint128
REF_70(uint128) (->oldCheckPoint) := TMP_176(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 415.sol-RNG-contribute(uint256)
digraph{
}
// Function: 415.sol-RNG-getRN(uint256)
digraph{
}
// Function: 415.sol-RNG-getUncorrelatedRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
baseRN = getRN(_block)

IRs:
TMP_199(uint256) = INTERNAL_CALL, RNG.getRN(uint256)(_block)
baseRN(uint256) := TMP_199(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
baseRN == 0

IRs:
TMP_200(bool) = baseRN == 0
CONDITION TMP_200"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: RETURN 4

EXPRESSION:
uint256(keccak256()(msg.sender,baseRN))

IRs:
TMP_201(bytes32) = SOLIDITY_CALL keccak256()(msg.sender,baseRN)
TMP_202 = CONVERT TMP_201 to uint256
RETURN TMP_202"];
6[label="Node Type: RETURN 6

EXPRESSION:
RN

IRs:
RETURN RN"];
}
// Function: 415.sol-RNG-requestRN(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contribute(_block)

IRs:
INTERNAL_CALL, RNG.contribute(uint256)(_block)"];
}
// Function: 415.sol-TokenController-onApprove(address,address,uint256)
digraph{
}
// Function: 415.sol-TokenController-onTransfer(address,address,uint256)
digraph{
}
// Function: 415.sol-TokenController-proxyPayment(address)
digraph{
}
}
