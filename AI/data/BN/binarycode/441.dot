digraph G {
// Function: 441.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_6(uint256) -> balances[_owner]
RETURN REF_6"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 441.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_13 = CONVERT 0 to address
TMP_14(bool) = _to != TMP_13
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_0(uint256) -> balances[msg.sender]
REF_1(uint256) -> balances[msg.sender]
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1', '_value'] 
REF_0(uint256) (->balances) := TMP_16(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_3(uint256) -> balances[_to]
REF_4(uint256) -> balances[_to]
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_4', '_value'] 
REF_3(uint256) (->balances) := TMP_17(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 441.sol-Bonus-getBonusFactor(uint256,Bonus.BonusData)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
countcutoffs = data.cutofftimes.length

IRs:
REF_72(uint256[6]) -> data.cutofftimes
REF_73 -> LENGTH REF_72
countcutoffs(uint256) := REF_73(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
timeIndex = countcutoffs

IRs:
timeIndex(uint256) := countcutoffs(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->12;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < countcutoffs

IRs:
TMP_104(bool) = i < countcutoffs
CONDITION TMP_104"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
timestamp < data.cutofftimes[i]

IRs:
REF_74(uint256[6]) -> data.cutofftimes
REF_75(uint256) -> REF_74[i]
TMP_105(bool) = timestamp < REF_75
CONDITION TMP_105"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
timeIndex = i

IRs:
timeIndex(uint256) := i(uint256)"];
8->9;
9[label="Node Type: BREAK 9
"];
9->4;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_106(uint256) := i(uint256)
i(uint256) = i + 1"];
11->6;
12[label="Node Type: RETURN 12

EXPRESSION:
data.factors[timeIndex]

IRs:
REF_76(uint256[7]) -> data.factors
REF_77(uint256) -> REF_76[timeIndex]
RETURN REF_77"];
13[label="Node Type: RETURN 13

EXPRESSION:
factor

IRs:
RETURN factor"];
}
// Function: 441.sol-Bonus-getFollowingCutoffTime(uint256,Bonus.BonusData)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
countcutoffs = data.cutofftimes.length

IRs:
REF_78(uint256[6]) -> data.cutofftimes
REF_79 -> LENGTH REF_78
countcutoffs(uint256) := REF_79(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
nextTime = 0

IRs:
nextTime(uint256) := 0(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->12;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < countcutoffs

IRs:
TMP_107(bool) = i < countcutoffs
CONDITION TMP_107"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
timestamp < data.cutofftimes[i]

IRs:
REF_80(uint256[6]) -> data.cutofftimes
REF_81(uint256) -> REF_80[i]
TMP_108(bool) = timestamp < REF_81
CONDITION TMP_108"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
nextTime = data.cutofftimes[i]

IRs:
REF_82(uint256[6]) -> data.cutofftimes
REF_83(uint256) -> REF_82[i]
nextTime(uint256) := REF_83(uint256)"];
8->9;
9[label="Node Type: BREAK 9
"];
9->4;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_109(uint256) := i(uint256)
i(uint256) = i + 1"];
11->6;
12[label="Node Type: RETURN 12

EXPRESSION:
nextTime

IRs:
RETURN nextTime"];
13[label="Node Type: RETURN 13

EXPRESSION:
nextTime

IRs:
RETURN nextTime"];
}
// Function: 441.sol-Bonus-initBonus(Bonus.BonusData)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
data.factors = (uint256(300),250,200,150,100,50,0)

IRs:
REF_70(uint256[7]) -> data.factors
TMP_97 = CONVERT 300 to uint256
REF_70(uint256[7]) = ['TMP_97(uint256)', '250(uint256)', '200(uint256)', '150(uint256)', '100(uint256)', '50(uint256)', '0(uint256)']"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
data.cutofftimes = (toTimestamp(2018,9,1),toTimestamp(2018,9,8),toTimestamp(2018,9,15),toTimestamp(2018,9,22),toTimestamp(2018,9,29),toTimestamp(2018,10,8))

IRs:
REF_71(uint256[6]) -> data.cutofftimes
TMP_98(uint256) = INTERNAL_CALL, Bonus.toTimestamp(uint16,uint8,uint8)(2018,9,1)
TMP_99(uint256) = INTERNAL_CALL, Bonus.toTimestamp(uint16,uint8,uint8)(2018,9,8)
TMP_100(uint256) = INTERNAL_CALL, Bonus.toTimestamp(uint16,uint8,uint8)(2018,9,15)
TMP_101(uint256) = INTERNAL_CALL, Bonus.toTimestamp(uint16,uint8,uint8)(2018,9,22)
TMP_102(uint256) = INTERNAL_CALL, Bonus.toTimestamp(uint16,uint8,uint8)(2018,9,29)
TMP_103(uint256) = INTERNAL_CALL, Bonus.toTimestamp(uint16,uint8,uint8)(2018,10,8)
REF_71(uint256[6]) = ['TMP_98(uint256)', 'TMP_99(uint256)', 'TMP_100(uint256)', 'TMP_101(uint256)', 'TMP_102(uint256)', 'TMP_103(uint256)']"];
}
// Function: 441.sol-Bonus-isLeapYear(uint16)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
year % 4 != 0

IRs:
TMP_128(uint16) = year % 4
TMP_129(bool) = TMP_128 != 0
CONDITION TMP_129"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
year % 100 != 0

IRs:
TMP_130(uint16) = year % 100
TMP_131(bool) = TMP_130 != 0
CONDITION TMP_131"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
year % 400 != 0

IRs:
TMP_132(uint16) = year % 400
TMP_133(bool) = TMP_132 != 0
CONDITION TMP_133"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 441.sol-Bonus-leapYearsBefore(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
year -= 1

IRs:
year(uint256) = year - 1"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
year / 4 - year / 100 + year / 400

IRs:
TMP_123(uint256) = year / 4
TMP_124(uint256) = year / 100
TMP_125(uint256) = TMP_123 - TMP_124
TMP_126(uint256) = year / 400
TMP_127(uint256) = TMP_125 + TMP_126
RETURN TMP_127"];
}
// Function: 441.sol-Bonus-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
ORIGIN_YEAR = 1970

IRs:
ORIGIN_YEAR(uint16) := 1970(uint256)"];
}
// Function: 441.sol-Bonus-toTimestamp(uint16,uint8,uint8)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
timestamp += (year - ORIGIN_YEAR) * 220752000

IRs:
TMP_110(uint16) = year - ORIGIN_YEAR
TMP_111(uint16) = TMP_110 * 220752000
timestamp(uint256) = timestamp + TMP_111"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
timestamp += (leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR)) * 86400

IRs:
TMP_112(uint256) = INTERNAL_CALL, Bonus.leapYearsBefore(uint256)(year)
TMP_113(uint256) = INTERNAL_CALL, Bonus.leapYearsBefore(uint256)(ORIGIN_YEAR)
TMP_114(uint256) = TMP_112 - TMP_113
TMP_115(uint256) = TMP_114 * 86400
timestamp(uint256) = timestamp + TMP_115"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
monthDayCounts[0] = 31

IRs:
REF_84(uint8) -> monthDayCounts[0]
REF_84(uint8) (->monthDayCounts) := 31(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
isLeapYear(year)

IRs:
TMP_116(bool) = INTERNAL_CALL, Bonus.isLeapYear(uint16)(year)
CONDITION TMP_116"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
monthDayCounts[1] = 29

IRs:
REF_85(uint8) -> monthDayCounts[1]
REF_85(uint8) (->monthDayCounts) := 29(uint256)"];
7->9;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
monthDayCounts[1] = 28

IRs:
REF_86(uint8) -> monthDayCounts[1]
REF_86(uint8) (->monthDayCounts) := 28(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
monthDayCounts[2] = 31

IRs:
REF_87(uint8) -> monthDayCounts[2]
REF_87(uint8) (->monthDayCounts) := 31(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
monthDayCounts[3] = 30

IRs:
REF_88(uint8) -> monthDayCounts[3]
REF_88(uint8) (->monthDayCounts) := 30(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
monthDayCounts[4] = 31

IRs:
REF_89(uint8) -> monthDayCounts[4]
REF_89(uint8) (->monthDayCounts) := 31(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
monthDayCounts[5] = 30

IRs:
REF_90(uint8) -> monthDayCounts[5]
REF_90(uint8) (->monthDayCounts) := 30(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
monthDayCounts[6] = 31

IRs:
REF_91(uint8) -> monthDayCounts[6]
REF_91(uint8) (->monthDayCounts) := 31(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
monthDayCounts[7] = 31

IRs:
REF_92(uint8) -> monthDayCounts[7]
REF_92(uint8) (->monthDayCounts) := 31(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
monthDayCounts[8] = 30

IRs:
REF_93(uint8) -> monthDayCounts[8]
REF_93(uint8) (->monthDayCounts) := 30(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
monthDayCounts[9] = 31

IRs:
REF_94(uint8) -> monthDayCounts[9]
REF_94(uint8) (->monthDayCounts) := 31(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
monthDayCounts[10] = 30

IRs:
REF_95(uint8) -> monthDayCounts[10]
REF_95(uint8) (->monthDayCounts) := 30(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
monthDayCounts[11] = 31

IRs:
REF_96(uint8) -> monthDayCounts[11]
REF_96(uint8) (->monthDayCounts) := 31(uint256)"];
19->22;
20[label="Node Type: BEGIN_LOOP 20
"];
20->23;
21[label="Node Type: END_LOOP 21
"];
21->26;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
i = 1

IRs:
i(uint16) := 1(uint256)"];
22->20;
23[label="Node Type: IF_LOOP 23

EXPRESSION:
i < month

IRs:
TMP_117(bool) = i < month
CONDITION TMP_117"];
23->24[label="True"];
23->21[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
timestamp += monthDayCounts[i - 1] * 86400

IRs:
TMP_118(uint16) = i - 1
REF_97(uint8) -> monthDayCounts[TMP_118]
TMP_119(uint8) = REF_97 * 86400
timestamp(uint256) = timestamp + TMP_119"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
i ++

IRs:
TMP_120(uint16) := i(uint16)
i(uint16) = i + 1"];
25->23;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
timestamp += (day - 1) * 86400

IRs:
TMP_121(uint8) = day - 1
TMP_122(uint8) = TMP_121 * 86400
timestamp(uint256) = timestamp + TMP_122"];
26->27;
27[label="Node Type: RETURN 27

EXPRESSION:
timestamp

IRs:
RETURN timestamp"];
28[label="Node Type: RETURN 28

EXPRESSION:
timestamp

IRs:
RETURN timestamp"];
}
// Function: 441.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 441.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 441.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 441.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 441.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 441.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 441.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 441.sol-QCOToken-QCOToken(address,address,address,address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stateControl = _stateControl

IRs:
stateControl(address) := _stateControl(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whitelistControl = _whitelistControl

IRs:
whitelistControl(address) := _whitelistControl(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
withdrawControl = _withdrawControl

IRs:
withdrawControl(address) := _withdrawControl(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokenAssignmentControl = _tokenAssignmentControl

IRs:
tokenAssignmentControl(address) := _tokenAssignmentControl(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
moveToState(States.Initial)

IRs:
REF_136(QCOToken.States) -> States.Initial
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_136)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
endBlock = 0

IRs:
endBlock(uint256) := 0(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ETH_QCO = 0

IRs:
ETH_QCO(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
totalSupply = maxTotalSupply

IRs:
totalSupply(uint256) := maxTotalSupply(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
soldTokens = 0

IRs:
soldTokens(uint256) := 0(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Bonus.initBonus(bonusData)

IRs:
LIBRARY_CALL, dest:Bonus, function:Bonus.initBonus(Bonus.BonusData), arguments:['bonusData'] "];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
teamWallet = address(new QravityTeamTimelock(this,_teamControl))

IRs:
TMP_156(QravityTeamTimelock) = new QravityTeamTimelock(this,_teamControl) 
TMP_157 = CONVERT TMP_156 to address
teamWallet(address) := TMP_157(address)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
reserves = _reserves

IRs:
reserves(address) := _reserves(address)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
balances[reserves] = totalSupply

IRs:
REF_138(uint256) -> balances[reserves]
REF_138(uint256) (->balances) := totalSupply(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Mint(reserves,totalSupply)

IRs:
Emit Mint(reserves,totalSupply)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Transfer(0x0,reserves,totalSupply)

IRs:
Emit Transfer(0,reserves,totalSupply)"];
}
// Function: 441.sol-QCOToken-abort()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
moveToState(States.Aborted)

IRs:
REF_184(QCOToken.States) -> States.Aborted
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_184)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyStateControl()

IRs:
MODIFIER_CALL, QCOToken.onlyStateControl()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
requireState(States.Paused)

IRs:
REF_185(QCOToken.States) -> States.Paused
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_185)"];
3->1;
}
// Function: 441.sol-QCOToken-addPresaleAmount(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == States.ValuationSet || state == States.Ico)

IRs:
REF_164(QCOToken.States) -> States.ValuationSet
TMP_205(bool) = state == REF_164
REF_165(QCOToken.States) -> States.Ico
TMP_206(bool) = state == REF_165
TMP_207(bool) = TMP_205 || TMP_206
TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
issueTokensToUser(beneficiary,amount)

IRs:
INTERNAL_CALL, QCOToken.issueTokensToUser(address,uint256)(beneficiary,amount)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyTokenAssignmentControl()

IRs:
MODIFIER_CALL, QCOToken.onlyTokenAssignmentControl()()"];
3->1;
}
// Function: 441.sol-QCOToken-addToWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_whitelisted] = true

IRs:
REF_181(bool) -> whitelist[_whitelisted]
REF_181(bool) (->whitelist) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Whitelisted(_whitelisted)

IRs:
Emit Whitelisted(_whitelisted)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWhitelist()

IRs:
MODIFIER_CALL, QCOToken.onlyWhitelist()()"];
3->1;
}
// Function: 441.sol-QCOToken-allowance(address,address)
digraph{
}
// Function: 441.sol-QCOToken-anyoneEndICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.number > endBlock)

IRs:
TMP_215(bool) = block.number > endBlock
TMP_216(None) = SOLIDITY_CALL require(bool)(TMP_215)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
burnAndFinish()

IRs:
INTERNAL_CALL, QCOToken.burnAndFinish()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
moveToState(States.Operational)

IRs:
REF_168(QCOToken.States) -> States.Operational
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_168)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
requireState(States.Ico)

IRs:
REF_169(QCOToken.States) -> States.Ico
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_169)"];
4->1;
}
// Function: 441.sol-QCOToken-approve(address,uint256)
digraph{
}
// Function: 441.sol-QCOToken-balanceOf(address)
digraph{
}
// Function: 441.sol-QCOToken-burnAndFinish()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = soldTokens.mul(100).div(percentForSale)

IRs:
TMP_220(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['soldTokens', '100'] 
TMP_221(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_220', 'percentForSale'] 
totalSupply(uint256) := TMP_221(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
teamAmount = totalSupply.mul(22).div(100)

IRs:
TMP_222(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalSupply', '22'] 
TMP_223(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_222', '100'] 
teamAmount(uint256) := TMP_223(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[teamWallet] = teamAmount

IRs:
REF_174(uint256) -> balances[teamWallet]
REF_174(uint256) (->balances) := teamAmount(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(reserves,teamWallet,teamAmount)

IRs:
Emit Transfer(reserves,teamWallet,teamAmount)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
reservesAmount = totalSupply.sub(soldTokens).sub(teamAmount)

IRs:
TMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', 'soldTokens'] 
TMP_226(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_225', 'teamAmount'] 
reservesAmount(uint256) := TMP_226(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(reserves,0x0,balances[reserves].sub(reservesAmount).sub(teamAmount))

IRs:
REF_177(uint256) -> balances[reserves]
TMP_227(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_177', 'reservesAmount'] 
TMP_228(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_227', 'teamAmount'] 
Emit Transfer(reserves,0,TMP_228)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[reserves] = reservesAmount

IRs:
REF_180(uint256) -> balances[reserves]
REF_180(uint256) (->balances) := reservesAmount(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
}
// Function: 441.sol-QCOToken-calcBonus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
basisTokens = weiAmount.mul(ETH_QCO)

IRs:
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'ETH_QCO'] 
basisTokens(uint256) := TMP_184(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
perMillBonus = getCurrentBonusFactor()

IRs:
TMP_185(uint256) = INTERNAL_CALL, QCOToken.getCurrentBonusFactor()()
perMillBonus(uint256) := TMP_185(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
basisTokens.mul(per_mill + perMillBonus).div(per_mill)

IRs:
TMP_186(uint256) = per_mill + perMillBonus
TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['basisTokens', 'TMP_186'] 
TMP_188(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_187', 'per_mill'] 
RETURN TMP_188"];
4[label="Node Type: RETURN 4

EXPRESSION:
resultingTokens

IRs:
RETURN resultingTokens"];
}
// Function: 441.sol-QCOToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_120(mapping(address => uint256)) -> allowed[msg.sender]
REF_121(uint256) -> REF_120[_spender]
oldValue(uint256) := REF_121(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_144(bool) = _subtractedValue > oldValue
CONDITION TMP_144"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_122(mapping(address => uint256)) -> allowed[msg.sender]
REF_123(uint256) -> REF_122[_spender]
REF_123(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_124(mapping(address => uint256)) -> allowed[msg.sender]
REF_125(uint256) -> REF_124[_spender]
TMP_145(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_125(uint256) (->allowed) := TMP_145(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_127(mapping(address => uint256)) -> allowed[msg.sender]
REF_128(uint256) -> REF_127[_spender]
Emit Approval(msg.sender,_spender,REF_128)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 441.sol-QCOToken-endICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
burnAndFinish()

IRs:
INTERNAL_CALL, QCOToken.burnAndFinish()()"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
moveToState(States.Operational)

IRs:
REF_166(QCOToken.States) -> States.Operational
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_166)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyStateControl()

IRs:
MODIFIER_CALL, QCOToken.onlyStateControl()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
requireState(States.Ico)

IRs:
REF_167(QCOToken.States) -> States.Ico
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_167)"];
4->1;
}
// Function: 441.sol-QCOToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(whitelist[msg.sender] == true)

IRs:
REF_139(bool) -> whitelist[msg.sender]
TMP_160(bool) = REF_139 == True
TMP_161(None) = SOLIDITY_CALL require(bool)(TMP_160)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_162(bool) = msg.value > 0
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.data.length < 4)

IRs:
REF_140 -> LENGTH msg.data
TMP_164(bool) = REF_140 < 4
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(block.number < endBlock)

IRs:
TMP_166(bool) = block.number < endBlock
TMP_167(None) = SOLIDITY_CALL require(bool)(TMP_166)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
soldToTuserWithBonus = calcBonus(msg.value)

IRs:
TMP_168(uint256) = INTERNAL_CALL, QCOToken.calcBonus(uint256)(msg.value)
soldToTuserWithBonus(uint256) := TMP_168(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
issueTokensToUser(msg.sender,soldToTuserWithBonus)

IRs:
INTERNAL_CALL, QCOToken.issueTokensToUser(address,uint256)(msg.sender,soldToTuserWithBonus)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ethPossibleRefunds[msg.sender] = ethPossibleRefunds[msg.sender].add(msg.value)

IRs:
REF_141(uint256) -> ethPossibleRefunds[msg.sender]
REF_142(uint256) -> ethPossibleRefunds[msg.sender]
TMP_170(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_142', 'msg.value'] 
REF_141(uint256) (->ethPossibleRefunds) := TMP_170(uint256)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
requireState(States.Ico)

IRs:
REF_144(QCOToken.States) -> States.Ico
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_144)"];
8->1;
}
// Function: 441.sol-QCOToken-getCurrentBonusFactor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
Bonus.getBonusFactor(now - pauseOffset,bonusData)

IRs:
TMP_180(uint256) = now - pauseOffset
TMP_181(uint256) = LIBRARY_CALL, dest:Bonus, function:Bonus.getBonusFactor(uint256,Bonus.BonusData), arguments:['TMP_180', 'bonusData'] 
RETURN TMP_181"];
2[label="Node Type: RETURN 2

EXPRESSION:
factor

IRs:
RETURN factor"];
}
// Function: 441.sol-QCOToken-getNextCutoffTime()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
Bonus.getFollowingCutoffTime(now - pauseOffset,bonusData)

IRs:
TMP_182(uint256) = now - pauseOffset
TMP_183(uint256) = LIBRARY_CALL, dest:Bonus, function:Bonus.getFollowingCutoffTime(uint256,Bonus.BonusData), arguments:['TMP_182', 'bonusData'] 
RETURN TMP_183"];
2[label="Node Type: RETURN 2

EXPRESSION:
timestamp

IRs:
RETURN timestamp"];
}
// Function: 441.sol-QCOToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_113(mapping(address => uint256)) -> allowed[msg.sender]
REF_114(uint256) -> REF_113[_spender]
REF_115(mapping(address => uint256)) -> allowed[msg.sender]
REF_116(uint256) -> REF_115[_spender]
TMP_142(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_116', '_addedValue'] 
REF_114(uint256) (->allowed) := TMP_142(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_118(mapping(address => uint256)) -> allowed[msg.sender]
REF_119(uint256) -> REF_118[_spender]
Emit Approval(msg.sender,_spender,REF_119)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 441.sol-QCOToken-issueTokensToUser(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
soldTokensAfterInvestment = soldTokens.add(amount)

IRs:
TMP_172(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['soldTokens', 'amount'] 
soldTokensAfterInvestment(uint256) := TMP_172(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(soldTokensAfterInvestment <= maxTotalSupply.mul(percentForSale).div(100))

IRs:
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['maxTotalSupply', 'percentForSale'] 
TMP_174(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_173', '100'] 
TMP_175(bool) = soldTokensAfterInvestment <= TMP_174
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[beneficiary] = balances[beneficiary].add(amount)

IRs:
REF_148(uint256) -> balances[beneficiary]
REF_149(uint256) -> balances[beneficiary]
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_149', 'amount'] 
REF_148(uint256) (->balances) := TMP_177(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[reserves] = balances[reserves].sub(amount)

IRs:
REF_151(uint256) -> balances[reserves]
REF_152(uint256) -> balances[reserves]
TMP_178(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_152', 'amount'] 
REF_151(uint256) (->balances) := TMP_178(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
soldTokens = soldTokensAfterInvestment

IRs:
soldTokens(uint256) := soldTokensAfterInvestment(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(reserves,beneficiary,amount)

IRs:
Emit Transfer(reserves,beneficiary,amount)"];
}
// Function: 441.sol-QCOToken-moveToState(QCOToken.States)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
StateTransition(state,_newState)

IRs:
Emit StateTransition(state,_newState)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
state = _newState

IRs:
state(QCOToken.States) := _newState(QCOToken.States)"];
}
// Function: 441.sol-QCOToken-onlyStateControl()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == stateControl)

IRs:
TMP_261(bool) = msg.sender == stateControl
TMP_262(None) = SOLIDITY_CALL require(bool)(TMP_261)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 441.sol-QCOToken-onlyTokenAssignmentControl()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tokenAssignmentControl)

IRs:
TMP_263(bool) = msg.sender == tokenAssignmentControl
TMP_264(None) = SOLIDITY_CALL require(bool)(TMP_263)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 441.sol-QCOToken-onlyWhitelist()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == whitelistControl)

IRs:
TMP_259(bool) = msg.sender == whitelistControl
TMP_260(None) = SOLIDITY_CALL require(bool)(TMP_259)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 441.sol-QCOToken-onlyWithdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == withdrawControl)

IRs:
TMP_265(bool) = msg.sender == withdrawControl
TMP_266(None) = SOLIDITY_CALL require(bool)(TMP_265)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 441.sol-QCOToken-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
moveToState(States.Paused)

IRs:
REF_182(QCOToken.States) -> States.Paused
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_182)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
pauseLastStart = now

IRs:
pauseLastStart(uint256) := now(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyStateControl()

IRs:
MODIFIER_CALL, QCOToken.onlyStateControl()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
requireState(States.Ico)

IRs:
REF_183(QCOToken.States) -> States.Ico
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_183)"];
4->1;
}
// Function: 441.sol-QCOToken-requestPayout(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyWithdraw()

IRs:
MODIFIER_CALL, QCOToken.onlyWithdraw()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
requireState(States.Operational)

IRs:
REF_194(QCOToken.States) -> States.Operational
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_194)"];
3->1;
}
// Function: 441.sol-QCOToken-requestRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ethPossibleRefunds[msg.sender] > 0)

IRs:
REF_188(uint256) -> ethPossibleRefunds[msg.sender]
TMP_244(bool) = REF_188 > 0
TMP_245(None) = SOLIDITY_CALL require(bool)(TMP_244)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
payout = ethPossibleRefunds[msg.sender]

IRs:
REF_189(uint256) -> ethPossibleRefunds[msg.sender]
payout(uint256) := REF_189(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ethPossibleRefunds[msg.sender] = 0

IRs:
REF_190(uint256) -> ethPossibleRefunds[msg.sender]
REF_190(uint256) (->ethPossibleRefunds) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(payout)

IRs:
Transfer dest:msg.sender value:payout"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
requireState(States.Aborted)

IRs:
REF_192(QCOToken.States) -> States.Aborted
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_192)"];
5->1;
}
// Function: 441.sol-QCOToken-requireState(QCOToken.States)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == _requiredState)

IRs:
TMP_267(bool) = state == _requiredState
TMP_268(None) = SOLIDITY_CALL require(bool)(TMP_267)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 441.sol-QCOToken-rescueToken(ERC20Basic,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_foreignToken.transfer(_to,_foreignToken.balanceOf(this))

IRs:
TMP_251(uint256) = HIGH_LEVEL_CALL, dest:_foreignToken(ERC20Basic), function:balanceOf, arguments:['this']  
TMP_252(bool) = HIGH_LEVEL_CALL, dest:_foreignToken(ERC20Basic), function:transfer, arguments:['_to', 'TMP_251']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyTokenAssignmentControl()

IRs:
MODIFIER_CALL, QCOToken.onlyTokenAssignmentControl()()"];
2->1;
}
// Function: 441.sol-QCOToken-resumeICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
moveToState(States.Ico)

IRs:
REF_186(QCOToken.States) -> States.Ico
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_186)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
pauseOffset = pauseOffset + (now - pauseLastStart)

IRs:
TMP_240(uint256) = now - pauseLastStart
TMP_241(uint256) = pauseOffset + TMP_240
pauseOffset(uint256) := TMP_241(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyStateControl()

IRs:
MODIFIER_CALL, QCOToken.onlyStateControl()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
requireState(States.Paused)

IRs:
REF_187(QCOToken.States) -> States.Paused
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_187)"];
4->1;
}
// Function: 441.sol-QCOToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Qravity Coin Token

IRs:
name(string) := Qravity Coin Token(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = QCO

IRs:
symbol(string) := QCO(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
pointMultiplier = 1e18

IRs:
pointMultiplier(uint256) := 1000000000000000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
maxTotalSupply = 1000000000 * pointMultiplier

IRs:
TMP_258(uint256) = 1000000000 * pointMultiplier
maxTotalSupply(uint256) := TMP_258(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
percentForSale = 50

IRs:
percentForSale(uint256) := 50(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
per_mill = 1000

IRs:
per_mill(uint256) := 1000(uint256)"];
}
// Function: 441.sol-QCOToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
pauseOffset = 0

IRs:
pauseOffset(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
pauseLastStart = 0

IRs:
pauseLastStart(uint256) := 0(uint256)"];
}
// Function: 441.sol-QCOToken-startICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.number < endBlock)

IRs:
TMP_200(bool) = block.number < endBlock
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
moveToState(States.Ico)

IRs:
REF_162(QCOToken.States) -> States.Ico
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_162)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyStateControl()

IRs:
MODIFIER_CALL, QCOToken.onlyStateControl()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
requireState(States.ValuationSet)

IRs:
REF_163(QCOToken.States) -> States.ValuationSet
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_163)"];
4->1;
}
// Function: 441.sol-QCOToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_254(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)
RETURN TMP_254"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
requireState(States.Operational)

IRs:
REF_197(QCOToken.States) -> States.Operational
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_197)"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 441.sol-QCOToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_256(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_256"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
requireState(States.Operational)

IRs:
REF_198(QCOToken.States) -> States.Operational
MODIFIER_CALL, QCOToken.requireState(QCOToken.States)(REF_198)"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 441.sol-QCOToken-updateEthICOVariables(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == States.Initial || state == States.ValuationSet)

IRs:
REF_159(QCOToken.States) -> States.Initial
TMP_190(bool) = state == REF_159
REF_160(QCOToken.States) -> States.ValuationSet
TMP_191(bool) = state == REF_160
TMP_192(bool) = TMP_190 || TMP_191
TMP_193(None) = SOLIDITY_CALL require(bool)(TMP_192)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_new_ETH_QCO > 0)

IRs:
TMP_194(bool) = _new_ETH_QCO > 0
TMP_195(None) = SOLIDITY_CALL require(bool)(TMP_194)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(block.number < _newEndBlock)

IRs:
TMP_196(bool) = block.number < _newEndBlock
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
endBlock = _newEndBlock

IRs:
endBlock(uint256) := _newEndBlock(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ETH_QCO = _new_ETH_QCO

IRs:
ETH_QCO(uint256) := _new_ETH_QCO(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
moveToState(States.ValuationSet)

IRs:
REF_161(QCOToken.States) -> States.ValuationSet
INTERNAL_CALL, QCOToken.moveToState(QCOToken.States)(REF_161)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyStateControl()

IRs:
MODIFIER_CALL, QCOToken.onlyStateControl()()"];
7->1;
}
// Function: 441.sol-QravityTeamTimelock-QravityTeamTimelock(ERC20Basic,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(_token) != 0x0)

IRs:
TMP_38 = CONVERT _token to address
TMP_39(bool) = TMP_38 != 0
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_controller != 0x0)

IRs:
TMP_41(bool) = _controller != 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token = _token

IRs:
token(ERC20Basic) := _token(ERC20Basic)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
controller = _controller

IRs:
controller(address) := _controller(address)"];
}
// Function: 441.sol-QravityTeamTimelock-availableAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
totalWalletAmount = releasedAmount.add(token.balanceOf(this))

IRs:
TMP_52(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releasedAmount', 'TMP_52'] 
totalWalletAmount(uint256) := TMP_53(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
canBeReleasedAmount = totalWalletAmount.mul(availablePercent(timestamp)).div(100)

IRs:
TMP_54(uint256) = INTERNAL_CALL, QravityTeamTimelock.availablePercent(uint256)(timestamp)
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalWalletAmount', 'TMP_54'] 
TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_55', '100'] 
canBeReleasedAmount(uint256) := TMP_56(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
canBeReleasedAmount.sub(releasedAmount)

IRs:
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['canBeReleasedAmount', 'releasedAmount'] 
RETURN TMP_57"];
4[label="Node Type: RETURN 4

EXPRESSION:
amount

IRs:
RETURN amount"];
}
// Function: 441.sol-QravityTeamTimelock-availablePercent(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
releasePercent = (uint256(0),20,30,40,50,60,70,80,90,100)

IRs:
TMP_58 = CONVERT 0 to uint256
releasePercent(uint256[10]) = ['TMP_58(uint256)', '20(uint256)', '30(uint256)', '40(uint256)', '50(uint256)', '60(uint256)', '70(uint256)', '80(uint256)', '90(uint256)', '100(uint256)']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
releaseTimes = (toTimestamp(2020,4,1),toTimestamp(2020,7,1),toTimestamp(2020,10,1),toTimestamp(2021,1,1),toTimestamp(2021,4,1),toTimestamp(2021,7,1),toTimestamp(2021,10,1),toTimestamp(2022,1,1),toTimestamp(2022,4,1),0)

IRs:
TMP_59(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2020,4,1)
TMP_60(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2020,7,1)
TMP_61(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2020,10,1)
TMP_62(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2021,1,1)
TMP_63(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2021,4,1)
TMP_64(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2021,7,1)
TMP_65(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2021,10,1)
TMP_66(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2022,1,1)
TMP_67(uint256) = INTERNAL_CALL, QravityTeamTimelock.toTimestamp(uint16,uint8,uint8)(2022,4,1)
releaseTimes(uint256[10]) = ['TMP_59(uint256)', 'TMP_60(uint256)', 'TMP_61(uint256)', 'TMP_62(uint256)', 'TMP_63(uint256)', 'TMP_64(uint256)', 'TMP_65(uint256)', 'TMP_66(uint256)', 'TMP_67(uint256)', '0(uint256)']"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
timeIndex = 0

IRs:
timeIndex(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < releaseTimes.length

IRs:
REF_52 -> LENGTH releaseTimes
TMP_68(bool) = i < REF_52
CONDITION TMP_68"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
timestamp < releaseTimes[i] || releaseTimes[i] == 0

IRs:
REF_53(uint256) -> releaseTimes[i]
TMP_69(bool) = timestamp < REF_53
REF_54(uint256) -> releaseTimes[i]
TMP_70(bool) = REF_54 == 0
TMP_71(bool) = TMP_69 || TMP_70
CONDITION TMP_71"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
timeIndex = i

IRs:
timeIndex(uint256) := i(uint256)"];
9->10;
10[label="Node Type: BREAK 10
"];
10->5;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_72(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: RETURN 13

EXPRESSION:
releasePercent[timeIndex]

IRs:
REF_55(uint256) -> releasePercent[timeIndex]
RETURN REF_55"];
14[label="Node Type: RETURN 14

EXPRESSION:
factor

IRs:
RETURN factor"];
}
// Function: 441.sol-QravityTeamTimelock-isLeapYear(uint16)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
year % 4 != 0

IRs:
TMP_91(uint16) = year % 4
TMP_92(bool) = TMP_91 != 0
CONDITION TMP_92"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
year % 100 != 0

IRs:
TMP_93(uint16) = year % 100
TMP_94(bool) = TMP_93 != 0
CONDITION TMP_94"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
year % 400 != 0

IRs:
TMP_95(uint16) = year % 400
TMP_96(bool) = TMP_95 != 0
CONDITION TMP_96"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 441.sol-QravityTeamTimelock-leapYearsBefore(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
year -= 1

IRs:
year(uint256) = year - 1"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
year / 4 - year / 100 + year / 400

IRs:
TMP_86(uint256) = year / 4
TMP_87(uint256) = year / 100
TMP_88(uint256) = TMP_86 - TMP_87
TMP_89(uint256) = year / 400
TMP_90(uint256) = TMP_88 + TMP_89
RETURN TMP_90"];
}
// Function: 441.sol-QravityTeamTimelock-release(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_43(bool) = msg.sender == controller
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_45(bool) = _amount > 0
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_amount <= availableAmount(now))

IRs:
TMP_47(uint256) = INTERNAL_CALL, QravityTeamTimelock.availableAmount(uint256)(now)
TMP_48(bool) = _amount <= TMP_47
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_beneficiary,_amount)

IRs:
TMP_50(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['_beneficiary', '_amount']  "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
releasedAmount = releasedAmount.add(_amount)

IRs:
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releasedAmount', '_amount'] 
releasedAmount(uint256) := TMP_51(uint256)"];
}
// Function: 441.sol-QravityTeamTimelock-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
ORIGIN_YEAR = 1970

IRs:
ORIGIN_YEAR(uint16) := 1970(uint256)"];
}
// Function: 441.sol-QravityTeamTimelock-toTimestamp(uint16,uint8,uint8)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
timestamp += (year - ORIGIN_YEAR) * 220752000

IRs:
TMP_73(uint16) = year - ORIGIN_YEAR
TMP_74(uint16) = TMP_73 * 220752000
timestamp(uint256) = timestamp + TMP_74"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
timestamp += (leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR)) * 86400

IRs:
TMP_75(uint256) = INTERNAL_CALL, QravityTeamTimelock.leapYearsBefore(uint256)(year)
TMP_76(uint256) = INTERNAL_CALL, QravityTeamTimelock.leapYearsBefore(uint256)(ORIGIN_YEAR)
TMP_77(uint256) = TMP_75 - TMP_76
TMP_78(uint256) = TMP_77 * 86400
timestamp(uint256) = timestamp + TMP_78"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
monthDayCounts[0] = 31

IRs:
REF_56(uint8) -> monthDayCounts[0]
REF_56(uint8) (->monthDayCounts) := 31(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
isLeapYear(year)

IRs:
TMP_79(bool) = INTERNAL_CALL, QravityTeamTimelock.isLeapYear(uint16)(year)
CONDITION TMP_79"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
monthDayCounts[1] = 29

IRs:
REF_57(uint8) -> monthDayCounts[1]
REF_57(uint8) (->monthDayCounts) := 29(uint256)"];
7->9;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
monthDayCounts[1] = 28

IRs:
REF_58(uint8) -> monthDayCounts[1]
REF_58(uint8) (->monthDayCounts) := 28(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
monthDayCounts[2] = 31

IRs:
REF_59(uint8) -> monthDayCounts[2]
REF_59(uint8) (->monthDayCounts) := 31(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
monthDayCounts[3] = 30

IRs:
REF_60(uint8) -> monthDayCounts[3]
REF_60(uint8) (->monthDayCounts) := 30(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
monthDayCounts[4] = 31

IRs:
REF_61(uint8) -> monthDayCounts[4]
REF_61(uint8) (->monthDayCounts) := 31(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
monthDayCounts[5] = 30

IRs:
REF_62(uint8) -> monthDayCounts[5]
REF_62(uint8) (->monthDayCounts) := 30(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
monthDayCounts[6] = 31

IRs:
REF_63(uint8) -> monthDayCounts[6]
REF_63(uint8) (->monthDayCounts) := 31(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
monthDayCounts[7] = 31

IRs:
REF_64(uint8) -> monthDayCounts[7]
REF_64(uint8) (->monthDayCounts) := 31(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
monthDayCounts[8] = 30

IRs:
REF_65(uint8) -> monthDayCounts[8]
REF_65(uint8) (->monthDayCounts) := 30(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
monthDayCounts[9] = 31

IRs:
REF_66(uint8) -> monthDayCounts[9]
REF_66(uint8) (->monthDayCounts) := 31(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
monthDayCounts[10] = 30

IRs:
REF_67(uint8) -> monthDayCounts[10]
REF_67(uint8) (->monthDayCounts) := 30(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
monthDayCounts[11] = 31

IRs:
REF_68(uint8) -> monthDayCounts[11]
REF_68(uint8) (->monthDayCounts) := 31(uint256)"];
19->22;
20[label="Node Type: BEGIN_LOOP 20
"];
20->23;
21[label="Node Type: END_LOOP 21
"];
21->26;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
i = 1

IRs:
i(uint16) := 1(uint256)"];
22->20;
23[label="Node Type: IF_LOOP 23

EXPRESSION:
i < month

IRs:
TMP_80(bool) = i < month
CONDITION TMP_80"];
23->24[label="True"];
23->21[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
timestamp += monthDayCounts[i - 1] * 86400

IRs:
TMP_81(uint16) = i - 1
REF_69(uint8) -> monthDayCounts[TMP_81]
TMP_82(uint8) = REF_69 * 86400
timestamp(uint256) = timestamp + TMP_82"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
i ++

IRs:
TMP_83(uint16) := i(uint16)
i(uint16) = i + 1"];
25->23;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
timestamp += (day - 1) * 86400

IRs:
TMP_84(uint8) = day - 1
TMP_85(uint8) = TMP_84 * 86400
timestamp(uint256) = timestamp + TMP_85"];
26->27;
27[label="Node Type: RETURN 27

EXPRESSION:
timestamp

IRs:
RETURN timestamp"];
28[label="Node Type: RETURN 28

EXPRESSION:
timestamp

IRs:
RETURN timestamp"];
}
// Function: 441.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 441.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_6(uint256) = a / b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 441.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 441.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_7(bool) = b <= a
TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_9(uint256) = a - b
RETURN TMP_9"];
}
// Function: 441.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_27(mapping(address => uint256)) -> allowed[_owner]
REF_28(uint256) -> REF_27[_spender]
RETURN REF_28"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 441.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_25(mapping(address => uint256)) -> allowed[msg.sender]
REF_26(uint256) -> REF_25[_spender]
REF_26(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 441.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 441.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
oldValue(uint256) := REF_37(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_35(bool) = _subtractedValue > oldValue
CONDITION TMP_35"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_38(mapping(address => uint256)) -> allowed[msg.sender]
REF_39(uint256) -> REF_38[_spender]
REF_39(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_40(mapping(address => uint256)) -> allowed[msg.sender]
REF_41(uint256) -> REF_40[_spender]
TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_41(uint256) (->allowed) := TMP_36(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
Emit Approval(msg.sender,_spender,REF_44)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 441.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_29(mapping(address => uint256)) -> allowed[msg.sender]
REF_30(uint256) -> REF_29[_spender]
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', '_addedValue'] 
REF_30(uint256) (->allowed) := TMP_33(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
Emit Approval(msg.sender,_spender,REF_35)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 441.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 441.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_25 = CONVERT 0 to address
TMP_26(bool) = _to != TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_allowance = allowed[_from][msg.sender]

IRs:
REF_14(mapping(address => uint256)) -> allowed[_from]
REF_15(uint256) -> REF_14[msg.sender]
_allowance(uint256) := REF_15(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_16(uint256) -> balances[_from]
REF_17(uint256) -> balances[_from]
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_17', '_value'] 
REF_16(uint256) (->balances) := TMP_28(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_19(uint256) -> balances[_to]
REF_20(uint256) -> balances[_to]
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_29(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
allowed[_from][msg.sender] = _allowance.sub(_value)

IRs:
REF_22(mapping(address => uint256)) -> allowed[_from]
REF_23(uint256) -> REF_22[msg.sender]
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_allowance', '_value'] 
REF_23(uint256) (->allowed) := TMP_30(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
}
