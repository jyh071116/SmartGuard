digraph G {
// Function: 58.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)
digraph{
}
// Function: 58.sol-AywakeToken-AywakeToken(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
changeController(_controller)

IRs:
INTERNAL_CALL, Controlled.changeController(address)(_controller)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MiniMeToken(_tokenFactory,0x0,0,AywakeToken,18,AWK,true)

IRs:
INTERNAL_CALL, MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)(_tokenFactory,0,0,AywakeToken,18,AWK,True)"];
2->1;
}
// Function: 58.sol-AywakeToken-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 58.sol-AywakeToken-MiniMeToken(address,address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenFactory = MiniMeTokenFactory(_tokenFactory)

IRs:
TMP_247 = CONVERT _tokenFactory to MiniMeTokenFactory
tokenFactory(MiniMeTokenFactory) := TMP_247(MiniMeTokenFactory)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
parentToken = MiniMeToken(_parentToken)

IRs:
TMP_248 = CONVERT _parentToken to MiniMeToken
parentToken(MiniMeToken) := TMP_248(MiniMeToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
parentSnapShotBlock = _parentSnapShotBlock

IRs:
parentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 58.sol-AywakeToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_131(mapping(address => uint256)) -> allowed[_owner]
REF_132(uint256) -> REF_131[_spender]
RETURN REF_132"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 58.sol-AywakeToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_282(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((_amount == 0) || (allowed[msg.sender][_spender] == 0))

IRs:
TMP_283(bool) = _amount == 0
REF_126(mapping(address => uint256)) -> allowed[msg.sender]
REF_127(uint256) -> REF_126[_spender]
TMP_284(bool) = REF_127 == 0
TMP_285(bool) = TMP_283 || TMP_284
TMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
isContract(controller)

IRs:
TMP_287(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_287"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))

IRs:
TMP_288 = CONVERT controller to TokenController
TMP_289(bool) = HIGH_LEVEL_CALL, dest:TMP_288(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[msg.sender][_spender] = _amount

IRs:
REF_129(mapping(address => uint256)) -> allowed[msg.sender]
REF_130(uint256) -> REF_129[_spender]
REF_130(uint256) (->allowed) := _amount(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Approval(msg.sender,_spender,_amount)

IRs:
Emit Approval(msg.sender,_spender,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-AywakeToken-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approve(_spender,_amount))

IRs:
TMP_292(bool) = INTERNAL_CALL, MiniMeToken.approve(address,uint256)(_spender,_amount)
TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)

IRs:
TMP_294 = CONVERT _spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_294(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-AywakeToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOfAt(_owner,block.number)

IRs:
TMP_281(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_owner,block.number)
RETURN TMP_281"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 58.sol-AywakeToken-balanceOfAt(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)

IRs:
REF_134(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_135 -> LENGTH REF_134
TMP_297(bool) = REF_135 == 0
REF_136(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_137(MiniMeToken.Checkpoint) -> REF_136[0]
REF_138(uint128) -> REF_137.fromBlock
TMP_298(bool) = REF_138 > _blockNumber
TMP_299(bool) = TMP_297 || TMP_298
CONDITION TMP_299"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_300 = CONVERT parentToken to address
TMP_301(bool) = TMP_300 != 0
CONDITION TMP_301"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_302(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_303(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:balanceOfAt, arguments:['_owner', 'TMP_302']  
RETURN TMP_303"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(balances[_owner],_blockNumber)

IRs:
REF_140(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_304(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(REF_140,_blockNumber)
RETURN TMP_304"];
}
// Function: 58.sol-AywakeToken-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 58.sol-AywakeToken-claimTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_376(bool) = _token == 0
CONDITION TMP_376"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_177(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_177"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_378 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_378(MiniMeToken)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_379(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_379(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_380(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 58.sol-AywakeToken-createCloneToken(string,uint8,string,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_snapshotBlock == 0

IRs:
TMP_313(bool) = _snapshotBlock == 0
CONDITION TMP_313"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_snapshotBlock = block.number

IRs:
_snapshotBlock(uint256) := block.number(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)

IRs:
TMP_314(MiniMeToken) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  
cloneToken(MiniMeToken) := TMP_314(MiniMeToken)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
cloneToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:cloneToken(MiniMeToken), function:changeController, arguments:['msg.sender']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
NewCloneToken(address(cloneToken),_snapshotBlock)

IRs:
TMP_316 = CONVERT cloneToken to address
Emit NewCloneToken(TMP_316,_snapshotBlock)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
address(cloneToken)

IRs:
TMP_318 = CONVERT cloneToken to address
RETURN TMP_318"];
}
// Function: 58.sol-AywakeToken-destroyTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_333(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_333(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply >= _amount)

IRs:
TMP_334(bool) = curTotalSupply >= _amount
TMP_335(None) = SOLIDITY_CALL require(bool)(TMP_334)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceFrom = balanceOf(_owner)

IRs:
TMP_336(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceFrom(uint256) := TMP_336(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_337(bool) = previousBalanceFrom >= _amount
TMP_338(None) = SOLIDITY_CALL require(bool)(TMP_337)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)

IRs:
TMP_339(uint256) = curTotalSupply - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_339)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceFrom - _amount)

IRs:
REF_148(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_341(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_148,TMP_341)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_owner,0,_amount)

IRs:
Emit Transfer(_owner,0,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 58.sol-AywakeToken-doTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_256(bool) = _amount == 0
CONDITION TMP_256"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(parentSnapShotBlock < block.number)

IRs:
TMP_258(bool) = parentSnapShotBlock < block.number
TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)((_to != 0) && (_to != address(this)))

IRs:
TMP_260(bool) = _to != 0
TMP_261 = CONVERT this to address
TMP_262(bool) = _to != TMP_261
TMP_263(bool) = TMP_260 && TMP_262
TMP_264(None) = SOLIDITY_CALL require(bool)(TMP_263)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
previousBalanceFrom = balanceOfAt(_from,block.number)

IRs:
TMP_265(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_from,block.number)
previousBalanceFrom(uint256) := TMP_265(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_266(bool) = previousBalanceFrom >= _amount
TMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
isContract(controller)

IRs:
TMP_268(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_268"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(TokenController(controller).onTransfer(_from,_to,_amount))

IRs:
TMP_269 = CONVERT controller to TokenController
TMP_270(bool) = HIGH_LEVEL_CALL, dest:TMP_269(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  
TMP_271(None) = SOLIDITY_CALL require(bool)(TMP_270)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
updateValueAtNow(balances[_from],previousBalanceFrom - _amount)

IRs:
REF_124(MiniMeToken.Checkpoint[]) -> balances[_from]
TMP_272(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_124,TMP_272)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
previousBalanceTo = balanceOfAt(_to,block.number)

IRs:
TMP_274(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_to,block.number)
previousBalanceTo(uint256) := TMP_274(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_275(uint256) = previousBalanceTo + _amount
TMP_276(bool) = TMP_275 >= previousBalanceTo
TMP_277(None) = SOLIDITY_CALL require(bool)(TMP_276)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
updateValueAtNow(balances[_to],previousBalanceTo + _amount)

IRs:
REF_125(MiniMeToken.Checkpoint[]) -> balances[_to]
TMP_278(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_125,TMP_278)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
}
// Function: 58.sol-AywakeToken-enableTransfers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 58.sol-AywakeToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_370(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_372 = CONVERT controller to TokenController
TMP_374(bool) = HIGH_LEVEL_CALL, dest:TMP_372(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)"];
}
// Function: 58.sol-AywakeToken-generateTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_319(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_319(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply + _amount >= curTotalSupply)

IRs:
TMP_320(uint256) = curTotalSupply + _amount
TMP_321(bool) = TMP_320 >= curTotalSupply
TMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceTo = balanceOf(_owner)

IRs:
TMP_323(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceTo(uint256) := TMP_323(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_324(uint256) = previousBalanceTo + _amount
TMP_325(bool) = TMP_324 >= previousBalanceTo
TMP_326(None) = SOLIDITY_CALL require(bool)(TMP_325)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)

IRs:
TMP_327(uint256) = curTotalSupply + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_327)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceTo + _amount)

IRs:
REF_147(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_329(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_147,TMP_329)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0,_owner,_amount)

IRs:
Emit Transfer(0,_owner,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 58.sol-AywakeToken-getValueAt(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
checkpoints.length == 0

IRs:
REF_149 -> LENGTH checkpoints
TMP_346(bool) = REF_149 == 0
CONDITION TMP_346"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_block >= checkpoints[checkpoints.length - 1].fromBlock

IRs:
REF_150 -> LENGTH checkpoints
TMP_347(uint256) = REF_150 - 1
REF_151(MiniMeToken.Checkpoint) -> checkpoints[TMP_347]
REF_152(uint128) -> REF_151.fromBlock
TMP_348(bool) = _block >= REF_152
CONDITION TMP_348"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
checkpoints[checkpoints.length - 1].value

IRs:
REF_153 -> LENGTH checkpoints
TMP_349(uint256) = REF_153 - 1
REF_154(MiniMeToken.Checkpoint) -> checkpoints[TMP_349]
REF_155(uint128) -> REF_154.value
RETURN REF_155"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_block < checkpoints[0].fromBlock

IRs:
REF_156(MiniMeToken.Checkpoint) -> checkpoints[0]
REF_157(uint128) -> REF_156.fromBlock
TMP_350(bool) = _block < REF_157
CONDITION TMP_350"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
0

IRs:
RETURN 0"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
min = 0

IRs:
min(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
max = checkpoints.length - 1

IRs:
REF_158 -> LENGTH checkpoints
TMP_351(uint256) = REF_158 - 1
max(uint256) := TMP_351(uint256)"];
11->12;
12[label="Node Type: BEGIN_LOOP 12
"];
12->13;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
max > min

IRs:
TMP_352(bool) = max > min
CONDITION TMP_352"];
13->14[label="True"];
13->19[label="False"];
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
mid = (max + min + 1) / 2

IRs:
TMP_353(uint256) = max + min
TMP_354(uint256) = TMP_353 + 1
TMP_355(uint256) = TMP_354 / 2
mid(uint256) := TMP_355(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
checkpoints[mid].fromBlock <= _block

IRs:
REF_159(MiniMeToken.Checkpoint) -> checkpoints[mid]
REF_160(uint128) -> REF_159.fromBlock
TMP_356(bool) = REF_160 <= _block
CONDITION TMP_356"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
min = mid

IRs:
min(uint256) := mid(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
max = mid - 1

IRs:
TMP_357(uint256) = mid - 1
max(uint256) := TMP_357(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->13;
19[label="Node Type: END_LOOP 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
checkpoints[min].value

IRs:
REF_161(MiniMeToken.Checkpoint) -> checkpoints[min]
REF_162(uint128) -> REF_161.value
RETURN REF_162"];
}
// Function: 58.sol-AywakeToken-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_addr == 0

IRs:
TMP_367(bool) = _addr == 0
CONDITION TMP_367"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
size > 0

IRs:
TMP_368(bool) = size > 0
RETURN TMP_368"];
}
// Function: 58.sol-AywakeToken-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_369(bool) = a < b
CONDITION TMP_369"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 58.sol-AywakeToken-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_386(bool) = msg.sender == controller
TMP_387(None) = SOLIDITY_CALL require(bool)(TMP_386)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 58.sol-AywakeToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
version = MMT_0.2

IRs:
version(string) := MMT_0.2(string)"];
}
// Function: 58.sol-AywakeToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupplyAt(block.number)

IRs:
TMP_296(uint256) = INTERNAL_CALL, MiniMeToken.totalSupplyAt(uint256)(block.number)
RETURN TMP_296"];
}
// Function: 58.sol-AywakeToken-totalSupplyAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)

IRs:
REF_141 -> LENGTH totalSupplyHistory
TMP_305(bool) = REF_141 == 0
REF_142(MiniMeToken.Checkpoint) -> totalSupplyHistory[0]
REF_143(uint128) -> REF_142.fromBlock
TMP_306(bool) = REF_143 > _blockNumber
TMP_307(bool) = TMP_305 || TMP_306
CONDITION TMP_307"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_308 = CONVERT parentToken to address
TMP_309(bool) = TMP_308 != 0
CONDITION TMP_309"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_310(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_311(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:totalSupplyAt, arguments:['TMP_310']  
RETURN TMP_311"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(totalSupplyHistory,_blockNumber)

IRs:
TMP_312(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)
RETURN TMP_312"];
}
// Function: 58.sol-AywakeToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_249(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
doTransfer(msg.sender,_to,_amount)

IRs:
INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(msg.sender,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-AywakeToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != controller

IRs:
TMP_251(bool) = msg.sender != controller
CONDITION TMP_251"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_252(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowed[_from][msg.sender] >= _amount)

IRs:
REF_119(mapping(address => uint256)) -> allowed[_from]
REF_120(uint256) -> REF_119[msg.sender]
TMP_253(bool) = REF_120 >= _amount
TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_121(mapping(address => uint256)) -> allowed[_from]
REF_122(uint256) -> REF_121[msg.sender]
REF_122(-> allowed) = REF_122 - _amount"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
doTransfer(_from,_to,_amount)

IRs:
INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(_from,_to,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-AywakeToken-updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)

IRs:
REF_163 -> LENGTH checkpoints
TMP_358(bool) = REF_163 == 0
REF_164 -> LENGTH checkpoints
TMP_359(uint256) = REF_164 - 1
REF_165(MiniMeToken.Checkpoint) -> checkpoints[TMP_359]
REF_166(uint128) -> REF_165.fromBlock
TMP_360(bool) = REF_166 < block.number
TMP_361(bool) = TMP_358 || TMP_360
CONDITION TMP_361"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newCheckPoint = checkpoints[checkpoints.length ++]

IRs:
REF_167 -> LENGTH checkpoints
TMP_362(uint256) := REF_167(uint256)
REF_167(-> checkpoints) = REF_167 + 1
REF_168(MiniMeToken.Checkpoint) -> checkpoints[TMP_362]
newCheckPoint(MiniMeToken.Checkpoint) := REF_168(MiniMeToken.Checkpoint)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newCheckPoint.fromBlock = uint128(block.number)

IRs:
REF_169(uint128) -> newCheckPoint.fromBlock
TMP_363 = CONVERT block.number to uint128
REF_169(uint128) (->newCheckPoint) := TMP_363(uint128)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newCheckPoint.value = uint128(_value)

IRs:
REF_170(uint128) -> newCheckPoint.value
TMP_364 = CONVERT _value to uint128
REF_170(uint128) (->newCheckPoint) := TMP_364(uint128)"];
4->7;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
oldCheckPoint = checkpoints[checkpoints.length - 1]

IRs:
REF_171 -> LENGTH checkpoints
TMP_365(uint256) = REF_171 - 1
REF_172(MiniMeToken.Checkpoint) -> checkpoints[TMP_365]
oldCheckPoint(MiniMeToken.Checkpoint) := REF_172(MiniMeToken.Checkpoint)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
oldCheckPoint.value = uint128(_value)

IRs:
REF_173(uint128) -> oldCheckPoint.value
TMP_366 = CONVERT _value to uint128
REF_173(uint128) (->oldCheckPoint) := TMP_366(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 58.sol-Controlled-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 58.sol-Controlled-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 58.sol-Controlled-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_1(bool) = msg.sender == controller
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 58.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 58.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 58.sol-ERC20-approveAndCall(address,uint256,bytes)
digraph{
}
// Function: 58.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 58.sol-ERC20-doTransfer(address,address,uint256)
digraph{
}
// Function: 58.sol-ERC20-totalSupply()
digraph{
}
// Function: 58.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 58.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 58.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 58.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 58.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 58.sol-LimitedTransferToken-allowance(address,address)
digraph{
}
// Function: 58.sol-LimitedTransferToken-approve(address,uint256)
digraph{
}
// Function: 58.sol-LimitedTransferToken-approveAndCall(address,uint256,bytes)
digraph{
}
// Function: 58.sol-LimitedTransferToken-balanceOf(address)
digraph{
}
// Function: 58.sol-LimitedTransferToken-canTransfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value < transferableTokens(_sender,uint64(now)))

IRs:
TMP_168 = CONVERT now to uint64
TMP_169(uint256) = INTERNAL_CALL, LimitedTransferToken.transferableTokens(address,uint64)(_sender,TMP_168)
TMP_170(bool) = _value < TMP_169
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 58.sol-LimitedTransferToken-doTransfer(address,address,uint256)
digraph{
}
// Function: 58.sol-LimitedTransferToken-totalSupply()
digraph{
}
// Function: 58.sol-LimitedTransferToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_163(bool) = INTERNAL_CALL, ERC20Basic.transfer(address,uint256)(_to,_value)
RETURN TMP_163"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
canTransfer(msg.sender,_value)

IRs:
MODIFIER_CALL, LimitedTransferToken.canTransfer(address,uint256)(msg.sender,_value)"];
2->1;
}
// Function: 58.sol-LimitedTransferToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_165(bool) = INTERNAL_CALL, ERC20.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_165"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
canTransfer(_from,_value)

IRs:
MODIFIER_CALL, LimitedTransferToken.canTransfer(address,uint256)(_from,_value)"];
2->1;
}
// Function: 58.sol-LimitedTransferToken-transferableTokens(address,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOf(holder)

IRs:
TMP_167(uint256) = INTERNAL_CALL, ERC20Basic.balanceOf(address)(holder)
RETURN TMP_167"];
}
// Function: 58.sol-MiniMeToken-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 58.sol-MiniMeToken-MiniMeToken(address,address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenFactory = MiniMeTokenFactory(_tokenFactory)

IRs:
TMP_22 = CONVERT _tokenFactory to MiniMeTokenFactory
tokenFactory(MiniMeTokenFactory) := TMP_22(MiniMeTokenFactory)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
parentToken = MiniMeToken(_parentToken)

IRs:
TMP_23 = CONVERT _parentToken to MiniMeToken
parentToken(MiniMeToken) := TMP_23(MiniMeToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
parentSnapShotBlock = _parentSnapShotBlock

IRs:
parentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 58.sol-MiniMeToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_12(mapping(address => uint256)) -> allowed[_owner]
REF_13(uint256) -> REF_12[_spender]
RETURN REF_13"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 58.sol-MiniMeToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_57(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((_amount == 0) || (allowed[msg.sender][_spender] == 0))

IRs:
TMP_58(bool) = _amount == 0
REF_7(mapping(address => uint256)) -> allowed[msg.sender]
REF_8(uint256) -> REF_7[_spender]
TMP_59(bool) = REF_8 == 0
TMP_60(bool) = TMP_58 || TMP_59
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
isContract(controller)

IRs:
TMP_62(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_62"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))

IRs:
TMP_63 = CONVERT controller to TokenController
TMP_64(bool) = HIGH_LEVEL_CALL, dest:TMP_63(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[msg.sender][_spender] = _amount

IRs:
REF_10(mapping(address => uint256)) -> allowed[msg.sender]
REF_11(uint256) -> REF_10[_spender]
REF_11(uint256) (->allowed) := _amount(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Approval(msg.sender,_spender,_amount)

IRs:
Emit Approval(msg.sender,_spender,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-MiniMeToken-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approve(_spender,_amount))

IRs:
TMP_67(bool) = INTERNAL_CALL, MiniMeToken.approve(address,uint256)(_spender,_amount)
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)

IRs:
TMP_69 = CONVERT _spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_69(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-MiniMeToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOfAt(_owner,block.number)

IRs:
TMP_56(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_owner,block.number)
RETURN TMP_56"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 58.sol-MiniMeToken-balanceOfAt(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)

IRs:
REF_15(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_16 -> LENGTH REF_15
TMP_72(bool) = REF_16 == 0
REF_17(MiniMeToken.Checkpoint[]) -> balances[_owner]
REF_18(MiniMeToken.Checkpoint) -> REF_17[0]
REF_19(uint128) -> REF_18.fromBlock
TMP_73(bool) = REF_19 > _blockNumber
TMP_74(bool) = TMP_72 || TMP_73
CONDITION TMP_74"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_75 = CONVERT parentToken to address
TMP_76(bool) = TMP_75 != 0
CONDITION TMP_76"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_77(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_78(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:balanceOfAt, arguments:['_owner', 'TMP_77']  
RETURN TMP_78"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(balances[_owner],_blockNumber)

IRs:
REF_21(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_79(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(REF_21,_blockNumber)
RETURN TMP_79"];
}
// Function: 58.sol-MiniMeToken-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 58.sol-MiniMeToken-claimTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_151(bool) = _token == 0
CONDITION TMP_151"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_153 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_153(MiniMeToken)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_154(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_154(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_155(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 58.sol-MiniMeToken-createCloneToken(string,uint8,string,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_snapshotBlock == 0

IRs:
TMP_88(bool) = _snapshotBlock == 0
CONDITION TMP_88"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_snapshotBlock = block.number

IRs:
_snapshotBlock(uint256) := block.number(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)

IRs:
TMP_89(MiniMeToken) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  
cloneToken(MiniMeToken) := TMP_89(MiniMeToken)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
cloneToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:cloneToken(MiniMeToken), function:changeController, arguments:['msg.sender']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
NewCloneToken(address(cloneToken),_snapshotBlock)

IRs:
TMP_91 = CONVERT cloneToken to address
Emit NewCloneToken(TMP_91,_snapshotBlock)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
address(cloneToken)

IRs:
TMP_93 = CONVERT cloneToken to address
RETURN TMP_93"];
}
// Function: 58.sol-MiniMeToken-destroyTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_108(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_108(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply >= _amount)

IRs:
TMP_109(bool) = curTotalSupply >= _amount
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceFrom = balanceOf(_owner)

IRs:
TMP_111(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceFrom(uint256) := TMP_111(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_112(bool) = previousBalanceFrom >= _amount
TMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)

IRs:
TMP_114(uint256) = curTotalSupply - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_114)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceFrom - _amount)

IRs:
REF_29(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_116(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_29,TMP_116)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_owner,0,_amount)

IRs:
Emit Transfer(_owner,0,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 58.sol-MiniMeToken-doTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_31(bool) = _amount == 0
CONDITION TMP_31"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(parentSnapShotBlock < block.number)

IRs:
TMP_33(bool) = parentSnapShotBlock < block.number
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)((_to != 0) && (_to != address(this)))

IRs:
TMP_35(bool) = _to != 0
TMP_36 = CONVERT this to address
TMP_37(bool) = _to != TMP_36
TMP_38(bool) = TMP_35 && TMP_37
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
previousBalanceFrom = balanceOfAt(_from,block.number)

IRs:
TMP_40(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_from,block.number)
previousBalanceFrom(uint256) := TMP_40(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(previousBalanceFrom >= _amount)

IRs:
TMP_41(bool) = previousBalanceFrom >= _amount
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
isContract(controller)

IRs:
TMP_43(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
CONDITION TMP_43"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(TokenController(controller).onTransfer(_from,_to,_amount))

IRs:
TMP_44 = CONVERT controller to TokenController
TMP_45(bool) = HIGH_LEVEL_CALL, dest:TMP_44(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
updateValueAtNow(balances[_from],previousBalanceFrom - _amount)

IRs:
REF_5(MiniMeToken.Checkpoint[]) -> balances[_from]
TMP_47(uint256) = previousBalanceFrom - _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_5,TMP_47)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
previousBalanceTo = balanceOfAt(_to,block.number)

IRs:
TMP_49(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_to,block.number)
previousBalanceTo(uint256) := TMP_49(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_50(uint256) = previousBalanceTo + _amount
TMP_51(bool) = TMP_50 >= previousBalanceTo
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
updateValueAtNow(balances[_to],previousBalanceTo + _amount)

IRs:
REF_6(MiniMeToken.Checkpoint[]) -> balances[_to]
TMP_53(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_6,TMP_53)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
}
// Function: 58.sol-MiniMeToken-enableTransfers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 58.sol-MiniMeToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_145(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_147 = CONVERT controller to TokenController
TMP_149(bool) = HIGH_LEVEL_CALL, dest:TMP_147(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)"];
}
// Function: 58.sol-MiniMeToken-generateTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTotalSupply = totalSupply()

IRs:
TMP_94(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()
curTotalSupply(uint256) := TMP_94(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(curTotalSupply + _amount >= curTotalSupply)

IRs:
TMP_95(uint256) = curTotalSupply + _amount
TMP_96(bool) = TMP_95 >= curTotalSupply
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalanceTo = balanceOf(_owner)

IRs:
TMP_98(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)
previousBalanceTo(uint256) := TMP_98(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(previousBalanceTo + _amount >= previousBalanceTo)

IRs:
TMP_99(uint256) = previousBalanceTo + _amount
TMP_100(bool) = TMP_99 >= previousBalanceTo
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)

IRs:
TMP_102(uint256) = curTotalSupply + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_102)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateValueAtNow(balances[_owner],previousBalanceTo + _amount)

IRs:
REF_28(MiniMeToken.Checkpoint[]) -> balances[_owner]
TMP_104(uint256) = previousBalanceTo + _amount
INTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_28,TMP_104)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0,_owner,_amount)

IRs:
Emit Transfer(0,_owner,_amount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
9->1;
}
// Function: 58.sol-MiniMeToken-getValueAt(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
checkpoints.length == 0

IRs:
REF_30 -> LENGTH checkpoints
TMP_121(bool) = REF_30 == 0
CONDITION TMP_121"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_block >= checkpoints[checkpoints.length - 1].fromBlock

IRs:
REF_31 -> LENGTH checkpoints
TMP_122(uint256) = REF_31 - 1
REF_32(MiniMeToken.Checkpoint) -> checkpoints[TMP_122]
REF_33(uint128) -> REF_32.fromBlock
TMP_123(bool) = _block >= REF_33
CONDITION TMP_123"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
checkpoints[checkpoints.length - 1].value

IRs:
REF_34 -> LENGTH checkpoints
TMP_124(uint256) = REF_34 - 1
REF_35(MiniMeToken.Checkpoint) -> checkpoints[TMP_124]
REF_36(uint128) -> REF_35.value
RETURN REF_36"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_block < checkpoints[0].fromBlock

IRs:
REF_37(MiniMeToken.Checkpoint) -> checkpoints[0]
REF_38(uint128) -> REF_37.fromBlock
TMP_125(bool) = _block < REF_38
CONDITION TMP_125"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
0

IRs:
RETURN 0"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
min = 0

IRs:
min(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
max = checkpoints.length - 1

IRs:
REF_39 -> LENGTH checkpoints
TMP_126(uint256) = REF_39 - 1
max(uint256) := TMP_126(uint256)"];
11->12;
12[label="Node Type: BEGIN_LOOP 12
"];
12->13;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
max > min

IRs:
TMP_127(bool) = max > min
CONDITION TMP_127"];
13->14[label="True"];
13->19[label="False"];
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
mid = (max + min + 1) / 2

IRs:
TMP_128(uint256) = max + min
TMP_129(uint256) = TMP_128 + 1
TMP_130(uint256) = TMP_129 / 2
mid(uint256) := TMP_130(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
checkpoints[mid].fromBlock <= _block

IRs:
REF_40(MiniMeToken.Checkpoint) -> checkpoints[mid]
REF_41(uint128) -> REF_40.fromBlock
TMP_131(bool) = REF_41 <= _block
CONDITION TMP_131"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
min = mid

IRs:
min(uint256) := mid(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
max = mid - 1

IRs:
TMP_132(uint256) = mid - 1
max(uint256) := TMP_132(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->13;
19[label="Node Type: END_LOOP 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
checkpoints[min].value

IRs:
REF_42(MiniMeToken.Checkpoint) -> checkpoints[min]
REF_43(uint128) -> REF_42.value
RETURN REF_43"];
}
// Function: 58.sol-MiniMeToken-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_addr == 0

IRs:
TMP_142(bool) = _addr == 0
CONDITION TMP_142"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
size > 0

IRs:
TMP_143(bool) = size > 0
RETURN TMP_143"];
}
// Function: 58.sol-MiniMeToken-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_144(bool) = a < b
CONDITION TMP_144"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 58.sol-MiniMeToken-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_158(bool) = msg.sender == controller
TMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 58.sol-MiniMeToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
version = MMT_0.2

IRs:
version(string) := MMT_0.2(string)"];
}
// Function: 58.sol-MiniMeToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupplyAt(block.number)

IRs:
TMP_71(uint256) = INTERNAL_CALL, MiniMeToken.totalSupplyAt(uint256)(block.number)
RETURN TMP_71"];
}
// Function: 58.sol-MiniMeToken-totalSupplyAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)

IRs:
REF_22 -> LENGTH totalSupplyHistory
TMP_80(bool) = REF_22 == 0
REF_23(MiniMeToken.Checkpoint) -> totalSupplyHistory[0]
REF_24(uint128) -> REF_23.fromBlock
TMP_81(bool) = REF_24 > _blockNumber
TMP_82(bool) = TMP_80 || TMP_81
CONDITION TMP_82"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
address(parentToken) != 0

IRs:
TMP_83 = CONVERT parentToken to address
TMP_84(bool) = TMP_83 != 0
CONDITION TMP_84"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
parentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))

IRs:
TMP_85(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)
TMP_86(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:totalSupplyAt, arguments:['TMP_85']  
RETURN TMP_86"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: RETURN 6

EXPRESSION:
getValueAt(totalSupplyHistory,_blockNumber)

IRs:
TMP_87(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)
RETURN TMP_87"];
}
// Function: 58.sol-MiniMeToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_24(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
doTransfer(msg.sender,_to,_amount)

IRs:
INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(msg.sender,_to,_amount)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-MiniMeToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != controller

IRs:
TMP_26(bool) = msg.sender != controller
CONDITION TMP_26"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_27(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowed[_from][msg.sender] >= _amount)

IRs:
REF_0(mapping(address => uint256)) -> allowed[_from]
REF_1(uint256) -> REF_0[msg.sender]
TMP_28(bool) = REF_1 >= _amount
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_2(mapping(address => uint256)) -> allowed[_from]
REF_3(uint256) -> REF_2[msg.sender]
REF_3(-> allowed) = REF_3 - _amount"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
doTransfer(_from,_to,_amount)

IRs:
INTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(_from,_to,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 58.sol-MiniMeToken-updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)

IRs:
REF_44 -> LENGTH checkpoints
TMP_133(bool) = REF_44 == 0
REF_45 -> LENGTH checkpoints
TMP_134(uint256) = REF_45 - 1
REF_46(MiniMeToken.Checkpoint) -> checkpoints[TMP_134]
REF_47(uint128) -> REF_46.fromBlock
TMP_135(bool) = REF_47 < block.number
TMP_136(bool) = TMP_133 || TMP_135
CONDITION TMP_136"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newCheckPoint = checkpoints[checkpoints.length ++]

IRs:
REF_48 -> LENGTH checkpoints
TMP_137(uint256) := REF_48(uint256)
REF_48(-> checkpoints) = REF_48 + 1
REF_49(MiniMeToken.Checkpoint) -> checkpoints[TMP_137]
newCheckPoint(MiniMeToken.Checkpoint) := REF_49(MiniMeToken.Checkpoint)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newCheckPoint.fromBlock = uint128(block.number)

IRs:
REF_50(uint128) -> newCheckPoint.fromBlock
TMP_138 = CONVERT block.number to uint128
REF_50(uint128) (->newCheckPoint) := TMP_138(uint128)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newCheckPoint.value = uint128(_value)

IRs:
REF_51(uint128) -> newCheckPoint.value
TMP_139 = CONVERT _value to uint128
REF_51(uint128) (->newCheckPoint) := TMP_139(uint128)"];
4->7;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
oldCheckPoint = checkpoints[checkpoints.length - 1]

IRs:
REF_52 -> LENGTH checkpoints
TMP_140(uint256) = REF_52 - 1
REF_53(MiniMeToken.Checkpoint) -> checkpoints[TMP_140]
oldCheckPoint(MiniMeToken.Checkpoint) := REF_53(MiniMeToken.Checkpoint)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
oldCheckPoint.value = uint128(_value)

IRs:
REF_54(uint128) -> oldCheckPoint.value
TMP_141 = CONVERT _value to uint128
REF_54(uint128) (->oldCheckPoint) := TMP_141(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 58.sol-MiniMeTokenFactory-createCloneToken(address,uint256,string,uint8,string,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
newToken = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled)

IRs:
TMP_161(MiniMeToken) = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) 
newToken(MiniMeToken) := TMP_161(MiniMeToken)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:newToken(MiniMeToken), function:changeController, arguments:['msg.sender']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
newToken

IRs:
RETURN newToken"];
}
// Function: 58.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_13(uint256) = a + b
c(uint256) := TMP_13(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a)

IRs:
TMP_14(bool) = c >= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_14)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 58.sol-SafeMath-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(assertion)

IRs:
TMP_20(None) = SOLIDITY_CALL require(bool)(assertion)"];
}
// Function: 58.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_9(uint256) = a / b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 58.sol-SafeMath-max256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_18(bool) = a >= b
CONDITION TMP_18"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 58.sol-SafeMath-max64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_16(bool) = a >= b
CONDITION TMP_16"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 58.sol-SafeMath-min256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_19(bool) = a < b
CONDITION TMP_19"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 58.sol-SafeMath-min64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_17(bool) = a < b
CONDITION TMP_17"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 58.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_3(uint256) = a * b
c(uint256) := TMP_3(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_4(bool) = a == 0
TMP_5(uint256) = c / a
TMP_6(bool) = TMP_5 == b
TMP_7(bool) = TMP_4 || TMP_6
INTERNAL_CALL, SafeMath.assert(bool)(TMP_7)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 58.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_10(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_10)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_12(uint256) = a - b
RETURN TMP_12"];
}
// Function: 58.sol-TokenController-onApprove(address,address,uint256)
digraph{
}
// Function: 58.sol-TokenController-onTransfer(address,address,uint256)
digraph{
}
// Function: 58.sol-TokenController-proxyPayment(address)
digraph{
}
// Function: 58.sol-VestedToken-Controlled()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = msg.sender

IRs:
controller(address) := msg.sender(address)"];
}
// Function: 58.sol-VestedToken-allowance(address,address)
digraph{
}
// Function: 58.sol-VestedToken-approve(address,uint256)
digraph{
}
// Function: 58.sol-VestedToken-approveAndCall(address,uint256,bytes)
digraph{
}
// Function: 58.sol-VestedToken-balanceOf(address)
digraph{
}
// Function: 58.sol-VestedToken-calculateVestedTokens(uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
time < cliff

IRs:
TMP_222(bool) = time < cliff
CONDITION TMP_222"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
time >= vesting

IRs:
TMP_223(bool) = time >= vesting
CONDITION TMP_223"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
tokens

IRs:
RETURN tokens"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
vestedTokens = SafeMath.div(SafeMath.mul(tokens,SafeMath.sub(time,start)),SafeMath.sub(vesting,start))

IRs:
TMP_224(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['time', 'start'] 
TMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'TMP_224'] 
TMP_226(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['vesting', 'start'] 
TMP_227(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_225', 'TMP_226'] 
vestedTokens(uint256) := TMP_227(uint256)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
vestedTokens

IRs:
RETURN vestedTokens"];
}
// Function: 58.sol-VestedToken-canTransfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value < transferableTokens(_sender,uint64(now)))

IRs:
TMP_243 = CONVERT now to uint64
TMP_244(uint256) = INTERNAL_CALL, VestedToken.transferableTokens(address,uint64)(_sender,TMP_243)
TMP_245(bool) = _value < TMP_244
TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 58.sol-VestedToken-changeController(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
controller = _newController

IRs:
controller(address) := _newController(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
2->1;
}
// Function: 58.sol-VestedToken-doTransfer(address,address,uint256)
digraph{
}
// Function: 58.sol-VestedToken-grantVestedTokens(address,uint256,uint64,uint64,uint64,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_cliff > _start && _vesting > _cliff)

IRs:
TMP_178(bool) = _cliff > _start
TMP_179(bool) = _vesting > _cliff
TMP_180(bool) = TMP_178 && TMP_179
TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenGrantsCount(_to) < MAX_GRANTS_PER_ADDRESS)

IRs:
TMP_182(uint256) = INTERNAL_CALL, VestedToken.tokenGrantsCount(address)(_to)
TMP_183(bool) = TMP_182 < MAX_GRANTS_PER_ADDRESS
TMP_184(None) = SOLIDITY_CALL require(bool)(TMP_183)"];
2->7;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
transfer(_to,_value)

IRs:
TMP_185(bool) = INTERNAL_CALL, LimitedTransferToken.transfer(address,uint256)(_to,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
NewTokenGrant(msg.sender,_to,_value,count - 1)

IRs:
TMP_186(uint256) = count - 1
Emit NewTokenGrant(msg.sender,_to,_value,TMP_186)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()"];
6->1;
7[label="Node Type: IF 7

EXPRESSION:
_revokable

IRs:
CONDITION _revokable"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
count = grants[_to].push(TokenGrant(msg.sender,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke))

IRs:
REF_62(VestedToken.TokenGrant[]) -> grants[_to]
TMP_189(VestedToken.TokenGrant) = new TokenGrant(msg.sender,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke)
REF_64 -> LENGTH REF_62
TMP_191(uint256) := REF_64(uint256)
TMP_192(uint256) = TMP_191 + 1
REF_64(uint256) (->grants) := TMP_192(uint256)
REF_65(VestedToken.TokenGrant) -> REF_62[TMP_191]
REF_65(VestedToken.TokenGrant) (->grants) := TMP_189(VestedToken.TokenGrant)
count(uint256) := TMP_190(None)"];
8->10;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
count = grants[_to].push(TokenGrant(0,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke))

IRs:
REF_66(VestedToken.TokenGrant[]) -> grants[_to]
TMP_193(VestedToken.TokenGrant) = new TokenGrant(0,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke)
REF_68 -> LENGTH REF_66
TMP_195(uint256) := REF_68(uint256)
TMP_196(uint256) = TMP_195 + 1
REF_68(uint256) (->grants) := TMP_196(uint256)
REF_69(VestedToken.TokenGrant) -> REF_66[TMP_195]
REF_69(VestedToken.TokenGrant) (->grants) := TMP_193(VestedToken.TokenGrant)
count(uint256) := TMP_194(None)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->4;
}
// Function: 58.sol-VestedToken-lastTokenIsTransferableDate(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
date = uint64(now)

IRs:
TMP_237 = CONVERT now to uint64
date(uint64) := TMP_237(uint64)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
grantIndex = grants[holder].length

IRs:
REF_113(VestedToken.TokenGrant[]) -> grants[holder]
REF_114 -> LENGTH REF_113
grantIndex(uint256) := REF_114(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->9;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < grantIndex

IRs:
TMP_238(bool) = i < grantIndex
CONDITION TMP_238"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
date = SafeMath.max64(grants[holder][i].vesting,date)

IRs:
REF_116(VestedToken.TokenGrant[]) -> grants[holder]
REF_117(VestedToken.TokenGrant) -> REF_116[i]
REF_118(uint64) -> REF_117.vesting
TMP_239(uint64) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.max64(uint64,uint64), arguments:['REF_118', 'date'] 
date(uint64) := TMP_239(uint64)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_240(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
9[label="Node Type: RETURN 9

EXPRESSION:
date

IRs:
RETURN date"];
}
// Function: 58.sol-VestedToken-nonVestedTokens(VestedToken.TokenGrant,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
grant.value.sub(vestedTokens(grant,time))

IRs:
REF_111(uint256) -> grant.value
TMP_235(uint256) = INTERNAL_CALL, VestedToken.vestedTokens(VestedToken.TokenGrant,uint64)(grant,time)
TMP_236(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', 'TMP_235'] 
RETURN TMP_236"];
}
// Function: 58.sol-VestedToken-onlyController()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == controller)

IRs:
TMP_241(bool) = msg.sender == controller
TMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 58.sol-VestedToken-revokeAllTokenGrants(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
grantsCount = tokenGrantsCount(_holder)

IRs:
TMP_207(uint256) = INTERNAL_CALL, VestedToken.tokenGrantsCount(address)(_holder)
grantsCount(uint256) := TMP_207(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < grantsCount

IRs:
TMP_208(bool) = i < grantsCount
CONDITION TMP_208"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
revokeTokenGrant(_holder,0)

IRs:
INTERNAL_CALL, VestedToken.revokeTokenGrant(address,uint256)(_holder,0)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_210(uint256) := i(uint256)
i(uint256) = i + 1"];
7->5;
}
// Function: 58.sol-VestedToken-revokeTokenGrant(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
grant = grants[_holder][_grantId]

IRs:
REF_70(VestedToken.TokenGrant[]) -> grants[_holder]
REF_71(VestedToken.TokenGrant) -> REF_70[_grantId]
grant(VestedToken.TokenGrant) := REF_71(VestedToken.TokenGrant)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(grant.revokable)

IRs:
REF_72(bool) -> grant.revokable
TMP_197(None) = SOLIDITY_CALL require(bool)(REF_72)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(grant.granter == msg.sender)

IRs:
REF_73(address) -> grant.granter
TMP_198(bool) = REF_73 == msg.sender
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_grantId >= grants[_holder].length)

IRs:
REF_74(VestedToken.TokenGrant[]) -> grants[_holder]
REF_75 -> LENGTH REF_74
TMP_200(bool) = _grantId >= REF_75
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)"];
4->12;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
nonVested = nonVestedTokens(grant,uint64(now))

IRs:
TMP_202 = CONVERT now to uint64
TMP_203(uint256) = INTERNAL_CALL, VestedToken.nonVestedTokens(VestedToken.TokenGrant,uint64)(grant,TMP_202)
nonVested(uint256) := TMP_203(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
delete grants[_holder][_grantId]

IRs:
REF_76(VestedToken.TokenGrant[]) -> grants[_holder]
REF_77(VestedToken.TokenGrant) -> REF_76[_grantId]
REF_76 = delete REF_77 "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
grants[_holder][_grantId] = grants[_holder][grants[_holder].length - 1]

IRs:
REF_78(VestedToken.TokenGrant[]) -> grants[_holder]
REF_79(VestedToken.TokenGrant) -> REF_78[_grantId]
REF_80(VestedToken.TokenGrant[]) -> grants[_holder]
REF_81(VestedToken.TokenGrant[]) -> grants[_holder]
REF_82 -> LENGTH REF_81
TMP_204(uint256) = REF_82 - 1
REF_83(VestedToken.TokenGrant) -> REF_80[TMP_204]
REF_79(VestedToken.TokenGrant) (->grants) := REF_83(VestedToken.TokenGrant)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
grants[_holder].length -= 1

IRs:
REF_84(VestedToken.TokenGrant[]) -> grants[_holder]
REF_85 -> LENGTH REF_84
REF_85(-> grants) = REF_85 - 1"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
doTransfer(_holder,receiver,nonVested)

IRs:
TMP_205(bool) = INTERNAL_CALL, ERC20.doTransfer(address,address,uint256)(_holder,receiver,nonVested)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Transfer(_holder,receiver,nonVested)

IRs:
Emit Transfer(_holder,receiver,nonVested)"];
12[label="Node Type: IF 12

EXPRESSION:
grant.burnsOnRevoke

IRs:
REF_86(bool) -> grant.burnsOnRevoke
CONDITION REF_86"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
receiver = 0xdead

IRs:
receiver(address) := 57005(uint256)"];
13->15;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
receiver = msg.sender

IRs:
receiver(address) := msg.sender(address)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->6;
}
// Function: 58.sol-VestedToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_GRANTS_PER_ADDRESS = 20

IRs:
MAX_GRANTS_PER_ADDRESS(uint256) := 20(uint256)"];
}
// Function: 58.sol-VestedToken-tokenGrant(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
grant = grants[_holder][_grantId]

IRs:
REF_98(VestedToken.TokenGrant[]) -> grants[_holder]
REF_99(VestedToken.TokenGrant) -> REF_98[_grantId]
grant(VestedToken.TokenGrant) := REF_99(VestedToken.TokenGrant)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
granter = grant.granter

IRs:
REF_100(address) -> grant.granter
granter(address) := REF_100(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
value = grant.value

IRs:
REF_101(uint256) -> grant.value
value(uint256) := REF_101(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
start = grant.start

IRs:
REF_102(uint64) -> grant.start
start(uint64) := REF_102(uint64)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
cliff = grant.cliff

IRs:
REF_103(uint64) -> grant.cliff
cliff(uint64) := REF_103(uint64)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
vesting = grant.vesting

IRs:
REF_104(uint64) -> grant.vesting
vesting(uint64) := REF_104(uint64)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
revokable = grant.revokable

IRs:
REF_105(bool) -> grant.revokable
revokable(bool) := REF_105(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
burnsOnRevoke = grant.burnsOnRevoke

IRs:
REF_106(bool) -> grant.burnsOnRevoke
burnsOnRevoke(bool) := REF_106(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
vested = vestedTokens(grant,uint64(now))

IRs:
TMP_228 = CONVERT now to uint64
TMP_229(uint256) = INTERNAL_CALL, VestedToken.vestedTokens(VestedToken.TokenGrant,uint64)(grant,TMP_228)
vested(uint256) := TMP_229(uint256)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
(granter,value,vested,start,cliff,vesting,revokable,burnsOnRevoke)

IRs:
RETURN granter,value,vested,start,cliff,vesting,revokable,burnsOnRevoke"];
}
// Function: 58.sol-VestedToken-tokenGrantsCount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
grants[_holder].length

IRs:
REF_92(VestedToken.TokenGrant[]) -> grants[_holder]
REF_93 -> LENGTH REF_92
RETURN REF_93"];
2[label="Node Type: RETURN 2

EXPRESSION:
index

IRs:
RETURN index"];
}
// Function: 58.sol-VestedToken-totalSupply()
digraph{
}
// Function: 58.sol-VestedToken-transfer(address,uint256)
digraph{
}
// Function: 58.sol-VestedToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 58.sol-VestedToken-transferableTokens(address,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
grantIndex = tokenGrantsCount(holder)

IRs:
TMP_211(uint256) = INTERNAL_CALL, VestedToken.tokenGrantsCount(address)(holder)
grantIndex(uint256) := TMP_211(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
grantIndex == 0

IRs:
TMP_212(bool) = grantIndex == 0
CONDITION TMP_212"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
balanceOf(holder)

IRs:
TMP_213(uint256) = INTERNAL_CALL, ERC20Basic.balanceOf(address)(holder)
RETURN TMP_213"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
nonVested = 0

IRs:
nonVested(uint256) := 0(uint256)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
7->12;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i < grantIndex

IRs:
TMP_214(bool) = i < grantIndex
CONDITION TMP_214"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nonVested = SafeMath.add(nonVested,nonVestedTokens(grants[holder][i],time))

IRs:
REF_88(VestedToken.TokenGrant[]) -> grants[holder]
REF_89(VestedToken.TokenGrant) -> REF_88[i]
TMP_215(uint256) = INTERNAL_CALL, VestedToken.nonVestedTokens(VestedToken.TokenGrant,uint64)(REF_89,time)
TMP_216(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['nonVested', 'TMP_215'] 
nonVested(uint256) := TMP_216(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_217(uint256) := i(uint256)
i(uint256) = i + 1"];
11->9;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
vestedTransferable = SafeMath.sub(balanceOf(holder),nonVested)

IRs:
TMP_218(uint256) = INTERNAL_CALL, ERC20Basic.balanceOf(address)(holder)
TMP_219(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_218', 'nonVested'] 
vestedTransferable(uint256) := TMP_219(uint256)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
SafeMath.min256(vestedTransferable,super.transferableTokens(holder,time))

IRs:
TMP_220(uint256) = INTERNAL_CALL, LimitedTransferToken.transferableTokens(address,uint64)(holder,time)
TMP_221(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.min256(uint256,uint256), arguments:['vestedTransferable', 'TMP_220'] 
RETURN TMP_221"];
}
// Function: 58.sol-VestedToken-vestedTokens(VestedToken.TokenGrant,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
calculateVestedTokens(grant.value,uint256(time),uint256(grant.start),uint256(grant.cliff),uint256(grant.vesting))

IRs:
REF_107(uint256) -> grant.value
TMP_230 = CONVERT time to uint256
REF_108(uint64) -> grant.start
TMP_231 = CONVERT REF_108 to uint256
REF_109(uint64) -> grant.cliff
TMP_232 = CONVERT REF_109 to uint256
REF_110(uint64) -> grant.vesting
TMP_233 = CONVERT REF_110 to uint256
TMP_234(uint256) = INTERNAL_CALL, VestedToken.calculateVestedTokens(uint256,uint256,uint256,uint256,uint256)(REF_107,TMP_230,TMP_231,TMP_232,TMP_233)
RETURN TMP_234"];
}
}
