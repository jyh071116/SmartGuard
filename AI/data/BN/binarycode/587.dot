digraph G {
// Function: 587.sol-Base-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_locks <= 0)

IRs:
TMP_13(bool) = _locks <= 0
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_15(uint256) = 0 - 1
TMP_16 = CONVERT TMP_15 to uint256
bitlocks(uint256) := TMP_16(uint256)"];
3->4;
4[label="Node Type: _ 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 587.sol-Base-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == allowed)

IRs:
TMP_17(bool) = msg.sender == allowed
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Base-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.data.length == size + 4)

IRs:
REF_0 -> LENGTH msg.data
TMP_19(uint256) = size + 4
TMP_20(bool) = REF_0 == TMP_19
TMP_21(None) = SOLIDITY_CALL assert(bool)(TMP_20)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Base-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
bitlocks = 0

IRs:
bitlocks(uint256) := 0(uint256)"];
}
// Function: 587.sol-ERC20-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_19(mapping(address => uint256)) -> allowed[_owner]
REF_20(uint256) -> REF_19[_spender]
RETURN REF_20"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 587.sol-ERC20-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_17(mapping(address => uint256)) -> allowed[msg.sender]
REF_18(uint256) -> REF_17[_spender]
REF_18(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_42(uint256) = 2 * 32
MODIFIER_CALL, Base.onlyPayloadSize(uint256)(TMP_42)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-ERC20-approve_fixed(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
allowed[msg.sender][_spender] == _currentValue

IRs:
REF_13(mapping(address => uint256)) -> allowed[msg.sender]
REF_14(uint256) -> REF_13[_spender]
TMP_35(bool) = REF_14 == _currentValue
CONDITION TMP_35"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_15(mapping(address => uint256)) -> allowed[msg.sender]
REF_16(uint256) -> REF_15[_spender]
REF_16(uint256) (->allowed) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyPayloadSize(3 * 32)

IRs:
TMP_38(uint256) = 3 * 32
MODIFIER_CALL, Base.onlyPayloadSize(uint256)(TMP_38)"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-ERC20-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_12(uint256) -> balances[_owner]
RETURN REF_12"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 587.sol-ERC20-isFrozenOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFrozen)

IRs:
TMP_55(None) = SOLIDITY_CALL require(bool)(isFrozen)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-ERC20-isNotFrozenOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFrozen)

IRs:
TMP_53 = UnaryType.BANG isFrozen 
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-ERC20-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_locks <= 0)

IRs:
TMP_44(bool) = _locks <= 0
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_46(uint256) = 0 - 1
TMP_47 = CONVERT TMP_46 to uint256
bitlocks(uint256) := TMP_47(uint256)"];
3->4;
4[label="Node Type: _ 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 587.sol-ERC20-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == allowed)

IRs:
TMP_48(bool) = msg.sender == allowed
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-ERC20-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.data.length == size + 4)

IRs:
REF_21 -> LENGTH msg.data
TMP_50(uint256) = size + 4
TMP_51(bool) = REF_21 == TMP_50
TMP_52(None) = SOLIDITY_CALL assert(bool)(TMP_51)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-ERC20-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFrozen = false

IRs:
isFrozen(bool) := False(bool)"];
}
// Function: 587.sol-ERC20-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_22 = CONVERT 0 to address
TMP_23(bool) = _to != TMP_22
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_to != address(this))

IRs:
TMP_25 = CONVERT this to address
TMP_26(bool) = _to != TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_1(uint256) -> balances[_from]
REF_2(uint256) -> balances[_from]
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_28(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_29(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_7(mapping(address => uint256)) -> allowed[_from]
REF_8(uint256) -> REF_7[msg.sender]
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_10', '_value'] 
REF_8(uint256) (->allowed) := TMP_30(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyPayloadSize(3 * 32)

IRs:
TMP_33(uint256) = 3 * 32
MODIFIER_CALL, Base.onlyPayloadSize(uint256)(TMP_33)"];
9->1;
10[label="Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 587.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_6(uint256) = a / b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 587.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 587.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_7(bool) = b <= a
TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_9(uint256) = a - b
RETURN TMP_9"];
}
// Function: 587.sol-Token-_mint(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[projectWallet] = balances[projectWallet].add(_tokensProject)

IRs:
REF_93(uint256) -> balances[projectWallet]
REF_94(uint256) -> balances[projectWallet]
TMP_170(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_94', '_tokensProject'] 
REF_93(uint256) (->balances) := TMP_170(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[foundersWallet] = balances[foundersWallet].add(_tokensFounders)

IRs:
REF_96(uint256) -> balances[foundersWallet]
REF_97(uint256) -> balances[foundersWallet]
TMP_171(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_97', '_tokensFounders'] 
REF_96(uint256) (->balances) := TMP_171(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(_tokensContributor)

IRs:
REF_99(uint256) -> balances[msg.sender]
REF_100(uint256) -> balances[msg.sender]
TMP_172(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_100', '_tokensContributor'] 
REF_99(uint256) (->balances) := TMP_172(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
invBalances[msg.sender] = invBalances[msg.sender].add(_tokensContributor).add(_tokensFounders).add(_tokensProject)

IRs:
REF_102(uint256) -> invBalances[msg.sender]
REF_103(uint256) -> invBalances[msg.sender]
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_103', '_tokensContributor'] 
TMP_174(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_173', '_tokensFounders'] 
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_174', '_tokensProject'] 
REF_102(uint256) (->invBalances) := TMP_175(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalInvSupply = totalInvSupply.add(_tokensContributor).add(_tokensFounders).add(_tokensProject)

IRs:
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalInvSupply', '_tokensContributor'] 
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_176', '_tokensFounders'] 
TMP_178(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_177', '_tokensProject'] 
totalInvSupply(uint256) := TMP_178(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalSupply = totalSupply.add(_tokensProject).add(_tokensFounders).add(_tokensContributor)

IRs:
TMP_179(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_tokensProject'] 
TMP_180(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_179', '_tokensFounders'] 
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_180', '_tokensContributor'] 
totalSupply(uint256) := TMP_181(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0x0,msg.sender,_tokensContributor)

IRs:
Emit Transfer(0,msg.sender,_tokensContributor)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(0x0,projectWallet,_tokensProject)

IRs:
Emit Transfer(0,projectWallet,_tokensProject)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(0x0,foundersWallet,_tokensFounders)

IRs:
Emit Transfer(0,foundersWallet,_tokensFounders)"];
}
// Function: 587.sol-Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_47(mapping(address => uint256)) -> allowed[_owner]
REF_48(uint256) -> REF_47[_spender]
RETURN REF_48"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 587.sol-Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
REF_46(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_82(uint256) = 2 * 32
MODIFIER_CALL, Base.onlyPayloadSize(uint256)(TMP_82)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-Token-approve_fixed(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
allowed[msg.sender][_spender] == _currentValue

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
TMP_75(bool) = REF_42 == _currentValue
CONDITION TMP_75"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyPayloadSize(3 * 32)

IRs:
TMP_78(uint256) = 3 * 32
MODIFIER_CALL, Base.onlyPayloadSize(uint256)(TMP_78)"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_40(uint256) -> balances[_owner]
RETURN REF_40"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 587.sol-Token-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_amount)

IRs:
REF_71(uint256) -> balances[msg.sender]
REF_72(uint256) -> balances[msg.sender]
TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_72', '_amount'] 
REF_71(uint256) (->balances) := TMP_129(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[burnAddress] = balances[burnAddress].add(_amount)

IRs:
REF_74(uint256) -> balances[burnAddress]
REF_75(uint256) -> balances[burnAddress]
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_75', '_amount'] 
REF_74(uint256) (->balances) := TMP_130(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply = totalSupply.sub(_amount)

IRs:
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_131(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,burnAddress,_amount)

IRs:
Emit Transfer(msg.sender,burnAddress,_amount)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burnAddress,_amount)

IRs:
Emit Burn(burnAddress,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
noAnyReentrancy()

IRs:
MODIFIER_CALL, Base.noAnyReentrancy()()"];
9->1;
10[label="Node Type: RETURN 10

EXPRESSION:
_success

IRs:
RETURN _success"];
}
// Function: 587.sol-Token-constructor(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
projectWallet = _projectWallet

IRs:
projectWallet(address) := _projectWallet(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
foundersWallet = _foundersWallet

IRs:
foundersWallet(address) := _foundersWallet(address)"];
}
// Function: 587.sol-Token-executeSettingsChange(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tgrSettingsAmount = amount

IRs:
tgrSettingsAmount(uint256) := amount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tgrSettingsMinimalContribution = minimalContribution

IRs:
tgrSettingsMinimalContribution(uint256) := minimalContribution(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tgrSettingsPartContributor = partContributor

IRs:
tgrSettingsPartContributor(uint256) := partContributor(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tgrSettingsPartProject = partProject

IRs:
tgrSettingsPartProject(uint256) := partProject(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tgrSettingsPartFounders = partFounders

IRs:
tgrSettingsPartFounders(uint256) := partFounders(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tgrSettingsBlocksPerStage = blocksPerStage

IRs:
tgrSettingsBlocksPerStage(uint256) := blocksPerStage(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tgrSettingsPartContributorIncreasePerStage = partContributorIncreasePerStage

IRs:
tgrSettingsPartContributorIncreasePerStage(uint256) := partContributorIncreasePerStage(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
tgrSettingsMaxStages = maxStages

IRs:
tgrSettingsMaxStages(uint256) := maxStages(uint256)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
only(projectWallet)

IRs:
MODIFIER_CALL, Base.only(address)(projectWallet)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isNotTgrLive()

IRs:
MODIFIER_CALL, Token.isNotTgrLive()()"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
12->1;
13[label="Node Type: RETURN 13

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-Token-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->25;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(whitelist.whitelist(msg.sender))

IRs:
TMP_84(bool) = HIGH_LEVEL_CALL, dest:whitelist(Whitelist), function:whitelist, arguments:['msg.sender']  
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tgrAmountCollected < tgrSettingsAmount)

IRs:
TMP_86(bool) = tgrAmountCollected < tgrSettingsAmount
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value >= tgrSettingsMinimalContribution)

IRs:
TMP_88(bool) = msg.value >= tgrSettingsMinimalContribution
TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage)

IRs:
TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'tgrStartBlock'] 
TMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_90', 'tgrSettingsBlocksPerStage'] 
stage(uint256) := TMP_91(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(stage < tgrSettingsMaxStages)

IRs:
TMP_92(bool) = stage < tgrSettingsMaxStages
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
etherToRefund = 0

IRs:
etherToRefund(uint256) := 0(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
etherContributed = msg.value

IRs:
etherContributed(uint256) := msg.value(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
currentPartContributor = tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage))

IRs:
TMP_94(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['stage', 'tgrSettingsPartContributorIncreasePerStage'] 
TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tgrSettingsPartContributor', 'TMP_94'] 
currentPartContributor(uint256) := TMP_95(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
allStakes = currentPartContributor.add(tgrSettingsPartProject).add(tgrSettingsPartFounders)

IRs:
TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['currentPartContributor', 'tgrSettingsPartProject'] 
TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_96', 'tgrSettingsPartFounders'] 
allStakes(uint256) := TMP_97(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
remainsToContribute = (tgrSettingsAmount.sub(tgrAmountCollected)).mul(allStakes).div(tgrSettingsPartProject)

IRs:
TMP_98(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tgrSettingsAmount', 'tgrAmountCollected'] 
TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_98', 'allStakes'] 
TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_99', 'tgrSettingsPartProject'] 
remainsToContribute(uint256) := TMP_100(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
(tgrSettingsAmount.sub(tgrAmountCollected)).mul(allStakes) % tgrSettingsPartProject != 0

IRs:
TMP_101(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tgrSettingsAmount', 'tgrAmountCollected'] 
TMP_102(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_101', 'allStakes'] 
TMP_103(uint256) = TMP_102 % tgrSettingsPartProject
TMP_104(bool) = TMP_103 != 0
CONDITION TMP_104"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
remainsToContribute = remainsToContribute + allStakes

IRs:
TMP_105(uint256) = remainsToContribute + allStakes
remainsToContribute(uint256) := TMP_105(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
remainsToContribute < msg.value

IRs:
TMP_106(bool) = remainsToContribute < msg.value
CONDITION TMP_106"];
14->15[label="True"];
14->17[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
etherToRefund = msg.value.sub(remainsToContribute)

IRs:
TMP_107(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'remainsToContribute'] 
etherToRefund(uint256) := TMP_107(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
etherContributed = remainsToContribute

IRs:
etherContributed(uint256) := remainsToContribute(uint256)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
tokensProject = etherContributed.mul(tgrSettingsPartProject).div(allStakes)

IRs:
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['etherContributed', 'tgrSettingsPartProject'] 
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_108', 'allStakes'] 
tokensProject(uint256) := TMP_109(uint256)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
tokensFounders = etherContributed.mul(tgrSettingsPartFounders).div(allStakes)

IRs:
TMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['etherContributed', 'tgrSettingsPartFounders'] 
TMP_111(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_110', 'allStakes'] 
tokensFounders(uint256) := TMP_111(uint256)"];
19->20;
20[label="Node Type: NEW VARIABLE 20

EXPRESSION:
tokensContributor = etherContributed.sub(tokensProject).sub(tokensFounders)

IRs:
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['etherContributed', 'tokensProject'] 
TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_112', 'tokensFounders'] 
tokensContributor(uint256) := TMP_113(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
tgrAmountCollected = tgrAmountCollected.add(tokensProject)

IRs:
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tgrAmountCollected', 'tokensProject'] 
tgrAmountCollected(uint256) := TMP_114(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
tgrContributedAmount = tgrContributedAmount.add(etherContributed)

IRs:
TMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tgrContributedAmount', 'etherContributed'] 
tgrContributedAmount(uint256) := TMP_115(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
_mint(tokensProject,tokensFounders,tokensContributor)

IRs:
INTERNAL_CALL, Token._mint(uint256,uint256,uint256)(tokensProject,tokensFounders,tokensContributor)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
msg.sender.transfer(etherToRefund)

IRs:
Transfer dest:msg.sender value:etherToRefund"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
isTgrLive()

IRs:
MODIFIER_CALL, Token.isTgrLive()()"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
noAnyReentrancy()

IRs:
MODIFIER_CALL, Base.noAnyReentrancy()()"];
27->1;
}
// Function: 587.sol-Token-isFrozenOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFrozen)

IRs:
TMP_223(None) = SOLIDITY_CALL require(bool)(isFrozen)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Token-isNotFrozenOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFrozen)

IRs:
TMP_221 = UnaryType.BANG isFrozen 
TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Token-isNotTgrLive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! tgrLive())

IRs:
TMP_235(bool) = INTERNAL_CALL, Token.tgrLive()()
TMP_236 = UnaryType.BANG TMP_235 
TMP_237(None) = SOLIDITY_CALL require(bool)(TMP_236)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Token-isTgrLive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tgrLive())

IRs:
TMP_233(bool) = INTERNAL_CALL, Token.tgrLive()()
TMP_234(None) = SOLIDITY_CALL require(bool)(TMP_233)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Token-multiTransfer(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3

EXPRESSION:
i < dests.length

IRs:
REF_85 -> LENGTH dests
TMP_149(bool) = i < REF_85
CONDITION TMP_149"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
transfer(dests[i],values[i])

IRs:
REF_86(address) -> dests[i]
REF_87(uint256) -> values[i]
TMP_150(bool) = INTERNAL_CALL, Token.transfer(address,uint256)(REF_86,REF_87)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
i += 1

IRs:
i(uint256) = i + 1"];
5->3;
6[label="Node Type: END_LOOP 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
i

IRs:
RETURN i"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
8->1;
}
// Function: 587.sol-Token-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_locks <= 0)

IRs:
TMP_224(bool) = _locks <= 0
TMP_225(None) = SOLIDITY_CALL require(bool)(TMP_224)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_226(uint256) = 0 - 1
TMP_227 = CONVERT TMP_226 to uint256
bitlocks(uint256) := TMP_227(uint256)"];
3->4;
4[label="Node Type: _ 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 587.sol-Token-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == allowed)

IRs:
TMP_228(bool) = msg.sender == allowed
TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Token-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.data.length == size + 4)

IRs:
REF_132 -> LENGTH msg.data
TMP_230(uint256) = size + 4
TMP_231(bool) = REF_132 == TMP_230
TMP_232(None) = SOLIDITY_CALL assert(bool)(TMP_231)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 587.sol-Token-setFreeze()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isFrozen = true

IRs:
isFrozen(bool) := True(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
only(projectWallet)

IRs:
MODIFIER_CALL, Base.only(address)(projectWallet)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
4->1;
}
// Function: 587.sol-Token-setWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist = Whitelist(_address)

IRs:
TMP_162 = CONVERT _address to Whitelist
whitelist(Whitelist) := TMP_162(Whitelist)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
only(projectWallet)

IRs:
MODIFIER_CALL, Base.only(address)(projectWallet)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
3->1;
}
// Function: 587.sol-Token-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Array.io Token

IRs:
name(string) := Array.io Token(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = eRAY

IRs:
symbol(string) := eRAY(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
burnAddress = address(0)

IRs:
TMP_220 = CONVERT 0 to address
burnAddress(address) := TMP_220(address)"];
}
// Function: 587.sol-Token-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFrozen = false

IRs:
isFrozen(bool) := False(bool)"];
}
// Function: 587.sol-Token-tgrCurrentPartContributor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tgrLive()

IRs:
TMP_199(bool) = INTERNAL_CALL, Token.tgrLive()()
CONDITION TMP_199"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage)

IRs:
TMP_200(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'tgrStartBlock'] 
TMP_201(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_200', 'tgrSettingsBlocksPerStage'] 
stage(uint256) := TMP_201(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
int256(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)))

IRs:
TMP_202(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['stage', 'tgrSettingsPartContributorIncreasePerStage'] 
TMP_203(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tgrSettingsPartContributor', 'TMP_202'] 
TMP_204 = CONVERT TMP_203 to int256
RETURN TMP_204"];
4[label="Node Type: RETURN 4

EXPRESSION:
- 1

IRs:
TMP_205(uint256) = 0 - 1
RETURN TMP_205"];
}
// Function: 587.sol-Token-tgrCurrentStage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tgrLive()

IRs:
TMP_214(bool) = INTERNAL_CALL, Token.tgrLive()()
CONDITION TMP_214"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
int256(block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1))

IRs:
TMP_215(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'tgrStartBlock'] 
TMP_216(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_215', 'tgrSettingsBlocksPerStage'] 
TMP_217(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_216', '1'] 
TMP_218 = CONVERT TMP_217 to int256
RETURN TMP_218"];
3[label="Node Type: RETURN 3

EXPRESSION:
- 1

IRs:
TMP_219(uint256) = 0 - 1
RETURN TMP_219"];
}
// Function: 587.sol-Token-tgrLive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tgrStartBlock == 0

IRs:
TMP_185(bool) = tgrStartBlock == 0
CONDITION TMP_185"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage)

IRs:
TMP_186(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'tgrStartBlock'] 
TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_186', 'tgrSettingsBlocksPerStage'] 
stage(uint256) := TMP_187(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
stage < tgrSettingsMaxStages

IRs:
TMP_188(bool) = stage < tgrSettingsMaxStages
CONDITION TMP_188"];
5->6[label="True"];
5->10[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
tgrAmountCollected >= tgrSettingsAmount

IRs:
TMP_189(bool) = tgrAmountCollected >= tgrSettingsAmount
CONDITION TMP_189"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 587.sol-Token-tgrNextPartContributor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tgrLive()

IRs:
TMP_206(bool) = INTERNAL_CALL, Token.tgrLive()()
CONDITION TMP_206"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1)

IRs:
TMP_207(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'tgrStartBlock'] 
TMP_208(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_207', 'tgrSettingsBlocksPerStage'] 
TMP_209(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_208', '1'] 
stage(uint256) := TMP_209(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
int256(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)))

IRs:
TMP_210(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['stage', 'tgrSettingsPartContributorIncreasePerStage'] 
TMP_211(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tgrSettingsPartContributor', 'TMP_210'] 
TMP_212 = CONVERT TMP_211 to int256
RETURN TMP_212"];
4[label="Node Type: RETURN 4

EXPRESSION:
- 1

IRs:
TMP_213(uint256) = 0 - 1
RETURN TMP_213"];
}
// Function: 587.sol-Token-tgrSetFinished()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
TGRFinished(block.number,tgrAmountCollected)

IRs:
Emit TGRFinished(block.number,tgrAmountCollected)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tgrStartBlock = 0

IRs:
tgrStartBlock(uint256) := 0(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
only(projectWallet)

IRs:
MODIFIER_CALL, Base.only(address)(projectWallet)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isTgrLive()

IRs:
MODIFIER_CALL, Token.isTgrLive()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
5->1;
}
// Function: 587.sol-Token-tgrSetLive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tgrNumber += 1

IRs:
tgrNumber(uint256) = tgrNumber + 1"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tgrStartBlock = block.number

IRs:
tgrStartBlock(uint256) := block.number(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tgrAmountCollected = 0

IRs:
tgrAmountCollected(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tgrContributedAmount = 0

IRs:
tgrContributedAmount(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
TGRStarted(tgrSettingsAmount,tgrSettingsMinimalContribution,tgrSettingsPartContributor,tgrSettingsPartProject,tgrSettingsPartFounders,tgrSettingsBlocksPerStage,tgrSettingsPartContributorIncreasePerStage,tgrSettingsMaxStages,block.number,tgrNumber)

IRs:
Emit TGRStarted(tgrSettingsAmount,tgrSettingsMinimalContribution,tgrSettingsPartContributor,tgrSettingsPartProject,tgrSettingsPartFounders,tgrSettingsBlocksPerStage,tgrSettingsPartContributorIncreasePerStage,tgrSettingsMaxStages,block.number,tgrNumber)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
only(projectWallet)

IRs:
MODIFIER_CALL, Base.only(address)(projectWallet)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isNotTgrLive()

IRs:
MODIFIER_CALL, Token.isNotTgrLive()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
8->1;
}
// Function: 587.sol-Token-tgrStageBlockLeft()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tgrLive()

IRs:
TMP_190(bool) = INTERNAL_CALL, Token.tgrLive()()
CONDITION TMP_190"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage)

IRs:
TMP_191(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'tgrStartBlock'] 
TMP_192(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_191', 'tgrSettingsBlocksPerStage'] 
stage(uint256) := TMP_192(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
int256(tgrStartBlock.add((stage + 1).mul(tgrSettingsBlocksPerStage)).sub(block.number))

IRs:
TMP_193(uint256) = stage + 1
TMP_194(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_193', 'tgrSettingsBlocksPerStage'] 
TMP_195(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tgrStartBlock', 'TMP_194'] 
TMP_196(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_195', 'block.number'] 
TMP_197 = CONVERT TMP_196 to int256
RETURN TMP_197"];
4[label="Node Type: RETURN 4

EXPRESSION:
- 1

IRs:
TMP_198(uint256) = 0 - 1
RETURN TMP_198"];
}
// Function: 587.sol-Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_137 = CONVERT 0 to address
TMP_138(bool) = _to != TMP_137
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_to != address(this))

IRs:
TMP_140 = CONVERT this to address
TMP_141(bool) = _to != TMP_140
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_79(uint256) -> balances[msg.sender]
REF_80(uint256) -> balances[msg.sender]
TMP_143(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_80', '_value'] 
REF_79(uint256) (->balances) := TMP_143(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_82(uint256) -> balances[_to]
REF_83(uint256) -> balances[_to]
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_83', '_value'] 
REF_82(uint256) (->balances) := TMP_144(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_147(uint256) = 2 * 32
MODIFIER_CALL, Base.onlyPayloadSize(uint256)(TMP_147)"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_62 = CONVERT 0 to address
TMP_63(bool) = _to != TMP_62
TMP_64(None) = SOLIDITY_CALL require(bool)(TMP_63)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_to != address(this))

IRs:
TMP_65 = CONVERT this to address
TMP_66(bool) = _to != TMP_65
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_29(uint256) -> balances[_from]
REF_30(uint256) -> balances[_from]
TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_30', '_value'] 
REF_29(uint256) (->balances) := TMP_68(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_32(uint256) -> balances[_to]
REF_33(uint256) -> balances[_to]
TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_33', '_value'] 
REF_32(uint256) (->balances) := TMP_69(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_35(mapping(address => uint256)) -> allowed[_from]
REF_36(uint256) -> REF_35[msg.sender]
REF_37(mapping(address => uint256)) -> allowed[_from]
REF_38(uint256) -> REF_37[msg.sender]
TMP_70(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_38', '_value'] 
REF_36(uint256) (->allowed) := TMP_70(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isNotFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isNotFrozenOnly()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyPayloadSize(3 * 32)

IRs:
TMP_73(uint256) = 3 * 32
MODIFIER_CALL, Base.onlyPayloadSize(uint256)(TMP_73)"];
9->1;
10[label="Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 587.sol-Token-withdrawFrozen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amountWithdraw = totalSupply.mul(invBalances[msg.sender]).div(totalInvSupply)

IRs:
REF_89(uint256) -> invBalances[msg.sender]
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalSupply', 'REF_89'] 
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_152', 'totalInvSupply'] 
amountWithdraw(uint256) := TMP_153(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
amountWithdraw > address(this).balance

IRs:
TMP_154 = CONVERT this to address
TMP_155(uint256) = SOLIDITY_CALL balance(address)(TMP_154)
TMP_156(bool) = amountWithdraw > TMP_155
CONDITION TMP_156"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
amountWithdraw = address(this).balance

IRs:
TMP_157 = CONVERT this to address
TMP_158(uint256) = SOLIDITY_CALL balance(address)(TMP_157)
amountWithdraw(uint256) := TMP_158(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
invBalances[msg.sender] = 0

IRs:
REF_91(uint256) -> invBalances[msg.sender]
REF_91(uint256) (->invBalances) := 0(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(amountWithdraw)

IRs:
Transfer dest:msg.sender value:amountWithdraw"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isFrozenOnly()

IRs:
MODIFIER_CALL, ERC20.isFrozenOnly()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
noAnyReentrancy()

IRs:
MODIFIER_CALL, Base.noAnyReentrancy()()"];
8->1;
}
// Function: 587.sol-Whitelist-add(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(operators[msg.sender])

IRs:
REF_23(bool) -> operators[msg.sender]
TMP_56(None) = SOLIDITY_CALL require(bool)(REF_23)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whitelist[_address] = true

IRs:
REF_24(bool) -> whitelist[_address]
REF_24(bool) (->whitelist) := True(bool)"];
}
// Function: 587.sol-Whitelist-addOperator(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(authority == msg.sender)

IRs:
TMP_58(bool) = authority == msg.sender
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
operators[_address] = true

IRs:
REF_27(bool) -> operators[_address]
REF_27(bool) (->operators) := True(bool)"];
}
// Function: 587.sol-Whitelist-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
authority = _authority

IRs:
authority(address) := _authority(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
operators[_authority] = true

IRs:
REF_22(bool) -> operators[_authority]
REF_22(bool) (->operators) := True(bool)"];
}
// Function: 587.sol-Whitelist-remove(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(operators[msg.sender])

IRs:
REF_25(bool) -> operators[msg.sender]
TMP_57(None) = SOLIDITY_CALL require(bool)(REF_25)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whitelist[_address] = false

IRs:
REF_26(bool) -> whitelist[_address]
REF_26(bool) (->whitelist) := False(bool)"];
}
// Function: 587.sol-Whitelist-removeOperator(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(authority == msg.sender)

IRs:
TMP_60(bool) = authority == msg.sender
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
operators[_address] = false

IRs:
REF_28(bool) -> operators[_address]
REF_28(bool) (->operators) := False(bool)"];
}
}
