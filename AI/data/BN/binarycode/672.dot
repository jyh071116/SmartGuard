digraph G {
// Function: 672.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)
digraph{
}
// Function: 672.sol-ERC20Interface-allowance(address,address)
digraph{
}
// Function: 672.sol-ERC20Interface-approve(address,uint256)
digraph{
}
// Function: 672.sol-ERC20Interface-balanceOf(address)
digraph{
}
// Function: 672.sol-ERC20Interface-totalSupply()
digraph{
}
// Function: 672.sol-ERC20Interface-transfer(address,uint256)
digraph{
}
// Function: 672.sol-ERC20Interface-transferFrom(address,address,uint256)
digraph{
}
// Function: 672.sol-FixedSupplyToken-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_23(bool) = msg.sender == newOwner
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_26 = CONVERT 0 to address
newOwner(address) := TMP_26(address)"];
}
// Function: 672.sol-FixedSupplyToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[tokenOwner][spender]

IRs:
REF_23(mapping(address => uint256)) -> allowed[tokenOwner]
REF_24(uint256) -> REF_23[spender]
RETURN REF_24"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 672.sol-FixedSupplyToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_10(mapping(address => uint256)) -> allowed[msg.sender]
REF_11(uint256) -> REF_10[spender]
REF_11(uint256) (->allowed) := tokens(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 672.sol-FixedSupplyToken-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_25(mapping(address => uint256)) -> allowed[msg.sender]
REF_26(uint256) -> REF_25[spender]
REF_26(uint256) (->allowed) := tokens(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_40 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_40(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  "];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 672.sol-FixedSupplyToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[tokenOwner]

IRs:
REF_3(uint256) -> balances[tokenOwner]
RETURN REF_3"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 672.sol-FixedSupplyToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
symbol = DOTCH

IRs:
symbol(string) := DOTCH(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = Diamond Of The Crypto Hill

IRs:
name(string) := Diamond Of The Crypto Hill(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = 0

IRs:
decimals(uint8) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_totalSupply = 10000000000

IRs:
_totalSupply(uint256) := 10000000000(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[this] = _totalSupply

IRs:
REF_0(uint256) -> balances[this]
REF_0(uint256) (->balances) := _totalSupply(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(address(0),this,_totalSupply)

IRs:
TMP_27 = CONVERT 0 to address
Emit Transfer(TMP_27,this,_totalSupply)"];
}
// Function: 672.sol-FixedSupplyToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_45(bool) = msg.sender == owner
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 672.sol-FixedSupplyToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_totalSupply.sub(balances[address(0)])

IRs:
TMP_29 = CONVERT 0 to address
REF_2(uint256) -> balances[TMP_29]
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_totalSupply', 'REF_2'] 
RETURN TMP_30"];
}
// Function: 672.sol-FixedSupplyToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(tokens)

IRs:
REF_4(uint256) -> balances[msg.sender]
REF_5(uint256) -> balances[msg.sender]
TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_5', 'tokens'] 
REF_4(uint256) (->balances) := TMP_31(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[to] = balances[to].add(tokens)

IRs:
REF_7(uint256) -> balances[to]
REF_8(uint256) -> balances[to]
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_8', 'tokens'] 
REF_7(uint256) (->balances) := TMP_32(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(msg.sender,to,tokens)

IRs:
Emit Transfer(msg.sender,to,tokens)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 672.sol-FixedSupplyToken-transferAnyERC20Token(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
ERC20Interface(tokenAddress).transfer(owner,tokens)

IRs:
TMP_42 = CONVERT tokenAddress to ERC20Interface
TMP_43(bool) = HIGH_LEVEL_CALL, dest:TMP_42(ERC20Interface), function:transfer, arguments:['owner', 'tokens']  
RETURN TMP_43"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 672.sol-FixedSupplyToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[from] = balances[from].sub(tokens)

IRs:
REF_12(uint256) -> balances[from]
REF_13(uint256) -> balances[from]
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_13', 'tokens'] 
REF_12(uint256) (->balances) := TMP_35(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens)

IRs:
REF_15(mapping(address => uint256)) -> allowed[from]
REF_16(uint256) -> REF_15[msg.sender]
REF_17(mapping(address => uint256)) -> allowed[from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_18', 'tokens'] 
REF_16(uint256) (->allowed) := TMP_36(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[to] = balances[to].add(tokens)

IRs:
REF_20(uint256) -> balances[to]
REF_21(uint256) -> balances[to]
TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_21', 'tokens'] 
REF_20(uint256) (->balances) := TMP_37(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(from,to,tokens)

IRs:
Emit Transfer(from,to,tokens)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 672.sol-FixedSupplyToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 672.sol-Game-Divs()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == roundownables[round].hillowner)

IRs:
REF_1157(Game.Ownables) -> roundownables[round]
REF_1158(address) -> REF_1157.hillowner
TMP_406(bool) = msg.sender == REF_1158
TMP_407(None) = SOLIDITY_CALL require(bool)(TMP_406)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
claimdivs()

IRs:
INTERNAL_CALL, Game.claimdivs()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(div)

IRs:
Transfer dest:msg.sender value:div"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onHarvest(msg.sender,div)

IRs:
Emit onHarvest(msg.sender,div)"];
}
// Function: 672.sol-Game-Divsforall()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(divsforall = true)

IRs:
divsforall(bool) := True(bool)
TMP_411(None) = SOLIDITY_CALL require(bool)(divsforall)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_412(bool) = msg.value >= 1000000000000000
TMP_413(None) = SOLIDITY_CALL require(bool)(TMP_412)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
div = harvestabledivs()

IRs:
TMP_414(uint256) = INTERNAL_CALL, Game.harvestabledivs()()
div(uint256) := TMP_414(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(div > 0)

IRs:
TMP_415(bool) = div > 0
TMP_416(None) = SOLIDITY_CALL require(bool)(TMP_415)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
claimdivs()

IRs:
INTERNAL_CALL, Game.claimdivs()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(div)

IRs:
Transfer dest:msg.sender value:div"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onHarvest(msg.sender,div)

IRs:
Emit onHarvest(msg.sender,div)"];
}
// Function: 672.sol-Game-Expand()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyp3d(ethforp3dbuy)

IRs:
INTERNAL_CALL, Game.buyp3d(uint256)(ethforp3dbuy)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ethforp3dbuy = 0

IRs:
ethforp3dbuy(uint256) := 0(uint256)"];
}
// Function: 672.sol-Game-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_66(bool) = msg.sender == newOwner
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_69 = CONVERT 0 to address
newOwner(address) := TMP_69(address)"];
}
// Function: 672.sol-Game-adddotchtooffer(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(dotchamount > 0)

IRs:
TMP_433(bool) = dotchamount > 0
TMP_434(None) = SOLIDITY_CALL require(bool)(TMP_433)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == marketplace[ordernumber].placedby)

IRs:
REF_1174(Game.Marketoffer) -> marketplace[ordernumber]
REF_1175(address) -> REF_1174.placedby
TMP_435(bool) = msg.sender == REF_1175
TMP_436(None) = SOLIDITY_CALL require(bool)(TMP_435)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balances[msg.sender] >= dotchamount)

IRs:
REF_1176(uint256) -> balances[msg.sender]
TMP_437(bool) = REF_1176 >= dotchamount
TMP_438(None) = SOLIDITY_CALL require(bool)(TMP_437)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(dotchamount)

IRs:
REF_1177(uint256) -> balances[msg.sender]
REF_1178(uint256) -> balances[msg.sender]
TMP_439(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1178', 'dotchamount'] 
REF_1177(uint256) (->balances) := TMP_439(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[this] = balances[this].add(dotchamount)

IRs:
REF_1180(uint256) -> balances[this]
REF_1181(uint256) -> balances[this]
TMP_440(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1181', 'dotchamount'] 
REF_1180(uint256) (->balances) := TMP_440(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,this,dotchamount)

IRs:
Emit Transfer(msg.sender,this,dotchamount)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
marketplace[ordernumber].amountdotch = marketplace[ordernumber].amountdotch.add(dotchamount)

IRs:
REF_1183(Game.Marketoffer) -> marketplace[ordernumber]
REF_1184(uint256) -> REF_1183.amountdotch
REF_1185(Game.Marketoffer) -> marketplace[ordernumber]
REF_1186(uint256) -> REF_1185.amountdotch
TMP_442(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1186', 'dotchamount'] 
REF_1184(uint256) (->marketplace) := TMP_442(uint256)"];
}
// Function: 672.sol-Game-allowance(address,address)
digraph{
}
// Function: 672.sol-Game-approve(address,uint256)
digraph{
}
// Function: 672.sol-Game-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_54(mapping(address => uint256)) -> allowed[msg.sender]
REF_55(uint256) -> REF_54[spender]
REF_55(uint256) (->allowed) := tokens(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_60 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_60(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  "];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 672.sol-Game-attack(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_184(bool) = msg.value >= 1000000000000000
TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
block.number > roundvars[round].lastblockpayout + roundvars[round].blocksbeforenewpay

IRs:
REF_451(Game.Variables) -> roundvars[round]
REF_452(uint256) -> REF_451.lastblockpayout
REF_453(Game.Variables) -> roundvars[round]
REF_454(uint256) -> REF_453.blocksbeforenewpay
TMP_186(uint256) = REF_452 + REF_454
TMP_187(bool) = block.number > TMP_186
CONDITION TMP_187"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
hillpayout()

IRs:
INTERNAL_CALL, Game.hillpayout()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
bpcheck = roundownables[round].villages[village].beginnerprotection.add(roundvars[round].bpamount)

IRs:
REF_455(Game.Ownables) -> roundownables[round]
REF_456(mapping(uint256 => Game.Village)) -> REF_455.villages
REF_457(Game.Village) -> REF_456[village]
REF_458(uint256) -> REF_457.beginnerprotection
REF_460(Game.Variables) -> roundvars[round]
REF_461(uint256) -> REF_460.bpamount
TMP_189(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_458', 'REF_461'] 
bpcheck(uint256) := TMP_189(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(block.number > bpcheck)

IRs:
TMP_190(bool) = block.number > bpcheck
TMP_191(None) = SOLIDITY_CALL require(bool)(TMP_190)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(roundownables[round].villages[village].owner != 0)

IRs:
REF_462(Game.Ownables) -> roundownables[round]
REF_463(mapping(uint256 => Game.Village)) -> REF_462.villages
REF_464(Game.Village) -> REF_463[village]
REF_465(address) -> REF_464.owner
TMP_192(bool) = REF_465 != 0
TMP_193(None) = SOLIDITY_CALL require(bool)(TMP_192)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(amtsoldiers <= roundownables[round].soldiers[msg.sender])

IRs:
REF_466(Game.Ownables) -> roundownables[round]
REF_467(mapping(address => uint256)) -> REF_466.soldiers
REF_468(uint256) -> REF_467[msg.sender]
TMP_194(bool) = amtsoldiers <= REF_468
TMP_195(None) = SOLIDITY_CALL require(bool)(TMP_194)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(amtsoldiers >= 1)

IRs:
TMP_196(bool) = amtsoldiers >= 1
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
msg.sender == roundownables[round].villages[village].owner

IRs:
REF_469(Game.Ownables) -> roundownables[round]
REF_470(mapping(uint256 => Game.Village)) -> REF_469.villages
REF_471(Game.Village) -> REF_470[village]
REF_472(address) -> REF_471.owner
TMP_198(bool) = msg.sender == REF_472
CONDITION TMP_198"];
10->11[label="True"];
10->14[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
roundownables[round].villages[village].defending = roundownables[round].villages[village].defending.add(amtsoldiers)

IRs:
REF_473(Game.Ownables) -> roundownables[round]
REF_474(mapping(uint256 => Game.Village)) -> REF_473.villages
REF_475(Game.Village) -> REF_474[village]
REF_476(uint256) -> REF_475.defending
REF_477(Game.Ownables) -> roundownables[round]
REF_478(mapping(uint256 => Game.Village)) -> REF_477.villages
REF_479(Game.Village) -> REF_478[village]
REF_480(uint256) -> REF_479.defending
TMP_199(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_480', 'amtsoldiers'] 
REF_476(uint256) (->roundownables) := TMP_199(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_482(Game.Ownables) -> roundownables[round]
REF_483(mapping(address => uint256)) -> REF_482.soldiers
REF_484(uint256) -> REF_483[msg.sender]
REF_485(Game.Ownables) -> roundownables[round]
REF_486(mapping(address => uint256)) -> REF_485.soldiers
REF_487(uint256) -> REF_486[msg.sender]
TMP_200(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_487', 'amtsoldiers'] 
REF_484(uint256) (->roundownables) := TMP_200(uint256)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
(false,0)

IRs:
RETURN False,0"];
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
msg.sender != roundownables[round].villages[village].owner

IRs:
REF_489(Game.Ownables) -> roundownables[round]
REF_490(mapping(uint256 => Game.Village)) -> REF_489.villages
REF_491(Game.Village) -> REF_490[village]
REF_492(address) -> REF_491.owner
TMP_201(bool) = msg.sender != REF_492
CONDITION TMP_201"];
15->16[label="True"];
15->31[label="False"];
16[label="Node Type: IF 16

EXPRESSION:
roundownables[round].villages[village].defending < amtsoldiers

IRs:
REF_493(Game.Ownables) -> roundownables[round]
REF_494(mapping(uint256 => Game.Village)) -> REF_493.villages
REF_495(Game.Village) -> REF_494[village]
REF_496(uint256) -> REF_495.defending
TMP_202(bool) = REF_496 < amtsoldiers
CONDITION TMP_202"];
16->17[label="True"];
16->24[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
battle(msg.sender,roundownables[round].villages[village].defending,roundownables[round].villages[village].owner,roundownables[round].villages[village].defending)

IRs:
REF_497(Game.Ownables) -> roundownables[round]
REF_498(mapping(uint256 => Game.Village)) -> REF_497.villages
REF_499(Game.Village) -> REF_498[village]
REF_500(uint256) -> REF_499.defending
REF_501(Game.Ownables) -> roundownables[round]
REF_502(mapping(uint256 => Game.Village)) -> REF_501.villages
REF_503(Game.Village) -> REF_502[village]
REF_504(address) -> REF_503.owner
REF_505(Game.Ownables) -> roundownables[round]
REF_506(mapping(uint256 => Game.Village)) -> REF_505.villages
REF_507(Game.Village) -> REF_506[village]
REF_508(uint256) -> REF_507.defending
Emit battle(msg.sender,REF_500,REF_504,REF_508)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
villtakeover(roundownables[round].villages[village].owner,msg.sender,village)

IRs:
REF_509(Game.Ownables) -> roundownables[round]
REF_510(mapping(uint256 => Game.Village)) -> REF_509.villages
REF_511(Game.Village) -> REF_510[village]
REF_512(address) -> REF_511.owner
Emit villtakeover(REF_512,msg.sender,village)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
roundownables[round].villages[village].owner = msg.sender

IRs:
REF_513(Game.Ownables) -> roundownables[round]
REF_514(mapping(uint256 => Game.Village)) -> REF_513.villages
REF_515(Game.Village) -> REF_514[village]
REF_516(address) -> REF_515.owner
REF_516(address) (->roundownables) := msg.sender(address)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
roundownables[round].villages[village].defending = amtsoldiers.sub(roundownables[round].villages[village].defending)

IRs:
REF_517(Game.Ownables) -> roundownables[round]
REF_518(mapping(uint256 => Game.Village)) -> REF_517.villages
REF_519(Game.Village) -> REF_518[village]
REF_520(uint256) -> REF_519.defending
REF_522(Game.Ownables) -> roundownables[round]
REF_523(mapping(uint256 => Game.Village)) -> REF_522.villages
REF_524(Game.Village) -> REF_523[village]
REF_525(uint256) -> REF_524.defending
TMP_205(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['amtsoldiers', 'REF_525'] 
REF_520(uint256) (->roundownables) := TMP_205(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_526(Game.Ownables) -> roundownables[round]
REF_527(mapping(address => uint256)) -> REF_526.soldiers
REF_528(uint256) -> REF_527[msg.sender]
REF_529(Game.Ownables) -> roundownables[round]
REF_530(mapping(address => uint256)) -> REF_529.soldiers
REF_531(uint256) -> REF_530[msg.sender]
TMP_206(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_531', 'amtsoldiers'] 
REF_528(uint256) (->roundownables) := TMP_206(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
collecttaxes(village)

IRs:
TMP_207(uint256) = INTERNAL_CALL, Game.collecttaxes(uint256)(village)"];
22->23;
23[label="Node Type: RETURN 23

EXPRESSION:
(true,roundownables[round].villages[village].defending)

IRs:
REF_533(Game.Ownables) -> roundownables[round]
REF_534(mapping(uint256 => Game.Village)) -> REF_533.villages
REF_535(Game.Village) -> REF_534[village]
REF_536(uint256) -> REF_535.defending
RETURN True,REF_536"];
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: IF 25

EXPRESSION:
roundownables[round].villages[village].defending >= amtsoldiers

IRs:
REF_537(Game.Ownables) -> roundownables[round]
REF_538(mapping(uint256 => Game.Village)) -> REF_537.villages
REF_539(Game.Village) -> REF_538[village]
REF_540(uint256) -> REF_539.defending
TMP_208(bool) = REF_540 >= amtsoldiers
CONDITION TMP_208"];
25->26[label="True"];
25->30[label="False"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
battle(msg.sender,amtsoldiers,roundownables[round].villages[village].owner,amtsoldiers)

IRs:
REF_541(Game.Ownables) -> roundownables[round]
REF_542(mapping(uint256 => Game.Village)) -> REF_541.villages
REF_543(Game.Village) -> REF_542[village]
REF_544(address) -> REF_543.owner
Emit battle(msg.sender,amtsoldiers,REF_544,amtsoldiers)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
roundownables[round].villages[village].defending = roundownables[round].villages[village].defending.sub(amtsoldiers)

IRs:
REF_545(Game.Ownables) -> roundownables[round]
REF_546(mapping(uint256 => Game.Village)) -> REF_545.villages
REF_547(Game.Village) -> REF_546[village]
REF_548(uint256) -> REF_547.defending
REF_549(Game.Ownables) -> roundownables[round]
REF_550(mapping(uint256 => Game.Village)) -> REF_549.villages
REF_551(Game.Village) -> REF_550[village]
REF_552(uint256) -> REF_551.defending
TMP_210(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_552', 'amtsoldiers'] 
REF_548(uint256) (->roundownables) := TMP_210(uint256)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_554(Game.Ownables) -> roundownables[round]
REF_555(mapping(address => uint256)) -> REF_554.soldiers
REF_556(uint256) -> REF_555[msg.sender]
REF_557(Game.Ownables) -> roundownables[round]
REF_558(mapping(address => uint256)) -> REF_557.soldiers
REF_559(uint256) -> REF_558[msg.sender]
TMP_211(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_559', 'amtsoldiers'] 
REF_556(uint256) (->roundownables) := TMP_211(uint256)"];
28->29;
29[label="Node Type: RETURN 29

EXPRESSION:
(false,amtsoldiers)

IRs:
RETURN False,amtsoldiers"];
30[label="Node Type: END_IF 30
"];
30->31;
31[label="Node Type: END_IF 31
"];
}
// Function: 672.sol-Game-attackhill(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_98(bool) = msg.value >= 1000000000000000
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay)

IRs:
REF_152(Game.Variables) -> roundvars[round]
REF_153(uint256) -> REF_152.lastblockpayout
REF_155(Game.Variables) -> roundvars[round]
REF_156(uint256) -> REF_155.blocksbeforenewpay
TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_153', 'REF_156'] 
TMP_101(bool) = block.number > TMP_100
CONDITION TMP_101"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
hillpayout()

IRs:
INTERNAL_CALL, Game.hillpayout()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(amtsoldiers <= roundownables[round].soldiers[msg.sender])

IRs:
REF_157(Game.Ownables) -> roundownables[round]
REF_158(mapping(address => uint256)) -> REF_157.soldiers
REF_159(uint256) -> REF_158[msg.sender]
TMP_103(bool) = amtsoldiers <= REF_159
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(amtsoldiers >= 1)

IRs:
TMP_105(bool) = amtsoldiers >= 1
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
msg.sender == roundownables[round].hillowner

IRs:
REF_160(Game.Ownables) -> roundownables[round]
REF_161(address) -> REF_160.hillowner
TMP_107(bool) = msg.sender == REF_161
CONDITION TMP_107"];
7->8[label="True"];
7->11[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
roundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.add(amtsoldiers)

IRs:
REF_162(Game.Ownables) -> roundownables[round]
REF_163(uint256) -> REF_162.soldiersdefendinghill
REF_164(Game.Ownables) -> roundownables[round]
REF_165(uint256) -> REF_164.soldiersdefendinghill
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_165', 'amtsoldiers'] 
REF_163(uint256) (->roundownables) := TMP_108(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_167(Game.Ownables) -> roundownables[round]
REF_168(mapping(address => uint256)) -> REF_167.soldiers
REF_169(uint256) -> REF_168[msg.sender]
REF_170(Game.Ownables) -> roundownables[round]
REF_171(mapping(address => uint256)) -> REF_170.soldiers
REF_172(uint256) -> REF_171[msg.sender]
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_172', 'amtsoldiers'] 
REF_169(uint256) (->roundownables) := TMP_109(uint256)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
(false,0)

IRs:
RETURN False,0"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
msg.sender != roundownables[round].hillowner

IRs:
REF_174(Game.Ownables) -> roundownables[round]
REF_175(address) -> REF_174.hillowner
TMP_110(bool) = msg.sender != REF_175
CONDITION TMP_110"];
12->13[label="True"];
12->27[label="False"];
13[label="Node Type: IF 13

EXPRESSION:
roundownables[round].soldiersdefendinghill < amtsoldiers

IRs:
REF_176(Game.Ownables) -> roundownables[round]
REF_177(uint256) -> REF_176.soldiersdefendinghill
TMP_111(bool) = REF_177 < amtsoldiers
CONDITION TMP_111"];
13->14[label="True"];
13->20[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
hilltakeover(roundownables[round].hillowner,msg.sender)

IRs:
REF_178(Game.Ownables) -> roundownables[round]
REF_179(address) -> REF_178.hillowner
Emit hilltakeover(REF_179,msg.sender)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
battle(msg.sender,roundownables[round].soldiersdefendinghill,roundownables[round].hillowner,roundownables[round].soldiersdefendinghill)

IRs:
REF_180(Game.Ownables) -> roundownables[round]
REF_181(uint256) -> REF_180.soldiersdefendinghill
REF_182(Game.Ownables) -> roundownables[round]
REF_183(address) -> REF_182.hillowner
REF_184(Game.Ownables) -> roundownables[round]
REF_185(uint256) -> REF_184.soldiersdefendinghill
Emit battle(msg.sender,REF_181,REF_183,REF_185)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
roundownables[round].hillowner = msg.sender

IRs:
REF_186(Game.Ownables) -> roundownables[round]
REF_187(address) -> REF_186.hillowner
REF_187(address) (->roundownables) := msg.sender(address)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
roundownables[round].soldiersdefendinghill = amtsoldiers.sub(roundownables[round].soldiersdefendinghill)

IRs:
REF_188(Game.Ownables) -> roundownables[round]
REF_189(uint256) -> REF_188.soldiersdefendinghill
REF_191(Game.Ownables) -> roundownables[round]
REF_192(uint256) -> REF_191.soldiersdefendinghill
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['amtsoldiers', 'REF_192'] 
REF_189(uint256) (->roundownables) := TMP_114(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_193(Game.Ownables) -> roundownables[round]
REF_194(mapping(address => uint256)) -> REF_193.soldiers
REF_195(uint256) -> REF_194[msg.sender]
REF_196(Game.Ownables) -> roundownables[round]
REF_197(mapping(address => uint256)) -> REF_196.soldiers
REF_198(uint256) -> REF_197[msg.sender]
TMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_198', 'amtsoldiers'] 
REF_195(uint256) (->roundownables) := TMP_115(uint256)"];
18->19;
19[label="Node Type: RETURN 19

EXPRESSION:
(true,roundownables[round].soldiersdefendinghill)

IRs:
REF_200(Game.Ownables) -> roundownables[round]
REF_201(uint256) -> REF_200.soldiersdefendinghill
RETURN True,REF_201"];
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
roundownables[round].soldiersdefendinghill >= amtsoldiers

IRs:
REF_202(Game.Ownables) -> roundownables[round]
REF_203(uint256) -> REF_202.soldiersdefendinghill
TMP_116(bool) = REF_203 >= amtsoldiers
CONDITION TMP_116"];
21->22[label="True"];
21->26[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
roundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.sub(amtsoldiers)

IRs:
REF_204(Game.Ownables) -> roundownables[round]
REF_205(uint256) -> REF_204.soldiersdefendinghill
REF_206(Game.Ownables) -> roundownables[round]
REF_207(uint256) -> REF_206.soldiersdefendinghill
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_207', 'amtsoldiers'] 
REF_205(uint256) (->roundownables) := TMP_117(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_209(Game.Ownables) -> roundownables[round]
REF_210(mapping(address => uint256)) -> REF_209.soldiers
REF_211(uint256) -> REF_210[msg.sender]
REF_212(Game.Ownables) -> roundownables[round]
REF_213(mapping(address => uint256)) -> REF_212.soldiers
REF_214(uint256) -> REF_213[msg.sender]
TMP_118(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_214', 'amtsoldiers'] 
REF_211(uint256) (->roundownables) := TMP_118(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
battle(msg.sender,amtsoldiers,roundownables[round].hillowner,amtsoldiers)

IRs:
REF_216(Game.Ownables) -> roundownables[round]
REF_217(address) -> REF_216.hillowner
Emit battle(msg.sender,amtsoldiers,REF_217,amtsoldiers)"];
24->25;
25[label="Node Type: RETURN 25

EXPRESSION:
(false,amtsoldiers)

IRs:
RETURN False,amtsoldiers"];
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: END_IF 27
"];
}
// Function: 672.sol-Game-balanceOf(address)
digraph{
}
// Function: 672.sol-Game-batchcollecttaxes(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 10000000000000000)

IRs:
TMP_228(bool) = msg.value >= 10000000000000000
TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(roundownables[round].villages[a].owner == msg.sender)

IRs:
REF_596(Game.Ownables) -> roundownables[round]
REF_597(mapping(uint256 => Game.Village)) -> REF_596.villages
REF_598(Game.Village) -> REF_597[a]
REF_599(address) -> REF_598.owner
TMP_230(bool) = REF_599 == msg.sender
TMP_231(None) = SOLIDITY_CALL require(bool)(TMP_230)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(roundownables[round].villages[b].owner == msg.sender)

IRs:
REF_600(Game.Ownables) -> roundownables[round]
REF_601(mapping(uint256 => Game.Village)) -> REF_600.villages
REF_602(Game.Village) -> REF_601[b]
REF_603(address) -> REF_602.owner
TMP_232(bool) = REF_603 == msg.sender
TMP_233(None) = SOLIDITY_CALL require(bool)(TMP_232)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(roundownables[round].villages[c].owner == msg.sender)

IRs:
REF_604(Game.Ownables) -> roundownables[round]
REF_605(mapping(uint256 => Game.Village)) -> REF_604.villages
REF_606(Game.Village) -> REF_605[c]
REF_607(address) -> REF_606.owner
TMP_234(bool) = REF_607 == msg.sender
TMP_235(None) = SOLIDITY_CALL require(bool)(TMP_234)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(roundownables[round].villages[d].owner == msg.sender)

IRs:
REF_608(Game.Ownables) -> roundownables[round]
REF_609(mapping(uint256 => Game.Village)) -> REF_608.villages
REF_610(Game.Village) -> REF_609[d]
REF_611(address) -> REF_610.owner
TMP_236(bool) = REF_611 == msg.sender
TMP_237(None) = SOLIDITY_CALL require(bool)(TMP_236)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(roundownables[round].villages[e].owner == msg.sender)

IRs:
REF_612(Game.Ownables) -> roundownables[round]
REF_613(mapping(uint256 => Game.Village)) -> REF_612.villages
REF_614(Game.Village) -> REF_613[e]
REF_615(address) -> REF_614.owner
TMP_238(bool) = REF_615 == msg.sender
TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(roundownables[round].villages[f].owner == msg.sender)

IRs:
REF_616(Game.Ownables) -> roundownables[round]
REF_617(mapping(uint256 => Game.Village)) -> REF_616.villages
REF_618(Game.Village) -> REF_617[f]
REF_619(address) -> REF_618.owner
TMP_240(bool) = REF_619 == msg.sender
TMP_241(None) = SOLIDITY_CALL require(bool)(TMP_240)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(roundownables[round].villages[g].owner == msg.sender)

IRs:
REF_620(Game.Ownables) -> roundownables[round]
REF_621(mapping(uint256 => Game.Village)) -> REF_620.villages
REF_622(Game.Village) -> REF_621[g]
REF_623(address) -> REF_622.owner
TMP_242(bool) = REF_623 == msg.sender
TMP_243(None) = SOLIDITY_CALL require(bool)(TMP_242)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(roundownables[round].villages[h].owner == msg.sender)

IRs:
REF_624(Game.Ownables) -> roundownables[round]
REF_625(mapping(uint256 => Game.Village)) -> REF_624.villages
REF_626(Game.Village) -> REF_625[h]
REF_627(address) -> REF_626.owner
TMP_244(bool) = REF_627 == msg.sender
TMP_245(None) = SOLIDITY_CALL require(bool)(TMP_244)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(roundownables[round].villages[i].owner == msg.sender)

IRs:
REF_628(Game.Ownables) -> roundownables[round]
REF_629(mapping(uint256 => Game.Village)) -> REF_628.villages
REF_630(Game.Village) -> REF_629[i]
REF_631(address) -> REF_630.owner
TMP_246(bool) = REF_631 == msg.sender
TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(roundownables[round].villages[j].owner == msg.sender)

IRs:
REF_632(Game.Ownables) -> roundownables[round]
REF_633(mapping(uint256 => Game.Village)) -> REF_632.villages
REF_634(Game.Village) -> REF_633[j]
REF_635(address) -> REF_634.owner
TMP_248(bool) = REF_635 == msg.sender
TMP_249(None) = SOLIDITY_CALL require(bool)(TMP_248)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[a].lastcollect)

IRs:
REF_636(Game.Ownables) -> roundownables[round]
REF_637(mapping(uint256 => Game.Village)) -> REF_636.villages
REF_638(Game.Village) -> REF_637[a]
REF_639(uint256) -> REF_638.lastcollect
TMP_250(bool) = block.number > REF_639
TMP_251(None) = SOLIDITY_CALL require(bool)(TMP_250)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[b].lastcollect)

IRs:
REF_640(Game.Ownables) -> roundownables[round]
REF_641(mapping(uint256 => Game.Village)) -> REF_640.villages
REF_642(Game.Village) -> REF_641[b]
REF_643(uint256) -> REF_642.lastcollect
TMP_252(bool) = block.number > REF_643
TMP_253(None) = SOLIDITY_CALL require(bool)(TMP_252)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[c].lastcollect)

IRs:
REF_644(Game.Ownables) -> roundownables[round]
REF_645(mapping(uint256 => Game.Village)) -> REF_644.villages
REF_646(Game.Village) -> REF_645[c]
REF_647(uint256) -> REF_646.lastcollect
TMP_254(bool) = block.number > REF_647
TMP_255(None) = SOLIDITY_CALL require(bool)(TMP_254)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[d].lastcollect)

IRs:
REF_648(Game.Ownables) -> roundownables[round]
REF_649(mapping(uint256 => Game.Village)) -> REF_648.villages
REF_650(Game.Village) -> REF_649[d]
REF_651(uint256) -> REF_650.lastcollect
TMP_256(bool) = block.number > REF_651
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[e].lastcollect)

IRs:
REF_652(Game.Ownables) -> roundownables[round]
REF_653(mapping(uint256 => Game.Village)) -> REF_652.villages
REF_654(Game.Village) -> REF_653[e]
REF_655(uint256) -> REF_654.lastcollect
TMP_258(bool) = block.number > REF_655
TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[f].lastcollect)

IRs:
REF_656(Game.Ownables) -> roundownables[round]
REF_657(mapping(uint256 => Game.Village)) -> REF_656.villages
REF_658(Game.Village) -> REF_657[f]
REF_659(uint256) -> REF_658.lastcollect
TMP_260(bool) = block.number > REF_659
TMP_261(None) = SOLIDITY_CALL require(bool)(TMP_260)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[g].lastcollect)

IRs:
REF_660(Game.Ownables) -> roundownables[round]
REF_661(mapping(uint256 => Game.Village)) -> REF_660.villages
REF_662(Game.Village) -> REF_661[g]
REF_663(uint256) -> REF_662.lastcollect
TMP_262(bool) = block.number > REF_663
TMP_263(None) = SOLIDITY_CALL require(bool)(TMP_262)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[h].lastcollect)

IRs:
REF_664(Game.Ownables) -> roundownables[round]
REF_665(mapping(uint256 => Game.Village)) -> REF_664.villages
REF_666(Game.Village) -> REF_665[h]
REF_667(uint256) -> REF_666.lastcollect
TMP_264(bool) = block.number > REF_667
TMP_265(None) = SOLIDITY_CALL require(bool)(TMP_264)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[i].lastcollect)

IRs:
REF_668(Game.Ownables) -> roundownables[round]
REF_669(mapping(uint256 => Game.Village)) -> REF_668.villages
REF_670(Game.Village) -> REF_669[i]
REF_671(uint256) -> REF_670.lastcollect
TMP_266(bool) = block.number > REF_671
TMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[j].lastcollect)

IRs:
REF_672(Game.Ownables) -> roundownables[round]
REF_673(mapping(uint256 => Game.Village)) -> REF_672.villages
REF_674(Game.Village) -> REF_673[j]
REF_675(uint256) -> REF_674.lastcollect
TMP_268(bool) = block.number > REF_675
TMP_269(None) = SOLIDITY_CALL require(bool)(TMP_268)"];
21->22;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[a].lastcollect)).mul((roundvars[round].nextVillageId.sub(a)))

IRs:
REF_677(Game.Ownables) -> roundownables[round]
REF_678(mapping(uint256 => Game.Village)) -> REF_677.villages
REF_679(Game.Village) -> REF_678[a]
REF_680(uint256) -> REF_679.lastcollect
TMP_270(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_680'] 
REF_682(Game.Variables) -> roundvars[round]
REF_683(uint256) -> REF_682.nextVillageId
TMP_271(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_683', 'a'] 
TMP_272(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_270', 'TMP_271'] 
test(uint256) := TMP_272(uint256)"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_685(Game.Variables) -> roundvars[round]
REF_686(uint256) -> REF_685.GOTCHatcontract
TMP_273(bool) = REF_686 < test
CONDITION TMP_273"];
23->24[label="True"];
23->26[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_687(Game.Variables) -> roundvars[round]
REF_688(uint256) -> REF_687.GOTCHatcontract
REF_689(Game.Variables) -> roundvars[round]
REF_690(uint256) -> REF_689.GOTCHatcontract
TMP_274(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_690', 'test'] 
REF_688(uint256) (->roundvars) := TMP_274(uint256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_692(Game.Variables) -> roundvars[round]
REF_693(uint256) -> REF_692.totalsupplyGOTCH
REF_694(Game.Variables) -> roundvars[round]
REF_695(uint256) -> REF_694.totalsupplyGOTCH
TMP_275(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_695', 'test'] 
REF_693(uint256) (->roundvars) := TMP_275(uint256)"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_697(Game.Ownables) -> roundownables[round]
REF_698(mapping(address => uint256)) -> REF_697.GOTCH
REF_699(uint256) -> REF_698[msg.sender]
REF_700(Game.Ownables) -> roundownables[round]
REF_701(mapping(address => uint256)) -> REF_700.GOTCH
REF_702(uint256) -> REF_701[msg.sender]
TMP_276(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_702', 'test'] 
REF_699(uint256) (->roundownables) := TMP_276(uint256)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_704(Game.Variables) -> roundvars[round]
REF_705(uint256) -> REF_704.GOTCHatcontract
REF_706(Game.Variables) -> roundvars[round]
REF_707(uint256) -> REF_706.GOTCHatcontract
TMP_277(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_707', 'test'] 
REF_705(uint256) (->roundvars) := TMP_277(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
roundownables[round].villages[a].lastcollect = block.number

IRs:
REF_709(Game.Ownables) -> roundownables[round]
REF_710(mapping(uint256 => Game.Village)) -> REF_709.villages
REF_711(Game.Village) -> REF_710[a]
REF_712(uint256) -> REF_711.lastcollect
REF_712(uint256) (->roundownables) := block.number(uint256)"];
29->30;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[b].lastcollect)).mul((roundvars[round].nextVillageId.sub(b)))

IRs:
REF_714(Game.Ownables) -> roundownables[round]
REF_715(mapping(uint256 => Game.Village)) -> REF_714.villages
REF_716(Game.Village) -> REF_715[b]
REF_717(uint256) -> REF_716.lastcollect
TMP_278(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_717'] 
REF_719(Game.Variables) -> roundvars[round]
REF_720(uint256) -> REF_719.nextVillageId
TMP_279(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_720', 'b'] 
TMP_280(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_278', 'TMP_279'] 
test(uint256) := TMP_280(uint256)"];
30->31;
31[label="Node Type: IF 31

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_722(Game.Variables) -> roundvars[round]
REF_723(uint256) -> REF_722.GOTCHatcontract
TMP_281(bool) = REF_723 < test
CONDITION TMP_281"];
31->32[label="True"];
31->34[label="False"];
32[label="Node Type: EXPRESSION 32

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_724(Game.Variables) -> roundvars[round]
REF_725(uint256) -> REF_724.GOTCHatcontract
REF_726(Game.Variables) -> roundvars[round]
REF_727(uint256) -> REF_726.GOTCHatcontract
TMP_282(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_727', 'test'] 
REF_725(uint256) (->roundvars) := TMP_282(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_729(Game.Variables) -> roundvars[round]
REF_730(uint256) -> REF_729.totalsupplyGOTCH
REF_731(Game.Variables) -> roundvars[round]
REF_732(uint256) -> REF_731.totalsupplyGOTCH
TMP_283(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_732', 'test'] 
REF_730(uint256) (->roundvars) := TMP_283(uint256)"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_734(Game.Ownables) -> roundownables[round]
REF_735(mapping(address => uint256)) -> REF_734.GOTCH
REF_736(uint256) -> REF_735[msg.sender]
REF_737(Game.Ownables) -> roundownables[round]
REF_738(mapping(address => uint256)) -> REF_737.GOTCH
REF_739(uint256) -> REF_738[msg.sender]
TMP_284(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_739', 'test'] 
REF_736(uint256) (->roundownables) := TMP_284(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_741(Game.Variables) -> roundvars[round]
REF_742(uint256) -> REF_741.GOTCHatcontract
REF_743(Game.Variables) -> roundvars[round]
REF_744(uint256) -> REF_743.GOTCHatcontract
TMP_285(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_744', 'test'] 
REF_742(uint256) (->roundvars) := TMP_285(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
roundownables[round].villages[b].lastcollect = block.number

IRs:
REF_746(Game.Ownables) -> roundownables[round]
REF_747(mapping(uint256 => Game.Village)) -> REF_746.villages
REF_748(Game.Village) -> REF_747[b]
REF_749(uint256) -> REF_748.lastcollect
REF_749(uint256) (->roundownables) := block.number(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[c].lastcollect)).mul((roundvars[round].nextVillageId.sub(c)))

IRs:
REF_751(Game.Ownables) -> roundownables[round]
REF_752(mapping(uint256 => Game.Village)) -> REF_751.villages
REF_753(Game.Village) -> REF_752[c]
REF_754(uint256) -> REF_753.lastcollect
TMP_286(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_754'] 
REF_756(Game.Variables) -> roundvars[round]
REF_757(uint256) -> REF_756.nextVillageId
TMP_287(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_757', 'c'] 
TMP_288(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_286', 'TMP_287'] 
test(uint256) := TMP_288(uint256)"];
38->39;
39[label="Node Type: IF 39

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_759(Game.Variables) -> roundvars[round]
REF_760(uint256) -> REF_759.GOTCHatcontract
TMP_289(bool) = REF_760 < test
CONDITION TMP_289"];
39->40[label="True"];
39->42[label="False"];
40[label="Node Type: EXPRESSION 40

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_761(Game.Variables) -> roundvars[round]
REF_762(uint256) -> REF_761.GOTCHatcontract
REF_763(Game.Variables) -> roundvars[round]
REF_764(uint256) -> REF_763.GOTCHatcontract
TMP_290(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_764', 'test'] 
REF_762(uint256) (->roundvars) := TMP_290(uint256)"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_766(Game.Variables) -> roundvars[round]
REF_767(uint256) -> REF_766.totalsupplyGOTCH
REF_768(Game.Variables) -> roundvars[round]
REF_769(uint256) -> REF_768.totalsupplyGOTCH
TMP_291(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_769', 'test'] 
REF_767(uint256) (->roundvars) := TMP_291(uint256)"];
41->42;
42[label="Node Type: END_IF 42
"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_771(Game.Ownables) -> roundownables[round]
REF_772(mapping(address => uint256)) -> REF_771.GOTCH
REF_773(uint256) -> REF_772[msg.sender]
REF_774(Game.Ownables) -> roundownables[round]
REF_775(mapping(address => uint256)) -> REF_774.GOTCH
REF_776(uint256) -> REF_775[msg.sender]
TMP_292(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_776', 'test'] 
REF_773(uint256) (->roundownables) := TMP_292(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_778(Game.Variables) -> roundvars[round]
REF_779(uint256) -> REF_778.GOTCHatcontract
REF_780(Game.Variables) -> roundvars[round]
REF_781(uint256) -> REF_780.GOTCHatcontract
TMP_293(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_781', 'test'] 
REF_779(uint256) (->roundvars) := TMP_293(uint256)"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
roundownables[round].villages[c].lastcollect = block.number

IRs:
REF_783(Game.Ownables) -> roundownables[round]
REF_784(mapping(uint256 => Game.Village)) -> REF_783.villages
REF_785(Game.Village) -> REF_784[c]
REF_786(uint256) -> REF_785.lastcollect
REF_786(uint256) (->roundownables) := block.number(uint256)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[j].lastcollect)).mul((roundvars[round].nextVillageId.sub(j)))

IRs:
REF_788(Game.Ownables) -> roundownables[round]
REF_789(mapping(uint256 => Game.Village)) -> REF_788.villages
REF_790(Game.Village) -> REF_789[j]
REF_791(uint256) -> REF_790.lastcollect
TMP_294(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_791'] 
REF_793(Game.Variables) -> roundvars[round]
REF_794(uint256) -> REF_793.nextVillageId
TMP_295(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_794', 'j'] 
TMP_296(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_294', 'TMP_295'] 
test(uint256) := TMP_296(uint256)"];
46->47;
47[label="Node Type: IF 47

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_796(Game.Variables) -> roundvars[round]
REF_797(uint256) -> REF_796.GOTCHatcontract
TMP_297(bool) = REF_797 < test
CONDITION TMP_297"];
47->48[label="True"];
47->50[label="False"];
48[label="Node Type: EXPRESSION 48

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_798(Game.Variables) -> roundvars[round]
REF_799(uint256) -> REF_798.GOTCHatcontract
REF_800(Game.Variables) -> roundvars[round]
REF_801(uint256) -> REF_800.GOTCHatcontract
TMP_298(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_801', 'test'] 
REF_799(uint256) (->roundvars) := TMP_298(uint256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_803(Game.Variables) -> roundvars[round]
REF_804(uint256) -> REF_803.totalsupplyGOTCH
REF_805(Game.Variables) -> roundvars[round]
REF_806(uint256) -> REF_805.totalsupplyGOTCH
TMP_299(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_806', 'test'] 
REF_804(uint256) (->roundvars) := TMP_299(uint256)"];
49->50;
50[label="Node Type: END_IF 50
"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_808(Game.Ownables) -> roundownables[round]
REF_809(mapping(address => uint256)) -> REF_808.GOTCH
REF_810(uint256) -> REF_809[msg.sender]
REF_811(Game.Ownables) -> roundownables[round]
REF_812(mapping(address => uint256)) -> REF_811.GOTCH
REF_813(uint256) -> REF_812[msg.sender]
TMP_300(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_813', 'test'] 
REF_810(uint256) (->roundownables) := TMP_300(uint256)"];
51->52;
52[label="Node Type: EXPRESSION 52

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_815(Game.Variables) -> roundvars[round]
REF_816(uint256) -> REF_815.GOTCHatcontract
REF_817(Game.Variables) -> roundvars[round]
REF_818(uint256) -> REF_817.GOTCHatcontract
TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_818', 'test'] 
REF_816(uint256) (->roundvars) := TMP_301(uint256)"];
52->53;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
roundownables[round].villages[j].lastcollect = block.number

IRs:
REF_820(Game.Ownables) -> roundownables[round]
REF_821(mapping(uint256 => Game.Village)) -> REF_820.villages
REF_822(Game.Village) -> REF_821[j]
REF_823(uint256) -> REF_822.lastcollect
REF_823(uint256) (->roundownables) := block.number(uint256)"];
53->54;
54[label="Node Type: EXPRESSION 54

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[d].lastcollect)).mul((roundvars[round].nextVillageId.sub(d)))

IRs:
REF_825(Game.Ownables) -> roundownables[round]
REF_826(mapping(uint256 => Game.Village)) -> REF_825.villages
REF_827(Game.Village) -> REF_826[d]
REF_828(uint256) -> REF_827.lastcollect
TMP_302(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_828'] 
REF_830(Game.Variables) -> roundvars[round]
REF_831(uint256) -> REF_830.nextVillageId
TMP_303(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_831', 'd'] 
TMP_304(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_302', 'TMP_303'] 
test(uint256) := TMP_304(uint256)"];
54->55;
55[label="Node Type: IF 55

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_833(Game.Variables) -> roundvars[round]
REF_834(uint256) -> REF_833.GOTCHatcontract
TMP_305(bool) = REF_834 < test
CONDITION TMP_305"];
55->56[label="True"];
55->58[label="False"];
56[label="Node Type: EXPRESSION 56

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_835(Game.Variables) -> roundvars[round]
REF_836(uint256) -> REF_835.GOTCHatcontract
REF_837(Game.Variables) -> roundvars[round]
REF_838(uint256) -> REF_837.GOTCHatcontract
TMP_306(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_838', 'test'] 
REF_836(uint256) (->roundvars) := TMP_306(uint256)"];
56->57;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_840(Game.Variables) -> roundvars[round]
REF_841(uint256) -> REF_840.totalsupplyGOTCH
REF_842(Game.Variables) -> roundvars[round]
REF_843(uint256) -> REF_842.totalsupplyGOTCH
TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_843', 'test'] 
REF_841(uint256) (->roundvars) := TMP_307(uint256)"];
57->58;
58[label="Node Type: END_IF 58
"];
58->59;
59[label="Node Type: EXPRESSION 59

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_845(Game.Ownables) -> roundownables[round]
REF_846(mapping(address => uint256)) -> REF_845.GOTCH
REF_847(uint256) -> REF_846[msg.sender]
REF_848(Game.Ownables) -> roundownables[round]
REF_849(mapping(address => uint256)) -> REF_848.GOTCH
REF_850(uint256) -> REF_849[msg.sender]
TMP_308(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_850', 'test'] 
REF_847(uint256) (->roundownables) := TMP_308(uint256)"];
59->60;
60[label="Node Type: EXPRESSION 60

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_852(Game.Variables) -> roundvars[round]
REF_853(uint256) -> REF_852.GOTCHatcontract
REF_854(Game.Variables) -> roundvars[round]
REF_855(uint256) -> REF_854.GOTCHatcontract
TMP_309(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_855', 'test'] 
REF_853(uint256) (->roundvars) := TMP_309(uint256)"];
60->61;
61[label="Node Type: EXPRESSION 61

EXPRESSION:
roundownables[round].villages[d].lastcollect = block.number

IRs:
REF_857(Game.Ownables) -> roundownables[round]
REF_858(mapping(uint256 => Game.Village)) -> REF_857.villages
REF_859(Game.Village) -> REF_858[d]
REF_860(uint256) -> REF_859.lastcollect
REF_860(uint256) (->roundownables) := block.number(uint256)"];
61->62;
62[label="Node Type: EXPRESSION 62

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[e].lastcollect)).mul((roundvars[round].nextVillageId.sub(e)))

IRs:
REF_862(Game.Ownables) -> roundownables[round]
REF_863(mapping(uint256 => Game.Village)) -> REF_862.villages
REF_864(Game.Village) -> REF_863[e]
REF_865(uint256) -> REF_864.lastcollect
TMP_310(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_865'] 
REF_867(Game.Variables) -> roundvars[round]
REF_868(uint256) -> REF_867.nextVillageId
TMP_311(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_868', 'e'] 
TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_310', 'TMP_311'] 
test(uint256) := TMP_312(uint256)"];
62->63;
63[label="Node Type: IF 63

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_870(Game.Variables) -> roundvars[round]
REF_871(uint256) -> REF_870.GOTCHatcontract
TMP_313(bool) = REF_871 < test
CONDITION TMP_313"];
63->64[label="True"];
63->66[label="False"];
64[label="Node Type: EXPRESSION 64

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_872(Game.Variables) -> roundvars[round]
REF_873(uint256) -> REF_872.GOTCHatcontract
REF_874(Game.Variables) -> roundvars[round]
REF_875(uint256) -> REF_874.GOTCHatcontract
TMP_314(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_875', 'test'] 
REF_873(uint256) (->roundvars) := TMP_314(uint256)"];
64->65;
65[label="Node Type: EXPRESSION 65

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_877(Game.Variables) -> roundvars[round]
REF_878(uint256) -> REF_877.totalsupplyGOTCH
REF_879(Game.Variables) -> roundvars[round]
REF_880(uint256) -> REF_879.totalsupplyGOTCH
TMP_315(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_880', 'test'] 
REF_878(uint256) (->roundvars) := TMP_315(uint256)"];
65->66;
66[label="Node Type: END_IF 66
"];
66->67;
67[label="Node Type: EXPRESSION 67

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_882(Game.Ownables) -> roundownables[round]
REF_883(mapping(address => uint256)) -> REF_882.GOTCH
REF_884(uint256) -> REF_883[msg.sender]
REF_885(Game.Ownables) -> roundownables[round]
REF_886(mapping(address => uint256)) -> REF_885.GOTCH
REF_887(uint256) -> REF_886[msg.sender]
TMP_316(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_887', 'test'] 
REF_884(uint256) (->roundownables) := TMP_316(uint256)"];
67->68;
68[label="Node Type: EXPRESSION 68

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_889(Game.Variables) -> roundvars[round]
REF_890(uint256) -> REF_889.GOTCHatcontract
REF_891(Game.Variables) -> roundvars[round]
REF_892(uint256) -> REF_891.GOTCHatcontract
TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_892', 'test'] 
REF_890(uint256) (->roundvars) := TMP_317(uint256)"];
68->69;
69[label="Node Type: EXPRESSION 69

EXPRESSION:
roundownables[round].villages[e].lastcollect = block.number

IRs:
REF_894(Game.Ownables) -> roundownables[round]
REF_895(mapping(uint256 => Game.Village)) -> REF_894.villages
REF_896(Game.Village) -> REF_895[e]
REF_897(uint256) -> REF_896.lastcollect
REF_897(uint256) (->roundownables) := block.number(uint256)"];
69->70;
70[label="Node Type: EXPRESSION 70

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[f].lastcollect)).mul((roundvars[round].nextVillageId.sub(f)))

IRs:
REF_899(Game.Ownables) -> roundownables[round]
REF_900(mapping(uint256 => Game.Village)) -> REF_899.villages
REF_901(Game.Village) -> REF_900[f]
REF_902(uint256) -> REF_901.lastcollect
TMP_318(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_902'] 
REF_904(Game.Variables) -> roundvars[round]
REF_905(uint256) -> REF_904.nextVillageId
TMP_319(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_905', 'f'] 
TMP_320(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_318', 'TMP_319'] 
test(uint256) := TMP_320(uint256)"];
70->71;
71[label="Node Type: IF 71

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_907(Game.Variables) -> roundvars[round]
REF_908(uint256) -> REF_907.GOTCHatcontract
TMP_321(bool) = REF_908 < test
CONDITION TMP_321"];
71->72[label="True"];
71->74[label="False"];
72[label="Node Type: EXPRESSION 72

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_909(Game.Variables) -> roundvars[round]
REF_910(uint256) -> REF_909.GOTCHatcontract
REF_911(Game.Variables) -> roundvars[round]
REF_912(uint256) -> REF_911.GOTCHatcontract
TMP_322(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_912', 'test'] 
REF_910(uint256) (->roundvars) := TMP_322(uint256)"];
72->73;
73[label="Node Type: EXPRESSION 73

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_914(Game.Variables) -> roundvars[round]
REF_915(uint256) -> REF_914.totalsupplyGOTCH
REF_916(Game.Variables) -> roundvars[round]
REF_917(uint256) -> REF_916.totalsupplyGOTCH
TMP_323(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_917', 'test'] 
REF_915(uint256) (->roundvars) := TMP_323(uint256)"];
73->74;
74[label="Node Type: END_IF 74
"];
74->75;
75[label="Node Type: EXPRESSION 75

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_919(Game.Ownables) -> roundownables[round]
REF_920(mapping(address => uint256)) -> REF_919.GOTCH
REF_921(uint256) -> REF_920[msg.sender]
REF_922(Game.Ownables) -> roundownables[round]
REF_923(mapping(address => uint256)) -> REF_922.GOTCH
REF_924(uint256) -> REF_923[msg.sender]
TMP_324(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_924', 'test'] 
REF_921(uint256) (->roundownables) := TMP_324(uint256)"];
75->76;
76[label="Node Type: EXPRESSION 76

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_926(Game.Variables) -> roundvars[round]
REF_927(uint256) -> REF_926.GOTCHatcontract
REF_928(Game.Variables) -> roundvars[round]
REF_929(uint256) -> REF_928.GOTCHatcontract
TMP_325(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_929', 'test'] 
REF_927(uint256) (->roundvars) := TMP_325(uint256)"];
76->77;
77[label="Node Type: EXPRESSION 77

EXPRESSION:
roundownables[round].villages[f].lastcollect = block.number

IRs:
REF_931(Game.Ownables) -> roundownables[round]
REF_932(mapping(uint256 => Game.Village)) -> REF_931.villages
REF_933(Game.Village) -> REF_932[f]
REF_934(uint256) -> REF_933.lastcollect
REF_934(uint256) (->roundownables) := block.number(uint256)"];
77->78;
78[label="Node Type: EXPRESSION 78

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[g].lastcollect)).mul((roundvars[round].nextVillageId.sub(g)))

IRs:
REF_936(Game.Ownables) -> roundownables[round]
REF_937(mapping(uint256 => Game.Village)) -> REF_936.villages
REF_938(Game.Village) -> REF_937[g]
REF_939(uint256) -> REF_938.lastcollect
TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_939'] 
REF_941(Game.Variables) -> roundvars[round]
REF_942(uint256) -> REF_941.nextVillageId
TMP_327(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_942', 'g'] 
TMP_328(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_326', 'TMP_327'] 
test(uint256) := TMP_328(uint256)"];
78->79;
79[label="Node Type: IF 79

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_944(Game.Variables) -> roundvars[round]
REF_945(uint256) -> REF_944.GOTCHatcontract
TMP_329(bool) = REF_945 < test
CONDITION TMP_329"];
79->80[label="True"];
79->82[label="False"];
80[label="Node Type: EXPRESSION 80

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_946(Game.Variables) -> roundvars[round]
REF_947(uint256) -> REF_946.GOTCHatcontract
REF_948(Game.Variables) -> roundvars[round]
REF_949(uint256) -> REF_948.GOTCHatcontract
TMP_330(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_949', 'test'] 
REF_947(uint256) (->roundvars) := TMP_330(uint256)"];
80->81;
81[label="Node Type: EXPRESSION 81

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_951(Game.Variables) -> roundvars[round]
REF_952(uint256) -> REF_951.totalsupplyGOTCH
REF_953(Game.Variables) -> roundvars[round]
REF_954(uint256) -> REF_953.totalsupplyGOTCH
TMP_331(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_954', 'test'] 
REF_952(uint256) (->roundvars) := TMP_331(uint256)"];
81->82;
82[label="Node Type: END_IF 82
"];
82->83;
83[label="Node Type: EXPRESSION 83

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_956(Game.Ownables) -> roundownables[round]
REF_957(mapping(address => uint256)) -> REF_956.GOTCH
REF_958(uint256) -> REF_957[msg.sender]
REF_959(Game.Ownables) -> roundownables[round]
REF_960(mapping(address => uint256)) -> REF_959.GOTCH
REF_961(uint256) -> REF_960[msg.sender]
TMP_332(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_961', 'test'] 
REF_958(uint256) (->roundownables) := TMP_332(uint256)"];
83->84;
84[label="Node Type: EXPRESSION 84

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_963(Game.Variables) -> roundvars[round]
REF_964(uint256) -> REF_963.GOTCHatcontract
REF_965(Game.Variables) -> roundvars[round]
REF_966(uint256) -> REF_965.GOTCHatcontract
TMP_333(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_966', 'test'] 
REF_964(uint256) (->roundvars) := TMP_333(uint256)"];
84->85;
85[label="Node Type: EXPRESSION 85

EXPRESSION:
roundownables[round].villages[g].lastcollect = block.number

IRs:
REF_968(Game.Ownables) -> roundownables[round]
REF_969(mapping(uint256 => Game.Village)) -> REF_968.villages
REF_970(Game.Village) -> REF_969[g]
REF_971(uint256) -> REF_970.lastcollect
REF_971(uint256) (->roundownables) := block.number(uint256)"];
85->86;
86[label="Node Type: EXPRESSION 86

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[h].lastcollect)).mul((roundvars[round].nextVillageId.sub(h)))

IRs:
REF_973(Game.Ownables) -> roundownables[round]
REF_974(mapping(uint256 => Game.Village)) -> REF_973.villages
REF_975(Game.Village) -> REF_974[h]
REF_976(uint256) -> REF_975.lastcollect
TMP_334(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_976'] 
REF_978(Game.Variables) -> roundvars[round]
REF_979(uint256) -> REF_978.nextVillageId
TMP_335(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_979', 'h'] 
TMP_336(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_334', 'TMP_335'] 
test(uint256) := TMP_336(uint256)"];
86->87;
87[label="Node Type: IF 87

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_981(Game.Variables) -> roundvars[round]
REF_982(uint256) -> REF_981.GOTCHatcontract
TMP_337(bool) = REF_982 < test
CONDITION TMP_337"];
87->88[label="True"];
87->90[label="False"];
88[label="Node Type: EXPRESSION 88

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_983(Game.Variables) -> roundvars[round]
REF_984(uint256) -> REF_983.GOTCHatcontract
REF_985(Game.Variables) -> roundvars[round]
REF_986(uint256) -> REF_985.GOTCHatcontract
TMP_338(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_986', 'test'] 
REF_984(uint256) (->roundvars) := TMP_338(uint256)"];
88->89;
89[label="Node Type: EXPRESSION 89

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_988(Game.Variables) -> roundvars[round]
REF_989(uint256) -> REF_988.totalsupplyGOTCH
REF_990(Game.Variables) -> roundvars[round]
REF_991(uint256) -> REF_990.totalsupplyGOTCH
TMP_339(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_991', 'test'] 
REF_989(uint256) (->roundvars) := TMP_339(uint256)"];
89->90;
90[label="Node Type: END_IF 90
"];
90->91;
91[label="Node Type: EXPRESSION 91

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_993(Game.Ownables) -> roundownables[round]
REF_994(mapping(address => uint256)) -> REF_993.GOTCH
REF_995(uint256) -> REF_994[msg.sender]
REF_996(Game.Ownables) -> roundownables[round]
REF_997(mapping(address => uint256)) -> REF_996.GOTCH
REF_998(uint256) -> REF_997[msg.sender]
TMP_340(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_998', 'test'] 
REF_995(uint256) (->roundownables) := TMP_340(uint256)"];
91->92;
92[label="Node Type: EXPRESSION 92

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_1000(Game.Variables) -> roundvars[round]
REF_1001(uint256) -> REF_1000.GOTCHatcontract
REF_1002(Game.Variables) -> roundvars[round]
REF_1003(uint256) -> REF_1002.GOTCHatcontract
TMP_341(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1003', 'test'] 
REF_1001(uint256) (->roundvars) := TMP_341(uint256)"];
92->93;
93[label="Node Type: EXPRESSION 93

EXPRESSION:
roundownables[round].villages[h].lastcollect = block.number

IRs:
REF_1005(Game.Ownables) -> roundownables[round]
REF_1006(mapping(uint256 => Game.Village)) -> REF_1005.villages
REF_1007(Game.Village) -> REF_1006[h]
REF_1008(uint256) -> REF_1007.lastcollect
REF_1008(uint256) (->roundownables) := block.number(uint256)"];
93->94;
94[label="Node Type: EXPRESSION 94

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[i].lastcollect)).mul((roundvars[round].nextVillageId.sub(i)))

IRs:
REF_1010(Game.Ownables) -> roundownables[round]
REF_1011(mapping(uint256 => Game.Village)) -> REF_1010.villages
REF_1012(Game.Village) -> REF_1011[i]
REF_1013(uint256) -> REF_1012.lastcollect
TMP_342(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_1013'] 
REF_1015(Game.Variables) -> roundvars[round]
REF_1016(uint256) -> REF_1015.nextVillageId
TMP_343(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1016', 'i'] 
TMP_344(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_342', 'TMP_343'] 
test(uint256) := TMP_344(uint256)"];
94->95;
95[label="Node Type: IF 95

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_1018(Game.Variables) -> roundvars[round]
REF_1019(uint256) -> REF_1018.GOTCHatcontract
TMP_345(bool) = REF_1019 < test
CONDITION TMP_345"];
95->96[label="True"];
95->98[label="False"];
96[label="Node Type: EXPRESSION 96

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_1020(Game.Variables) -> roundvars[round]
REF_1021(uint256) -> REF_1020.GOTCHatcontract
REF_1022(Game.Variables) -> roundvars[round]
REF_1023(uint256) -> REF_1022.GOTCHatcontract
TMP_346(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1023', 'test'] 
REF_1021(uint256) (->roundvars) := TMP_346(uint256)"];
96->97;
97[label="Node Type: EXPRESSION 97

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_1025(Game.Variables) -> roundvars[round]
REF_1026(uint256) -> REF_1025.totalsupplyGOTCH
REF_1027(Game.Variables) -> roundvars[round]
REF_1028(uint256) -> REF_1027.totalsupplyGOTCH
TMP_347(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1028', 'test'] 
REF_1026(uint256) (->roundvars) := TMP_347(uint256)"];
97->98;
98[label="Node Type: END_IF 98
"];
98->99;
99[label="Node Type: EXPRESSION 99

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_1030(Game.Ownables) -> roundownables[round]
REF_1031(mapping(address => uint256)) -> REF_1030.GOTCH
REF_1032(uint256) -> REF_1031[msg.sender]
REF_1033(Game.Ownables) -> roundownables[round]
REF_1034(mapping(address => uint256)) -> REF_1033.GOTCH
REF_1035(uint256) -> REF_1034[msg.sender]
TMP_348(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1035', 'test'] 
REF_1032(uint256) (->roundownables) := TMP_348(uint256)"];
99->100;
100[label="Node Type: EXPRESSION 100

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_1037(Game.Variables) -> roundvars[round]
REF_1038(uint256) -> REF_1037.GOTCHatcontract
REF_1039(Game.Variables) -> roundvars[round]
REF_1040(uint256) -> REF_1039.GOTCHatcontract
TMP_349(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1040', 'test'] 
REF_1038(uint256) (->roundvars) := TMP_349(uint256)"];
100->101;
101[label="Node Type: EXPRESSION 101

EXPRESSION:
roundownables[round].villages[i].lastcollect = block.number

IRs:
REF_1042(Game.Ownables) -> roundownables[round]
REF_1043(mapping(uint256 => Game.Village)) -> REF_1042.villages
REF_1044(Game.Village) -> REF_1043[i]
REF_1045(uint256) -> REF_1044.lastcollect
REF_1045(uint256) (->roundownables) := block.number(uint256)"];
}
// Function: 672.sol-Game-batchcreatevillage(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 10000000000000000 * amt)

IRs:
TMP_161(uint256) = 10000000000000000 * amt
TMP_162(bool) = msg.value >= TMP_161
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amt >= 1)

IRs:
TMP_164(bool) = amt >= 1
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amt <= 40)

IRs:
TMP_166(bool) = amt <= 40
TMP_167(None) = SOLIDITY_CALL require(bool)(TMP_166)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay)

IRs:
REF_345(Game.Variables) -> roundvars[round]
REF_346(uint256) -> REF_345.lastblockpayout
REF_348(Game.Variables) -> roundvars[round]
REF_349(uint256) -> REF_348.blocksbeforenewpay
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_346', 'REF_349'] 
TMP_169(bool) = block.number > TMP_168
CONDITION TMP_169"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
hillpayout()

IRs:
INTERNAL_CALL, Game.hillpayout()()"];
5->6;
6[label="Node Type: END_IF 6
"];
6->9;
7[label="Node Type: BEGIN_LOOP 7
"];
7->10;
8[label="Node Type: END_LOOP 8
"];
8->17;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
9->7;
10[label="Node Type: IF_LOOP 10

EXPRESSION:
i < amt

IRs:
TMP_171(bool) = i < amt
CONDITION TMP_171"];
10->11[label="True"];
10->8[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender

IRs:
REF_350(Game.Ownables) -> roundownables[round]
REF_351(mapping(uint256 => Game.Village)) -> REF_350.villages
REF_352(Game.Variables) -> roundvars[round]
REF_353(uint256) -> REF_352.nextVillageId
REF_354(Game.Village) -> REF_351[REF_353]
REF_355(address) -> REF_354.owner
REF_355(address) (->roundownables) := msg.sender(address)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number

IRs:
REF_356(Game.Ownables) -> roundownables[round]
REF_357(mapping(uint256 => Game.Village)) -> REF_356.villages
REF_358(Game.Variables) -> roundvars[round]
REF_359(uint256) -> REF_358.nextVillageId
REF_360(Game.Village) -> REF_357[REF_359]
REF_361(uint256) -> REF_360.lastcollect
REF_361(uint256) (->roundownables) := block.number(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number

IRs:
REF_362(Game.Ownables) -> roundownables[round]
REF_363(mapping(uint256 => Game.Village)) -> REF_362.villages
REF_364(Game.Variables) -> roundvars[round]
REF_365(uint256) -> REF_364.nextVillageId
REF_366(Game.Village) -> REF_363[REF_365]
REF_367(uint256) -> REF_366.beginnerprotection
REF_367(uint256) (->roundownables) := block.number(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
roundvars[round].nextVillageId ++

IRs:
REF_368(Game.Variables) -> roundvars[round]
REF_369(uint256) -> REF_368.nextVillageId
TMP_172(uint256) := REF_369(uint256)
REF_369(-> roundvars) = REF_369 + 1"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId

IRs:
REF_370(Game.Ownables) -> roundownables[round]
REF_371(mapping(uint256 => Game.Village)) -> REF_370.villages
REF_372(Game.Variables) -> roundvars[round]
REF_373(uint256) -> REF_372.nextVillageId
REF_374(Game.Village) -> REF_371[REF_373]
REF_375(uint256) -> REF_374.defending
REF_376(Game.Variables) -> roundvars[round]
REF_377(uint256) -> REF_376.nextVillageId
REF_375(uint256) (->roundownables) := REF_377(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_173(uint256) := i(uint256)
i(uint256) = i + 1"];
16->10;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
Redeemable[msg.sender] = Redeemable[msg.sender].add(amt)

IRs:
REF_378(uint256) -> Redeemable[msg.sender]
REF_379(uint256) -> Redeemable[msg.sender]
TMP_174(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_379', 'amt'] 
REF_378(uint256) (->Redeemable) := TMP_174(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
roundownables[round].redeemedvils[msg.sender] = roundownables[round].redeemedvils[msg.sender].add(amt)

IRs:
REF_381(Game.Ownables) -> roundownables[round]
REF_382(mapping(address => uint256)) -> REF_381.redeemedvils
REF_383(uint256) -> REF_382[msg.sender]
REF_384(Game.Ownables) -> roundownables[round]
REF_385(mapping(address => uint256)) -> REF_384.redeemedvils
REF_386(uint256) -> REF_385[msg.sender]
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_386', 'amt'] 
REF_383(uint256) (->roundownables) := TMP_175(uint256)"];
}
// Function: 672.sol-Game-buyDOTCH(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_385(bool) = msg.value >= 1000000000000000
TMP_386(None) = SOLIDITY_CALL require(bool)(TMP_385)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(roundownables[round].ERCtradeactive == true)

IRs:
REF_1125(Game.Ownables) -> roundownables[round]
REF_1126(bool) -> REF_1125.ERCtradeactive
TMP_387(bool) = REF_1126 == True
TMP_388(None) = SOLIDITY_CALL require(bool)(TMP_387)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balances[this] >= amt)

IRs:
REF_1127(uint256) -> balances[this]
TMP_389(bool) = REF_1127 >= amt
TMP_390(None) = SOLIDITY_CALL require(bool)(TMP_389)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(roundownables[round].GOTCH[msg.sender] >= amt.mul(10000))

IRs:
REF_1128(Game.Ownables) -> roundownables[round]
REF_1129(mapping(address => uint256)) -> REF_1128.GOTCH
REF_1130(uint256) -> REF_1129[msg.sender]
TMP_391(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amt', '10000'] 
TMP_392(bool) = REF_1130 >= TMP_391
TMP_393(None) = SOLIDITY_CALL require(bool)(TMP_392)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(amt >= 1)

IRs:
TMP_394(bool) = amt >= 1
TMP_395(None) = SOLIDITY_CALL require(bool)(TMP_394)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[this] = balances[this].sub(amt)

IRs:
REF_1132(uint256) -> balances[this]
REF_1133(uint256) -> balances[this]
TMP_396(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1133', 'amt'] 
REF_1132(uint256) (->balances) := TMP_396(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(amt)

IRs:
REF_1135(uint256) -> balances[msg.sender]
REF_1136(uint256) -> balances[msg.sender]
TMP_397(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1136', 'amt'] 
REF_1135(uint256) (->balances) := TMP_397(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(this,msg.sender,amt)

IRs:
Emit Transfer(this,msg.sender,amt)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].sub(amt.mul(10000))

IRs:
REF_1138(Game.Ownables) -> roundownables[round]
REF_1139(mapping(address => uint256)) -> REF_1138.GOTCH
REF_1140(uint256) -> REF_1139[msg.sender]
REF_1141(Game.Ownables) -> roundownables[round]
REF_1142(mapping(address => uint256)) -> REF_1141.GOTCH
REF_1143(uint256) -> REF_1142[msg.sender]
TMP_399(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amt', '10000'] 
TMP_400(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1143', 'TMP_399'] 
REF_1140(uint256) (->roundownables) := TMP_400(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
roundownables[round].GOTCH[this] = roundownables[round].GOTCH[this].add(amt.mul(10000))

IRs:
REF_1146(Game.Ownables) -> roundownables[round]
REF_1147(mapping(address => uint256)) -> REF_1146.GOTCH
REF_1148(uint256) -> REF_1147[this]
REF_1149(Game.Ownables) -> roundownables[round]
REF_1150(mapping(address => uint256)) -> REF_1149.GOTCH
REF_1151(uint256) -> REF_1150[this]
TMP_401(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amt', '10000'] 
TMP_402(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1151', 'TMP_401'] 
REF_1148(uint256) (->roundownables) := TMP_402(uint256)"];
}
// Function: 672.sol-Game-buyp3d(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
P3Dcontract_.buy.value(amt)(this)

IRs:
TMP_404(uint256) = HIGH_LEVEL_CALL, dest:P3Dcontract_(HourglassInterface), function:buy, arguments:['this'] value:amt "];
}
// Function: 672.sol-Game-buysoldiers(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_141(bool) = msg.value >= 1000000000000000
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
updatesolsforhire()

IRs:
INTERNAL_CALL, Game.updatesolsforhire()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
updatesolbuyrate()

IRs:
INTERNAL_CALL, Game.updatesolbuyrate()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amount <= roundvars[round].solsforhire)

IRs:
REF_276(Game.Variables) -> roundvars[round]
REF_277(uint256) -> REF_276.solsforhire
TMP_145(bool) = amount <= REF_277
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].add(amount)

IRs:
REF_278(Game.Ownables) -> roundownables[round]
REF_279(mapping(address => uint256)) -> REF_278.soldiers
REF_280(uint256) -> REF_279[msg.sender]
REF_281(Game.Ownables) -> roundownables[round]
REF_282(mapping(address => uint256)) -> REF_281.soldiers
REF_283(uint256) -> REF_282[msg.sender]
TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_283', 'amount'] 
REF_280(uint256) (->roundownables) := TMP_147(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundvars[round].solsforhire = roundvars[round].solsforhire.sub(amount)

IRs:
REF_285(Game.Variables) -> roundvars[round]
REF_286(uint256) -> REF_285.solsforhire
REF_287(Game.Variables) -> roundvars[round]
REF_288(uint256) -> REF_287.solsforhire
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_288', 'amount'] 
REF_286(uint256) (->roundvars) := TMP_148(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].sub(amount.mul(roundvars[round].soldierprice))

IRs:
REF_290(Game.Ownables) -> roundownables[round]
REF_291(mapping(address => uint256)) -> REF_290.GOTCH
REF_292(uint256) -> REF_291[msg.sender]
REF_293(Game.Ownables) -> roundownables[round]
REF_294(mapping(address => uint256)) -> REF_293.GOTCH
REF_295(uint256) -> REF_294[msg.sender]
REF_298(Game.Variables) -> roundvars[round]
REF_299(uint256) -> REF_298.soldierprice
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'REF_299'] 
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_295', 'TMP_149'] 
REF_292(uint256) (->roundownables) := TMP_150(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(amount.mul(roundvars[round].soldierprice))

IRs:
REF_300(Game.Variables) -> roundvars[round]
REF_301(uint256) -> REF_300.GOTCHatcontract
REF_302(Game.Variables) -> roundvars[round]
REF_303(uint256) -> REF_302.GOTCHatcontract
REF_306(Game.Variables) -> roundvars[round]
REF_307(uint256) -> REF_306.soldierprice
TMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'REF_307'] 
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_303', 'TMP_151'] 
REF_301(uint256) (->roundvars) := TMP_152(uint256)"];
}
// Function: 672.sol-Game-changebeginnerprotection(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
roundvars[round].bpamount = blockcount

IRs:
REF_237(Game.Variables) -> roundvars[round]
REF_238(uint256) -> REF_237.bpamount
REF_238(uint256) (->roundvars) := blockcount(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 672.sol-Game-changesoldierreplenishrate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
roundvars[round].soldierreplenishrate = rate

IRs:
REF_239(Game.Variables) -> roundvars[round]
REF_240(uint256) -> REF_239.soldierreplenishrate
REF_240(uint256) (->roundvars) := rate(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 672.sol-Game-changetradestatus(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
roundownables[round].ERCtradeactive = active

IRs:
REF_235(Game.Ownables) -> roundownables[round]
REF_236(bool) -> REF_235.ERCtradeactive
REF_236(bool) (->roundownables) := active(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 672.sol-Game-cheapredeemvillage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_176(bool) = msg.value >= 1000000000000000
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(roundownables[round].redeemedvils[msg.sender] < Redeemable[msg.sender])

IRs:
REF_388(Game.Ownables) -> roundownables[round]
REF_389(mapping(address => uint256)) -> REF_388.redeemedvils
REF_390(uint256) -> REF_389[msg.sender]
REF_391(uint256) -> Redeemable[msg.sender]
TMP_178(bool) = REF_390 < REF_391
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender

IRs:
REF_392(Game.Ownables) -> roundownables[round]
REF_393(mapping(uint256 => Game.Village)) -> REF_392.villages
REF_394(Game.Variables) -> roundvars[round]
REF_395(uint256) -> REF_394.nextVillageId
REF_396(Game.Village) -> REF_393[REF_395]
REF_397(address) -> REF_396.owner
REF_397(address) (->roundownables) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number

IRs:
REF_398(Game.Ownables) -> roundownables[round]
REF_399(mapping(uint256 => Game.Village)) -> REF_398.villages
REF_400(Game.Variables) -> roundvars[round]
REF_401(uint256) -> REF_400.nextVillageId
REF_402(Game.Village) -> REF_399[REF_401]
REF_403(uint256) -> REF_402.lastcollect
REF_403(uint256) (->roundownables) := block.number(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number

IRs:
REF_404(Game.Ownables) -> roundownables[round]
REF_405(mapping(uint256 => Game.Village)) -> REF_404.villages
REF_406(Game.Variables) -> roundvars[round]
REF_407(uint256) -> REF_406.nextVillageId
REF_408(Game.Village) -> REF_405[REF_407]
REF_409(uint256) -> REF_408.beginnerprotection
REF_409(uint256) (->roundownables) := block.number(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundvars[round].nextVillageId ++

IRs:
REF_410(Game.Variables) -> roundvars[round]
REF_411(uint256) -> REF_410.nextVillageId
TMP_180(uint256) := REF_411(uint256)
REF_411(-> roundvars) = REF_411 + 1"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId

IRs:
REF_412(Game.Ownables) -> roundownables[round]
REF_413(mapping(uint256 => Game.Village)) -> REF_412.villages
REF_414(Game.Variables) -> roundvars[round]
REF_415(uint256) -> REF_414.nextVillageId
REF_416(Game.Village) -> REF_413[REF_415]
REF_417(uint256) -> REF_416.defending
REF_418(Game.Variables) -> roundvars[round]
REF_419(uint256) -> REF_418.nextVillageId
REF_417(uint256) (->roundownables) := REF_419(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
roundownables[round].redeemedvils[msg.sender] ++

IRs:
REF_420(Game.Ownables) -> roundownables[round]
REF_421(mapping(address => uint256)) -> REF_420.redeemedvils
REF_422(uint256) -> REF_421[msg.sender]
TMP_181(uint256) := REF_422(uint256)
REF_422(-> roundownables) = REF_422 + 1"];
}
// Function: 672.sol-Game-claimdivs()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
P3Dcontract_.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:P3Dcontract_(HourglassInterface), function:withdraw, arguments:[]  "];
}
// Function: 672.sol-Game-collecttaxes(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_350(bool) = msg.value >= 1000000000000000
TMP_351(None) = SOLIDITY_CALL require(bool)(TMP_350)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay)

IRs:
REF_1046(Game.Variables) -> roundvars[round]
REF_1047(uint256) -> REF_1046.lastblockpayout
REF_1049(Game.Variables) -> roundvars[round]
REF_1050(uint256) -> REF_1049.blocksbeforenewpay
TMP_352(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1047', 'REF_1050'] 
TMP_353(bool) = block.number > TMP_352
CONDITION TMP_353"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
hillpayout()

IRs:
INTERNAL_CALL, Game.hillpayout()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(roundownables[round].villages[village].owner == msg.sender)

IRs:
REF_1051(Game.Ownables) -> roundownables[round]
REF_1052(mapping(uint256 => Game.Village)) -> REF_1051.villages
REF_1053(Game.Village) -> REF_1052[village]
REF_1054(address) -> REF_1053.owner
TMP_355(bool) = REF_1054 == msg.sender
TMP_356(None) = SOLIDITY_CALL require(bool)(TMP_355)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(block.number > roundownables[round].villages[village].lastcollect)

IRs:
REF_1055(Game.Ownables) -> roundownables[round]
REF_1056(mapping(uint256 => Game.Village)) -> REF_1055.villages
REF_1057(Game.Village) -> REF_1056[village]
REF_1058(uint256) -> REF_1057.lastcollect
TMP_357(bool) = block.number > REF_1058
TMP_358(None) = SOLIDITY_CALL require(bool)(TMP_357)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
test = (block.number.sub(roundownables[round].villages[village].lastcollect)).mul((roundvars[round].nextVillageId.sub(village)))

IRs:
REF_1060(Game.Ownables) -> roundownables[round]
REF_1061(mapping(uint256 => Game.Village)) -> REF_1060.villages
REF_1062(Game.Village) -> REF_1061[village]
REF_1063(uint256) -> REF_1062.lastcollect
TMP_359(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_1063'] 
REF_1065(Game.Variables) -> roundvars[round]
REF_1066(uint256) -> REF_1065.nextVillageId
TMP_360(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1066', 'village'] 
TMP_361(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_359', 'TMP_360'] 
test(uint256) := TMP_361(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
roundvars[round].GOTCHatcontract < test

IRs:
REF_1068(Game.Variables) -> roundvars[round]
REF_1069(uint256) -> REF_1068.GOTCHatcontract
TMP_362(bool) = REF_1069 < test
CONDITION TMP_362"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test)

IRs:
REF_1070(Game.Variables) -> roundvars[round]
REF_1071(uint256) -> REF_1070.GOTCHatcontract
REF_1072(Game.Variables) -> roundvars[round]
REF_1073(uint256) -> REF_1072.GOTCHatcontract
TMP_363(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1073', 'test'] 
REF_1071(uint256) (->roundvars) := TMP_363(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test)

IRs:
REF_1075(Game.Variables) -> roundvars[round]
REF_1076(uint256) -> REF_1075.totalsupplyGOTCH
REF_1077(Game.Variables) -> roundvars[round]
REF_1078(uint256) -> REF_1077.totalsupplyGOTCH
TMP_364(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1078', 'test'] 
REF_1076(uint256) (->roundvars) := TMP_364(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test)

IRs:
REF_1080(Game.Ownables) -> roundownables[round]
REF_1081(mapping(address => uint256)) -> REF_1080.GOTCH
REF_1082(uint256) -> REF_1081[msg.sender]
REF_1083(Game.Ownables) -> roundownables[round]
REF_1084(mapping(address => uint256)) -> REF_1083.GOTCH
REF_1085(uint256) -> REF_1084[msg.sender]
TMP_365(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1085', 'test'] 
REF_1082(uint256) (->roundownables) := TMP_365(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test)

IRs:
REF_1087(Game.Variables) -> roundvars[round]
REF_1088(uint256) -> REF_1087.GOTCHatcontract
REF_1089(Game.Variables) -> roundvars[round]
REF_1090(uint256) -> REF_1089.GOTCHatcontract
TMP_366(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1090', 'test'] 
REF_1088(uint256) (->roundvars) := TMP_366(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
roundownables[round].villages[village].lastcollect = block.number

IRs:
REF_1092(Game.Ownables) -> roundownables[round]
REF_1093(mapping(uint256 => Game.Village)) -> REF_1092.villages
REF_1094(Game.Village) -> REF_1093[village]
REF_1095(uint256) -> REF_1094.lastcollect
REF_1095(uint256) (->roundownables) := block.number(uint256)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
test

IRs:
RETURN test"];
}
// Function: 672.sol-Game-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
round ++

IRs:
TMP_72(uint256) := round(uint256)
round(uint256) = round + 1"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roundvars[round].totalsupplyGOTCH = 10000

IRs:
REF_94(Game.Variables) -> roundvars[round]
REF_95(uint256) -> REF_94.totalsupplyGOTCH
REF_95(uint256) (->roundvars) := 10000(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
roundvars[round].GOTCHatcontract = 10000

IRs:
REF_96(Game.Variables) -> roundvars[round]
REF_97(uint256) -> REF_96.GOTCHatcontract
REF_97(uint256) (->roundvars) := 10000(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roundvars[round].solsforhire = 100

IRs:
REF_98(Game.Variables) -> roundvars[round]
REF_99(uint256) -> REF_98.solsforhire
REF_99(uint256) (->roundvars) := 100(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundvars[round].soldierreplenishrate = 50

IRs:
REF_100(Game.Variables) -> roundvars[round]
REF_101(uint256) -> REF_100.soldierreplenishrate
REF_101(uint256) (->roundvars) := 50(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundvars[round].solslastupdate = block.number

IRs:
REF_102(Game.Variables) -> roundvars[round]
REF_103(uint256) -> REF_102.solslastupdate
REF_103(uint256) (->roundvars) := block.number(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updatesolbuyrate()

IRs:
INTERNAL_CALL, Game.updatesolbuyrate()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
roundvars[round].lastblockpayout = block.number

IRs:
REF_104(Game.Variables) -> roundvars[round]
REF_105(uint256) -> REF_104.lastblockpayout
REF_105(uint256) (->roundvars) := block.number(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundownables[round].hillowner = msg.sender

IRs:
REF_106(Game.Ownables) -> roundownables[round]
REF_107(address) -> REF_106.hillowner
REF_107(address) (->roundownables) := msg.sender(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
roundvars[round].nextpayamount = 0

IRs:
REF_108(Game.Variables) -> roundvars[round]
REF_109(uint256) -> REF_108.nextpayamount
REF_109(uint256) (->roundvars) := 0(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
roundvars[round].nextowneramount = 0

IRs:
REF_110(Game.Variables) -> roundvars[round]
REF_111(uint256) -> REF_110.nextowneramount
REF_111(uint256) (->roundvars) := 0(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
roundvars[round].previousethamount = 0

IRs:
REF_112(Game.Variables) -> roundvars[round]
REF_113(uint256) -> REF_112.previousethamount
REF_113(uint256) (->roundvars) := 0(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
roundvars[round].blocksbeforenewpay = 250

IRs:
REF_114(Game.Variables) -> roundvars[round]
REF_115(uint256) -> REF_114.blocksbeforenewpay
REF_115(uint256) (->roundvars) := 250(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
roundvars[round].bpamount = 30000

IRs:
REF_116(Game.Variables) -> roundvars[round]
REF_117(uint256) -> REF_116.bpamount
REF_117(uint256) (->roundvars) := 30000(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
roundownables[round].ERCtradeactive = true

IRs:
REF_118(Game.Ownables) -> roundownables[round]
REF_119(bool) -> REF_118.ERCtradeactive
REF_119(bool) (->roundownables) := True(bool)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
roundownables[round].roundlength = 10000000000000000000000

IRs:
REF_120(Game.Ownables) -> roundownables[round]
REF_121(uint256) -> REF_120.roundlength
REF_121(uint256) (->roundownables) := 10000000000000000000000(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
divsforall = false

IRs:
divsforall(bool) := False(bool)"];
}
// Function: 672.sol-Game-createvillage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 10000000000000000)

IRs:
TMP_153(bool) = msg.value >= 10000000000000000
TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay)

IRs:
REF_308(Game.Variables) -> roundvars[round]
REF_309(uint256) -> REF_308.lastblockpayout
REF_311(Game.Variables) -> roundvars[round]
REF_312(uint256) -> REF_311.blocksbeforenewpay
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_309', 'REF_312'] 
TMP_156(bool) = block.number > TMP_155
CONDITION TMP_156"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
hillpayout()

IRs:
INTERNAL_CALL, Game.hillpayout()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender

IRs:
REF_313(Game.Ownables) -> roundownables[round]
REF_314(mapping(uint256 => Game.Village)) -> REF_313.villages
REF_315(Game.Variables) -> roundvars[round]
REF_316(uint256) -> REF_315.nextVillageId
REF_317(Game.Village) -> REF_314[REF_316]
REF_318(address) -> REF_317.owner
REF_318(address) (->roundownables) := msg.sender(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number

IRs:
REF_319(Game.Ownables) -> roundownables[round]
REF_320(mapping(uint256 => Game.Village)) -> REF_319.villages
REF_321(Game.Variables) -> roundvars[round]
REF_322(uint256) -> REF_321.nextVillageId
REF_323(Game.Village) -> REF_320[REF_322]
REF_324(uint256) -> REF_323.lastcollect
REF_324(uint256) (->roundownables) := block.number(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number

IRs:
REF_325(Game.Ownables) -> roundownables[round]
REF_326(mapping(uint256 => Game.Village)) -> REF_325.villages
REF_327(Game.Variables) -> roundvars[round]
REF_328(uint256) -> REF_327.nextVillageId
REF_329(Game.Village) -> REF_326[REF_328]
REF_330(uint256) -> REF_329.beginnerprotection
REF_330(uint256) (->roundownables) := block.number(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
roundvars[round].nextVillageId ++

IRs:
REF_331(Game.Variables) -> roundvars[round]
REF_332(uint256) -> REF_331.nextVillageId
TMP_158(uint256) := REF_332(uint256)
REF_332(-> roundvars) = REF_332 + 1"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId

IRs:
REF_333(Game.Ownables) -> roundownables[round]
REF_334(mapping(uint256 => Game.Village)) -> REF_333.villages
REF_335(Game.Variables) -> roundvars[round]
REF_336(uint256) -> REF_335.nextVillageId
REF_337(Game.Village) -> REF_334[REF_336]
REF_338(uint256) -> REF_337.defending
REF_339(Game.Variables) -> roundvars[round]
REF_340(uint256) -> REF_339.nextVillageId
REF_338(uint256) (->roundownables) := REF_340(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Redeemable[msg.sender] ++

IRs:
REF_341(uint256) -> Redeemable[msg.sender]
TMP_159(uint256) := REF_341(uint256)
REF_341(-> Redeemable) = REF_341 + 1"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
roundownables[round].redeemedvils[msg.sender] ++

IRs:
REF_342(Game.Ownables) -> roundownables[round]
REF_343(mapping(address => uint256)) -> REF_342.redeemedvils
REF_344(uint256) -> REF_343[msg.sender]
TMP_160(uint256) := REF_344(uint256)
REF_344(-> roundownables) = REF_344 + 1"];
}
// Function: 672.sol-Game-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 672.sol-Game-gotchinfo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(roundownables[round].GOTCH[lookup])

IRs:
REF_75(Game.Ownables) -> roundownables[round]
REF_76(mapping(address => uint256)) -> REF_75.GOTCH
REF_77(uint256) -> REF_76[lookup]
RETURN REF_77"];
2[label="Node Type: RETURN 2

EXPRESSION:
Gold

IRs:
RETURN Gold"];
}
// Function: 672.sol-Game-harvestabledivs()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(P3Dcontract_.dividendsOf(address(this)))

IRs:
TMP_70 = CONVERT this to address
TMP_71(uint256) = HIGH_LEVEL_CALL, dest:P3Dcontract_(HourglassInterface), function:dividendsOf, arguments:['TMP_70']  
RETURN TMP_71"];
}
// Function: 672.sol-Game-hillpayout()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))

IRs:
REF_122(Game.Variables) -> roundvars[round]
REF_123(uint256) -> REF_122.lastblockpayout
REF_125(Game.Variables) -> roundvars[round]
REF_126(uint256) -> REF_125.blocksbeforenewpay
TMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_123', 'REF_126'] 
TMP_75(bool) = block.number > TMP_74
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roundvars[round].lastblockpayout = roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay)

IRs:
REF_127(Game.Variables) -> roundvars[round]
REF_128(uint256) -> REF_127.lastblockpayout
REF_129(Game.Variables) -> roundvars[round]
REF_130(uint256) -> REF_129.lastblockpayout
REF_132(Game.Variables) -> roundvars[round]
REF_133(uint256) -> REF_132.blocksbeforenewpay
TMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_130', 'REF_133'] 
REF_128(uint256) (->roundvars) := TMP_77(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ethforp3dbuy = ethforp3dbuy.add((address(this).balance.sub(ethforp3dbuy)).div(100))

IRs:
TMP_78 = CONVERT this to address
TMP_79(uint256) = SOLIDITY_CALL balance(address)(TMP_78)
TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_79', 'ethforp3dbuy'] 
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_80', '100'] 
TMP_82(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['ethforp3dbuy', 'TMP_81'] 
ethforp3dbuy(uint256) := TMP_82(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
owner.transfer((address(this).balance.sub(ethforp3dbuy)).div(100))

IRs:
TMP_83 = CONVERT this to address
TMP_84(uint256) = SOLIDITY_CALL balance(address)(TMP_83)
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_84', 'ethforp3dbuy'] 
TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_85', '100'] 
Transfer dest:owner value:TMP_86"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundvars[round].ATPO = roundvars[round].ATPO.add((address(this).balance.sub(ethforp3dbuy)).div(2))

IRs:
REF_140(Game.Variables) -> roundvars[round]
REF_141(uint256) -> REF_140.ATPO
REF_142(Game.Variables) -> roundvars[round]
REF_143(uint256) -> REF_142.ATPO
TMP_88 = CONVERT this to address
TMP_89(uint256) = SOLIDITY_CALL balance(address)(TMP_88)
TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_89', 'ethforp3dbuy'] 
TMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_90', '2'] 
TMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_143', 'TMP_91'] 
REF_141(uint256) (->roundvars) := TMP_92(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundownables[round].hillowner.transfer((address(this).balance.sub(ethforp3dbuy)).div(2))

IRs:
REF_147(Game.Ownables) -> roundownables[round]
REF_148(address) -> REF_147.hillowner
TMP_93 = CONVERT this to address
TMP_94(uint256) = SOLIDITY_CALL balance(address)(TMP_93)
TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_94', 'ethforp3dbuy'] 
TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_95', '2'] 
Transfer dest:REF_148 value:TMP_96"];
}
// Function: 672.sol-Game-offerchangeprice(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(price > 0)

IRs:
TMP_453(bool) = price > 0
TMP_454(None) = SOLIDITY_CALL require(bool)(TMP_453)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == marketplace[ordernumber].placedby)

IRs:
REF_1202(Game.Marketoffer) -> marketplace[ordernumber]
REF_1203(address) -> REF_1202.placedby
TMP_455(bool) = msg.sender == REF_1203
TMP_456(None) = SOLIDITY_CALL require(bool)(TMP_455)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
marketplace[ordernumber].wantsthisamtweiperdotch = price

IRs:
REF_1204(Game.Marketoffer) -> marketplace[ordernumber]
REF_1205(uint256) -> REF_1204.wantsthisamtweiperdotch
REF_1205(uint256) (->marketplace) := price(uint256)"];
}
// Function: 672.sol-Game-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_483(bool) = msg.sender == owner
TMP_484(None) = SOLIDITY_CALL require(bool)(TMP_483)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 672.sol-Game-placeoffer(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(dotchamount > 0)

IRs:
TMP_421(bool) = dotchamount > 0
TMP_422(None) = SOLIDITY_CALL require(bool)(TMP_421)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(askingpriceinwei > 0)

IRs:
TMP_423(bool) = askingpriceinwei > 0
TMP_424(None) = SOLIDITY_CALL require(bool)(TMP_423)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balances[msg.sender] >= dotchamount)

IRs:
REF_1161(uint256) -> balances[msg.sender]
TMP_425(bool) = REF_1161 >= dotchamount
TMP_426(None) = SOLIDITY_CALL require(bool)(TMP_425)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_427(bool) = msg.value >= 1000000000000000
TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(dotchamount)

IRs:
REF_1162(uint256) -> balances[msg.sender]
REF_1163(uint256) -> balances[msg.sender]
TMP_429(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1163', 'dotchamount'] 
REF_1162(uint256) (->balances) := TMP_429(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[this] = balances[this].add(dotchamount)

IRs:
REF_1165(uint256) -> balances[this]
REF_1166(uint256) -> balances[this]
TMP_430(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1166', 'dotchamount'] 
REF_1165(uint256) (->balances) := TMP_430(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,this,dotchamount)

IRs:
Emit Transfer(msg.sender,this,dotchamount)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
marketplace[nextmarketoffer].placedby = msg.sender

IRs:
REF_1168(Game.Marketoffer) -> marketplace[nextmarketoffer]
REF_1169(address) -> REF_1168.placedby
REF_1169(address) (->marketplace) := msg.sender(address)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
marketplace[nextmarketoffer].amountdotch = dotchamount

IRs:
REF_1170(Game.Marketoffer) -> marketplace[nextmarketoffer]
REF_1171(uint256) -> REF_1170.amountdotch
REF_1171(uint256) (->marketplace) := dotchamount(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
marketplace[nextmarketoffer].wantsthisamtweiperdotch = askingpriceinwei

IRs:
REF_1172(Game.Marketoffer) -> marketplace[nextmarketoffer]
REF_1173(uint256) -> REF_1172.wantsthisamtweiperdotch
REF_1173(uint256) (->marketplace) := askingpriceinwei(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
nextmarketoffer ++

IRs:
TMP_432(uint256) := nextmarketoffer(uint256)
nextmarketoffer(uint256) = nextmarketoffer + 1"];
}
// Function: 672.sol-Game-playerinfo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(roundownables[round].redeemedvils[lookup],Redeemable[lookup],roundownables[round].soldiers[lookup],roundownables[round].GOTCH[lookup])

IRs:
REF_84(Game.Ownables) -> roundownables[round]
REF_85(mapping(address => uint256)) -> REF_84.redeemedvils
REF_86(uint256) -> REF_85[lookup]
REF_87(uint256) -> Redeemable[lookup]
REF_88(Game.Ownables) -> roundownables[round]
REF_89(mapping(address => uint256)) -> REF_88.soldiers
REF_90(uint256) -> REF_89[lookup]
REF_91(Game.Ownables) -> roundownables[round]
REF_92(mapping(address => uint256)) -> REF_91.GOTCH
REF_93(uint256) -> REF_92[lookup]
RETURN REF_86,REF_87,REF_90,REF_93"];
2[label="Node Type: RETURN 2

EXPRESSION:
(redeemedvils,redeemablevils,soldiers,GOTCH)

IRs:
RETURN redeemedvils,redeemablevils,soldiers,GOTCH"];
}
// Function: 672.sol-Game-preregvills(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].owner = reg

IRs:
REF_423(Game.Ownables) -> roundownables[round]
REF_424(mapping(uint256 => Game.Village)) -> REF_423.villages
REF_425(Game.Variables) -> roundvars[round]
REF_426(uint256) -> REF_425.nextVillageId
REF_427(Game.Village) -> REF_424[REF_426]
REF_428(address) -> REF_427.owner
REF_428(address) (->roundownables) := reg(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number

IRs:
REF_429(Game.Ownables) -> roundownables[round]
REF_430(mapping(uint256 => Game.Village)) -> REF_429.villages
REF_431(Game.Variables) -> roundvars[round]
REF_432(uint256) -> REF_431.nextVillageId
REF_433(Game.Village) -> REF_430[REF_432]
REF_434(uint256) -> REF_433.lastcollect
REF_434(uint256) (->roundownables) := block.number(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number

IRs:
REF_435(Game.Ownables) -> roundownables[round]
REF_436(mapping(uint256 => Game.Village)) -> REF_435.villages
REF_437(Game.Variables) -> roundvars[round]
REF_438(uint256) -> REF_437.nextVillageId
REF_439(Game.Village) -> REF_436[REF_438]
REF_440(uint256) -> REF_439.beginnerprotection
REF_440(uint256) (->roundownables) := block.number(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roundvars[round].nextVillageId ++

IRs:
REF_441(Game.Variables) -> roundvars[round]
REF_442(uint256) -> REF_441.nextVillageId
TMP_182(uint256) := REF_442(uint256)
REF_442(-> roundvars) = REF_442 + 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId

IRs:
REF_443(Game.Ownables) -> roundownables[round]
REF_444(mapping(uint256 => Game.Village)) -> REF_443.villages
REF_445(Game.Variables) -> roundvars[round]
REF_446(uint256) -> REF_445.nextVillageId
REF_447(Game.Village) -> REF_444[REF_446]
REF_448(uint256) -> REF_447.defending
REF_449(Game.Variables) -> roundvars[round]
REF_450(uint256) -> REF_449.nextVillageId
REF_448(uint256) (->roundownables) := REF_450(uint256)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
6->1;
}
// Function: 672.sol-Game-redeemablevilsinfo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(roundownables[round].redeemedvils[lookup])

IRs:
REF_81(Game.Ownables) -> roundownables[round]
REF_82(mapping(address => uint256)) -> REF_81.redeemedvils
REF_83(uint256) -> REF_82[lookup]
RETURN REF_83"];
2[label="Node Type: RETURN 2

EXPRESSION:
redeemedvils

IRs:
RETURN redeemedvils"];
}
// Function: 672.sol-Game-removedotchtooffer(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(dotchamount > 0)

IRs:
TMP_443(bool) = dotchamount > 0
TMP_444(None) = SOLIDITY_CALL require(bool)(TMP_443)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == marketplace[ordernumber].placedby)

IRs:
REF_1188(Game.Marketoffer) -> marketplace[ordernumber]
REF_1189(address) -> REF_1188.placedby
TMP_445(bool) = msg.sender == REF_1189
TMP_446(None) = SOLIDITY_CALL require(bool)(TMP_445)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balances[this] >= dotchamount)

IRs:
REF_1190(uint256) -> balances[this]
TMP_447(bool) = REF_1190 >= dotchamount
TMP_448(None) = SOLIDITY_CALL require(bool)(TMP_447)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(dotchamount)

IRs:
REF_1191(uint256) -> balances[msg.sender]
REF_1192(uint256) -> balances[msg.sender]
TMP_449(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1192', 'dotchamount'] 
REF_1191(uint256) (->balances) := TMP_449(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[this] = balances[this].sub(dotchamount)

IRs:
REF_1194(uint256) -> balances[this]
REF_1195(uint256) -> balances[this]
TMP_450(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1195', 'dotchamount'] 
REF_1194(uint256) (->balances) := TMP_450(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(this,msg.sender,dotchamount)

IRs:
Emit Transfer(this,msg.sender,dotchamount)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
marketplace[ordernumber].amountdotch = marketplace[ordernumber].amountdotch.sub(dotchamount)

IRs:
REF_1197(Game.Marketoffer) -> marketplace[ordernumber]
REF_1198(uint256) -> REF_1197.amountdotch
REF_1199(Game.Marketoffer) -> marketplace[ordernumber]
REF_1200(uint256) -> REF_1199.amountdotch
TMP_452(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1200', 'dotchamount'] 
REF_1198(uint256) (->marketplace) := TMP_452(uint256)"];
}
// Function: 672.sol-Game-renewbeginnerprotection(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= (roundvars[round].nextVillageId.sub(village)).mul(1000000000000000))

IRs:
REF_588(Game.Variables) -> roundvars[round]
REF_589(uint256) -> REF_588.nextVillageId
TMP_224(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_589', 'village'] 
TMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_224', '1000000000000000'] 
TMP_226(bool) = msg.value >= TMP_225
TMP_227(None) = SOLIDITY_CALL require(bool)(TMP_226)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roundownables[round].villages[village].beginnerprotection = block.number

IRs:
REF_592(Game.Ownables) -> roundownables[round]
REF_593(mapping(uint256 => Game.Village)) -> REF_592.villages
REF_594(Game.Village) -> REF_593[village]
REF_595(uint256) -> REF_594.beginnerprotection
REF_595(uint256) (->roundownables) := block.number(uint256)"];
}
// Function: 672.sol-Game-sellDOTCH(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_367(bool) = msg.value >= 1000000000000000
TMP_368(None) = SOLIDITY_CALL require(bool)(TMP_367)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(roundownables[round].ERCtradeactive == true)

IRs:
REF_1096(Game.Ownables) -> roundownables[round]
REF_1097(bool) -> REF_1096.ERCtradeactive
TMP_369(bool) = REF_1097 == True
TMP_370(None) = SOLIDITY_CALL require(bool)(TMP_369)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(roundownables[round].GOTCH[this] >= amt.mul(10000))

IRs:
REF_1098(Game.Ownables) -> roundownables[round]
REF_1099(mapping(address => uint256)) -> REF_1098.GOTCH
REF_1100(uint256) -> REF_1099[this]
TMP_371(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amt', '10000'] 
TMP_372(bool) = REF_1100 >= TMP_371
TMP_373(None) = SOLIDITY_CALL require(bool)(TMP_372)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(balances[msg.sender] >= amt)

IRs:
REF_1102(uint256) -> balances[msg.sender]
TMP_374(bool) = REF_1102 >= amt
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(amt >= 1)

IRs:
TMP_376(bool) = amt >= 1
TMP_377(None) = SOLIDITY_CALL require(bool)(TMP_376)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[this] = balances[this].add(amt)

IRs:
REF_1103(uint256) -> balances[this]
REF_1104(uint256) -> balances[this]
TMP_378(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1104', 'amt'] 
REF_1103(uint256) (->balances) := TMP_378(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(amt)

IRs:
REF_1106(uint256) -> balances[msg.sender]
REF_1107(uint256) -> balances[msg.sender]
TMP_379(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1107', 'amt'] 
REF_1106(uint256) (->balances) := TMP_379(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,this,amt)

IRs:
Emit Transfer(msg.sender,this,amt)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundownables[round].GOTCH[this] = roundownables[round].GOTCH[this].sub(amt.mul(10000))

IRs:
REF_1109(Game.Ownables) -> roundownables[round]
REF_1110(mapping(address => uint256)) -> REF_1109.GOTCH
REF_1111(uint256) -> REF_1110[this]
REF_1112(Game.Ownables) -> roundownables[round]
REF_1113(mapping(address => uint256)) -> REF_1112.GOTCH
REF_1114(uint256) -> REF_1113[this]
TMP_381(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amt', '10000'] 
TMP_382(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1114', 'TMP_381'] 
REF_1111(uint256) (->roundownables) := TMP_382(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(amt.mul(10000))

IRs:
REF_1117(Game.Ownables) -> roundownables[round]
REF_1118(mapping(address => uint256)) -> REF_1117.GOTCH
REF_1119(uint256) -> REF_1118[msg.sender]
REF_1120(Game.Ownables) -> roundownables[round]
REF_1121(mapping(address => uint256)) -> REF_1120.GOTCH
REF_1122(uint256) -> REF_1121[msg.sender]
TMP_383(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amt', '10000'] 
TMP_384(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1122', 'TMP_383'] 
REF_1119(uint256) (->roundownables) := TMP_384(uint256)"];
}
// Function: 672.sol-Game-setdivsforall(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
divsforall = active

IRs:
divsforall(bool) := active(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 672.sol-Game-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe)

IRs:
TMP_482 = CONVERT 1024571475019602228541062862604156821122634084286 to HourglassInterface
P3Dcontract_(HourglassInterface) := TMP_482(HourglassInterface)"];
}
// Function: 672.sol-Game-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
nextroundlength = 10000000000000000000000

IRs:
nextroundlength(uint256) := 10000000000000000000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
nextroundtotalsupplyGOTCH = 10000

IRs:
nextroundtotalsupplyGOTCH(uint256) := 10000(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
nextroundGOTCHatcontract = 10000

IRs:
nextroundGOTCHatcontract(uint256) := 10000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
nextroundsolsforhire = 100

IRs:
nextroundsolsforhire(uint256) := 100(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
nextroundsoldierreplenishrate = 50

IRs:
nextroundsoldierreplenishrate(uint256) := 50(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
nextroundblocksbeforenewpay = 250

IRs:
nextroundblocksbeforenewpay(uint256) := 250(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
nextroundERCtradeactive = true

IRs:
nextroundERCtradeactive(bool) := True(bool)"];
}
// Function: 672.sol-Game-soldiersinfo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(roundownables[round].soldiers[lookup])

IRs:
REF_78(Game.Ownables) -> roundownables[round]
REF_79(mapping(address => uint256)) -> REF_78.soldiers
REF_80(uint256) -> REF_79[lookup]
RETURN REF_80"];
2[label="Node Type: RETURN 2

EXPRESSION:
soldiers

IRs:
RETURN soldiers"];
}
// Function: 672.sol-Game-startnewround()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(roundvars[round].ATPO > roundownables[round].roundlength)

IRs:
REF_1235(Game.Variables) -> roundvars[round]
REF_1236(uint256) -> REF_1235.ATPO
REF_1237(Game.Ownables) -> roundownables[round]
REF_1238(uint256) -> REF_1237.roundlength
TMP_475(bool) = REF_1236 > REF_1238
TMP_476(None) = SOLIDITY_CALL require(bool)(TMP_475)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
round ++

IRs:
TMP_477(uint256) := round(uint256)
round(uint256) = round + 1"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
roundvars[round].totalsupplyGOTCH = nextroundtotalsupplyGOTCH

IRs:
REF_1239(Game.Variables) -> roundvars[round]
REF_1240(uint256) -> REF_1239.totalsupplyGOTCH
REF_1240(uint256) (->roundvars) := nextroundtotalsupplyGOTCH(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roundvars[round].GOTCHatcontract = nextroundtotalsupplyGOTCH

IRs:
REF_1241(Game.Variables) -> roundvars[round]
REF_1242(uint256) -> REF_1241.GOTCHatcontract
REF_1242(uint256) (->roundvars) := nextroundtotalsupplyGOTCH(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundvars[round].solsforhire = nextroundsolsforhire

IRs:
REF_1243(Game.Variables) -> roundvars[round]
REF_1244(uint256) -> REF_1243.solsforhire
REF_1244(uint256) (->roundvars) := nextroundsolsforhire(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundvars[round].soldierreplenishrate = nextroundsoldierreplenishrate

IRs:
REF_1245(Game.Variables) -> roundvars[round]
REF_1246(uint256) -> REF_1245.soldierreplenishrate
REF_1246(uint256) (->roundvars) := nextroundsoldierreplenishrate(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundvars[round].solslastupdate = block.number

IRs:
REF_1247(Game.Variables) -> roundvars[round]
REF_1248(uint256) -> REF_1247.solslastupdate
REF_1248(uint256) (->roundvars) := block.number(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
updatesolbuyrate()

IRs:
INTERNAL_CALL, Game.updatesolbuyrate()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundvars[round].lastblockpayout = block.number

IRs:
REF_1249(Game.Variables) -> roundvars[round]
REF_1250(uint256) -> REF_1249.lastblockpayout
REF_1250(uint256) (->roundvars) := block.number(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
roundownables[round].hillowner = msg.sender

IRs:
REF_1251(Game.Ownables) -> roundownables[round]
REF_1252(address) -> REF_1251.hillowner
REF_1252(address) (->roundownables) := msg.sender(address)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
roundvars[round].nextpayamount = roundvars[round - 1].nextpayamount

IRs:
REF_1253(Game.Variables) -> roundvars[round]
REF_1254(uint256) -> REF_1253.nextpayamount
TMP_479(uint256) = round - 1
REF_1255(Game.Variables) -> roundvars[TMP_479]
REF_1256(uint256) -> REF_1255.nextpayamount
REF_1254(uint256) (->roundvars) := REF_1256(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
roundvars[round].nextowneramount = roundvars[round - 1].nextowneramount

IRs:
REF_1257(Game.Variables) -> roundvars[round]
REF_1258(uint256) -> REF_1257.nextowneramount
TMP_480(uint256) = round - 1
REF_1259(Game.Variables) -> roundvars[TMP_480]
REF_1260(uint256) -> REF_1259.nextowneramount
REF_1258(uint256) (->roundvars) := REF_1260(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
roundvars[round].previousethamount = roundvars[round - 1].previousethamount

IRs:
REF_1261(Game.Variables) -> roundvars[round]
REF_1262(uint256) -> REF_1261.previousethamount
TMP_481(uint256) = round - 1
REF_1263(Game.Variables) -> roundvars[TMP_481]
REF_1264(uint256) -> REF_1263.previousethamount
REF_1262(uint256) (->roundvars) := REF_1264(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
roundvars[round].blocksbeforenewpay = nextroundblocksbeforenewpay

IRs:
REF_1265(Game.Variables) -> roundvars[round]
REF_1266(uint256) -> REF_1265.blocksbeforenewpay
REF_1266(uint256) (->roundvars) := nextroundblocksbeforenewpay(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
roundownables[round].ERCtradeactive = nextroundERCtradeactive

IRs:
REF_1267(Game.Ownables) -> roundownables[round]
REF_1268(bool) -> REF_1267.ERCtradeactive
REF_1268(bool) (->roundownables) := nextroundERCtradeactive(bool)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
roundvars[round].bpamount = 30000

IRs:
REF_1269(Game.Variables) -> roundvars[round]
REF_1270(uint256) -> REF_1269.bpamount
REF_1270(uint256) (->roundvars) := 30000(uint256)"];
}
// Function: 672.sol-Game-support(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_212(bool) = msg.value >= 1000000000000000
TMP_213(None) = SOLIDITY_CALL require(bool)(TMP_212)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(roundownables[round].villages[village].owner == msg.sender)

IRs:
REF_561(Game.Ownables) -> roundownables[round]
REF_562(mapping(uint256 => Game.Village)) -> REF_561.villages
REF_563(Game.Village) -> REF_562[village]
REF_564(address) -> REF_563.owner
TMP_214(bool) = REF_564 == msg.sender
TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(roundownables[round].villages[village].owner != 0)

IRs:
REF_565(Game.Ownables) -> roundownables[round]
REF_566(mapping(uint256 => Game.Village)) -> REF_565.villages
REF_567(Game.Village) -> REF_566[village]
REF_568(address) -> REF_567.owner
TMP_216(bool) = REF_568 != 0
TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amtsoldiers <= roundownables[round].soldiers[msg.sender])

IRs:
REF_569(Game.Ownables) -> roundownables[round]
REF_570(mapping(address => uint256)) -> REF_569.soldiers
REF_571(uint256) -> REF_570[msg.sender]
TMP_218(bool) = amtsoldiers <= REF_571
TMP_219(None) = SOLIDITY_CALL require(bool)(TMP_218)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(amtsoldiers >= 1)

IRs:
TMP_220(bool) = amtsoldiers >= 1
TMP_221(None) = SOLIDITY_CALL require(bool)(TMP_220)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundownables[round].villages[village].defending = roundownables[round].villages[village].defending.add(amtsoldiers)

IRs:
REF_572(Game.Ownables) -> roundownables[round]
REF_573(mapping(uint256 => Game.Village)) -> REF_572.villages
REF_574(Game.Village) -> REF_573[village]
REF_575(uint256) -> REF_574.defending
REF_576(Game.Ownables) -> roundownables[round]
REF_577(mapping(uint256 => Game.Village)) -> REF_576.villages
REF_578(Game.Village) -> REF_577[village]
REF_579(uint256) -> REF_578.defending
TMP_222(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_579', 'amtsoldiers'] 
REF_575(uint256) (->roundownables) := TMP_222(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_581(Game.Ownables) -> roundownables[round]
REF_582(mapping(address => uint256)) -> REF_581.soldiers
REF_583(uint256) -> REF_582[msg.sender]
REF_584(Game.Ownables) -> roundownables[round]
REF_585(mapping(address => uint256)) -> REF_584.soldiers
REF_586(uint256) -> REF_585[msg.sender]
TMP_223(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_586', 'amtsoldiers'] 
REF_583(uint256) (->roundownables) := TMP_223(uint256)"];
}
// Function: 672.sol-Game-supporthill(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_120(bool) = msg.value >= 1000000000000000
TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(roundownables[round].hillowner == msg.sender)

IRs:
REF_218(Game.Ownables) -> roundownables[round]
REF_219(address) -> REF_218.hillowner
TMP_122(bool) = REF_219 == msg.sender
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amtsoldiers <= roundownables[round].soldiers[msg.sender])

IRs:
REF_220(Game.Ownables) -> roundownables[round]
REF_221(mapping(address => uint256)) -> REF_220.soldiers
REF_222(uint256) -> REF_221[msg.sender]
TMP_124(bool) = amtsoldiers <= REF_222
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amtsoldiers >= 1)

IRs:
TMP_126(bool) = amtsoldiers >= 1
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
roundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.add(amtsoldiers)

IRs:
REF_223(Game.Ownables) -> roundownables[round]
REF_224(uint256) -> REF_223.soldiersdefendinghill
REF_225(Game.Ownables) -> roundownables[round]
REF_226(uint256) -> REF_225.soldiersdefendinghill
TMP_128(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_226', 'amtsoldiers'] 
REF_224(uint256) (->roundownables) := TMP_128(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers)

IRs:
REF_228(Game.Ownables) -> roundownables[round]
REF_229(mapping(address => uint256)) -> REF_228.soldiers
REF_230(uint256) -> REF_229[msg.sender]
REF_231(Game.Ownables) -> roundownables[round]
REF_232(mapping(address => uint256)) -> REF_231.soldiers
REF_233(uint256) -> REF_232[msg.sender]
TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_233', 'amtsoldiers'] 
REF_230(uint256) (->roundownables) := TMP_129(uint256)"];
}
// Function: 672.sol-Game-takeoffer(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= marketplace[ordernumber].wantsthisamtweiperdotch.mul(amtdotch))

IRs:
REF_1206(Game.Marketoffer) -> marketplace[ordernumber]
REF_1207(uint256) -> REF_1206.wantsthisamtweiperdotch
TMP_457(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_1207', 'amtdotch'] 
TMP_458(bool) = msg.value >= TMP_457
TMP_459(None) = SOLIDITY_CALL require(bool)(TMP_458)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amtdotch > 0)

IRs:
TMP_460(bool) = amtdotch > 0
TMP_461(None) = SOLIDITY_CALL require(bool)(TMP_460)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(marketplace[ordernumber].amountdotch >= amtdotch)

IRs:
REF_1209(Game.Marketoffer) -> marketplace[ordernumber]
REF_1210(uint256) -> REF_1209.amountdotch
TMP_462(bool) = REF_1210 >= amtdotch
TMP_463(None) = SOLIDITY_CALL require(bool)(TMP_462)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender != marketplace[ordernumber].placedby)

IRs:
REF_1211(Game.Marketoffer) -> marketplace[ordernumber]
REF_1212(address) -> REF_1211.placedby
TMP_464(bool) = msg.sender != REF_1212
TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(balances[this] >= amtdotch)

IRs:
REF_1213(uint256) -> balances[this]
TMP_466(bool) = REF_1213 >= amtdotch
TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
marketplace[ordernumber].amountdotch = marketplace[ordernumber].amountdotch.sub(amtdotch)

IRs:
REF_1214(Game.Marketoffer) -> marketplace[ordernumber]
REF_1215(uint256) -> REF_1214.amountdotch
REF_1216(Game.Marketoffer) -> marketplace[ordernumber]
REF_1217(uint256) -> REF_1216.amountdotch
TMP_468(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1217', 'amtdotch'] 
REF_1215(uint256) (->marketplace) := TMP_468(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(amtdotch)

IRs:
REF_1219(uint256) -> balances[msg.sender]
REF_1220(uint256) -> balances[msg.sender]
TMP_469(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1220', 'amtdotch'] 
REF_1219(uint256) (->balances) := TMP_469(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
balances[this] = balances[this].sub(amtdotch)

IRs:
REF_1222(uint256) -> balances[this]
REF_1223(uint256) -> balances[this]
TMP_470(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1223', 'amtdotch'] 
REF_1222(uint256) (->balances) := TMP_470(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(this,msg.sender,amtdotch)

IRs:
Emit Transfer(this,msg.sender,amtdotch)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
dotchsale(marketplace[ordernumber].placedby,marketplace[ordernumber].wantsthisamtweiperdotch,msg.sender,amtdotch)

IRs:
REF_1225(Game.Marketoffer) -> marketplace[ordernumber]
REF_1226(address) -> REF_1225.placedby
REF_1227(Game.Marketoffer) -> marketplace[ordernumber]
REF_1228(uint256) -> REF_1227.wantsthisamtweiperdotch
Emit dotchsale(REF_1226,REF_1228,msg.sender,amtdotch)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
marketplace[ordernumber].placedby.transfer(marketplace[ordernumber].wantsthisamtweiperdotch.mul(amtdotch))

IRs:
REF_1229(Game.Marketoffer) -> marketplace[ordernumber]
REF_1230(address) -> REF_1229.placedby
REF_1232(Game.Marketoffer) -> marketplace[ordernumber]
REF_1233(uint256) -> REF_1232.wantsthisamtweiperdotch
TMP_473(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_1233', 'amtdotch'] 
Transfer dest:REF_1230 value:TMP_473"];
}
// Function: 672.sol-Game-totalSupply()
digraph{
}
// Function: 672.sol-Game-transfer(address,uint256)
digraph{
}
// Function: 672.sol-Game-transferAnyERC20Token(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
ERC20Interface(tokenAddress).transfer(owner,tokens)

IRs:
TMP_62 = CONVERT tokenAddress to ERC20Interface
TMP_63(bool) = HIGH_LEVEL_CALL, dest:TMP_62(ERC20Interface), function:transfer, arguments:['owner', 'tokens']  
RETURN TMP_63"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 672.sol-Game-transferFrom(address,address,uint256)
digraph{
}
// Function: 672.sol-Game-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 672.sol-Game-updatesolbuyrate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
roundvars[round].solsforhire > roundvars[round].totalsupplyGOTCH

IRs:
REF_257(Game.Variables) -> roundvars[round]
REF_258(uint256) -> REF_257.solsforhire
REF_259(Game.Variables) -> roundvars[round]
REF_260(uint256) -> REF_259.totalsupplyGOTCH
TMP_138(bool) = REF_258 > REF_260
CONDITION TMP_138"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roundvars[round].solsforhire = roundvars[round].totalsupplyGOTCH

IRs:
REF_261(Game.Variables) -> roundvars[round]
REF_262(uint256) -> REF_261.solsforhire
REF_263(Game.Variables) -> roundvars[round]
REF_264(uint256) -> REF_263.totalsupplyGOTCH
REF_262(uint256) (->roundvars) := REF_264(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roundvars[round].soldierprice = roundvars[round].totalsupplyGOTCH.div(roundvars[round].solsforhire)

IRs:
REF_265(Game.Variables) -> roundvars[round]
REF_266(uint256) -> REF_265.soldierprice
REF_267(Game.Variables) -> roundvars[round]
REF_268(uint256) -> REF_267.totalsupplyGOTCH
REF_270(Game.Variables) -> roundvars[round]
REF_271(uint256) -> REF_270.solsforhire
TMP_139(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_268', 'REF_271'] 
REF_266(uint256) (->roundvars) := TMP_139(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
roundvars[round].soldierprice < 1

IRs:
REF_272(Game.Variables) -> roundvars[round]
REF_273(uint256) -> REF_272.soldierprice
TMP_140(bool) = REF_273 < 1
CONDITION TMP_140"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundvars[round].soldierprice = 1

IRs:
REF_274(Game.Variables) -> roundvars[round]
REF_275(uint256) -> REF_274.soldierprice
REF_275(uint256) (->roundvars) := 1(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 672.sol-Game-updatesolsforhire()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
roundvars[round].solsforhire = roundvars[round].solsforhire.add((block.number.sub(roundvars[round].solslastupdate)).mul(roundvars[round].nextVillageId).mul(roundvars[round].soldierreplenishrate))

IRs:
REF_241(Game.Variables) -> roundvars[round]
REF_242(uint256) -> REF_241.solsforhire
REF_243(Game.Variables) -> roundvars[round]
REF_244(uint256) -> REF_243.solsforhire
REF_247(Game.Variables) -> roundvars[round]
REF_248(uint256) -> REF_247.solslastupdate
TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'REF_248'] 
REF_250(Game.Variables) -> roundvars[round]
REF_251(uint256) -> REF_250.nextVillageId
TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_134', 'REF_251'] 
REF_253(Game.Variables) -> roundvars[round]
REF_254(uint256) -> REF_253.soldierreplenishrate
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_135', 'REF_254'] 
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_244', 'TMP_136'] 
REF_242(uint256) (->roundvars) := TMP_137(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roundvars[round].solslastupdate = block.number

IRs:
REF_255(Game.Variables) -> roundvars[round]
REF_256(uint256) -> REF_255.solslastupdate
REF_256(uint256) (->roundvars) := block.number(uint256)"];
}
// Function: 672.sol-Game-villageinfo(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(roundownables[round].villages[lookup].owner,roundownables[round].villages[lookup].defending,roundownables[round].villages[lookup].lastcollect,roundownables[round].villages[lookup].beginnerprotection)

IRs:
REF_59(Game.Ownables) -> roundownables[round]
REF_60(mapping(uint256 => Game.Village)) -> REF_59.villages
REF_61(Game.Village) -> REF_60[lookup]
REF_62(address) -> REF_61.owner
REF_63(Game.Ownables) -> roundownables[round]
REF_64(mapping(uint256 => Game.Village)) -> REF_63.villages
REF_65(Game.Village) -> REF_64[lookup]
REF_66(uint256) -> REF_65.defending
REF_67(Game.Ownables) -> roundownables[round]
REF_68(mapping(uint256 => Game.Village)) -> REF_67.villages
REF_69(Game.Village) -> REF_68[lookup]
REF_70(uint256) -> REF_69.lastcollect
REF_71(Game.Ownables) -> roundownables[round]
REF_72(mapping(uint256 => Game.Village)) -> REF_71.villages
REF_73(Game.Village) -> REF_72[lookup]
REF_74(uint256) -> REF_73.beginnerprotection
RETURN REF_62,REF_66,REF_70,REF_74"];
2[label="Node Type: RETURN 2

EXPRESSION:
(owner,soldiersdefending,lastcollect,beginnersprotection)

IRs:
RETURN owner,soldiersdefending,lastcollect,beginnersprotection"];
}
// Function: 672.sol-HourglassInterface-balanceOf(address)
digraph{
}
// Function: 672.sol-HourglassInterface-buy(address)
digraph{
}
// Function: 672.sol-HourglassInterface-dividendsOf(address)
digraph{
}
// Function: 672.sol-HourglassInterface-exit()
digraph{
}
// Function: 672.sol-HourglassInterface-fallback()
digraph{
}
// Function: 672.sol-HourglassInterface-reinvest()
digraph{
}
// Function: 672.sol-HourglassInterface-sell(uint256)
digraph{
}
// Function: 672.sol-HourglassInterface-stakingRequirement()
digraph{
}
// Function: 672.sol-HourglassInterface-transfer(address,uint256)
digraph{
}
// Function: 672.sol-HourglassInterface-withdraw()
digraph{
}
// Function: 672.sol-Owned-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_16(bool) = msg.sender == newOwner
TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_19 = CONVERT 0 to address
newOwner(address) := TMP_19(address)"];
}
// Function: 672.sol-Owned-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220

IRs:
owner(address) := 63132959354516410259346061757283036995022197280(address)"];
}
// Function: 672.sol-Owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_20(bool) = msg.sender == owner
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 672.sol-Owned-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 672.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_0(uint256) = a + b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(c >= a)

IRs:
TMP_1(bool) = c >= a
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 672.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b > 0)

IRs:
TMP_12(bool) = b > 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a / b

IRs:
TMP_14(uint256) = a / b
c(uint256) := TMP_14(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 672.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_6(uint256) = a * b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(a == 0 || c / a == b)

IRs:
TMP_7(bool) = a == 0
TMP_8(uint256) = c / a
TMP_9(bool) = TMP_8 == b
TMP_10(bool) = TMP_7 || TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 672.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b <= a)

IRs:
TMP_3(bool) = b <= a
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_5(uint256) = a - b
c(uint256) := TMP_5(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
}
