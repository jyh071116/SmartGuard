digraph G {
// Function: 25219.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 25219.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 25219.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 25219.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 25219.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 25219.sol-ERC223Receiver-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 25219.sol-EllipseMarketMakerLib-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 25219.sol-EllipseMarketMakerLib-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
previousOwner = owner

IRs:
previousOwner(address) := owner(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwnerCandidate

IRs:
owner(address) := newOwnerCandidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newOwnerCandidate = address(0)

IRs:
TMP_70 = CONVERT 0 to address
newOwnerCandidate(address) := TMP_70(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
OwnershipTransferred(previousOwner,owner)

IRs:
Emit OwnershipTransferred(previousOwner,owner)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwnerCandidate()

IRs:
MODIFIER_CALL, Ownable.onlyOwnerCandidate()()"];
5->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-calcReserve(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_R2 = _S2.mul(_S1.sub(_R1.mul(_S1).mul(2).sub(_R1.toPower2()).sqrt())).div(_S1)

IRs:
TMP_161(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_R1', '_S1'] 
TMP_162(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_161', '2'] 
TMP_163(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.toPower2(uint256), arguments:['_R1'] 
TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_162', 'TMP_163'] 
TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sqrt(uint256), arguments:['TMP_164'] 
TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_S1', 'TMP_165'] 
TMP_167(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_S2', 'TMP_166'] 
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_167', '_S1'] 
_R2(uint256) := TMP_168(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_R2

IRs:
RETURN _R2"];
}
// Function: 25219.sol-EllipseMarketMakerLib-canTrade()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(openForPublic || msg.sender == owner)

IRs:
TMP_237(bool) = msg.sender == owner
TMP_238(bool) = openForPublic || TMP_237
TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-canTrade223()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(openForPublic || tkn.sender == owner)

IRs:
REF_56(address) -> tkn.sender
TMP_240(bool) = REF_56 == owner
TMP_241(bool) = openForPublic || TMP_240
TMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-change(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
change(_toToken,0)

IRs:
TMP_183(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.change(address,uint256)(_toToken,0)
RETURN TMP_183"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
canTrade223()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.canTrade223()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenPayable()

IRs:
MODIFIER_CALL, Standard223Receiver.tokenPayable()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-EllipseMarketMakerLib-change(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fromToken = tkn.addr

IRs:
REF_34(address) -> tkn.addr
fromToken(address) := REF_34(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
inAmount = tkn.value

IRs:
REF_35(uint256) -> tkn.value
inAmount(uint256) := REF_35(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
returnAmount = exchange(fromToken,inAmount,_toToken,_minReturn)

IRs:
TMP_186(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.exchange(address,uint256,address,uint256)(fromToken,inAmount,_toToken,_minReturn)
returnAmount(uint256) := TMP_186(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
returnAmount == 0

IRs:
TMP_187(bool) = returnAmount == 0
CONDITION TMP_187"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_188(None) = SOLIDITY_CALL revert()()"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ERC20(_toToken).transfer(tkn.sender,returnAmount)

IRs:
TMP_189 = CONVERT _toToken to ERC20
REF_37(address) -> tkn.sender
TMP_190(bool) = HIGH_LEVEL_CALL, dest:TMP_189(ERC20), function:transfer, arguments:['REF_37', 'returnAmount']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(validateReserves())

IRs:
TMP_191(bool) = INTERNAL_CALL, EllipseMarketMakerLib.validateReserves()()
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Change(fromToken,inAmount,_toToken,returnAmount,tkn.sender)

IRs:
REF_38(address) -> tkn.sender
Emit Change(fromToken,inAmount,_toToken,returnAmount,REF_38)"];
9->12;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
canTrade223()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.canTrade223()()"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tokenPayable()

IRs:
MODIFIER_CALL, Standard223Receiver.tokenPayable()()"];
11->1;
12[label="Node Type: RETURN 12

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-EllipseMarketMakerLib-change(address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
change(_fromToken,_inAmount,_toToken,0)

IRs:
TMP_169(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.change(address,uint256,address,uint256)(_fromToken,_inAmount,_toToken,0)
RETURN TMP_169"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
canTrade()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.canTrade()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-EllipseMarketMakerLib-change(address,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ERC20(_fromToken).transferFrom(msg.sender,this,_inAmount))

IRs:
TMP_171 = CONVERT _fromToken to ERC20
TMP_172(bool) = HIGH_LEVEL_CALL, dest:TMP_171(ERC20), function:transferFrom, arguments:['msg.sender', 'this', '_inAmount']  
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
returnAmount = exchange(_fromToken,_inAmount,_toToken,_minReturn)

IRs:
TMP_174(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.exchange(address,uint256,address,uint256)(_fromToken,_inAmount,_toToken,_minReturn)
returnAmount(uint256) := TMP_174(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
returnAmount == 0

IRs:
TMP_175(bool) = returnAmount == 0
CONDITION TMP_175"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
revert()()

IRs:
TMP_176(None) = SOLIDITY_CALL revert()()"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ERC20(_toToken).transfer(msg.sender,returnAmount)

IRs:
TMP_177 = CONVERT _toToken to ERC20
TMP_178(bool) = HIGH_LEVEL_CALL, dest:TMP_177(ERC20), function:transfer, arguments:['msg.sender', 'returnAmount']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(validateReserves())

IRs:
TMP_179(bool) = INTERNAL_CALL, EllipseMarketMakerLib.validateReserves()()
TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Change(_fromToken,_inAmount,_toToken,returnAmount,msg.sender)

IRs:
Emit Change(_fromToken,_inAmount,_toToken,returnAmount,msg.sender)"];
8->10;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
canTrade()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.canTrade()()"];
9->1;
10[label="Node Type: RETURN 10

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-EllipseMarketMakerLib-constructor(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->15;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_mmLib != address(0))

IRs:
TMP_79 = CONVERT 0 to address
TMP_80(bool) = _mmLib != TMP_79
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token1 != address(0))

IRs:
TMP_82 = CONVERT 0 to address
TMP_83(bool) = _token1 != TMP_82
TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_token2 != address(0))

IRs:
TMP_85 = CONVERT 0 to address
TMP_86(bool) = _token2 != TMP_85
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_token1 != _token2)

IRs:
TMP_88(bool) = _token1 != _token2
TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
mmLib = _mmLib

IRs:
mmLib(address) := _mmLib(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token1 = ERC20(_token1)

IRs:
TMP_90 = CONVERT _token1 to ERC20
token1(ERC20) := TMP_90(ERC20)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token2 = ERC20(_token2)

IRs:
TMP_91 = CONVERT _token2 to ERC20
token2(ERC20) := TMP_91(ERC20)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
R1 = 0

IRs:
R1(uint256) := 0(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
R2 = 0

IRs:
R2(uint256) := 0(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
S1 = token1.totalSupply()

IRs:
TMP_92(uint256) = HIGH_LEVEL_CALL, dest:token1(ERC20), function:totalSupply, arguments:[]  
S1(uint256) := TMP_92(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
S2 = token2.totalSupply()

IRs:
TMP_93(uint256) = HIGH_LEVEL_CALL, dest:token2(ERC20), function:totalSupply, arguments:[]  
S2(uint256) := TMP_93(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
operational = false

IRs:
operational(bool) := False(bool)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
openForPublic = false

IRs:
openForPublic(bool) := False(bool)"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
true

IRs:
RETURN True"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
notConstructed()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.notConstructed()()"];
16->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-exchange(address,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
returnAmount = quoteAndReserves(_fromToken,_inAmount,_toToken)

IRs:
TMP_196(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.quoteAndReserves(address,uint256,address)(_fromToken,_inAmount,_toToken)
returnAmount(uint256) := TMP_196(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
returnAmount == 0 || returnAmount < _minReturn

IRs:
TMP_197(bool) = returnAmount == 0
TMP_198(bool) = returnAmount < _minReturn
TMP_199(bool) = TMP_197 || TMP_198
CONDITION TMP_199"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateReserve()

IRs:
INTERNAL_CALL, EllipseMarketMakerLib.updateReserve()()"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-EllipseMarketMakerLib-getCurrentPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
getPrice(R1,R2,S1,S2)

IRs:
TMP_121(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.getPrice(uint256,uint256,uint256,uint256)(R1,R2,S1,S2)
RETURN TMP_121"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isOperational()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.isOperational()()"];
2->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-getPrice(uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
price = PRECISION

IRs:
price(uint256) := PRECISION(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
price = price.mul(_S1.sub(_R1))

IRs:
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_S1', '_R1'] 
TMP_124(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['price', 'TMP_123'] 
price(uint256) := TMP_124(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
price = price.div(_S2.sub(_R2))

IRs:
TMP_125(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_S2', '_R2'] 
TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['price', 'TMP_125'] 
price(uint256) := TMP_126(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
price = price.mul(_S2)

IRs:
TMP_127(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['price', '_S2'] 
price(uint256) := TMP_127(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
price = price.div(_S1)

IRs:
TMP_128(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['price', '_S1'] 
price(uint256) := TMP_128(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
price = price.mul(_S2)

IRs:
TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['price', '_S2'] 
price(uint256) := TMP_129(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
price = price.div(_S1)

IRs:
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['price', '_S1'] 
price(uint256) := TMP_130(uint256)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 25219.sol-EllipseMarketMakerLib-initialize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
R1 = token1.balanceOf(this)

IRs:
TMP_112(uint256) = HIGH_LEVEL_CALL, dest:token1(ERC20), function:balanceOf, arguments:['this']  
R1(uint256) := TMP_112(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
R2 = token2.balanceOf(this)

IRs:
TMP_113(uint256) = HIGH_LEVEL_CALL, dest:token2(ERC20), function:balanceOf, arguments:['this']  
R2(uint256) := TMP_113(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
success = ((R1 == 0 && R2 == S2) || (R2 == 0 && R1 == S1))

IRs:
TMP_114(bool) = R1 == 0
TMP_115(bool) = R2 == S2
TMP_116(bool) = TMP_114 && TMP_115
TMP_117(bool) = R2 == 0
TMP_118(bool) = R1 == S1
TMP_119(bool) = TMP_117 && TMP_118
TMP_120(bool) = TMP_116 || TMP_119
success(bool) := TMP_120(bool)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
success

IRs:
CONDITION success"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
operational = true

IRs:
operational(bool) := True(bool)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 25219.sol-EllipseMarketMakerLib-initializeAfterTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(initialize())

IRs:
TMP_103(bool) = INTERNAL_CALL, EllipseMarketMakerLib.initialize()()
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
notOperational()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.notOperational()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-initializeOnTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(initialize())

IRs:
TMP_107(bool) = INTERNAL_CALL, EllipseMarketMakerLib.initialize()()
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
notOperational()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.notOperational()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyTokenOwner()

IRs:
MODIFIER_CALL, TokenOwnable.onlyTokenOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokenPayable()

IRs:
MODIFIER_CALL, Standard223Receiver.tokenPayable()()"];
5->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-isOpenForPublic()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
(openForPublic && operational)

IRs:
TMP_98(bool) = openForPublic && operational
RETURN TMP_98"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-isOperational()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(operational)

IRs:
TMP_234(None) = SOLIDITY_CALL require(bool)(operational)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-notConstructed()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(mmLib == address(0))

IRs:
TMP_231 = CONVERT 0 to address
TMP_232(bool) = mmLib == TMP_231
TMP_233(None) = SOLIDITY_CALL require(bool)(TMP_232)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-notOperational()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! operational)

IRs:
TMP_235 = UnaryType.BANG operational 
TMP_236(None) = SOLIDITY_CALL require(bool)(TMP_235)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_226(bool) = msg.sender == owner
TMP_227(None) = SOLIDITY_CALL require(bool)(TMP_226)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-onlyOwnerCandidate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwnerCandidate)

IRs:
TMP_228(bool) = msg.sender == newOwnerCandidate
TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-onlyTokenOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tkn.sender == owner)

IRs:
REF_55(address) -> tkn.sender
TMP_224(bool) = REF_55 == owner
TMP_225(None) = SOLIDITY_CALL require(bool)(TMP_224)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-openForPublicTrade()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
openForPublic = true

IRs:
openForPublic(bool) := True(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isOperational()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.isOperational()()"];
4->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-quote(address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->20;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
token1 == _fromToken && token2 == _toToken

IRs:
TMP_146(bool) = token1 == _fromToken
TMP_147(bool) = token2 == _toToken
TMP_148(bool) = TMP_146 && TMP_147
CONDITION TMP_148"];
3->4[label="True"];
3->10[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_R1 = R1.add(_inAmount)

IRs:
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['R1', '_inAmount'] 
_R1(uint256) := TMP_149(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_R2 = calcReserve(_R1,S1,S2)

IRs:
TMP_150(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.calcReserve(uint256,uint256,uint256)(_R1,S1,S2)
_R2(uint256) := TMP_150(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
_R2 > R2

IRs:
TMP_151(bool) = _R2 > R2
CONDITION TMP_151"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
0

IRs:
RETURN 0"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
returnAmount = R2.sub(_R2)

IRs:
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['R2', '_R2'] 
returnAmount(uint256) := TMP_152(uint256)"];
9->19;
10[label="Node Type: IF 10

EXPRESSION:
token2 == _fromToken && token1 == _toToken

IRs:
TMP_153(bool) = token2 == _fromToken
TMP_154(bool) = token1 == _toToken
TMP_155(bool) = TMP_153 && TMP_154
CONDITION TMP_155"];
10->11[label="True"];
10->17[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_R2 = R2.add(_inAmount)

IRs:
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['R2', '_inAmount'] 
_R2(uint256) := TMP_156(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_R1 = calcReserve(_R2,S2,S1)

IRs:
TMP_157(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.calcReserve(uint256,uint256,uint256)(_R2,S2,S1)
_R1(uint256) := TMP_157(uint256)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
_R1 > R1

IRs:
TMP_158(bool) = _R1 > R1
CONDITION TMP_158"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: RETURN 14

EXPRESSION:
0

IRs:
RETURN 0"];
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
returnAmount = R1.sub(_R1)

IRs:
TMP_159(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['R1', '_R1'] 
returnAmount(uint256) := TMP_159(uint256)"];
16->18;
17[label="Node Type: RETURN 17

EXPRESSION:
0

IRs:
RETURN 0"];
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->21;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
isOperational()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.isOperational()()"];
20->1;
21[label="Node Type: RETURN 21

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-EllipseMarketMakerLib-quoteAndReserves(address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->18;
1[label="Node Type: IF 1

EXPRESSION:
token1 == _fromToken && token2 == _toToken

IRs:
TMP_131(bool) = token1 == _fromToken
TMP_132(bool) = token2 == _toToken
TMP_133(bool) = TMP_131 && TMP_132
CONDITION TMP_133"];
1->2[label="True"];
1->8[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
l_R1 = R1.add(_inAmount)

IRs:
TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['R1', '_inAmount'] 
l_R1(uint256) := TMP_134(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
l_R2 = calcReserve(l_R1,S1,S2)

IRs:
TMP_135(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.calcReserve(uint256,uint256,uint256)(l_R1,S1,S2)
l_R2(uint256) := TMP_135(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
l_R2 > R2

IRs:
TMP_136(bool) = l_R2 > R2
CONDITION TMP_136"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
0

IRs:
RETURN 0"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
returnAmount = R2.sub(l_R2)

IRs:
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['R2', 'l_R2'] 
returnAmount(uint256) := TMP_137(uint256)"];
7->17;
8[label="Node Type: IF 8

EXPRESSION:
token2 == _fromToken && token1 == _toToken

IRs:
TMP_138(bool) = token2 == _fromToken
TMP_139(bool) = token1 == _toToken
TMP_140(bool) = TMP_138 && TMP_139
CONDITION TMP_140"];
8->9[label="True"];
8->15[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
l_R2 = R2.add(_inAmount)

IRs:
TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['R2', '_inAmount'] 
l_R2(uint256) := TMP_141(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
l_R1 = calcReserve(l_R2,S2,S1)

IRs:
TMP_142(uint256) = INTERNAL_CALL, EllipseMarketMakerLib.calcReserve(uint256,uint256,uint256)(l_R2,S2,S1)
l_R1(uint256) := TMP_142(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
l_R1 > R1

IRs:
TMP_143(bool) = l_R1 > R1
CONDITION TMP_143"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: RETURN 12

EXPRESSION:
0

IRs:
RETURN 0"];
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
returnAmount = R1.sub(l_R1)

IRs:
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['R1', 'l_R1'] 
returnAmount(uint256) := TMP_144(uint256)"];
14->16;
15[label="Node Type: RETURN 15

EXPRESSION:
0

IRs:
RETURN 0"];
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->19;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
isOperational()

IRs:
MODIFIER_CALL, EllipseMarketMakerLib.isOperational()()"];
18->1;
19[label="Node Type: RETURN 19

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-EllipseMarketMakerLib-requestOwnershipTransfer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwnerCandidate != address(0))

IRs:
TMP_65 = CONVERT 0 to address
TMP_66(bool) = _newOwnerCandidate != TMP_65
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newOwnerCandidate = _newOwnerCandidate

IRs:
newOwnerCandidate(address) := _newOwnerCandidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnershipRequested(msg.sender,newOwnerCandidate)

IRs:
Emit OwnershipRequested(msg.sender,newOwnerCandidate)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 25219.sol-EllipseMarketMakerLib-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
PRECISION = 10 ** 18

IRs:
TMP_223(uint256) = 10 ** 18
PRECISION(uint256) := TMP_223(uint256)"];
}
// Function: 25219.sol-EllipseMarketMakerLib-supportsToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(token1 == _token || token2 == _token)

IRs:
TMP_100(bool) = token1 == _token
TMP_101(bool) = token2 == _token
TMP_102(bool) = TMP_100 || TMP_101
RETURN TMP_102"];
}
// Function: 25219.sol-EllipseMarketMakerLib-tokenFallback(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! supportsToken(msg.sender)

IRs:
TMP_73(bool) = INTERNAL_CALL, EllipseMarketMakerLib.supportsToken(address)(msg.sender)
TMP_74 = UnaryType.BANG TMP_73 
CONDITION TMP_74"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tkn = Tkn(msg.sender,_sender,_value)

IRs:
TMP_75(Standard223Receiver.Tkn) = new Tkn(msg.sender,_sender,_value)
tkn(Standard223Receiver.Tkn) := TMP_75(Standard223Receiver.Tkn)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
__isTokenFallback = true

IRs:
__isTokenFallback(bool) := True(bool)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
! address(this).delegatecall(_data)

IRs:
TMP_76 = CONVERT this to address
TMP_77(bool) = LOW_LEVEL_CALL, dest:TMP_76, function:delegatecall, arguments:['_data']  
TMP_78 = UnaryType.BANG TMP_77 
CONDITION TMP_78"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
__isTokenFallback = false

IRs:
__isTokenFallback(bool) := False(bool)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
__isTokenFallback = false

IRs:
__isTokenFallback(bool) := False(bool)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: RETURN 12

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 25219.sol-EllipseMarketMakerLib-tokenPayable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(__isTokenFallback)

IRs:
TMP_230(None) = SOLIDITY_CALL require(bool)(__isTokenFallback)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-EllipseMarketMakerLib-updateReserve()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
R1 = l_R1

IRs:
R1(uint256) := l_R1(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
R2 = l_R2

IRs:
R2(uint256) := l_R2(uint256)"];
}
// Function: 25219.sol-EllipseMarketMakerLib-validateReserves()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(token1.balanceOf(this) >= R1 && token2.balanceOf(this) >= R2)

IRs:
TMP_201(uint256) = HIGH_LEVEL_CALL, dest:token1(ERC20), function:balanceOf, arguments:['this']  
TMP_202(bool) = TMP_201 >= R1
TMP_203(uint256) = HIGH_LEVEL_CALL, dest:token2(ERC20), function:balanceOf, arguments:['this']  
TMP_204(bool) = TMP_203 >= R2
TMP_205(bool) = TMP_202 && TMP_204
RETURN TMP_205"];
}
// Function: 25219.sol-EllipseMarketMakerLib-withdrawExcessReserves()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
token1.balanceOf(this) > R1

IRs:
TMP_206(uint256) = HIGH_LEVEL_CALL, dest:token1(ERC20), function:balanceOf, arguments:['this']  
TMP_207(bool) = TMP_206 > R1
CONDITION TMP_207"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
returnAmount = returnAmount.add(token1.balanceOf(this).sub(R1))

IRs:
TMP_208(uint256) = HIGH_LEVEL_CALL, dest:token1(ERC20), function:balanceOf, arguments:['this']  
TMP_209(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_208', 'R1'] 
TMP_210(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['returnAmount', 'TMP_209'] 
returnAmount(uint256) := TMP_210(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token1.transfer(msg.sender,token1.balanceOf(this).sub(R1))

IRs:
TMP_211(uint256) = HIGH_LEVEL_CALL, dest:token1(ERC20), function:balanceOf, arguments:['this']  
TMP_212(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_211', 'R1'] 
TMP_213(bool) = HIGH_LEVEL_CALL, dest:token1(ERC20), function:transfer, arguments:['msg.sender', 'TMP_212']  "];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
token2.balanceOf(this) > R2

IRs:
TMP_214(uint256) = HIGH_LEVEL_CALL, dest:token2(ERC20), function:balanceOf, arguments:['this']  
TMP_215(bool) = TMP_214 > R2
CONDITION TMP_215"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
returnAmount = returnAmount.add(token2.balanceOf(this).sub(R2))

IRs:
TMP_216(uint256) = HIGH_LEVEL_CALL, dest:token2(ERC20), function:balanceOf, arguments:['this']  
TMP_217(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_216', 'R2'] 
TMP_218(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['returnAmount', 'TMP_217'] 
returnAmount(uint256) := TMP_218(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token2.transfer(msg.sender,token2.balanceOf(this).sub(R2))

IRs:
TMP_219(uint256) = HIGH_LEVEL_CALL, dest:token2(ERC20), function:balanceOf, arguments:['this']  
TMP_220(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_219', 'R2'] 
TMP_221(bool) = HIGH_LEVEL_CALL, dest:token2(ERC20), function:transfer, arguments:['msg.sender', 'TMP_220']  "];
7->8;
8[label="Node Type: END_IF 8
"];
8->10;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
9->1;
10[label="Node Type: RETURN 10

EXPRESSION:
returnAmount

IRs:
RETURN returnAmount"];
}
// Function: 25219.sol-IEllipseMarketMaker-calcReserve(uint256,uint256,uint256)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-change(address)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-change(address,uint256)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-change(address,uint256,address)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-change(address,uint256,address,uint256)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-getCurrentPrice()
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-getPrice(uint256,uint256,uint256,uint256)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-initializeAfterTransfer()
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-initializeOnTransfer()
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-isOpenForPublic()
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-openForPublicTrade()
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-quote(address,uint256,address)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
PRECISION = 10 ** 18

IRs:
TMP_24(uint256) = 10 ** 18
PRECISION(uint256) := TMP_24(uint256)"];
}
// Function: 25219.sol-IEllipseMarketMaker-supportsToken(address)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-validateReserves()
digraph{
}
// Function: 25219.sol-IEllipseMarketMaker-withdrawExcessReserves()
digraph{
}
// Function: 25219.sol-MarketMaker-change(address)
digraph{
}
// Function: 25219.sol-MarketMaker-change(address,uint256)
digraph{
}
// Function: 25219.sol-MarketMaker-change(address,uint256,address)
digraph{
}
// Function: 25219.sol-MarketMaker-change(address,uint256,address,uint256)
digraph{
}
// Function: 25219.sol-MarketMaker-getCurrentPrice()
digraph{
}
// Function: 25219.sol-MarketMaker-isOpenForPublic()
digraph{
}
// Function: 25219.sol-MarketMaker-openForPublicTrade()
digraph{
}
// Function: 25219.sol-MarketMaker-quote(address,uint256,address)
digraph{
}
// Function: 25219.sol-MarketMaker-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 25219.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 25219.sol-Ownable-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
previousOwner = owner

IRs:
previousOwner(address) := owner(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwnerCandidate

IRs:
owner(address) := newOwnerCandidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newOwnerCandidate = address(0)

IRs:
TMP_30 = CONVERT 0 to address
newOwnerCandidate(address) := TMP_30(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
OwnershipTransferred(previousOwner,owner)

IRs:
Emit OwnershipTransferred(previousOwner,owner)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwnerCandidate()

IRs:
MODIFIER_CALL, Ownable.onlyOwnerCandidate()()"];
5->1;
}
// Function: 25219.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_33(bool) = msg.sender == owner
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-Ownable-onlyOwnerCandidate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwnerCandidate)

IRs:
TMP_35(bool) = msg.sender == newOwnerCandidate
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-Ownable-requestOwnershipTransfer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwnerCandidate != address(0))

IRs:
TMP_25 = CONVERT 0 to address
TMP_26(bool) = _newOwnerCandidate != TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newOwnerCandidate = _newOwnerCandidate

IRs:
newOwnerCandidate(address) := _newOwnerCandidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnershipRequested(msg.sender,newOwnerCandidate)

IRs:
Emit OwnershipRequested(msg.sender,newOwnerCandidate)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 25219.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 25219.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_6(uint256) = a / b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 25219.sol-SafeMath-max256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_15(bool) = a >= b
CONDITION TMP_15"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 25219.sol-SafeMath-max64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_13(bool) = a >= b
CONDITION TMP_13"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 25219.sol-SafeMath-min256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_16(bool) = a < b
CONDITION TMP_16"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 25219.sol-SafeMath-min64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_14(bool) = a < b
CONDITION TMP_14"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 25219.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 25219.sol-SafeMath-sqrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = (a + 1) / 2

IRs:
TMP_18(uint256) = a + 1
TMP_19(uint256) = TMP_18 / 2
c(uint256) := TMP_19(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
b = a

IRs:
b(uint256) := a(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
c < b

IRs:
TMP_20(bool) = c < b
CONDITION TMP_20"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
b = c

IRs:
b(uint256) := c(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
c = (a / c + c) / 2

IRs:
TMP_21(uint256) = a / c
TMP_22(uint256) = TMP_21 + c
TMP_23(uint256) = TMP_22 / 2
c(uint256) := TMP_23(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 25219.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b <= a)

IRs:
TMP_7(bool) = b <= a
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_9(uint256) = a - b
RETURN TMP_9"];
}
// Function: 25219.sol-SafeMath-toPower2(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mul(a,a)

IRs:
TMP_17(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(a,a)
RETURN TMP_17"];
}
// Function: 25219.sol-Standard223Receiver-supportsToken(address)
digraph{
}
// Function: 25219.sol-Standard223Receiver-tokenFallback(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! supportsToken(msg.sender)

IRs:
TMP_37(bool) = INTERNAL_CALL, Standard223Receiver.supportsToken(address)(msg.sender)
TMP_38 = UnaryType.BANG TMP_37 
CONDITION TMP_38"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tkn = Tkn(msg.sender,_sender,_value)

IRs:
TMP_39(Standard223Receiver.Tkn) = new Tkn(msg.sender,_sender,_value)
tkn(Standard223Receiver.Tkn) := TMP_39(Standard223Receiver.Tkn)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
__isTokenFallback = true

IRs:
__isTokenFallback(bool) := True(bool)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
! address(this).delegatecall(_data)

IRs:
TMP_40 = CONVERT this to address
TMP_41(bool) = LOW_LEVEL_CALL, dest:TMP_40, function:delegatecall, arguments:['_data']  
TMP_42 = UnaryType.BANG TMP_41 
CONDITION TMP_42"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
__isTokenFallback = false

IRs:
__isTokenFallback(bool) := False(bool)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
__isTokenFallback = false

IRs:
__isTokenFallback(bool) := False(bool)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: RETURN 12

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 25219.sol-Standard223Receiver-tokenPayable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(__isTokenFallback)

IRs:
TMP_43(None) = SOLIDITY_CALL require(bool)(__isTokenFallback)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-TokenOwnable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 25219.sol-TokenOwnable-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
previousOwner = owner

IRs:
previousOwner(address) := owner(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwnerCandidate

IRs:
owner(address) := newOwnerCandidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
newOwnerCandidate = address(0)

IRs:
TMP_49 = CONVERT 0 to address
newOwnerCandidate(address) := TMP_49(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
OwnershipTransferred(previousOwner,owner)

IRs:
Emit OwnershipTransferred(previousOwner,owner)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwnerCandidate()

IRs:
MODIFIER_CALL, Ownable.onlyOwnerCandidate()()"];
5->1;
}
// Function: 25219.sol-TokenOwnable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_58(bool) = msg.sender == owner
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-TokenOwnable-onlyOwnerCandidate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwnerCandidate)

IRs:
TMP_60(bool) = msg.sender == newOwnerCandidate
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-TokenOwnable-onlyTokenOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tkn.sender == owner)

IRs:
REF_2(address) -> tkn.sender
TMP_63(bool) = REF_2 == owner
TMP_64(None) = SOLIDITY_CALL require(bool)(TMP_63)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 25219.sol-TokenOwnable-requestOwnershipTransfer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwnerCandidate != address(0))

IRs:
TMP_44 = CONVERT 0 to address
TMP_45(bool) = _newOwnerCandidate != TMP_44
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newOwnerCandidate = _newOwnerCandidate

IRs:
newOwnerCandidate(address) := _newOwnerCandidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnershipRequested(msg.sender,newOwnerCandidate)

IRs:
Emit OwnershipRequested(msg.sender,newOwnerCandidate)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 25219.sol-TokenOwnable-supportsToken(address)
digraph{
}
// Function: 25219.sol-TokenOwnable-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 25219.sol-TokenOwnable-tokenPayable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(__isTokenFallback)

IRs:
TMP_62(None) = SOLIDITY_CALL require(bool)(__isTokenFallback)"];
1->2;
2[label="Node Type: _ 2
"];
}
}
