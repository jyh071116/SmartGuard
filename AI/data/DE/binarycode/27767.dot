digraph G {
// Function: 27767.sol-ERC20Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_spender
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
remaining
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 27767.sol-ERC20Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value == 0 || allowance[msg.sender][_spender] == 0)

IRs:
TMP_24(bool) = _value == 0
REF_12(mapping(address => uint256)) -> allowance[msg.sender]
REF_13(uint256) -> REF_12[_spender]
TMP_25(bool) = REF_13 == 0
TMP_26(bool) = TMP_24 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowance[msg.sender][_spender] = _value

IRs:
REF_14(mapping(address => uint256)) -> allowance[msg.sender]
REF_15(uint256) -> REF_14[_spender]
REF_15(uint256) (->allowance) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(_spender)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 27767.sol-ERC20Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 27767.sol-ERC20Token-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_8(uint256) = x + y
z(uint256) := TMP_8(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= x)

IRs:
TMP_9(bool) = z >= x
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 27767.sol-ERC20Token-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_11(bool) = x >= y
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_13(uint256) = x - y
RETURN TMP_13"];
}
// Function: 27767.sol-ERC20Token-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
}
// Function: 27767.sol-ERC20Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 27767.sol-ERC20Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value)

IRs:
REF_0(uint256) -> balanceOf[msg.sender]
REF_1(uint256) -> balanceOf[msg.sender]
TMP_14(uint256) = INTERNAL_CALL, RegaUtils.safeSub(uint256,uint256)(REF_1,_value)
REF_0(uint256) (->balanceOf) := TMP_14(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[_to] = safeAdd(balanceOf[_to],_value)

IRs:
REF_2(uint256) -> balanceOf[_to]
REF_3(uint256) -> balanceOf[_to]
TMP_15(uint256) = INTERNAL_CALL, RegaUtils.safeAdd(uint256,uint256)(REF_3,_value)
REF_2(uint256) (->balanceOf) := TMP_15(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
validAddress(_to)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(_to)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 27767.sol-ERC20Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value)

IRs:
REF_4(mapping(address => uint256)) -> allowance[_from]
REF_5(uint256) -> REF_4[msg.sender]
REF_6(mapping(address => uint256)) -> allowance[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_18(uint256) = INTERNAL_CALL, RegaUtils.safeSub(uint256,uint256)(REF_7,_value)
REF_5(uint256) (->allowance) := TMP_18(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[_from] = safeSub(balanceOf[_from],_value)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_from]
TMP_19(uint256) = INTERNAL_CALL, RegaUtils.safeSub(uint256,uint256)(REF_9,_value)
REF_8(uint256) (->balanceOf) := TMP_19(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_to] = safeAdd(balanceOf[_to],_value)

IRs:
REF_10(uint256) -> balanceOf[_to]
REF_11(uint256) -> balanceOf[_to]
TMP_20(uint256) = INTERNAL_CALL, RegaUtils.safeAdd(uint256,uint256)(REF_11,_value)
REF_10(uint256) (->balanceOf) := TMP_20(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
validAddress(_from)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(_from)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
validAddress(_to)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(_to)"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 27767.sol-ERC20Token-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_30(bool) = _address != 0
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-FeesControllerBase-addPayee(address)
digraph{
}
// Function: 27767.sol-FeesControllerBase-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_spender
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
remaining
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 27767.sol-FeesControllerBase-approve(address,uint256)
digraph{
}
// Function: 27767.sol-FeesControllerBase-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 27767.sol-FeesControllerBase-boardOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == board)

IRs:
TMP_132(bool) = msg.sender == board
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-FeesControllerBase-calculateFee()
digraph{
}
// Function: 27767.sol-FeesControllerBase-init()
digraph{
}
// Function: 27767.sol-FeesControllerBase-removePayee(address)
digraph{
}
// Function: 27767.sol-FeesControllerBase-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_126(uint256) = x + y
z(uint256) := TMP_126(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= x)

IRs:
TMP_127(bool) = z >= x
TMP_128(None) = SOLIDITY_CALL assert(bool)(TMP_127)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 27767.sol-FeesControllerBase-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_129(bool) = x >= y
TMP_130(None) = SOLIDITY_CALL assert(bool)(TMP_129)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_131(uint256) = x - y
RETURN TMP_131"];
}
// Function: 27767.sol-FeesControllerBase-setRepayment()
digraph{
}
// Function: 27767.sol-FeesControllerBase-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
}
// Function: 27767.sol-FeesControllerBase-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 27767.sol-FeesControllerBase-transfer(address,uint256)
digraph{
}
// Function: 27767.sol-FeesControllerBase-transferFrom(address,address,uint256)
digraph{
}
// Function: 27767.sol-FeesControllerBase-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_134(bool) = _address != 0
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-FeesControllerBase-withdrawFee()
digraph{
}
// Function: 27767.sol-IERC20Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_spender
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
remaining
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 27767.sol-IERC20Token-approve(address,uint256)
digraph{
}
// Function: 27767.sol-IERC20Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 27767.sol-IERC20Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 27767.sol-IERC20Token-transfer(address,uint256)
digraph{
}
// Function: 27767.sol-IERC20Token-transferFrom(address,address,uint256)
digraph{
}
// Function: 27767.sol-RSTBase-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_spender
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
remaining
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 27767.sol-RSTBase-approve(address,uint256)
digraph{
}
// Function: 27767.sol-RSTBase-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 27767.sol-RSTBase-boardOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == board)

IRs:
TMP_56(bool) = msg.sender == board
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-RSTBase-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_48(uint256) = x + y
z(uint256) := TMP_48(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= x)

IRs:
TMP_49(bool) = z >= x
TMP_50(None) = SOLIDITY_CALL assert(bool)(TMP_49)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 27767.sol-RSTBase-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_51(bool) = x >= y
TMP_52(None) = SOLIDITY_CALL assert(bool)(TMP_51)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_53(uint256) = x - y
RETURN TMP_53"];
}
// Function: 27767.sol-RSTBase-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
}
// Function: 27767.sol-RSTBase-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 27767.sol-RSTBase-transfer(address,uint256)
digraph{
}
// Function: 27767.sol-RSTBase-transferFrom(address,address,uint256)
digraph{
}
// Function: 27767.sol-RSTBase-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_54(bool) = _address != 0
TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-RegaUtils-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_0(uint256) = x + y
z(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= x)

IRs:
TMP_1(bool) = z >= x
TMP_2(None) = SOLIDITY_CALL assert(bool)(TMP_1)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 27767.sol-RegaUtils-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_3(bool) = x >= y
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_5(uint256) = x - y
RETURN TMP_5"];
}
// Function: 27767.sol-RegaUtils-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_6(bool) = _address != 0
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-RiskSharingToken-RiskSharingToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
board = _board

IRs:
board(address) := _board(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenController = TokenControllerBase(0)

IRs:
TMP_158 = CONVERT 0 to TokenControllerBase
tokenController(TokenControllerBase) := TMP_158(TokenControllerBase)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
votingController = VotingControllerBase(0)

IRs:
TMP_159 = CONVERT 0 to VotingControllerBase
votingController(VotingControllerBase) := TMP_159(VotingControllerBase)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
weiForToken = uint256(10) ** (18 - 1 - decimals)

IRs:
TMP_160 = CONVERT 10 to uint256
TMP_161(uint256) = 18 - 1
TMP_162(uint256) = TMP_161 - decimals
TMP_163(uint256) = TMP_160 ** TMP_162
weiForToken(uint256) := TMP_163(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
reserve = 0

IRs:
reserve(uint256) := 0(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
crr = 20

IRs:
crr(uint32) := 20(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
totalAccounts = 0

IRs:
totalAccounts(uint8) := 0(uint256)"];
}
// Function: 27767.sol-RiskSharingToken-addPayee(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! feesController.delegatecall(msg.data)

IRs:
TMP_232(bool) = LOW_LEVEL_CALL, dest:feesController, function:delegatecall, arguments:['msg.data']  
TMP_233 = UnaryType.BANG TMP_232 
CONDITION TMP_233"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_234(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(feesController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(feesController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-addToReserve()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! tokenController.delegatecall(msg.data)

IRs:
TMP_201(bool) = LOW_LEVEL_CALL, dest:tokenController, function:delegatecall, arguments:['msg.data']  
TMP_202 = UnaryType.BANG TMP_201 
CONDITION TMP_202"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_203(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(tokenController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(tokenController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_spender
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
remaining
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 27767.sol-RiskSharingToken-approve(address,uint256)
digraph{
}
// Function: 27767.sol-RiskSharingToken-authorized()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == board)

IRs:
TMP_252(bool) = msg.sender == owner
TMP_253(bool) = msg.sender == board
TMP_254(bool) = TMP_252 || TMP_253
TMP_255(None) = SOLIDITY_CALL require(bool)(TMP_254)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-RiskSharingToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 27767.sol-RiskSharingToken-boardOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == board)

IRs:
TMP_250(bool) = msg.sender == board
TMP_251(None) = SOLIDITY_CALL require(bool)(TMP_250)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-RiskSharingToken-buy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! tokenController.delegatecall(msg.data)

IRs:
TMP_193(bool) = LOW_LEVEL_CALL, dest:tokenController, function:delegatecall, arguments:['msg.data']  
TMP_194 = UnaryType.BANG TMP_193 
CONDITION TMP_194"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_195(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(tokenController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(tokenController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-calculateFee()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! feesController.delegatecall(msg.data)

IRs:
TMP_228(bool) = LOW_LEVEL_CALL, dest:feesController, function:delegatecall, arguments:['msg.data']  
TMP_229 = UnaryType.BANG TMP_228 
CONDITION TMP_229"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_230(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(feesController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(feesController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 27767.sol-RiskSharingToken-issueToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! tokenController.delegatecall(msg.data)

IRs:
TMP_210(bool) = LOW_LEVEL_CALL, dest:tokenController, function:delegatecall, arguments:['msg.data']  
TMP_211 = UnaryType.BANG TMP_210 
CONDITION TMP_211"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_212(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
authorized()

IRs:
MODIFIER_CALL, RiskSharingToken.authorized()()"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-issueTokens(uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! tokenController.delegatecall(msg.data)

IRs:
TMP_214(bool) = LOW_LEVEL_CALL, dest:tokenController, function:delegatecall, arguments:['msg.data']  
TMP_215 = UnaryType.BANG TMP_214 
CONDITION TMP_215"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_216(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, RiskSharingToken.ownerOnly()()"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-ownerOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_248(bool) = msg.sender == owner
TMP_249(None) = SOLIDITY_CALL require(bool)(TMP_248)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-RiskSharingToken-removePayee(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! feesController.delegatecall(msg.data)

IRs:
TMP_236(bool) = LOW_LEVEL_CALL, dest:feesController, function:delegatecall, arguments:['msg.data']  
TMP_237 = UnaryType.BANG TMP_236 
CONDITION TMP_237"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_238(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(feesController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(feesController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_152(uint256) = x + y
z(uint256) := TMP_152(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= x)

IRs:
TMP_153(bool) = z >= x
TMP_154(None) = SOLIDITY_CALL assert(bool)(TMP_153)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 27767.sol-RiskSharingToken-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_155(bool) = x >= y
TMP_156(None) = SOLIDITY_CALL assert(bool)(TMP_155)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_157(uint256) = x - y
RETURN TMP_157"];
}
// Function: 27767.sol-RiskSharingToken-sell(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! tokenController.delegatecall(msg.data)

IRs:
TMP_197(bool) = LOW_LEVEL_CALL, dest:tokenController, function:delegatecall, arguments:['msg.data']  
TMP_198 = UnaryType.BANG TMP_197 
CONDITION TMP_198"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_199(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(tokenController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(tokenController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-setFeesController(FeesControllerBase)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
feesController = fc

IRs:
feesController(FeesControllerBase) := fc(FeesControllerBase)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! feesController.delegatecall(bytes4(sha3()(init())))

IRs:
TMP_218(bytes32) = SOLIDITY_CALL sha3()(init())
TMP_219 = CONVERT TMP_218 to bytes4
TMP_220(bool) = LOW_LEVEL_CALL, dest:feesController, function:delegatecall, arguments:['TMP_219']  
TMP_221 = UnaryType.BANG TMP_220 
CONDITION TMP_221"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_222(None) = SOLIDITY_CALL revert()()"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
boardOnly()

IRs:
MODIFIER_CALL, RiskSharingToken.boardOnly()()"];
5->1;
}
// Function: 27767.sol-RiskSharingToken-setRepayment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! feesController.delegatecall(msg.data)

IRs:
TMP_240(bool) = LOW_LEVEL_CALL, dest:feesController, function:delegatecall, arguments:['msg.data']  
TMP_241 = UnaryType.BANG TMP_240 
CONDITION TMP_241"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_242(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(feesController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(feesController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-setTokenController(TokenControllerBase,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenController = tc

IRs:
tokenController(TokenControllerBase) := tc(TokenControllerBase)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_tokenData != address(0)

IRs:
TMP_164 = CONVERT 0 to address
TMP_165(bool) = _tokenData != TMP_164
CONDITION TMP_165"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenData = _tokenData

IRs:
tokenData(address) := _tokenData(address)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
tokenController != TokenControllerBase(0)

IRs:
TMP_166 = CONVERT 0 to TokenControllerBase
TMP_167(bool) = tokenController != TMP_166
CONDITION TMP_167"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
! tokenController.delegatecall(bytes4(sha3()(init())))

IRs:
TMP_168(bytes32) = SOLIDITY_CALL sha3()(init())
TMP_169 = CONVERT TMP_168 to bytes4
TMP_170(bool) = LOW_LEVEL_CALL, dest:tokenController, function:delegatecall, arguments:['TMP_169']  
TMP_171 = UnaryType.BANG TMP_170 
CONDITION TMP_171"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
revert()()

IRs:
TMP_172(None) = SOLIDITY_CALL revert()()"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
boardOnly()

IRs:
MODIFIER_CALL, RiskSharingToken.boardOnly()()"];
10->1;
}
// Function: 27767.sol-RiskSharingToken-setVotingController(VotingControllerBase)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
votingController = vc

IRs:
votingController(VotingControllerBase) := vc(VotingControllerBase)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
boardOnly()

IRs:
MODIFIER_CALL, RiskSharingToken.boardOnly()()"];
2->1;
}
// Function: 27767.sol-RiskSharingToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = 0.1

IRs:
version(string) := 0.1(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
name = REGA Risk Sharing Token

IRs:
name(string) := REGA Risk Sharing Token(string)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
symbol = RST

IRs:
symbol(string) := RST(string)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
decimals = 10

IRs:
decimals(uint8) := 10(uint256)"];
}
// Function: 27767.sol-RiskSharingToken-startVoting(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! votingController.delegatecall(msg.data)

IRs:
TMP_175(bool) = LOW_LEVEL_CALL, dest:votingController, function:delegatecall, arguments:['msg.data']  
TMP_176 = UnaryType.BANG TMP_175 
CONDITION TMP_176"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_177(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
boardOnly()

IRs:
MODIFIER_CALL, RiskSharingToken.boardOnly()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
validAddress(votingController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(votingController)"];
5->1;
}
// Function: 27767.sol-RiskSharingToken-stopVoting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! votingController.delegatecall(msg.data)

IRs:
TMP_180(bool) = LOW_LEVEL_CALL, dest:votingController, function:delegatecall, arguments:['msg.data']  
TMP_181 = UnaryType.BANG TMP_180 
CONDITION TMP_181"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_182(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
boardOnly()

IRs:
MODIFIER_CALL, RiskSharingToken.boardOnly()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
validAddress(votingController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(votingController)"];
5->1;
}
// Function: 27767.sol-RiskSharingToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 27767.sol-RiskSharingToken-transfer(address,uint256)
digraph{
}
// Function: 27767.sol-RiskSharingToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 27767.sol-RiskSharingToken-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_246(bool) = _address != 0
TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-RiskSharingToken-voteAgainst()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! votingController.delegatecall(msg.data)

IRs:
TMP_189(bool) = LOW_LEVEL_CALL, dest:votingController, function:delegatecall, arguments:['msg.data']  
TMP_190 = UnaryType.BANG TMP_189 
CONDITION TMP_190"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_191(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(votingController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(votingController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-voteFor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! votingController.delegatecall(msg.data)

IRs:
TMP_185(bool) = LOW_LEVEL_CALL, dest:votingController, function:delegatecall, arguments:['msg.data']  
TMP_186 = UnaryType.BANG TMP_185 
CONDITION TMP_186"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_187(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(votingController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(votingController)"];
4->1;
}
// Function: 27767.sol-RiskSharingToken-withdraw(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(safeSub(this.balance,amount) >= reserve)

IRs:
REF_104(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_205(uint256) = INTERNAL_CALL, RegaUtils.safeSub(uint256,uint256)(REF_104,amount)
TMP_206(bool) = TMP_205 >= reserve
TMP_207(None) = SOLIDITY_CALL require(bool)(TMP_206)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
board.transfer(amount)

IRs:
Transfer dest:board value:amount"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
boardOnly()

IRs:
MODIFIER_CALL, RiskSharingToken.boardOnly()()"];
3->1;
}
// Function: 27767.sol-RiskSharingToken-withdrawFee()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
! feesController.delegatecall(msg.data)

IRs:
TMP_224(bool) = LOW_LEVEL_CALL, dest:feesController, function:delegatecall, arguments:['msg.data']  
TMP_225 = UnaryType.BANG TMP_224 
CONDITION TMP_225"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_226(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(feesController)

IRs:
MODIFIER_CALL, RegaUtils.validAddress(address)(feesController)"];
4->1;
}
// Function: 27767.sol-TokenControllerBase-addToReserve()
digraph{
}
// Function: 27767.sol-TokenControllerBase-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_spender
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
remaining
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 27767.sol-TokenControllerBase-approve(address,uint256)
digraph{
}
// Function: 27767.sol-TokenControllerBase-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 27767.sol-TokenControllerBase-boardOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == board)

IRs:
TMP_80(bool) = msg.sender == board
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-TokenControllerBase-buy()
digraph{
}
// Function: 27767.sol-TokenControllerBase-init()
digraph{
}
// Function: 27767.sol-TokenControllerBase-isBuyOpen()
digraph{
}
// Function: 27767.sol-TokenControllerBase-isSellOpen()
digraph{
}
// Function: 27767.sol-TokenControllerBase-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_74(uint256) = x + y
z(uint256) := TMP_74(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= x)

IRs:
TMP_75(bool) = z >= x
TMP_76(None) = SOLIDITY_CALL assert(bool)(TMP_75)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 27767.sol-TokenControllerBase-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_77(bool) = x >= y
TMP_78(None) = SOLIDITY_CALL assert(bool)(TMP_77)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_79(uint256) = x - y
RETURN TMP_79"];
}
// Function: 27767.sol-TokenControllerBase-sell(uint256)
digraph{
}
// Function: 27767.sol-TokenControllerBase-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
}
// Function: 27767.sol-TokenControllerBase-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 27767.sol-TokenControllerBase-transfer(address,uint256)
digraph{
}
// Function: 27767.sol-TokenControllerBase-transferFrom(address,address,uint256)
digraph{
}
// Function: 27767.sol-TokenControllerBase-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_82(bool) = _address != 0
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-VotingControllerBase-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_spender
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
remaining
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 27767.sol-VotingControllerBase-approve(address,uint256)
digraph{
}
// Function: 27767.sol-VotingControllerBase-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_owner
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 27767.sol-VotingControllerBase-boardOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == board)

IRs:
TMP_106(bool) = msg.sender == board
TMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-VotingControllerBase-getCurrentVotingDescription()
digraph{
}
// Function: 27767.sol-VotingControllerBase-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_100(uint256) = x + y
z(uint256) := TMP_100(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= x)

IRs:
TMP_101(bool) = z >= x
TMP_102(None) = SOLIDITY_CALL assert(bool)(TMP_101)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 27767.sol-VotingControllerBase-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_103(bool) = x >= y
TMP_104(None) = SOLIDITY_CALL assert(bool)(TMP_103)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_105(uint256) = x - y
RETURN TMP_105"];
}
// Function: 27767.sol-VotingControllerBase-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
}
// Function: 27767.sol-VotingControllerBase-startVoting()
digraph{
}
// Function: 27767.sol-VotingControllerBase-stopVoting()
digraph{
}
// Function: 27767.sol-VotingControllerBase-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 27767.sol-VotingControllerBase-transfer(address,uint256)
digraph{
}
// Function: 27767.sol-VotingControllerBase-transferFrom(address,address,uint256)
digraph{
}
// Function: 27767.sol-VotingControllerBase-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_108(bool) = _address != 0
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 27767.sol-VotingControllerBase-voteAgainst()
digraph{
}
// Function: 27767.sol-VotingControllerBase-voteFor()
digraph{
}
}
