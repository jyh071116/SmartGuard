digraph G {
// Function: 20625.sol-ContractReceiver-tokenFallback(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_0 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_1 = CONVERT REF_4 to uint32
TMP_2(uint32) = TMP_1 << 8
TMP_3(uint32) = TMP_0 + TMP_2
REF_5(None) -> _data[1]
TMP_4 = CONVERT REF_5 to uint32
TMP_5(uint32) = TMP_4 << 16
TMP_6(uint32) = TMP_3 + TMP_5
REF_6(None) -> _data[0]
TMP_7 = CONVERT REF_6 to uint32
TMP_8(uint32) = TMP_7 << 24
TMP_9(uint32) = TMP_6 + TMP_8
u(uint32) := TMP_9(uint32)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_10 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_10(bytes4)"];
}
// Function: 20625.sol-ELTToken-ELTToken(address,string,string,uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply = _totalSupply

IRs:
totalSupply(uint256) := _totalSupply(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
decimals = _decimals

IRs:
decimals(uint256) := _decimals(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_owner] = _totalSupply

IRs:
REF_130(uint256) -> balances[_owner]
REF_130(uint256) (->balances) := _totalSupply(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
releaseFinalizationDate = _releaseFinalizationDate

IRs:
releaseFinalizationDate(uint256) := _releaseFinalizationDate(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
released = false

IRs:
released(bool) := False(bool)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
VersionedToken(_initialVersion)

IRs:
INTERNAL_CALL, VersionedToken.VersionedToken(address)(_initialVersion)"];
8->1;
}
// Function: 20625.sol-ELTToken-VersionedToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
upgradableContractAddress = initialVersion

IRs:
upgradableContractAddress(address) := initialVersion(address)"];
}
// Function: 20625.sol-ELTToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
upgradableContractMem = upgradableContractAddress

IRs:
upgradableContractMem(address) := upgradableContractAddress(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
functionCall = msg.data

IRs:
functionCall(bytes) := msg.data(bytes)"];
2->3;
3[label="Node Type: INLINE ASM 3
"];
3->4;
4[label="Node Type: END INLINE ASM 4
"];
}
// Function: 20625.sol-ELTToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_195(bool) = msg.sender == owner
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20625.sol-ELTToken-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20625.sol-ELTToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-ELTToken-update(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
upgradableContractAddress = newVersion

IRs:
upgradableContractAddress(address) := newVersion(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-ELTTokenImpl-ELTTokenImpl()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 20625.sol-ELTTokenImpl-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_151(mapping(address => uint256)) -> allowed[_owner]
REF_152(uint256) -> REF_151[_spender]
RETURN REF_152"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 20625.sol-ELTTokenImpl-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_149(mapping(address => uint256)) -> allowed[msg.sender]
REF_150(uint256) -> REF_149[_spender]
REF_150(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-ELTTokenImpl-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_153(uint256) -> balances[_owner]
RETURN REF_153"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 20625.sol-ELTTokenImpl-checkTransferRequirements(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_216 = CONVERT 0 to address
TMP_217(bool) = _to != TMP_216
TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(released == true)

IRs:
TMP_219(bool) = released == True
TMP_220(None) = SOLIDITY_CALL require(bool)(TMP_219)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > releaseFinalizationDate)

IRs:
TMP_221(bool) = now > releaseFinalizationDate
TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
timevault[msg.sender] != 0

IRs:
REF_155(uint256) -> timevault[msg.sender]
TMP_223(bool) = REF_155 != 0
CONDITION TMP_223"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(now > timevault[msg.sender])

IRs:
REF_156(uint256) -> timevault[msg.sender]
TMP_224(bool) = now > REF_156
TMP_225(None) = SOLIDITY_CALL require(bool)(TMP_224)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
balanceOf(_from) < _value

IRs:
TMP_226(uint256) = INTERNAL_CALL, ERC20Token.balanceOf(address)(_from)
TMP_227(bool) = TMP_226 < _value
CONDITION TMP_227"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_228(None) = SOLIDITY_CALL revert()()"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 20625.sol-ELTTokenImpl-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_138(mapping(address => uint256)) -> allowed[msg.sender]
REF_139(uint256) -> REF_138[_spender]
oldValue(uint256) := REF_139(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_199(bool) = _subtractedValue > oldValue
CONDITION TMP_199"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_140(mapping(address => uint256)) -> allowed[msg.sender]
REF_141(uint256) -> REF_140[_spender]
REF_141(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_142(mapping(address => uint256)) -> allowed[msg.sender]
REF_143(uint256) -> REF_142[_spender]
TMP_200(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_143(uint256) (->allowed) := TMP_200(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_145(mapping(address => uint256)) -> allowed[msg.sender]
REF_146(uint256) -> REF_145[_spender]
Emit Approval(msg.sender,_spender,REF_146)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ELTTokenImpl-getNow()
digraph{
}
// Function: 20625.sol-ELTTokenImpl-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_131(mapping(address => uint256)) -> allowed[msg.sender]
REF_132(uint256) -> REF_131[_spender]
REF_133(mapping(address => uint256)) -> allowed[msg.sender]
REF_134(uint256) -> REF_133[_spender]
TMP_197(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_134', '_addedValue'] 
REF_132(uint256) (->allowed) := TMP_197(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_136(mapping(address => uint256)) -> allowed[msg.sender]
REF_137(uint256) -> REF_136[_spender]
Emit Approval(msg.sender,_spender,REF_137)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ELTTokenImpl-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(length > 0)

IRs:
TMP_209(bool) = length > 0
RETURN TMP_209"];
5[label="Node Type: RETURN 5

EXPRESSION:
is_contract

IRs:
RETURN is_contract"];
}
// Function: 20625.sol-ELTTokenImpl-isToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
true

IRs:
RETURN True"];
2[label="Node Type: RETURN 2

EXPRESSION:
weAre

IRs:
RETURN weAre"];
}
// Function: 20625.sol-ELTTokenImpl-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_243(bool) = msg.sender == owner
TMP_244(None) = SOLIDITY_CALL require(bool)(TMP_243)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20625.sol-ELTTokenImpl-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20625.sol-ELTTokenImpl-releaseTokenTransfer(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
released = _value

IRs:
released(bool) := _value(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-ELTTokenImpl-setTokenInformation(string,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
UpdatedTokenInformation(name,symbol)

IRs:
Emit UpdatedTokenInformation(name,symbol)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 20625.sol-ELTTokenImpl-setreleaseFinalizationDate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
releaseFinalizationDate = _value

IRs:
releaseFinalizationDate(uint256) := _value(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-ELTTokenImpl-timeVault(address)
digraph{
}
// Function: 20625.sol-ELTTokenImpl-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
transfer(_to,_value,empty)

IRs:
TMP_204(bool) = INTERNAL_CALL, ERC20Token.transfer(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_204"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ELTTokenImpl-transfer(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_205(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(_to)
CONDITION TMP_205"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
transferToContract(_to,_value,_data,false)

IRs:
TMP_206(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_206"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToAddress(_to,_value,_data,false)

IRs:
TMP_207(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_207"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ELTTokenImpl-transferByOwner(address,uint256,uint256)
digraph{
}
// Function: 20625.sol-ELTTokenImpl-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(to)

IRs:
TMP_234(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(to)
CONDITION TMP_234"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToContract(to,value,empty,true)

IRs:
TMP_235(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_235"];
4[label="Node Type: RETURN 4

EXPRESSION:
transferToAddress(to,value,empty,true)

IRs:
TMP_236(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_236"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(value)

IRs:
REF_165(mapping(address => uint256)) -> allowed[from]
REF_166(uint256) -> REF_165[msg.sender]
REF_167(mapping(address => uint256)) -> allowed[from]
REF_168(uint256) -> REF_167[msg.sender]
TMP_237(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_168', 'value'] 
REF_166(uint256) (->allowed) := TMP_237(uint256)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-ELTTokenImpl-transferIfRequirementsMet(address,address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
checkTransferRequirements(_from,_to,_value)

IRs:
INTERNAL_CALL, ERC20Token.checkTransferRequirements(address,address,uint256)(_from,_to,_value)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
withAllowances

IRs:
CONDITION withAllowances"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_157(mapping(address => uint256)) -> allowed[_from]
REF_158(uint256) -> REF_157[msg.sender]
TMP_230(bool) = _value <= REF_158
TMP_231(None) = SOLIDITY_CALL require(bool)(TMP_230)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] = balances[msg.sender].sub(_value)

IRs:
REF_159(uint256) -> balances[_from]
REF_160(uint256) -> balances[msg.sender]
TMP_232(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_160', '_value'] 
REF_159(uint256) (->balances) := TMP_232(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_162(uint256) -> balances[_to]
REF_163(uint256) -> balances[_to]
TMP_233(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_163', '_value'] 
REF_162(uint256) (->balances) := TMP_233(uint256)"];
}
// Function: 20625.sol-ELTTokenImpl-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-ELTTokenImpl-transferToAddress(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ELTTokenImpl-transferToContract(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
receiver = ContractReceiver(_to)

IRs:
TMP_213 = CONVERT _to to ContractReceiver
receiver(ContractReceiver) := TMP_213(ContractReceiver)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ContractReceiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ERC20Interface-allowance(address,address)
digraph{
}
// Function: 20625.sol-ERC20Interface-approve(address,uint256)
digraph{
}
// Function: 20625.sol-ERC20Interface-balanceOf(address)
digraph{
}
// Function: 20625.sol-ERC20Interface-transfer(address,uint256)
digraph{
}
// Function: 20625.sol-ERC20Interface-transferFrom(address,address,uint256)
digraph{
}
// Function: 20625.sol-ERC20Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_10(mapping(address => uint256)) -> allowed[_owner]
REF_11(uint256) -> REF_10[_spender]
RETURN REF_11"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 20625.sol-ERC20Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[msg.sender]
REF_9(uint256) -> REF_8[_spender]
REF_9(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-ERC20Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_12(uint256) -> balances[_owner]
RETURN REF_12"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 20625.sol-ERC20Token-checkTransferRequirements(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_39 = CONVERT 0 to address
TMP_40(bool) = _to != TMP_39
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(released == true)

IRs:
TMP_42(bool) = released == True
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > releaseFinalizationDate)

IRs:
TMP_44(bool) = now > releaseFinalizationDate
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
timevault[msg.sender] != 0

IRs:
REF_14(uint256) -> timevault[msg.sender]
TMP_46(bool) = REF_14 != 0
CONDITION TMP_46"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(now > timevault[msg.sender])

IRs:
REF_15(uint256) -> timevault[msg.sender]
TMP_47(bool) = now > REF_15
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
balanceOf(_from) < _value

IRs:
TMP_49(uint256) = INTERNAL_CALL, ERC20Token.balanceOf(address)(_from)
TMP_50(bool) = TMP_49 < _value
CONDITION TMP_50"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_51(None) = SOLIDITY_CALL revert()()"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 20625.sol-ERC20Token-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(length > 0)

IRs:
TMP_32(bool) = length > 0
RETURN TMP_32"];
5[label="Node Type: RETURN 5

EXPRESSION:
is_contract

IRs:
RETURN is_contract"];
}
// Function: 20625.sol-ERC20Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
transfer(_to,_value,empty)

IRs:
TMP_27(bool) = INTERNAL_CALL, ERC20Token.transfer(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_27"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ERC20Token-transfer(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_28(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(_to)
CONDITION TMP_28"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
transferToContract(_to,_value,_data,false)

IRs:
TMP_29(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_29"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToAddress(_to,_value,_data,false)

IRs:
TMP_30(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_30"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ERC20Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(to)

IRs:
TMP_57(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(to)
CONDITION TMP_57"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToContract(to,value,empty,true)

IRs:
TMP_58(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_58"];
4[label="Node Type: RETURN 4

EXPRESSION:
transferToAddress(to,value,empty,true)

IRs:
TMP_59(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_59"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(value)

IRs:
REF_24(mapping(address => uint256)) -> allowed[from]
REF_25(uint256) -> REF_24[msg.sender]
REF_26(mapping(address => uint256)) -> allowed[from]
REF_27(uint256) -> REF_26[msg.sender]
TMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_27', 'value'] 
REF_25(uint256) (->allowed) := TMP_60(uint256)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-ERC20Token-transferIfRequirementsMet(address,address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
checkTransferRequirements(_from,_to,_value)

IRs:
INTERNAL_CALL, ERC20Token.checkTransferRequirements(address,address,uint256)(_from,_to,_value)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
withAllowances

IRs:
CONDITION withAllowances"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_16(mapping(address => uint256)) -> allowed[_from]
REF_17(uint256) -> REF_16[msg.sender]
TMP_53(bool) = _value <= REF_17
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] = balances[msg.sender].sub(_value)

IRs:
REF_18(uint256) -> balances[_from]
REF_19(uint256) -> balances[msg.sender]
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_19', '_value'] 
REF_18(uint256) (->balances) := TMP_55(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_21(uint256) -> balances[_to]
REF_22(uint256) -> balances[_to]
TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_22', '_value'] 
REF_21(uint256) (->balances) := TMP_56(uint256)"];
}
// Function: 20625.sol-ERC20Token-transferToAddress(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ERC20Token-transferToContract(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
receiver = ContractReceiver(_to)

IRs:
TMP_36 = CONVERT _to to ContractReceiver
receiver(ContractReceiver) := TMP_36(ContractReceiver)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ContractReceiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-ERC223Interface-balanceOf(address)
digraph{
}
// Function: 20625.sol-ERC223Interface-transfer(address,uint256,bytes)
digraph{
}
// Function: 20625.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_24(uint256) = a + b
c(uint256) := TMP_24(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_25(bool) = c >= a
TMP_26(None) = SOLIDITY_CALL assert(bool)(TMP_25)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 20625.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_20(uint256) = a / b
c(uint256) := TMP_20(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 20625.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_14(uint256) = a * b
c(uint256) := TMP_14(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_15(bool) = a == 0
TMP_16(uint256) = c / a
TMP_17(bool) = TMP_16 == b
TMP_18(bool) = TMP_15 || TMP_17
TMP_19(None) = SOLIDITY_CALL assert(bool)(TMP_18)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 20625.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_21(bool) = b <= a
TMP_22(None) = SOLIDITY_CALL assert(bool)(TMP_21)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_23(uint256) = a - b
RETURN TMP_23"];
}
// Function: 20625.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_56(mapping(address => uint256)) -> allowed[_owner]
REF_57(uint256) -> REF_56[_spender]
RETURN REF_57"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 20625.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_54(mapping(address => uint256)) -> allowed[msg.sender]
REF_55(uint256) -> REF_54[_spender]
REF_55(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-StandardToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_58(uint256) -> balances[_owner]
RETURN REF_58"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 20625.sol-StandardToken-checkTransferRequirements(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_114 = CONVERT 0 to address
TMP_115(bool) = _to != TMP_114
TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(released == true)

IRs:
TMP_117(bool) = released == True
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > releaseFinalizationDate)

IRs:
TMP_119(bool) = now > releaseFinalizationDate
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
timevault[msg.sender] != 0

IRs:
REF_60(uint256) -> timevault[msg.sender]
TMP_121(bool) = REF_60 != 0
CONDITION TMP_121"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(now > timevault[msg.sender])

IRs:
REF_61(uint256) -> timevault[msg.sender]
TMP_122(bool) = now > REF_61
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
balanceOf(_from) < _value

IRs:
TMP_124(uint256) = INTERNAL_CALL, ERC20Token.balanceOf(address)(_from)
TMP_125(bool) = TMP_124 < _value
CONDITION TMP_125"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_126(None) = SOLIDITY_CALL revert()()"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 20625.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
oldValue(uint256) := REF_83(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_139(bool) = _subtractedValue > oldValue
CONDITION TMP_139"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_84(mapping(address => uint256)) -> allowed[msg.sender]
REF_85(uint256) -> REF_84[_spender]
REF_85(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_86(mapping(address => uint256)) -> allowed[msg.sender]
REF_87(uint256) -> REF_86[_spender]
TMP_140(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_87(uint256) (->allowed) := TMP_140(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_89(mapping(address => uint256)) -> allowed[msg.sender]
REF_90(uint256) -> REF_89[_spender]
Emit Approval(msg.sender,_spender,REF_90)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardToken-getNow()
digraph{
}
// Function: 20625.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_78', '_addedValue'] 
REF_76(uint256) (->allowed) := TMP_137(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_80(mapping(address => uint256)) -> allowed[msg.sender]
REF_81(uint256) -> REF_80[_spender]
Emit Approval(msg.sender,_spender,REF_81)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardToken-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(length > 0)

IRs:
TMP_107(bool) = length > 0
RETURN TMP_107"];
5[label="Node Type: RETURN 5

EXPRESSION:
is_contract

IRs:
RETURN is_contract"];
}
// Function: 20625.sol-StandardToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_142(bool) = msg.sender == owner
TMP_143(None) = SOLIDITY_CALL require(bool)(TMP_142)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20625.sol-StandardToken-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20625.sol-StandardToken-timeVault(address)
digraph{
}
// Function: 20625.sol-StandardToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
transfer(_to,_value,empty)

IRs:
TMP_102(bool) = INTERNAL_CALL, ERC20Token.transfer(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_102"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardToken-transfer(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_103(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(_to)
CONDITION TMP_103"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
transferToContract(_to,_value,_data,false)

IRs:
TMP_104(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_104"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToAddress(_to,_value,_data,false)

IRs:
TMP_105(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_105"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardToken-transferByOwner(address,uint256,uint256)
digraph{
}
// Function: 20625.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(to)

IRs:
TMP_132(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(to)
CONDITION TMP_132"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToContract(to,value,empty,true)

IRs:
TMP_133(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_133"];
4[label="Node Type: RETURN 4

EXPRESSION:
transferToAddress(to,value,empty,true)

IRs:
TMP_134(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_134"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(value)

IRs:
REF_70(mapping(address => uint256)) -> allowed[from]
REF_71(uint256) -> REF_70[msg.sender]
REF_72(mapping(address => uint256)) -> allowed[from]
REF_73(uint256) -> REF_72[msg.sender]
TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_73', 'value'] 
REF_71(uint256) (->allowed) := TMP_135(uint256)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-StandardToken-transferIfRequirementsMet(address,address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
checkTransferRequirements(_from,_to,_value)

IRs:
INTERNAL_CALL, ERC20Token.checkTransferRequirements(address,address,uint256)(_from,_to,_value)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
withAllowances

IRs:
CONDITION withAllowances"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_62(mapping(address => uint256)) -> allowed[_from]
REF_63(uint256) -> REF_62[msg.sender]
TMP_128(bool) = _value <= REF_63
TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] = balances[msg.sender].sub(_value)

IRs:
REF_64(uint256) -> balances[_from]
REF_65(uint256) -> balances[msg.sender]
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_65', '_value'] 
REF_64(uint256) (->balances) := TMP_130(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_67(uint256) -> balances[_to]
REF_68(uint256) -> balances[_to]
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_68', '_value'] 
REF_67(uint256) (->balances) := TMP_131(uint256)"];
}
// Function: 20625.sol-StandardToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-StandardToken-transferToAddress(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardToken-transferToContract(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
receiver = ContractReceiver(_to)

IRs:
TMP_111 = CONVERT _to to ContractReceiver
receiver(ContractReceiver) := TMP_111(ContractReceiver)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ContractReceiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardTokenExt-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_111(mapping(address => uint256)) -> allowed[_owner]
REF_112(uint256) -> REF_111[_spender]
RETURN REF_112"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 20625.sol-StandardTokenExt-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_109(mapping(address => uint256)) -> allowed[msg.sender]
REF_110(uint256) -> REF_109[_spender]
REF_110(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-StandardTokenExt-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_113(uint256) -> balances[_owner]
RETURN REF_113"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 20625.sol-StandardTokenExt-checkTransferRequirements(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_163 = CONVERT 0 to address
TMP_164(bool) = _to != TMP_163
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(released == true)

IRs:
TMP_166(bool) = released == True
TMP_167(None) = SOLIDITY_CALL require(bool)(TMP_166)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > releaseFinalizationDate)

IRs:
TMP_168(bool) = now > releaseFinalizationDate
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
timevault[msg.sender] != 0

IRs:
REF_115(uint256) -> timevault[msg.sender]
TMP_170(bool) = REF_115 != 0
CONDITION TMP_170"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(now > timevault[msg.sender])

IRs:
REF_116(uint256) -> timevault[msg.sender]
TMP_171(bool) = now > REF_116
TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
balanceOf(_from) < _value

IRs:
TMP_173(uint256) = INTERNAL_CALL, ERC20Token.balanceOf(address)(_from)
TMP_174(bool) = TMP_173 < _value
CONDITION TMP_174"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_175(None) = SOLIDITY_CALL revert()()"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 20625.sol-StandardTokenExt-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_98(mapping(address => uint256)) -> allowed[msg.sender]
REF_99(uint256) -> REF_98[_spender]
oldValue(uint256) := REF_99(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_146(bool) = _subtractedValue > oldValue
CONDITION TMP_146"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_100(mapping(address => uint256)) -> allowed[msg.sender]
REF_101(uint256) -> REF_100[_spender]
REF_101(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_102(mapping(address => uint256)) -> allowed[msg.sender]
REF_103(uint256) -> REF_102[_spender]
TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_103(uint256) (->allowed) := TMP_147(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_105(mapping(address => uint256)) -> allowed[msg.sender]
REF_106(uint256) -> REF_105[_spender]
Emit Approval(msg.sender,_spender,REF_106)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardTokenExt-getNow()
digraph{
}
// Function: 20625.sol-StandardTokenExt-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_91(mapping(address => uint256)) -> allowed[msg.sender]
REF_92(uint256) -> REF_91[_spender]
REF_93(mapping(address => uint256)) -> allowed[msg.sender]
REF_94(uint256) -> REF_93[_spender]
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_94', '_addedValue'] 
REF_92(uint256) (->allowed) := TMP_144(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_96(mapping(address => uint256)) -> allowed[msg.sender]
REF_97(uint256) -> REF_96[_spender]
Emit Approval(msg.sender,_spender,REF_97)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardTokenExt-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(length > 0)

IRs:
TMP_156(bool) = length > 0
RETURN TMP_156"];
5[label="Node Type: RETURN 5

EXPRESSION:
is_contract

IRs:
RETURN is_contract"];
}
// Function: 20625.sol-StandardTokenExt-isToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
true

IRs:
RETURN True"];
2[label="Node Type: RETURN 2

EXPRESSION:
weAre

IRs:
RETURN weAre"];
}
// Function: 20625.sol-StandardTokenExt-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_186(bool) = msg.sender == owner
TMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20625.sol-StandardTokenExt-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20625.sol-StandardTokenExt-timeVault(address)
digraph{
}
// Function: 20625.sol-StandardTokenExt-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
transfer(_to,_value,empty)

IRs:
TMP_151(bool) = INTERNAL_CALL, ERC20Token.transfer(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_151"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardTokenExt-transfer(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_152(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(_to)
CONDITION TMP_152"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
transferToContract(_to,_value,_data,false)

IRs:
TMP_153(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_153"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToAddress(_to,_value,_data,false)

IRs:
TMP_154(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_154"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardTokenExt-transferByOwner(address,uint256,uint256)
digraph{
}
// Function: 20625.sol-StandardTokenExt-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(to)

IRs:
TMP_181(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(to)
CONDITION TMP_181"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToContract(to,value,empty,true)

IRs:
TMP_182(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_182"];
4[label="Node Type: RETURN 4

EXPRESSION:
transferToAddress(to,value,empty,true)

IRs:
TMP_183(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_183"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(value)

IRs:
REF_125(mapping(address => uint256)) -> allowed[from]
REF_126(uint256) -> REF_125[msg.sender]
REF_127(mapping(address => uint256)) -> allowed[from]
REF_128(uint256) -> REF_127[msg.sender]
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_128', 'value'] 
REF_126(uint256) (->allowed) := TMP_184(uint256)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-StandardTokenExt-transferIfRequirementsMet(address,address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
checkTransferRequirements(_from,_to,_value)

IRs:
INTERNAL_CALL, ERC20Token.checkTransferRequirements(address,address,uint256)(_from,_to,_value)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
withAllowances

IRs:
CONDITION withAllowances"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_117(mapping(address => uint256)) -> allowed[_from]
REF_118(uint256) -> REF_117[msg.sender]
TMP_177(bool) = _value <= REF_118
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] = balances[msg.sender].sub(_value)

IRs:
REF_119(uint256) -> balances[_from]
REF_120(uint256) -> balances[msg.sender]
TMP_179(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_120', '_value'] 
REF_119(uint256) (->balances) := TMP_179(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_122(uint256) -> balances[_to]
REF_123(uint256) -> balances[_to]
TMP_180(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_123', '_value'] 
REF_122(uint256) (->balances) := TMP_180(uint256)"];
}
// Function: 20625.sol-StandardTokenExt-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-StandardTokenExt-transferToAddress(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-StandardTokenExt-transferToContract(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
receiver = ContractReceiver(_to)

IRs:
TMP_160 = CONVERT _to to ContractReceiver
receiver(ContractReceiver) := TMP_160(ContractReceiver)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ContractReceiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-TimeVaultInterface-allowance(address,address)
digraph{
}
// Function: 20625.sol-TimeVaultInterface-approve(address,uint256)
digraph{
}
// Function: 20625.sol-TimeVaultInterface-balanceOf(address)
digraph{
}
// Function: 20625.sol-TimeVaultInterface-getNow()
digraph{
}
// Function: 20625.sol-TimeVaultInterface-timeVault(address)
digraph{
}
// Function: 20625.sol-TimeVaultInterface-transfer(address,uint256)
digraph{
}
// Function: 20625.sol-TimeVaultInterface-transfer(address,uint256,bytes)
digraph{
}
// Function: 20625.sol-TimeVaultInterface-transferByOwner(address,uint256,uint256)
digraph{
}
// Function: 20625.sol-TimeVaultInterface-transferFrom(address,address,uint256)
digraph{
}
// Function: 20625.sol-TimeVaultToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_31(mapping(address => uint256)) -> allowed[_owner]
REF_32(uint256) -> REF_31[_spender]
RETURN REF_32"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 20625.sol-TimeVaultToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_29(mapping(address => uint256)) -> allowed[msg.sender]
REF_30(uint256) -> REF_29[_spender]
REF_30(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-TimeVaultToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_33(uint256) -> balances[_owner]
RETURN REF_33"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 20625.sol-TimeVaultToken-checkTransferRequirements(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_73 = CONVERT 0 to address
TMP_74(bool) = _to != TMP_73
TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(released == true)

IRs:
TMP_76(bool) = released == True
TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > releaseFinalizationDate)

IRs:
TMP_78(bool) = now > releaseFinalizationDate
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
timevault[msg.sender] != 0

IRs:
REF_35(uint256) -> timevault[msg.sender]
TMP_80(bool) = REF_35 != 0
CONDITION TMP_80"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(now > timevault[msg.sender])

IRs:
REF_36(uint256) -> timevault[msg.sender]
TMP_81(bool) = now > REF_36
TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
balanceOf(_from) < _value

IRs:
TMP_83(uint256) = INTERNAL_CALL, ERC20Token.balanceOf(address)(_from)
TMP_84(bool) = TMP_83 < _value
CONDITION TMP_84"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_85(None) = SOLIDITY_CALL revert()()"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 20625.sol-TimeVaultToken-getNow()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now

IRs:
RETURN now"];
2[label="Node Type: RETURN 2

EXPRESSION:
blockchainTimeNow

IRs:
RETURN blockchainTimeNow"];
}
// Function: 20625.sol-TimeVaultToken-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(length > 0)

IRs:
TMP_66(bool) = length > 0
RETURN TMP_66"];
5[label="Node Type: RETURN 5

EXPRESSION:
is_contract

IRs:
RETURN is_contract"];
}
// Function: 20625.sol-TimeVaultToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_98(bool) = msg.sender == owner
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20625.sol-TimeVaultToken-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20625.sol-TimeVaultToken-timeVault(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
timevault[owner]

IRs:
REF_51(uint256) -> timevault[owner]
RETURN REF_51"];
2[label="Node Type: RETURN 2

EXPRESSION:
earliestTransferTime

IRs:
RETURN earliestTransferTime"];
}
// Function: 20625.sol-TimeVaultToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
transfer(_to,_value,empty)

IRs:
TMP_61(bool) = INTERNAL_CALL, ERC20Token.transfer(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_61"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-TimeVaultToken-transfer(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_62(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(_to)
CONDITION TMP_62"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
transferToContract(_to,_value,_data,false)

IRs:
TMP_63(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_63"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToAddress(_to,_value,_data,false)

IRs:
TMP_64(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(_to,_value,_data,False)
RETURN TMP_64"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-TimeVaultToken-transferByOwner(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfer(to,value)

IRs:
TMP_96(bool) = INTERNAL_CALL, ERC20Token.transfer(address,uint256)(to,value)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
timevault[to] = earliestReTransferTime

IRs:
REF_50(uint256) -> timevault[to]
REF_50(uint256) (->timevault) := earliestReTransferTime(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 20625.sol-TimeVaultToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(to)

IRs:
TMP_91(bool) = INTERNAL_CALL, ERC20Token.isContract(address)(to)
CONDITION TMP_91"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToContract(to,value,empty,true)

IRs:
TMP_92(bool) = INTERNAL_CALL, ERC20Token.transferToContract(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_92"];
4[label="Node Type: RETURN 4

EXPRESSION:
transferToAddress(to,value,empty,true)

IRs:
TMP_93(bool) = INTERNAL_CALL, ERC20Token.transferToAddress(address,uint256,bytes,bool)(to,value,empty,True)
RETURN TMP_93"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(value)

IRs:
REF_45(mapping(address => uint256)) -> allowed[from]
REF_46(uint256) -> REF_45[msg.sender]
REF_47(mapping(address => uint256)) -> allowed[from]
REF_48(uint256) -> REF_47[msg.sender]
TMP_94(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_48', 'value'] 
REF_46(uint256) (->allowed) := TMP_94(uint256)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 20625.sol-TimeVaultToken-transferIfRequirementsMet(address,address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
checkTransferRequirements(_from,_to,_value)

IRs:
INTERNAL_CALL, ERC20Token.checkTransferRequirements(address,address,uint256)(_from,_to,_value)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
withAllowances

IRs:
CONDITION withAllowances"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_37(mapping(address => uint256)) -> allowed[_from]
REF_38(uint256) -> REF_37[msg.sender]
TMP_87(bool) = _value <= REF_38
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] = balances[msg.sender].sub(_value)

IRs:
REF_39(uint256) -> balances[_from]
REF_40(uint256) -> balances[msg.sender]
TMP_89(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_40', '_value'] 
REF_39(uint256) (->balances) := TMP_89(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_42(uint256) -> balances[_to]
REF_43(uint256) -> balances[_to]
TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_43', '_value'] 
REF_42(uint256) (->balances) := TMP_90(uint256)"];
}
// Function: 20625.sol-TimeVaultToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-TimeVaultToken-transferToAddress(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-TimeVaultToken-transferToContract(address,uint256,bytes,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferIfRequirementsMet(msg.sender,_to,_value,withAllowance)

IRs:
INTERNAL_CALL, ERC20Token.transferIfRequirementsMet(address,address,uint256,bool)(msg.sender,_to,_value,withAllowance)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
receiver = ContractReceiver(_to)

IRs:
TMP_70 = CONVERT _to to ContractReceiver
receiver(ContractReceiver) := TMP_70(ContractReceiver)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ContractReceiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 20625.sol-VersionedToken-VersionedToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
upgradableContractAddress = initialVersion

IRs:
upgradableContractAddress(address) := initialVersion(address)"];
}
// Function: 20625.sol-VersionedToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
upgradableContractMem = upgradableContractAddress

IRs:
upgradableContractMem(address) := upgradableContractAddress(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
functionCall = msg.data

IRs:
functionCall(bytes) := msg.data(bytes)"];
2->3;
3[label="Node Type: INLINE ASM 3
"];
3->4;
4[label="Node Type: END INLINE ASM 4
"];
}
// Function: 20625.sol-VersionedToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_190(bool) = msg.sender == owner
TMP_191(None) = SOLIDITY_CALL require(bool)(TMP_190)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20625.sol-VersionedToken-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20625.sol-VersionedToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-VersionedToken-update(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
upgradableContractAddress = newVersion

IRs:
upgradableContractAddress(address) := newVersion(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 20625.sol-owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_12(bool) = msg.sender == owner
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20625.sol-owned-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20625.sol-owned-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
}
