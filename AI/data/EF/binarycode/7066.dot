digraph G {
// Function: 7066.sol-AbstractToken-AbstractToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7066.sol-AbstractToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowances[_owner][_spender]

IRs:
REF_15(mapping(address => uint256)) -> allowances[_owner]
REF_16(uint256) -> REF_15[_spender]
RETURN REF_16"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 7066.sol-AbstractToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowances[msg.sender][_spender] = _value

IRs:
REF_13(mapping(address => uint256)) -> allowances[msg.sender]
REF_14(uint256) -> REF_13[_spender]
REF_14(uint256) (->allowances) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7066.sol-AbstractToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[_owner]

IRs:
REF_0(uint256) -> accounts[_owner]
RETURN REF_0"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 7066.sol-AbstractToken-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x <= MAX_UINT256 - y)

IRs:
TMP_12(uint256) = MAX_UINT256 - y
TMP_13(bool) = x <= TMP_12
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x + y

IRs:
TMP_15(uint256) = x + y
RETURN TMP_15"];
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-AbstractToken-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
y == 0

IRs:
TMP_19(bool) = y == 0
CONDITION TMP_19"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(x <= MAX_UINT256 / y)

IRs:
TMP_20(uint256) = MAX_UINT256 / y
TMP_21(bool) = x <= TMP_20
TMP_22(None) = SOLIDITY_CALL assert(bool)(TMP_21)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
x * y

IRs:
TMP_23(uint256) = x * y
RETURN TMP_23"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-AbstractToken-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_16(bool) = x >= y
TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_18(uint256) = x - y
RETURN TMP_18"];
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-AbstractToken-totalSupply()
digraph{
}
// Function: 7066.sol-AbstractToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fromBalance = accounts[msg.sender]

IRs:
REF_1(uint256) -> accounts[msg.sender]
fromBalance(uint256) := REF_1(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
fromBalance < _value

IRs:
TMP_24(bool) = fromBalance < _value
CONDITION TMP_24"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
_value > 0 && msg.sender != _to

IRs:
TMP_25(bool) = _value > 0
TMP_26(bool) = msg.sender != _to
TMP_27(bool) = TMP_25 && TMP_26
CONDITION TMP_27"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
accounts[msg.sender] = safeSub(fromBalance,_value)

IRs:
REF_2(uint256) -> accounts[msg.sender]
TMP_28(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(fromBalance,_value)
REF_2(uint256) (->accounts) := TMP_28(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
accounts[_to] = safeAdd(accounts[_to],_value)

IRs:
REF_3(uint256) -> accounts[_to]
REF_4(uint256) -> accounts[_to]
TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_4,_value)
REF_3(uint256) (->accounts) := TMP_29(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7066.sol-AbstractToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderAllowance = allowances[_from][msg.sender]

IRs:
REF_5(mapping(address => uint256)) -> allowances[_from]
REF_6(uint256) -> REF_5[msg.sender]
spenderAllowance(uint256) := REF_6(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
spenderAllowance < _value

IRs:
TMP_31(bool) = spenderAllowance < _value
CONDITION TMP_31"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
fromBalance = accounts[_from]

IRs:
REF_7(uint256) -> accounts[_from]
fromBalance(uint256) := REF_7(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
fromBalance < _value

IRs:
TMP_32(bool) = fromBalance < _value
CONDITION TMP_32"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
allowances[_from][msg.sender] = safeSub(spenderAllowance,_value)

IRs:
REF_8(mapping(address => uint256)) -> allowances[_from]
REF_9(uint256) -> REF_8[msg.sender]
TMP_33(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(spenderAllowance,_value)
REF_9(uint256) (->allowances) := TMP_33(uint256)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
_value > 0 && _from != _to

IRs:
TMP_34(bool) = _value > 0
TMP_35(bool) = _from != _to
TMP_36(bool) = TMP_34 && TMP_35
CONDITION TMP_36"];
10->11[label="True"];
10->13[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
accounts[_from] = safeSub(fromBalance,_value)

IRs:
REF_10(uint256) -> accounts[_from]
TMP_37(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(fromBalance,_value)
REF_10(uint256) (->accounts) := TMP_37(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
accounts[_to] = safeAdd(accounts[_to],_value)

IRs:
REF_11(uint256) -> accounts[_to]
REF_12(uint256) -> accounts[_to]
TMP_38(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_12,_value)
REF_11(uint256) (->accounts) := TMP_38(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
true

IRs:
RETURN True"];
16[label="Node Type: RETURN 16

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7066.sol-EURSToken-AbstractToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7066.sol-EURSToken-EURSToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
fixedFee = DEFAULT_FEE

IRs:
fixedFee(uint256) := DEFAULT_FEE(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minVariableFee = 0

IRs:
minVariableFee(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
maxVariableFee = 0

IRs:
maxVariableFee(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
variableFeeNumerator = 0

IRs:
variableFeeNumerator(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
feeCollector = _feeCollector

IRs:
feeCollector(address) := _feeCollector(address)"];
}
// Function: 7066.sol-EURSToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
AbstractToken.allowance(_owner,_spender)

IRs:
TMP_117(uint256) = INTERNAL_CALL, AbstractToken.allowance(address,address)(_owner,_spender)
RETURN TMP_117"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 7066.sol-EURSToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
AbstractToken.approve(_spender,_value)

IRs:
TMP_115(bool) = INTERNAL_CALL, AbstractToken.approve(address,uint256)(_spender,_value)
RETURN TMP_115"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7066.sol-EURSToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
AbstractToken.balanceOf(_owner)

IRs:
TMP_76(uint256) = INTERNAL_CALL, AbstractToken.balanceOf(address)(_owner)
RETURN TMP_76"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 7066.sol-EURSToken-burnTokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_155(bool) = msg.sender == owner
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_value > 0

IRs:
TMP_157(bool) = _value > 0
CONDITION TMP_157"];
2->3[label="True"];
2->10[label="False"];
3[label="Node Type: IF 3

EXPRESSION:
_value <= accounts[msg.sender]

IRs:
REF_73(uint256) -> accounts[msg.sender]
TMP_158(bool) = _value <= REF_73
CONDITION TMP_158"];
3->4[label="True"];
3->8[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
accounts[msg.sender] = safeSub(accounts[msg.sender],_value)

IRs:
REF_74(uint256) -> accounts[msg.sender]
REF_75(uint256) -> accounts[msg.sender]
TMP_159(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_75,_value)
REF_74(uint256) (->accounts) := TMP_159(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokensCount = safeSub(tokensCount,_value)

IRs:
TMP_160(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(tokensCount,_value)
tokensCount(uint256) := TMP_160(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,address(0),_value)

IRs:
TMP_161 = CONVERT 0 to address
Emit Transfer(msg.sender,TMP_161,_value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
12->1;
}
// Function: 7066.sol-EURSToken-calculateFee(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amount <= MAX_TOKENS_COUNT)

IRs:
TMP_188(bool) = _amount <= MAX_TOKENS_COUNT
TMP_189(None) = SOLIDITY_CALL require(bool)(TMP_188)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_fee = safeMul(_amount,variableFeeNumerator) / FEE_DENOMINATOR

IRs:
TMP_190(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(_amount,variableFeeNumerator)
TMP_191(uint256) = TMP_190 / FEE_DENOMINATOR
_fee(uint256) := TMP_191(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_fee < minVariableFee

IRs:
TMP_192(bool) = _fee < minVariableFee
CONDITION TMP_192"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_fee = minVariableFee

IRs:
_fee(uint256) := minVariableFee(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
_fee > maxVariableFee

IRs:
TMP_193(bool) = _fee > maxVariableFee
CONDITION TMP_193"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_fee = maxVariableFee

IRs:
_fee(uint256) := maxVariableFee(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_fee = safeAdd(_fee,fixedFee)

IRs:
TMP_194(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(_fee,fixedFee)
_fee(uint256) := TMP_194(uint256)"];
9->11;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
10->1;
11[label="Node Type: RETURN 11

EXPRESSION:
_fee

IRs:
RETURN _fee"];
}
// Function: 7066.sol-EURSToken-createTokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_145(bool) = msg.sender == owner
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_value > 0

IRs:
TMP_147(bool) = _value > 0
CONDITION TMP_147"];
2->3[label="True"];
2->10[label="False"];
3[label="Node Type: IF 3

EXPRESSION:
_value <= safeSub(MAX_TOKENS_COUNT,tokensCount)

IRs:
TMP_148(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(MAX_TOKENS_COUNT,tokensCount)
TMP_149(bool) = _value <= TMP_148
CONDITION TMP_149"];
3->4[label="True"];
3->8[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
accounts[msg.sender] = safeAdd(accounts[msg.sender],_value)

IRs:
REF_71(uint256) -> accounts[msg.sender]
REF_72(uint256) -> accounts[msg.sender]
TMP_150(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_72,_value)
REF_71(uint256) (->accounts) := TMP_150(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokensCount = safeAdd(tokensCount,_value)

IRs:
TMP_151(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokensCount,_value)
tokensCount(uint256) := TMP_151(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(address(0),msg.sender,_value)

IRs:
TMP_152 = CONVERT 0 to address
Emit Transfer(TMP_152,msg.sender,_value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
12->1;
}
// Function: 7066.sol-EURSToken-decimals()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
2

IRs:
RETURN 2"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
}
// Function: 7066.sol-EURSToken-delegatable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
delegate == address(0)

IRs:
TMP_205 = CONVERT 0 to address
TMP_206(bool) = delegate == TMP_205
CONDITION TMP_206"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value == 0)

IRs:
TMP_207(bool) = msg.value == 0
TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207)"];
2->3;
3[label="Node Type: _ 3
"];
3->6;
4[label="Node Type: INLINE ASM 4
"];
4->5;
5[label="Node Type: END INLINE ASM 5
"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 7066.sol-EURSToken-delegatedTransfer(address,uint256,uint256,uint256,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->34;
1[label="Node Type: IF 1

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_from = ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(thisAddress(),messageSenderAddress(),_to,_value,_fee,_nonce),_v,_r,_s)

IRs:
TMP_119(address) = INTERNAL_CALL, EURSToken.thisAddress()()
TMP_120(address) = INTERNAL_CALL, EURSToken.messageSenderAddress()()
TMP_121(bytes32) = SOLIDITY_CALL keccak256()(TMP_119,TMP_120,_to,_value,_fee,_nonce)
TMP_122(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_121,_v,_r,_s)
_from(address) := TMP_122(address)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_nonce != nonces[_from]

IRs:
REF_57(uint256) -> nonces[_from]
TMP_123(bool) = _nonce != REF_57
CONDITION TMP_123"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
(addressFlags[_from] | addressFlags[_to]) & BLACK_LIST_FLAG == BLACK_LIST_FLAG

IRs:
REF_58(uint256) -> addressFlags[_from]
REF_59(uint256) -> addressFlags[_to]
TMP_124(uint256) = REF_58 | REF_59
TMP_125(uint256) = TMP_124 & BLACK_LIST_FLAG
TMP_126(bool) = TMP_125 == BLACK_LIST_FLAG
CONDITION TMP_126"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->35;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
balance = accounts[_from]

IRs:
REF_60(uint256) -> accounts[_from]
balance(uint256) := REF_60(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
_value > balance

IRs:
TMP_127(bool) = _value > balance
CONDITION TMP_127"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: RETURN 13

EXPRESSION:
false

IRs:
RETURN False"];
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
balance = safeSub(balance,_value)

IRs:
TMP_128(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(balance,_value)
balance(uint256) := TMP_128(uint256)"];
15->16;
16[label="Node Type: IF 16

EXPRESSION:
fee > balance

IRs:
TMP_129(bool) = fee > balance
CONDITION TMP_129"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: RETURN 17

EXPRESSION:
false

IRs:
RETURN False"];
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
balance = safeSub(balance,fee)

IRs:
TMP_130(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(balance,fee)
balance(uint256) := TMP_130(uint256)"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
_fee > balance

IRs:
TMP_131(bool) = _fee > balance
CONDITION TMP_131"];
20->21[label="True"];
20->22[label="False"];
21[label="Node Type: RETURN 21

EXPRESSION:
false

IRs:
RETURN False"];
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
balance = safeSub(balance,_fee)

IRs:
TMP_132(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(balance,_fee)
balance(uint256) := TMP_132(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
nonces[_from] = _nonce + 1

IRs:
REF_61(uint256) -> nonces[_from]
TMP_133(uint256) = _nonce + 1
REF_61(uint256) (->nonces) := TMP_133(uint256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
accounts[_from] = balance

IRs:
REF_62(uint256) -> accounts[_from]
REF_62(uint256) (->accounts) := balance(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
accounts[_to] = safeAdd(accounts[_to],_value)

IRs:
REF_63(uint256) -> accounts[_to]
REF_64(uint256) -> accounts[_to]
TMP_134(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_64,_value)
REF_63(uint256) (->accounts) := TMP_134(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
accounts[feeCollector] = safeAdd(accounts[feeCollector],fee)

IRs:
REF_65(uint256) -> accounts[feeCollector]
REF_66(uint256) -> accounts[feeCollector]
TMP_135(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_66,fee)
REF_65(uint256) (->accounts) := TMP_135(uint256)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
accounts[msg.sender] = safeAdd(accounts[msg.sender],_fee)

IRs:
REF_67(uint256) -> accounts[msg.sender]
REF_68(uint256) -> accounts[msg.sender]
TMP_136(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_68,_fee)
REF_67(uint256) (->accounts) := TMP_136(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
29->30;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
Transfer(_from,feeCollector,fee)

IRs:
Emit Transfer(_from,feeCollector,fee)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
Transfer(_from,msg.sender,_fee)

IRs:
Emit Transfer(_from,msg.sender,_fee)"];
31->32;
32[label="Node Type: RETURN 32

EXPRESSION:
true

IRs:
RETURN True"];
34[label="Node Type: EXPRESSION 34

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
34->1;
35[label="Node Type: IF 35

EXPRESSION:
(addressFlags[_from] | addressFlags[_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG

IRs:
REF_69(uint256) -> addressFlags[_from]
REF_70(uint256) -> addressFlags[_to]
TMP_141(uint256) = REF_69 | REF_70
TMP_142(uint256) = TMP_141 & ZERO_FEE_FLAG
TMP_143(bool) = TMP_142 == ZERO_FEE_FLAG
CONDITION TMP_143"];
35->36[label="True"];
35->37[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
fee = 0

IRs:
fee(uint256) := 0(uint256)"];
36->38;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
fee = calculateFee(_value)

IRs:
TMP_144(uint256) = INTERNAL_CALL, EURSToken.calculateFee(uint256)(_value)
fee(uint256) := TMP_144(uint256)"];
37->38;
38[label="Node Type: END_IF 38
"];
38->11;
}
// Function: 7066.sol-EURSToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_70(None) = SOLIDITY_CALL revert()()"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
}
// Function: 7066.sol-EURSToken-flags(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
addressFlags[_address]

IRs:
REF_78(uint256) -> addressFlags[_address]
RETURN REF_78"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
}
// Function: 7066.sol-EURSToken-freezeTransfers()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_164(bool) = msg.sender == owner
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! frozen

IRs:
TMP_166 = UnaryType.BANG frozen 
CONDITION TMP_166"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Freeze()

IRs:
Emit Freeze()"];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
6->1;
}
// Function: 7066.sol-EURSToken-getFeeParameters()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_fixedFee = fixedFee

IRs:
_fixedFee(uint256) := fixedFee(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_minVariableFee = minVariableFee

IRs:
_minVariableFee(uint256) := minVariableFee(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_maxVariableFee = maxVariableFee

IRs:
_maxVariableFee(uint256) := maxVariableFee(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_variableFeeNumnerator = variableFeeNumerator

IRs:
_variableFeeNumnerator(uint256) := variableFeeNumerator(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
(_fixedFee,_minVariableFee,_maxVariableFee,_variableFeeNumnerator)

IRs:
RETURN _fixedFee,_minVariableFee,_maxVariableFee,_variableFeeNumnerator"];
}
// Function: 7066.sol-EURSToken-messageSenderAddress()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 7066.sol-EURSToken-name()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
STASIS EURS Token

IRs:
RETURN STASIS EURS Token"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
}
// Function: 7066.sol-EURSToken-nonce(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
nonces[_owner]

IRs:
REF_76(uint256) -> nonces[_owner]
RETURN REF_76"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
}
// Function: 7066.sol-EURSToken-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x <= MAX_UINT256 - y)

IRs:
TMP_58(uint256) = MAX_UINT256 - y
TMP_59(bool) = x <= TMP_58
TMP_60(None) = SOLIDITY_CALL assert(bool)(TMP_59)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x + y

IRs:
TMP_61(uint256) = x + y
RETURN TMP_61"];
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-EURSToken-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
y == 0

IRs:
TMP_65(bool) = y == 0
CONDITION TMP_65"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(x <= MAX_UINT256 / y)

IRs:
TMP_66(uint256) = MAX_UINT256 / y
TMP_67(bool) = x <= TMP_66
TMP_68(None) = SOLIDITY_CALL assert(bool)(TMP_67)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
x * y

IRs:
TMP_69(uint256) = x * y
RETURN TMP_69"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-EURSToken-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_62(bool) = x >= y
TMP_63(None) = SOLIDITY_CALL assert(bool)(TMP_62)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_64(uint256) = x - y
RETURN TMP_64"];
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-EURSToken-setDelegate(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_200(bool) = msg.sender == owner
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
delegate != _delegate

IRs:
TMP_202(bool) = delegate != _delegate
CONDITION TMP_202"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delegate = _delegate

IRs:
delegate(address) := _delegate(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Delegation(delegate)

IRs:
Emit Delegation(delegate)"];
4->5;
5[label="Node Type: END_IF 5
"];
}
// Function: 7066.sol-EURSToken-setFeeCollector(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_175(bool) = msg.sender == owner
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feeCollector = _newFeeCollector

IRs:
feeCollector(address) := _newFeeCollector(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
3->1;
}
// Function: 7066.sol-EURSToken-setFeeParameters(uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_179(bool) = msg.sender == owner
TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_minVariableFee <= _maxVariableFee)

IRs:
TMP_181(bool) = _minVariableFee <= _maxVariableFee
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_variableFeeNumerator <= MAX_FEE_NUMERATOR)

IRs:
TMP_183(bool) = _variableFeeNumerator <= MAX_FEE_NUMERATOR
TMP_184(None) = SOLIDITY_CALL require(bool)(TMP_183)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
fixedFee = _fixedFee

IRs:
fixedFee(uint256) := _fixedFee(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
minVariableFee = _minVariableFee

IRs:
minVariableFee(uint256) := _minVariableFee(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
maxVariableFee = _maxVariableFee

IRs:
maxVariableFee(uint256) := _maxVariableFee(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
variableFeeNumerator = _variableFeeNumerator

IRs:
variableFeeNumerator(uint256) := _variableFeeNumerator(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
FeeChange(_fixedFee,_minVariableFee,_maxVariableFee,_variableFeeNumerator)

IRs:
Emit FeeChange(_fixedFee,_minVariableFee,_maxVariableFee,_variableFeeNumerator)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
9->1;
}
// Function: 7066.sol-EURSToken-setFlags(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_196(bool) = msg.sender == owner
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
addressFlags[_address] = _flags

IRs:
REF_77(uint256) -> addressFlags[_address]
REF_77(uint256) (->addressFlags) := _flags(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
3->1;
}
// Function: 7066.sol-EURSToken-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_173(bool) = msg.sender == owner
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 7066.sol-EURSToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
FEE_DENOMINATOR = 100000

IRs:
FEE_DENOMINATOR(uint256) := 100000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
MAX_FEE_NUMERATOR = FEE_DENOMINATOR

IRs:
MAX_FEE_NUMERATOR(uint256) := FEE_DENOMINATOR(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
MIN_FEE_NUMERATIOR = 0

IRs:
MIN_FEE_NUMERATIOR(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
MAX_TOKENS_COUNT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / MAX_FEE_NUMERATOR

IRs:
TMP_204(uint256) = 115792089237316195423570985008687907853269984665640564039457584007913129639935 / MAX_FEE_NUMERATOR
MAX_TOKENS_COUNT(uint256) := TMP_204(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
DEFAULT_FEE = 5e2

IRs:
DEFAULT_FEE(uint256) := 500(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
BLACK_LIST_FLAG = 0x01

IRs:
BLACK_LIST_FLAG(uint256) := 1(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
ZERO_FEE_FLAG = 0x02

IRs:
ZERO_FEE_FLAG(uint256) := 2(uint256)"];
}
// Function: 7066.sol-EURSToken-symbol()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
EURS

IRs:
RETURN EURS"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
}
// Function: 7066.sol-EURSToken-thisAddress()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
this

IRs:
RETURN this"];
}
// Function: 7066.sol-EURSToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
tokensCount

IRs:
RETURN tokensCount"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
2->1;
}
// Function: 7066.sol-EURSToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: IF 1

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: IF 3

EXPRESSION:
(addressFlags[msg.sender] | addressFlags[_to]) & BLACK_LIST_FLAG == BLACK_LIST_FLAG

IRs:
REF_35(uint256) -> addressFlags[msg.sender]
REF_36(uint256) -> addressFlags[_to]
TMP_78(uint256) = REF_35 | REF_36
TMP_79(uint256) = TMP_78 & BLACK_LIST_FLAG
TMP_80(bool) = TMP_79 == BLACK_LIST_FLAG
CONDITION TMP_80"];
3->4[label="True"];
3->15[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
6[label="Node Type: IF 6

EXPRESSION:
_value <= accounts[msg.sender] && fee <= safeSub(accounts[msg.sender],_value)

IRs:
REF_37(uint256) -> accounts[msg.sender]
TMP_81(bool) = _value <= REF_37
REF_38(uint256) -> accounts[msg.sender]
TMP_82(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_38,_value)
TMP_83(bool) = fee <= TMP_82
TMP_84(bool) = TMP_81 && TMP_83
CONDITION TMP_84"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(AbstractToken.transfer(_to,_value))

IRs:
TMP_85(bool) = INTERNAL_CALL, AbstractToken.transfer(address,uint256)(_to,_value)
TMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(AbstractToken.transfer(feeCollector,fee))

IRs:
TMP_87(bool) = INTERNAL_CALL, AbstractToken.transfer(address,uint256)(feeCollector,fee)
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
14->1;
15[label="Node Type: IF 15

EXPRESSION:
(addressFlags[msg.sender] | addressFlags[_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG

IRs:
REF_41(uint256) -> addressFlags[msg.sender]
REF_42(uint256) -> addressFlags[_to]
TMP_90(uint256) = REF_41 | REF_42
TMP_91(uint256) = TMP_90 & ZERO_FEE_FLAG
TMP_92(bool) = TMP_91 == ZERO_FEE_FLAG
CONDITION TMP_92"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
fee = 0

IRs:
fee(uint256) := 0(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
fee = calculateFee(_value)

IRs:
TMP_93(uint256) = INTERNAL_CALL, EURSToken.calculateFee(uint256)(_value)
fee(uint256) := TMP_93(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->6;
}
// Function: 7066.sol-EURSToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: IF 1

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: IF 3

EXPRESSION:
(addressFlags[_from] | addressFlags[_to]) & BLACK_LIST_FLAG == BLACK_LIST_FLAG

IRs:
REF_43(uint256) -> addressFlags[_from]
REF_44(uint256) -> addressFlags[_to]
TMP_94(uint256) = REF_43 | REF_44
TMP_95(uint256) = TMP_94 & BLACK_LIST_FLAG
TMP_96(bool) = TMP_95 == BLACK_LIST_FLAG
CONDITION TMP_96"];
3->4[label="True"];
3->15[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
6[label="Node Type: IF 6

EXPRESSION:
_value <= allowances[_from][msg.sender] && fee <= safeSub(allowances[_from][msg.sender],_value) && _value <= accounts[_from] && fee <= safeSub(accounts[_from],_value)

IRs:
REF_45(mapping(address => uint256)) -> allowances[_from]
REF_46(uint256) -> REF_45[msg.sender]
TMP_97(bool) = _value <= REF_46
REF_47(mapping(address => uint256)) -> allowances[_from]
REF_48(uint256) -> REF_47[msg.sender]
TMP_98(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_48,_value)
TMP_99(bool) = fee <= TMP_98
TMP_100(bool) = TMP_97 && TMP_99
REF_49(uint256) -> accounts[_from]
TMP_101(bool) = _value <= REF_49
TMP_102(bool) = TMP_100 && TMP_101
REF_50(uint256) -> accounts[_from]
TMP_103(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_50,_value)
TMP_104(bool) = fee <= TMP_103
TMP_105(bool) = TMP_102 && TMP_104
CONDITION TMP_105"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(AbstractToken.transferFrom(_from,_to,_value))

IRs:
TMP_106(bool) = INTERNAL_CALL, AbstractToken.transferFrom(address,address,uint256)(_from,_to,_value)
TMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(AbstractToken.transferFrom(_from,feeCollector,fee))

IRs:
TMP_108(bool) = INTERNAL_CALL, AbstractToken.transferFrom(address,address,uint256)(_from,feeCollector,fee)
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
14->1;
15[label="Node Type: IF 15

EXPRESSION:
(addressFlags[_from] | addressFlags[_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG

IRs:
REF_53(uint256) -> addressFlags[_from]
REF_54(uint256) -> addressFlags[_to]
TMP_111(uint256) = REF_53 | REF_54
TMP_112(uint256) = TMP_111 & ZERO_FEE_FLAG
TMP_113(bool) = TMP_112 == ZERO_FEE_FLAG
CONDITION TMP_113"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
fee = 0

IRs:
fee(uint256) := 0(uint256)"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
fee = calculateFee(_value)

IRs:
TMP_114(uint256) = INTERNAL_CALL, EURSToken.calculateFee(uint256)(_value)
fee(uint256) := TMP_114(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->6;
}
// Function: 7066.sol-EURSToken-unfreezeTransfers()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_169(bool) = msg.sender == owner
TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Unfreeze()

IRs:
Emit Unfreeze()"];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
delegatable()

IRs:
MODIFIER_CALL, EURSToken.delegatable()()"];
6->1;
}
// Function: 7066.sol-SafeMath-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x <= MAX_UINT256 - y)

IRs:
TMP_0(uint256) = MAX_UINT256 - y
TMP_1(bool) = x <= TMP_0
TMP_2(None) = SOLIDITY_CALL assert(bool)(TMP_1)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x + y

IRs:
TMP_3(uint256) = x + y
RETURN TMP_3"];
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-SafeMath-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
y == 0

IRs:
TMP_7(bool) = y == 0
CONDITION TMP_7"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(x <= MAX_UINT256 / y)

IRs:
TMP_8(uint256) = MAX_UINT256 / y
TMP_9(bool) = x <= TMP_8
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
x * y

IRs:
TMP_11(uint256) = x * y
RETURN TMP_11"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-SafeMath-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(x >= y)

IRs:
TMP_4(bool) = x >= y
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x - y

IRs:
TMP_6(uint256) = x - y
RETURN TMP_6"];
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7066.sol-SafeMath-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

IRs:
MAX_UINT256(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)"];
}
// Function: 7066.sol-Token-allowance(address,address)
digraph{
}
// Function: 7066.sol-Token-approve(address,uint256)
digraph{
}
// Function: 7066.sol-Token-balanceOf(address)
digraph{
}
// Function: 7066.sol-Token-totalSupply()
digraph{
}
// Function: 7066.sol-Token-transfer(address,uint256)
digraph{
}
// Function: 7066.sol-Token-transferFrom(address,address,uint256)
digraph{
}
}
