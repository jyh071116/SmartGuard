digraph G {
// Function: 1155.sol-ERC223Receiving-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 1155.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_278(uint256) = a + b
c(uint256) := TMP_278(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_279(bool) = c >= a
TMP_280(None) = SOLIDITY_CALL assert(bool)(TMP_279)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1155.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_274(uint256) = a / b
c(uint256) := TMP_274(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1155.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_269(bool) = a == 0
CONDITION TMP_269"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_270(uint256) = a * b
c(uint256) := TMP_270(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_271(uint256) = c / a
TMP_272(bool) = TMP_271 == b
TMP_273(None) = SOLIDITY_CALL assert(bool)(TMP_272)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1155.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_275(bool) = b <= a
TMP_276(None) = SOLIDITY_CALL assert(bool)(TMP_275)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_277(uint256) = a - b
RETURN TMP_277"];
}
// Function: 1155.sol-ZTHInterface-balanceOf(address)
digraph{
}
// Function: 1155.sol-ZTHInterface-buyAndSetDivPercentage(address,uint8,string)
digraph{
}
// Function: 1155.sol-ZTHInterface-exit()
digraph{
}
// Function: 1155.sol-ZTHInterface-sell(uint256)
digraph{
}
// Function: 1155.sol-ZTHInterface-transfer(address,uint256)
digraph{
}
// Function: 1155.sol-ZTHInterface-transferFrom(address,address,uint256)
digraph{
}
// Function: 1155.sol-ZTHInterface-withdraw(address)
digraph{
}
// Function: 1155.sol-ZethrBankroll-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_16(bool) -> isOwner[owner]
REF_16(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_18 -> LENGTH owners
TMP_33(uint256) := REF_18(uint256)
TMP_34(uint256) = TMP_33 + 1
REF_18(uint256) (->owners) := TMP_34(uint256)
REF_19(address) -> owners[TMP_33]
REF_19(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, ZethrBankroll.onlyWallet()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, ZethrBankroll.ownerDoesNotExist(address)(owner)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notNull(owner)

IRs:
MODIFIER_CALL, ZethrBankroll.notNull(address)(owner)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
validRequirement(owners.length + 1,required)

IRs:
REF_20 -> LENGTH owners
TMP_39(uint256) = REF_20 + 1
MODIFIER_CALL, ZethrBankroll.validRequirement(uint256,uint256)(TMP_39,required)"];
7->1;
}
// Function: 1155.sol-ZethrBankroll-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = transactionCount

IRs:
transactionId(uint256) := transactionCount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId] = Transaction({destination:destination,value:value,data:data,executed:false})

IRs:
REF_53(ZethrBankroll.Transaction) -> transactions[transactionId]
TMP_83(ZethrBankroll.Transaction) = new Transaction(destination,value,data,False)
REF_53(ZethrBankroll.Transaction) (->transactions) := TMP_83(ZethrBankroll.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactionCount += 1

IRs:
transactionCount(uint256) = transactionCount + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, ZethrBankroll.notNull(address)(destination)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 1155.sol-ZethrBankroll-addZethrAddresses(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
zethrAddress = _zethr

IRs:
zethrAddress(address) := _zethr(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
divCardAddress = _divcards

IRs:
divCardAddress(address) := _divcards(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ZTHTKN = ZTHInterface(zethrAddress)

IRs:
TMP_7 = CONVERT zethrAddress to ZTHInterface
ZTHTKN(ZTHInterface) := TMP_7(ZTHInterface)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
4->1;
}
// Function: 1155.sol-ZethrBankroll-allocateTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
dailyAmount = dailyTokensPerContract[_contract]

IRs:
REF_98(uint256) -> dailyTokensPerContract[_contract]
dailyAmount(uint256) := REF_98(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
zthPresent = ZTHTKN.balanceOf(_contract)

IRs:
TMP_148(uint256) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:balanceOf, arguments:['_contract']  
zthPresent(uint256) := TMP_148(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
zthPresent <= dailyAmount

IRs:
TMP_149(bool) = zthPresent <= dailyAmount
CONDITION TMP_149"];
3->4[label="True"];
3->8[label="False"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
toDispense = dailyAmount.sub(zthPresent)

IRs:
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dailyAmount', 'zthPresent'] 
toDispense(uint256) := TMP_150(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(permissibleTokenWithdrawal(toDispense))

IRs:
TMP_151(bool) = INTERNAL_CALL, ZethrBankroll.permissibleTokenWithdrawal(uint256)(toDispense)
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(ZTHTKN.transfer(_contract,toDispense))

IRs:
TMP_153(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:transfer, arguments:['_contract', 'toDispense']  
TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
DailyTokensSent(_contract,toDispense)

IRs:
Emit DailyTokensSent(_contract,toDispense)"];
7->11;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
toRetrieve = zthPresent.sub(dailyAmount)

IRs:
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['zthPresent', 'dailyAmount'] 
toRetrieve(uint256) := TMP_156(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(ZTHTKN.transferFrom(_contract,address(this),toRetrieve))

IRs:
TMP_157 = CONVERT this to address
TMP_158(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:transferFrom, arguments:['_contract', 'TMP_157', 'toRetrieve']  
TMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
DailyTokensReceived(_contract,toRetrieve)

IRs:
Emit DailyTokensReceived(_contract,toRetrieve)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
DailyTokenAdmin(_contract)

IRs:
Emit DailyTokenAdmin(_contract)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
contractIsWhiteListed(_contract)

IRs:
MODIFIER_CALL, ZethrBankroll.contractIsWhiteListed(address)(_contract)"];
14->1;
}
// Function: 1155.sol-ZethrBankroll-alterTokenGrant(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
dailyTokensPerContract[_contract] = _newAmount

IRs:
REF_92(uint256) -> dailyTokensPerContract[_contract]
REF_92(uint256) (->dailyTokensPerContract) := _newAmount(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
contractIsWhiteListed(_contract)

IRs:
MODIFIER_CALL, ZethrBankroll.contractIsWhiteListed(address)(_contract)"];
3->1;
}
// Function: 1155.sol-ZethrBankroll-buyInWithAllBalanced()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: IF 1

EXPRESSION:
! reEntered

IRs:
TMP_182 = UnaryType.BANG reEntered 
CONDITION TMP_182"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
balance = address(this).balance

IRs:
TMP_183 = CONVERT this to address
TMP_184(uint256) = SOLIDITY_CALL balance(address)(TMP_183)
balance(uint256) := TMP_184(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balance > 10000000000000000)

IRs:
TMP_185(bool) = balance > 10000000000000000
TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ZTHTKN.buyAndSetDivPercentage.value(balance)(address(0x0),33,)

IRs:
TMP_188 = CONVERT 0 to address
TMP_189(uint256) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:buyAndSetDivPercentage, arguments:['TMP_188', '33', ''] value:balance "];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
6->1;
}
// Function: 1155.sol-ZethrBankroll-buyTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
savings = address(this).balance

IRs:
TMP_10 = CONVERT this to address
TMP_11(uint256) = SOLIDITY_CALL balance(address)(TMP_10)
savings(uint256) := TMP_11(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
savings > 10000000000000000

IRs:
TMP_12(bool) = savings > 10000000000000000
CONDITION TMP_12"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ZTHTKN.buyAndSetDivPercentage.value(savings)(address(0x0),33,)

IRs:
TMP_14 = CONVERT 0 to address
TMP_15(uint256) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:buyAndSetDivPercentage, arguments:['TMP_14', '33', ''] value:savings "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
BankrollInvest(savings)

IRs:
Emit BankrollInvest(savings)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
EtherLogged(msg.value,msg.sender)

IRs:
Emit EtherLogged(msg.value,msg.sender)"];
5->6;
6[label="Node Type: END_IF 6
"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
7->1;
}
// Function: 1155.sol-ZethrBankroll-changeDivCardAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
divCardAddress = _newDivCardAddress

IRs:
divCardAddress(address) := _newDivCardAddress(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
2->1;
}
// Function: 1155.sol-ZethrBankroll-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, ZethrBankroll.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_36 -> LENGTH owners
MODIFIER_CALL, ZethrBankroll.validRequirement(uint256,uint256)(REF_36,_required)"];
4->1;
}
// Function: 1155.sol-ZethrBankroll-confirmTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_37(mapping(address => bool)) -> confirmations[transactionId]
REF_38(bool) -> REF_37[msg.sender]
REF_38(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, ZethrBankroll.executeTransaction(uint256)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, ZethrBankroll.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transactionExists(transactionId)

IRs:
MODIFIER_CALL, ZethrBankroll.transactionExists(uint256)(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, ZethrBankroll.notConfirmed(uint256,address)(transactionId,msg.sender)"];
6->1;
}
// Function: 1155.sol-ZethrBankroll-confirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! confirmations[transactionId][owner]

IRs:
REF_127(mapping(address => bool)) -> confirmations[transactionId]
REF_128(bool) -> REF_127[owner]
TMP_255 = UnaryType.BANG REF_128 
CONDITION TMP_255"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_256(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-constructor(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_0 -> LENGTH _owners
TMP_0(bool) = i < REF_0
CONDITION TMP_0"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
isOwner[_owners[i]] || _owners[i] == 0

IRs:
REF_1(address) -> _owners[i]
REF_2(bool) -> isOwner[REF_1]
REF_3(address) -> _owners[i]
TMP_1(bool) = REF_3 == 0
TMP_2(bool) = REF_2 || TMP_1
CONDITION TMP_2"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_3(None) = SOLIDITY_CALL revert()()"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_4(address) -> _owners[i]
REF_5(bool) -> isOwner[REF_4]
REF_5(bool) (->isOwner) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_4(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
dailyResetTime = now - (86400)

IRs:
TMP_5(uint256) = now - 86400
dailyResetTime(uint256) := TMP_5(uint256)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_6 -> LENGTH _owners
MODIFIER_CALL, ZethrBankroll.validRequirement(uint256,uint256)(REF_6,_required)"];
13->3;
}
// Function: 1155.sol-ZethrBankroll-contractIsNotWhiteListed(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isWhitelisted[contractAddress]

IRs:
REF_120(bool) -> isWhitelisted[contractAddress]
CONDITION REF_120"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_245(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-contractIsWhiteListed(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isWhitelisted[contractAddress]

IRs:
REF_121(bool) -> isWhitelisted[contractAddress]
TMP_246 = UnaryType.BANG REF_121 
CONDITION TMP_246"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_247(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-contractTokenWithdraw(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isWhitelisted[msg.sender])

IRs:
REF_90(bool) -> isWhitelisted[msg.sender]
TMP_131(None) = SOLIDITY_CALL require(bool)(REF_90)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ZTHTKN.transfer(target,amount))

IRs:
TMP_132(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:transfer, arguments:['target', 'amount']  
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
contractIsWhiteListed(msg.sender)

IRs:
MODIFIER_CALL, ZethrBankroll.contractIsWhiteListed(address)(msg.sender)"];
3->1;
}
// Function: 1155.sol-ZethrBankroll-dailyAccounting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < whiteListedContracts.length

IRs:
REF_94 -> LENGTH whiteListedContracts
TMP_137(bool) = i < REF_94
CONDITION TMP_137"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_contract = whiteListedContracts[i]

IRs:
REF_95(address) -> whiteListedContracts[i]
_contract(address) := REF_95(address)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
dailyTokensPerContract[_contract] > 0

IRs:
REF_96(uint256) -> dailyTokensPerContract[_contract]
TMP_138(bool) = REF_96 > 0
CONDITION TMP_138"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
allocateTokens(_contract)

IRs:
INTERNAL_CALL, ZethrBankroll.allocateTokens(address)(_contract)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
DailyTokenAdmin(_contract)

IRs:
Emit DailyTokenAdmin(_contract)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_141(uint256) := i(uint256)
i(uint256) = i + 1"];
10->4;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
11->3;
}
// Function: 1155.sol-ZethrBankroll-deWhiteListContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isWhitelisted[contractAddress] = false

IRs:
REF_83(bool) -> isWhitelisted[contractAddress]
REF_83(bool) (->isWhitelisted) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < whiteListedContracts.length - 1

IRs:
REF_84 -> LENGTH whiteListedContracts
TMP_123(uint256) = REF_84 - 1
TMP_124(bool) = i < TMP_123
CONDITION TMP_124"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
whiteListedContracts[i] == contractAddress

IRs:
REF_85(address) -> whiteListedContracts[i]
TMP_125(bool) = REF_85 == contractAddress
CONDITION TMP_125"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
whiteListedContracts[i] = owners[whiteListedContracts.length - 1]

IRs:
REF_86(address) -> whiteListedContracts[i]
REF_87 -> LENGTH whiteListedContracts
TMP_126(uint256) = REF_87 - 1
REF_88(address) -> owners[TMP_126]
REF_86(address) (->whiteListedContracts) := REF_88(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_127(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
whiteListedContracts.length -= 1

IRs:
REF_89 -> LENGTH whiteListedContracts
REF_89(-> whiteListedContracts) = REF_89 - 1"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
WhiteListRemoval(contractAddress)

IRs:
Emit WhiteListRemoval(contractAddress)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
contractIsWhiteListed(contractAddress)

IRs:
MODIFIER_CALL, ZethrBankroll.contractIsWhiteListed(address)(contractAddress)"];
14->1;
}
// Function: 1155.sol-ZethrBankroll-deposit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
NonICOBuyins = NonICOBuyins.add(msg.value)

IRs:
TMP_9(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['NonICOBuyins', 'msg.value'] 
NonICOBuyins(uint256) := TMP_9(uint256)"];
}
// Function: 1155.sol-ZethrBankroll-devTokenWithdraw(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(permissibleTokenWithdrawal(amount))

IRs:
TMP_164(bool) = INTERNAL_CALL, ZethrBankroll.permissibleTokenWithdrawal(uint256)(amount)
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
amountPerPerson = SafeMath.div(amount,owners.length)

IRs:
REF_105 -> LENGTH owners
TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['amount', 'REF_105'] 
amountPerPerson(uint256) := TMP_166(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->9;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < owners.length

IRs:
REF_106 -> LENGTH owners
TMP_167(bool) = i < REF_106
CONDITION TMP_167"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ZTHTKN.transfer(owners[i],amountPerPerson)

IRs:
REF_108(address) -> owners[i]
TMP_168(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:transfer, arguments:['REF_108', 'amountPerPerson']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_169(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
DevWithdraw(amount,amountPerPerson)

IRs:
Emit DevWithdraw(amount,amountPerPerson)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, ZethrBankroll.onlyWallet()()"];
10->1;
}
// Function: 1155.sol-ZethrBankroll-executeTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_74(bool) = INTERNAL_CALL, ZethrBankroll.isConfirmed(uint256)(transactionId)
CONDITION TMP_74"];
1->2[label="True"];
1->9[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
txToExecute = transactions[transactionId]

IRs:
REF_41(ZethrBankroll.Transaction) -> transactions[transactionId]
txToExecute(ZethrBankroll.Transaction) := REF_41(ZethrBankroll.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
txToExecute.executed = true

IRs:
REF_42(bool) -> txToExecute.executed
REF_42(bool) (->txToExecute) := True(bool)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
txToExecute.destination.call.value(txToExecute.value)(txToExecute.data)

IRs:
REF_43(address) -> txToExecute.destination
REF_46(uint256) -> txToExecute.value
REF_47(bytes) -> txToExecute.data
TMP_76(bool) = LOW_LEVEL_CALL, dest:REF_43, function:call, arguments:['REF_47'] value:REF_46 
CONDITION TMP_76"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)"];
5->8;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
txToExecute.executed = false

IRs:
REF_48(bool) -> txToExecute.executed
REF_48(bool) (->txToExecute) := False(bool)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, ZethrBankroll.notExecuted(uint256)(transactionId)"];
10->1;
}
// Function: 1155.sol-ZethrBankroll-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1155.sol-ZethrBankroll-fromHex(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
ss = bytes(s)

IRs:
TMP_223 = CONVERT s to bytes
ss(bytes) := TMP_223(bytes)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ss.length % 2 == 0)

IRs:
REF_114 -> LENGTH ss
TMP_224(uint256) = REF_114 % 2
TMP_225(bool) = TMP_224 == 0
TMP_226(None) = SOLIDITY_CALL require(bool)(TMP_225)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
r = new bytes(ss.length / 2)

IRs:
REF_115 -> LENGTH ss
TMP_228(uint256) = REF_115 / 2
TMP_229 = new bytes(TMP_228)
r(bytes) := TMP_229(bytes)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->10;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < ss.length / 2

IRs:
REF_116 -> LENGTH ss
TMP_230(uint256) = REF_116 / 2
TMP_231(bool) = i < TMP_230
CONDITION TMP_231"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
r[i] = bytes1(fromHexChar(uint256(ss[2 * i])) * 16 + fromHexChar(uint256(ss[2 * i + 1])))

IRs:
REF_117(bytes1) -> r[i]
TMP_232(uint256) = 2 * i
REF_118(None) -> ss[TMP_232]
TMP_233 = CONVERT REF_118 to uint256
TMP_234(uint256) = INTERNAL_CALL, ZethrBankroll.fromHexChar(uint256)(TMP_233)
TMP_235(uint256) = TMP_234 * 16
TMP_236(uint256) = 2 * i
TMP_237(uint256) = TMP_236 + 1
REF_119(None) -> ss[TMP_237]
TMP_238 = CONVERT REF_119 to uint256
TMP_239(uint256) = INTERNAL_CALL, ZethrBankroll.fromHexChar(uint256)(TMP_238)
TMP_240(uint256) = TMP_235 + TMP_239
TMP_241 = CONVERT TMP_240 to bytes1
REF_117(bytes1) (->r) := TMP_241(bytes1)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
9->7;
10[label="Node Type: RETURN 10

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 1155.sol-ZethrBankroll-fromHexChar(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
bytes1(c) >= bytes1(0) && bytes1(c) <= bytes1(9)

IRs:
TMP_191 = CONVERT c to bytes1
TMP_192 = CONVERT 0 to bytes1
TMP_193(bool) = TMP_191 >= TMP_192
TMP_194 = CONVERT c to bytes1
TMP_195 = CONVERT 9 to bytes1
TMP_196(bool) = TMP_194 <= TMP_195
TMP_197(bool) = TMP_193 && TMP_196
CONDITION TMP_197"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
c - uint256(bytes1(0))

IRs:
TMP_198 = CONVERT 0 to bytes1
TMP_199 = CONVERT TMP_198 to uint256
TMP_200(uint256) = c - TMP_199
RETURN TMP_200"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
bytes1(c) >= bytes1(a) && bytes1(c) <= bytes1(f)

IRs:
TMP_201 = CONVERT c to bytes1
TMP_202 = CONVERT a to bytes1
TMP_203(bool) = TMP_201 >= TMP_202
TMP_204 = CONVERT c to bytes1
TMP_205 = CONVERT f to bytes1
TMP_206(bool) = TMP_204 <= TMP_205
TMP_207(bool) = TMP_203 && TMP_206
CONDITION TMP_207"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
10 + c - uint256(bytes1(a))

IRs:
TMP_208(uint256) = 10 + c
TMP_209 = CONVERT a to bytes1
TMP_210 = CONVERT TMP_209 to uint256
TMP_211(uint256) = TMP_208 - TMP_210
RETURN TMP_211"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
bytes1(c) >= bytes1(A) && bytes1(c) <= bytes1(F)

IRs:
TMP_212 = CONVERT c to bytes1
TMP_213 = CONVERT A to bytes1
TMP_214(bool) = TMP_212 >= TMP_213
TMP_215 = CONVERT c to bytes1
TMP_216 = CONVERT F to bytes1
TMP_217(bool) = TMP_215 <= TMP_216
TMP_218(bool) = TMP_214 && TMP_217
CONDITION TMP_218"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
10 + c - uint256(bytes1(A))

IRs:
TMP_219(uint256) = 10 + c
TMP_220 = CONVERT A to bytes1
TMP_221 = CONVERT TMP_220 to uint256
TMP_222(uint256) = TMP_219 - TMP_221
RETURN TMP_222"];
9[label="Node Type: END_IF 9
"];
}
// Function: 1155.sol-ZethrBankroll-getConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_54 -> LENGTH owners
TMP_86(bool) = i < REF_54
CONDITION TMP_86"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_55(mapping(address => bool)) -> confirmations[transactionId]
REF_56(address) -> owners[i]
REF_57(bool) -> REF_55[REF_56]
CONDITION REF_57"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_87(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 1155.sol-ZethrBankroll-getConfirmations(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
confirmationsTemp = new address[](owners.length)

IRs:
REF_62 -> LENGTH owners
TMP_95(address[])  = new address[](REF_62)
confirmationsTemp(address[]) = ['TMP_95(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length

IRs:
REF_63 -> LENGTH owners
TMP_96(bool) = i < REF_63
CONDITION TMP_96"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_64(mapping(address => bool)) -> confirmations[transactionId]
REF_65(address) -> owners[i]
REF_66(bool) -> REF_64[REF_65]
CONDITION REF_66"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
confirmationsTemp[count] = owners[i]

IRs:
REF_67(address) -> confirmationsTemp[count]
REF_68(address) -> owners[i]
REF_67(address) (->confirmationsTemp) := REF_68(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_97(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_confirmations = new address[](count)

IRs:
TMP_99(address[])  = new address[](count)
_confirmations(address[]) = ['TMP_99(address[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < count

IRs:
TMP_100(bool) = i < count
CONDITION TMP_100"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_confirmations[i] = confirmationsTemp[i]

IRs:
REF_69(address) -> _confirmations[i]
REF_70(address) -> confirmationsTemp[i]
REF_69(address) (->_confirmations) := REF_70(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_101(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_confirmations

IRs:
RETURN _confirmations"];
}
// Function: 1155.sol-ZethrBankroll-getOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owners

IRs:
RETURN owners"];
}
// Function: 1155.sol-ZethrBankroll-getTransactionCount(bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < transactionCount

IRs:
TMP_88(bool) = i < transactionCount
CONDITION TMP_88"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_58(ZethrBankroll.Transaction) -> transactions[i]
REF_59(bool) -> REF_58.executed
TMP_89 = UnaryType.BANG REF_59 
TMP_90(bool) = pending && TMP_89
REF_60(ZethrBankroll.Transaction) -> transactions[i]
REF_61(bool) -> REF_60.executed
TMP_91(bool) = executed && REF_61
TMP_92(bool) = TMP_90 || TMP_91
CONDITION TMP_92"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_93(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 1155.sol-ZethrBankroll-getTransactionIds(uint256,uint256,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
transactionIdsTemp = new uint256[](transactionCount)

IRs:
TMP_103(uint256[])  = new uint256[](transactionCount)
transactionIdsTemp(uint256[]) = ['TMP_103(uint256[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < transactionCount

IRs:
TMP_104(bool) = i < transactionCount
CONDITION TMP_104"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_71(ZethrBankroll.Transaction) -> transactions[i]
REF_72(bool) -> REF_71.executed
TMP_105 = UnaryType.BANG REF_72 
TMP_106(bool) = pending && TMP_105
REF_73(ZethrBankroll.Transaction) -> transactions[i]
REF_74(bool) -> REF_73.executed
TMP_107(bool) = executed && REF_74
TMP_108(bool) = TMP_106 || TMP_107
CONDITION TMP_108"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transactionIdsTemp[count] = i

IRs:
REF_75(uint256) -> transactionIdsTemp[count]
REF_75(uint256) (->transactionIdsTemp) := i(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_109(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_transactionIds = new uint256[](to - from)

IRs:
TMP_111(uint256) = to - from
TMP_112(uint256[])  = new uint256[](TMP_111)
_transactionIds(uint256[]) = ['TMP_112(uint256[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < to

IRs:
TMP_113(bool) = i < to
CONDITION TMP_113"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionIds[i - from] = transactionIdsTemp[i]

IRs:
TMP_114(uint256) = i - from
REF_76(uint256) -> _transactionIds[TMP_114]
REF_77(uint256) -> transactionIdsTemp[i]
REF_76(uint256) (->_transactionIds) := REF_77(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_115(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_transactionIds

IRs:
RETURN _transactionIds"];
}
// Function: 1155.sol-ZethrBankroll-isAnOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
caller = msg.sender

IRs:
caller(address) := msg.sender(address)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! isOwner[caller]

IRs:
REF_122(bool) -> isOwner[caller]
TMP_248 = UnaryType.BANG REF_122 
CONDITION TMP_248"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_249(None) = SOLIDITY_CALL revert()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: _ 5
"];
}
// Function: 1155.sol-ZethrBankroll-isConfirmed(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_49 -> LENGTH owners
TMP_80(bool) = i < REF_49
CONDITION TMP_80"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_50(mapping(address => bool)) -> confirmations[transactionId]
REF_51(address) -> owners[i]
REF_52(bool) -> REF_50[REF_51]
CONDITION REF_52"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_81(bool) = count == required
CONDITION TMP_81"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_82(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
}
// Function: 1155.sol-ZethrBankroll-notConfirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
confirmations[transactionId][owner]

IRs:
REF_129(mapping(address => bool)) -> confirmations[transactionId]
REF_130(bool) -> REF_129[owner]
CONDITION REF_130"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_257(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-notExecuted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].executed

IRs:
REF_131(ZethrBankroll.Transaction) -> transactions[transactionId]
REF_132(bool) -> REF_131.executed
CONDITION REF_132"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_258(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_address == 0

IRs:
TMP_259(bool) = _address == 0
CONDITION TMP_259"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_260(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != address(this)

IRs:
TMP_242 = CONVERT this to address
TMP_243(bool) = msg.sender != TMP_242
CONDITION TMP_243"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_244(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isOwner[owner]

IRs:
REF_123(bool) -> isOwner[owner]
CONDITION REF_123"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_250(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isOwner[owner]

IRs:
REF_124(bool) -> isOwner[owner]
TMP_251 = UnaryType.BANG REF_124 
CONDITION TMP_251"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_252(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-permissibleTokenWithdrawal(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
currentTime = now

IRs:
currentTime(uint256) := now(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tokenBalance = ZTHTKN.balanceOf(address(this))

IRs:
TMP_19 = CONVERT this to address
TMP_20(uint256) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:balanceOf, arguments:['TMP_19']  
tokenBalance(uint256) := TMP_20(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
maxPerTx = (tokenBalance.mul(MAX_WITHDRAW_PCT_TX)).div(100)

IRs:
TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenBalance', 'MAX_WITHDRAW_PCT_TX'] 
TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_21', '100'] 
maxPerTx(uint256) := TMP_22(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_toWithdraw <= maxPerTx)

IRs:
TMP_23(bool) = _toWithdraw <= maxPerTx
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
currentTime - dailyResetTime >= resetTimer

IRs:
TMP_25(uint256) = currentTime - dailyResetTime
TMP_26(bool) = TMP_25 >= resetTimer
CONDITION TMP_26"];
5->6[label="True"];
5->10[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
dailyResetTime = currentTime

IRs:
dailyResetTime(uint256) := currentTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
dailyTknLimit = (tokenBalance.mul(MAX_WITHDRAW_PCT_DAILY)).div(100)

IRs:
TMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenBalance', 'MAX_WITHDRAW_PCT_DAILY'] 
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_27', '100'] 
dailyTknLimit(uint256) := TMP_28(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
tknsDispensedToday = _toWithdraw

IRs:
tknsDispensedToday(uint256) := _toWithdraw(uint256)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: IF 10

EXPRESSION:
tknsDispensedToday.add(_toWithdraw) <= dailyTknLimit

IRs:
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tknsDispensedToday', '_toWithdraw'] 
TMP_30(bool) = TMP_29 <= dailyTknLimit
CONDITION TMP_30"];
10->11[label="True"];
10->13[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tknsDispensedToday += _toWithdraw

IRs:
tknsDispensedToday(uint256) = tknsDispensedToday + _toWithdraw"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
13[label="Node Type: RETURN 13

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 1155.sol-ZethrBankroll-queryTokenGrant(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
dailyTokensPerContract[_contract]

IRs:
REF_93(uint256) -> dailyTokensPerContract[_contract]
RETURN REF_93"];
}
// Function: 1155.sol-ZethrBankroll-receiveDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! reEntered

IRs:
TMP_173 = UnaryType.BANG reEntered 
CONDITION TMP_173"];
1->2[label="True"];
1->9[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
ActualBalance = (address(this).balance.sub(NonICOBuyins))

IRs:
TMP_174 = CONVERT this to address
TMP_175(uint256) = SOLIDITY_CALL balance(address)(TMP_174)
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_175', 'NonICOBuyins'] 
ActualBalance(uint256) := TMP_176(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
ActualBalance > 10000000000000000

IRs:
TMP_177(bool) = ActualBalance > 10000000000000000
CONDITION TMP_177"];
3->4[label="True"];
3->8[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
reEntered = true

IRs:
reEntered(bool) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ZTHTKN.buyAndSetDivPercentage.value(ActualBalance)(address(0x0),33,)

IRs:
TMP_179 = CONVERT 0 to address
TMP_180(uint256) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:buyAndSetDivPercentage, arguments:['TMP_179', '33', ''] value:ActualBalance "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
BankrollInvest(ActualBalance)

IRs:
Emit BankrollInvest(ActualBalance)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
reEntered = false

IRs:
reEntered(bool) := False(bool)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 1155.sol-ZethrBankroll-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = false

IRs:
REF_21(bool) -> isOwner[owner]
REF_21(bool) (->isOwner) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_22 -> LENGTH owners
TMP_41(uint256) = REF_22 - 1
TMP_42(bool) = i < TMP_41
CONDITION TMP_42"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
owners[i] == owner

IRs:
REF_23(address) -> owners[i]
TMP_43(bool) = REF_23 == owner
CONDITION TMP_43"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_24(address) -> owners[i]
REF_25 -> LENGTH owners
TMP_44(uint256) = REF_25 - 1
REF_26(address) -> owners[TMP_44]
REF_24(address) (->owners) := REF_26(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_45(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
owners.length -= 1

IRs:
REF_27 -> LENGTH owners
REF_27(-> owners) = REF_27 - 1"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
required > owners.length

IRs:
REF_28 -> LENGTH owners
TMP_46(bool) = required > REF_28
CONDITION TMP_46"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
changeRequirement(owners.length)

IRs:
REF_29 -> LENGTH owners
INTERNAL_CALL, ZethrBankroll.changeRequirement(uint256)(REF_29)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, ZethrBankroll.onlyWallet()()"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, ZethrBankroll.ownerExists(address)(owner)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
validRequirement(owners.length,required)

IRs:
REF_30 -> LENGTH owners
MODIFIER_CALL, ZethrBankroll.validRequirement(uint256,uint256)(REF_30,required)"];
18->1;
}
// Function: 1155.sol-ZethrBankroll-replaceOwner(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_31 -> LENGTH owners
TMP_52(bool) = i < REF_31
CONDITION TMP_52"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
owners[i] == owner

IRs:
REF_32(address) -> owners[i]
TMP_53(bool) = REF_32 == owner
CONDITION TMP_53"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
owners[i] = newOwner

IRs:
REF_33(address) -> owners[i]
REF_33(address) (->owners) := newOwner(address)"];
6->7;
7[label="Node Type: BREAK 7
"];
7->2;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_54(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
isOwner[owner] = false

IRs:
REF_34(bool) -> isOwner[owner]
REF_34(bool) (->isOwner) := False(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isOwner[newOwner] = true

IRs:
REF_35(bool) -> isOwner[newOwner]
REF_35(bool) (->isOwner) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerAddition(newOwner)

IRs:
Emit OwnerAddition(newOwner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, ZethrBankroll.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, ZethrBankroll.ownerExists(address)(owner)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerDoesNotExist(newOwner)

IRs:
MODIFIER_CALL, ZethrBankroll.ownerDoesNotExist(address)(newOwner)"];
16->3;
}
// Function: 1155.sol-ZethrBankroll-retrieveTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ZTHTKN.transferFrom(_contract,address(this),_amount))

IRs:
TMP_143 = CONVERT this to address
TMP_144(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:transferFrom, arguments:['_contract', 'TMP_143', '_amount']  
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
contractIsWhiteListed(_contract)

IRs:
MODIFIER_CALL, ZethrBankroll.contractIsWhiteListed(address)(_contract)"];
3->1;
}
// Function: 1155.sol-ZethrBankroll-revokeConfirmation(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_39(mapping(address => bool)) -> confirmations[transactionId]
REF_40(bool) -> REF_39[msg.sender]
REF_40(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, ZethrBankroll.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, ZethrBankroll.confirmed(uint256,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, ZethrBankroll.notExecuted(uint256)(transactionId)"];
5->1;
}
// Function: 1155.sol-ZethrBankroll-setDailyTokenLimit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
dailyTknLimit = limit

IRs:
dailyTknLimit(uint256) := limit(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
2->1;
}
// Function: 1155.sol-ZethrBankroll-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_OWNER_COUNT = 10

IRs:
MAX_OWNER_COUNT(uint256) := 10(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
MAX_WITHDRAW_PCT_DAILY = 15

IRs:
MAX_WITHDRAW_PCT_DAILY(uint256) := 15(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
MAX_WITHDRAW_PCT_TX = 5

IRs:
MAX_WITHDRAW_PCT_TX(uint256) := 5(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
resetTimer = 86400

IRs:
resetTimer(uint256) := 86400(uint256)"];
}
// Function: 1155.sol-ZethrBankroll-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
reEntered = false

IRs:
reEntered(bool) := False(bool)"];
}
// Function: 1155.sol-ZethrBankroll-submitTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data)

IRs:
TMP_63(uint256) = INTERNAL_CALL, ZethrBankroll.addTransaction(address,uint256,bytes)(destination,value,data)
transactionId(uint256) := TMP_63(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, ZethrBankroll.confirmTransaction(uint256)(transactionId)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 1155.sol-ZethrBankroll-tokenFallback(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1155.sol-ZethrBankroll-transactionExists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].destination == 0

IRs:
REF_125(ZethrBankroll.Transaction) -> transactions[transactionId]
REF_126(address) -> REF_125.destination
TMP_253(bool) = REF_126 == 0
CONDITION TMP_253"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_254(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0

IRs:
TMP_261(bool) = ownerCount > MAX_OWNER_COUNT
TMP_262(bool) = _required > ownerCount
TMP_263(bool) = TMP_261 || TMP_262
TMP_264(bool) = _required == 0
TMP_265(bool) = TMP_263 || TMP_264
TMP_266(bool) = ownerCount == 0
TMP_267(bool) = TMP_265 || TMP_266
CONDITION TMP_267"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_268(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 1155.sol-ZethrBankroll-whiteListContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isWhitelisted[contractAddress] = true

IRs:
REF_78(bool) -> isWhitelisted[contractAddress]
REF_78(bool) (->isWhitelisted) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whiteListedContracts.push(contractAddress)

IRs:
REF_80 -> LENGTH whiteListedContracts
TMP_117(uint256) := REF_80(uint256)
TMP_118(uint256) = TMP_117 + 1
REF_80(uint256) (->whiteListedContracts) := TMP_118(uint256)
REF_81(address) -> whiteListedContracts[TMP_117]
REF_81(address) (->whiteListedContracts) := contractAddress(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
dailyTokensPerContract[contractAddress] = 0

IRs:
REF_82(uint256) -> dailyTokensPerContract[contractAddress]
REF_82(uint256) (->dailyTokensPerContract) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
WhiteListAddition(contractAddress)

IRs:
Emit WhiteListAddition(contractAddress)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isAnOwner()

IRs:
MODIFIER_CALL, ZethrBankroll.isAnOwner()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
contractIsNotWhiteListed(contractAddress)

IRs:
MODIFIER_CALL, ZethrBankroll.contractIsNotWhiteListed(address)(contractAddress)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notNull(contractAddress)

IRs:
MODIFIER_CALL, ZethrBankroll.notNull(address)(contractAddress)"];
7->1;
}
}
