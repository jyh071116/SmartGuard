digraph G {
// Function: 1216.sol-ArtifactCoin-ArtifactCoin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
distr(offical,OfficalHolding)

IRs:
TMP_24(bool) = INTERNAL_CALL, ArtifactCoin.distr(address,uint256)(offical,OfficalHolding)"];
}
// Function: 1216.sol-ArtifactCoin-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_80(mapping(address => uint256)) -> allowed[_owner]
REF_81(uint256) -> REF_80[_spender]
RETURN REF_81"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 1216.sol-ArtifactCoin-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_78(mapping(address => uint256)) -> allowed[msg.sender]
REF_79(uint256) -> REF_78[_spender]
REF_79(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1216.sol-ArtifactCoin-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_29(uint256) -> balances[_owner]
RETURN REF_29"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 1216.sol-ArtifactCoin-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_84(uint256) -> balances[msg.sender]
TMP_181(bool) = _value <= REF_84
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_85(uint256) -> balances[burner]
REF_86(uint256) -> balances[burner]
TMP_183(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_86', '_value'] 
REF_85(uint256) (->balances) := TMP_183(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_184(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalDistributed = totalDistributed.sub(_value)

IRs:
TMP_185(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDistributed', '_value'] 
totalDistributed(uint256) := TMP_185(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
7->1;
}
// Function: 1216.sol-ArtifactCoin-canDistr()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! distributionFinished)

IRs:
TMP_195 = UnaryType.BANG distributionFinished 
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1216.sol-ArtifactCoin-canTrans()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(canTransfer == true)

IRs:
TMP_199(bool) = canTransfer == True
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1216.sol-ArtifactCoin-changeBaseValue(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
freeGiveBase = _freeGiveBase

IRs:
freeGiveBase(uint256) := _freeGiveBase(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
etherGetBase = _etherGetBase

IRs:
etherGetBase(uint256) := _etherGetBase(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
lowEth = _lowEth

IRs:
lowEth(uint256) := _lowEth(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
5->1;
}
// Function: 1216.sol-ArtifactCoin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_65 = CONVERT 0 to address
TMP_66(bool) = newOwner != TMP_65
CONDITION TMP_66"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
4->1;
}
// Function: 1216.sol-ArtifactCoin-decimals()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
decimals_

IRs:
RETURN decimals_"];
2[label="Node Type: RETURN 2

EXPRESSION:
_decimals

IRs:
RETURN _decimals"];
}
// Function: 1216.sol-ArtifactCoin-disableWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(addresses.length <= 255)

IRs:
REF_34 -> LENGTH addresses
TMP_73(bool) = REF_34 <= 255
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < addresses.length

IRs:
REF_35 -> LENGTH addresses
TMP_75(bool) = i < REF_35
CONDITION TMP_75"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
blacklist[addresses[i]] = true

IRs:
REF_36(address) -> addresses[i]
REF_37(bool) -> blacklist[REF_36]
REF_37(bool) (->blacklist) := True(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_76(uint8) := i(uint8)
i(uint8) = i + 1"];
7->5;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
8->1;
}
// Function: 1216.sol-ArtifactCoin-distr(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(totalRemaining >= 0)

IRs:
TMP_92(bool) = totalRemaining >= 0
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= totalRemaining)

IRs:
TMP_94(bool) = _amount <= totalRemaining
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalDistributed = totalDistributed.add(_amount)

IRs:
TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDistributed', '_amount'] 
totalDistributed(uint256) := TMP_96(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalRemaining = totalRemaining.sub(_amount)

IRs:
TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalRemaining', '_amount'] 
totalRemaining(uint256) := TMP_97(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_40(uint256) -> balances[_to]
REF_41(uint256) -> balances[_to]
TMP_98(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_41', '_amount'] 
REF_40(uint256) (->balances) := TMP_98(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_99 = CONVERT 0 to address
Emit Transfer(TMP_99,_to,_amount)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
8->1;
}
// Function: 1216.sol-ArtifactCoin-distributeAmounts(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(addresses.length <= 255)

IRs:
REF_46 -> LENGTH addresses
TMP_114(bool) = REF_46 <= 255
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(addresses.length == amounts.length)

IRs:
REF_47 -> LENGTH addresses
REF_48 -> LENGTH amounts
TMP_116(bool) = REF_47 == REF_48
TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < addresses.length

IRs:
REF_49 -> LENGTH addresses
TMP_118(bool) = i < REF_49
CONDITION TMP_118"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(amounts[i] <= totalRemaining)

IRs:
REF_50(uint256) -> amounts[i]
TMP_119(bool) = REF_50 <= totalRemaining
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
distr(addresses[i],amounts[i])

IRs:
REF_51(address) -> addresses[i]
REF_52(uint256) -> amounts[i]
TMP_121(bool) = INTERNAL_CALL, ArtifactCoin.distr(address,uint256)(REF_51,REF_52)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
totalDistributed >= totalSupply_

IRs:
TMP_122(bool) = totalDistributed >= totalSupply_
CONDITION TMP_122"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_123(uint8) := i(uint8)
i(uint8) = i + 1"];
12->6;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
14->1;
}
// Function: 1216.sol-ArtifactCoin-distribution(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(addresses.length <= 255)

IRs:
REF_43 -> LENGTH addresses
TMP_102(bool) = REF_43 <= 255
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount <= totalRemaining)

IRs:
TMP_104(bool) = amount <= totalRemaining
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->10;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < addresses.length

IRs:
REF_44 -> LENGTH addresses
TMP_106(bool) = i < REF_44
CONDITION TMP_106"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(amount <= totalRemaining)

IRs:
TMP_107(bool) = amount <= totalRemaining
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
distr(addresses[i],amount)

IRs:
REF_45(address) -> addresses[i]
TMP_109(bool) = INTERNAL_CALL, ArtifactCoin.distr(address,uint256)(REF_45,amount)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_110(uint8) := i(uint8)
i(uint8) = i + 1"];
9->6;
10[label="Node Type: IF 10

EXPRESSION:
totalDistributed >= totalSupply_

IRs:
TMP_111(bool) = totalDistributed >= totalSupply_
CONDITION TMP_111"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)"];
11->12;
12[label="Node Type: END_IF 12
"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
14->1;
}
// Function: 1216.sol-ArtifactCoin-enableWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(addresses.length <= 255)

IRs:
REF_30 -> LENGTH addresses
TMP_68(bool) = REF_30 <= 255
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < addresses.length

IRs:
REF_31 -> LENGTH addresses
TMP_70(bool) = i < REF_31
CONDITION TMP_70"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
blacklist[addresses[i]] = false

IRs:
REF_32(address) -> addresses[i]
REF_33(bool) -> blacklist[REF_32]
REF_33(bool) (->blacklist) := False(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_71(uint8) := i(uint8)
i(uint8) = i + 1"];
7->5;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
8->1;
}
// Function: 1216.sol-ArtifactCoin-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
get()

IRs:
INTERNAL_CALL, ArtifactCoin.get()()"];
}
// Function: 1216.sol-ArtifactCoin-finishDistribution()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
4->1;
}
// Function: 1216.sol-ArtifactCoin-finishEthGet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
endEthGet = true

IRs:
endEthGet(bool) := True(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
4->1;
}
// Function: 1216.sol-ArtifactCoin-finishFreeGet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
endFreeGet = true

IRs:
endFreeGet(bool) := True(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
4->1;
}
// Function: 1216.sol-ArtifactCoin-get()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->25;
1[label="Node Type: IF 1

EXPRESSION:
freeGiveBase > totalRemaining

IRs:
TMP_127(bool) = freeGiveBase > totalRemaining
CONDITION TMP_127"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
freeGiveBase = totalRemaining

IRs:
freeGiveBase(uint256) := totalRemaining(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
etherValue = msg.value

IRs:
etherValue(uint256) := msg.value(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6
"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
gasPrice = tx.gasprice

IRs:
gasPrice(uint256) := tx.gasprice(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
etherValue > lowEth

IRs:
TMP_128(bool) = etherValue > lowEth
CONDITION TMP_128"];
8->9[label="True"];
8->17[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(endEthGet == false)

IRs:
TMP_129(bool) = endEthGet == False
TMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
value = etherValue.mul(etherGetBase)

IRs:
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['etherValue', 'etherGetBase'] 
value(uint256) := TMP_131(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
value = value.add(freeGiveBase.mul(gasPrice.div(1e8)))

IRs:
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['gasPrice', '100000000'] 
TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['freeGiveBase', 'TMP_132'] 
TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['value', 'TMP_133'] 
value(uint256) := TMP_134(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(value <= totalRemaining)

IRs:
TMP_135(bool) = value <= totalRemaining
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
distr(investor,value)

IRs:
TMP_137(bool) = INTERNAL_CALL, ArtifactCoin.distr(address,uint256)(investor,value)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
! owner.send(etherValue)

IRs:
TMP_138 = SEND dest:owner value:etherValue
TMP_139 = UnaryType.BANG TMP_138 
CONDITION TMP_139"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
revert()()

IRs:
TMP_140(None) = SOLIDITY_CALL revert()()"];
15->16;
16[label="Node Type: END_IF 16
"];
16->21;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(endFreeGet == false && freeGiveBase <= totalRemaining && now >= unlockUnixTime[investor])

IRs:
TMP_141(bool) = endFreeGet == False
TMP_142(bool) = freeGiveBase <= totalRemaining
TMP_143(bool) = TMP_141 && TMP_142
REF_58(uint256) -> unlockUnixTime[investor]
TMP_144(bool) = now >= REF_58
TMP_145(bool) = TMP_143 && TMP_144
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
value = freeGiveBase.mul(gasPrice.div(1e8))

IRs:
TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['gasPrice', '100000000'] 
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['freeGiveBase', 'TMP_147'] 
value(uint256) := TMP_148(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
distr(investor,value)

IRs:
TMP_149(bool) = INTERNAL_CALL, ArtifactCoin.distr(address,uint256)(investor,value)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
unlockUnixTime[investor] = now + 86400

IRs:
REF_61(uint256) -> unlockUnixTime[investor]
TMP_150(uint256) = now + 86400
REF_61(uint256) (->unlockUnixTime) := TMP_150(uint256)"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: IF 22

EXPRESSION:
totalDistributed >= totalSupply_

IRs:
TMP_151(bool) = totalDistributed >= totalSupply_
CONDITION TMP_151"];
22->23[label="True"];
22->24[label="False"];
23[label="Node Type: EXPRESSION 23

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)"];
23->24;
24[label="Node Type: END_IF 24
"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
onlyWhitelist()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyWhitelist()()"];
26->1;
}
// Function: 1216.sol-ArtifactCoin-getTokenBalance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
t = ForeignToken(tokenAddress)

IRs:
TMP_173 = CONVERT tokenAddress to ForeignToken
t(ForeignToken) := TMP_173(ForeignToken)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
bal = t.balanceOf(who)

IRs:
TMP_174(uint256) = HIGH_LEVEL_CALL, dest:t(ForeignToken), function:balanceOf, arguments:['who']  
bal(uint256) := TMP_174(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
bal

IRs:
RETURN bal"];
}
// Function: 1216.sol-ArtifactCoin-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(length > 0)

IRs:
TMP_48(bool) = length > 0
RETURN TMP_48"];
5[label="Node Type: RETURN 5

EXPRESSION:
is_contract

IRs:
RETURN is_contract"];
}
// Function: 1216.sol-ArtifactCoin-name()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
name_

IRs:
RETURN name_"];
2[label="Node Type: RETURN 2

EXPRESSION:
_name

IRs:
RETURN _name"];
}
// Function: 1216.sol-ArtifactCoin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_197(bool) = msg.sender == owner
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1216.sol-ArtifactCoin-onlyWhitelist()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(blacklist[msg.sender] == false)

IRs:
REF_94(bool) -> blacklist[msg.sender]
TMP_201(bool) = REF_94 == False
TMP_202(None) = SOLIDITY_CALL require(bool)(TMP_201)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1216.sol-ArtifactCoin-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
name_ = ArtifactCoin

IRs:
name_(string) := ArtifactCoin(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
Information = アーティファクトチェーン

IRs:
Information(string) := アーティファクトチェーン(string)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
symbol_ = 3A

IRs:
symbol_(string) := 3A(string)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
decimals_ = 18

IRs:
decimals_(uint8) := 18(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
canTransfer = true

IRs:
canTransfer(bool) := True(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
etherGetBase = 6000000

IRs:
etherGetBase(uint256) := 6000000(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
totalSupply_ = 2000000000e18

IRs:
totalSupply_(uint256) := 2000000000000000000000000000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
OfficalHolding = totalSupply_.mul(30).div(100)

IRs:
TMP_193(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalSupply_', '30'] 
TMP_194(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_193', '100'] 
OfficalHolding(uint256) := TMP_194(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
totalRemaining = totalSupply_

IRs:
totalRemaining(uint256) := totalSupply_(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
totalDistributed = 0

IRs:
totalDistributed(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
freeGiveBase = 300e17

IRs:
freeGiveBase(uint256) := 30000000000000000000(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
lowEth = 1e14

IRs:
lowEth(uint256) := 100000000000000(uint256)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
distributionFinished = false

IRs:
distributionFinished(bool) := False(bool)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
endFreeGet = false

IRs:
endFreeGet(bool) := False(bool)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
endEthGet = false

IRs:
endEthGet(bool) := False(bool)"];
}
// Function: 1216.sol-ArtifactCoin-startDistribution()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
distributionFinished = false

IRs:
distributionFinished(bool) := False(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->1;
}
// Function: 1216.sol-ArtifactCoin-startEthGet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
endEthGet = false

IRs:
endEthGet(bool) := False(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
4->1;
}
// Function: 1216.sol-ArtifactCoin-startFreeGet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
endFreeGet = false

IRs:
endFreeGet(bool) := False(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ArtifactCoin.canDistr()()"];
4->1;
}
// Function: 1216.sol-ArtifactCoin-startTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
canTransfer = true

IRs:
canTransfer(bool) := True(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->1;
}
// Function: 1216.sol-ArtifactCoin-stopTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
canTransfer = false

IRs:
canTransfer(bool) := False(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
3->1;
}
// Function: 1216.sol-ArtifactCoin-symbol()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
symbol_

IRs:
RETURN symbol_"];
2[label="Node Type: RETURN 2

EXPRESSION:
_symbol

IRs:
RETURN _symbol"];
}
// Function: 1216.sol-ArtifactCoin-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
2[label="Node Type: RETURN 2

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply"];
}
// Function: 1216.sol-ArtifactCoin-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isContract(_to)

IRs:
TMP_44(bool) = INTERNAL_CALL, ArtifactCoin.isContract(address)(_to)
CONDITION TMP_44"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToContract(_to,_value,empty)

IRs:
TMP_45(bool) = INTERNAL_CALL, ArtifactCoin.transferToContract(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_45"];
4[label="Node Type: RETURN 4

EXPRESSION:
transferToAddress(_to,_value,empty)

IRs:
TMP_46(bool) = INTERNAL_CALL, ArtifactCoin.transferToAddress(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_46"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
canTrans()

IRs:
MODIFIER_CALL, ArtifactCoin.canTrans()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1216.sol-ArtifactCoin-transfer(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_40(bool) = INTERNAL_CALL, ArtifactCoin.isContract(address)(_to)
CONDITION TMP_40"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
transferToContract(_to,_value,_data)

IRs:
TMP_41(bool) = INTERNAL_CALL, ArtifactCoin.transferToContract(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_41"];
3[label="Node Type: RETURN 3

EXPRESSION:
transferToAddress(_to,_value,_data)

IRs:
TMP_42(bool) = INTERNAL_CALL, ArtifactCoin.transferToAddress(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_42"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canTrans()

IRs:
MODIFIER_CALL, ArtifactCoin.canTrans()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1216.sol-ArtifactCoin-transfer(address,uint256,bytes,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_25(bool) = INTERNAL_CALL, ArtifactCoin.isContract(address)(_to)
CONDITION TMP_25"];
1->2[label="True"];
1->11[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_26(uint256) = INTERNAL_CALL, ArtifactCoin.balanceOf(address)(msg.sender)
TMP_27(bool) = TMP_26 < _value
CONDITION TMP_27"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_28(None) = SOLIDITY_CALL revert()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_8(uint256) -> balances[msg.sender]
REF_9(uint256) -> balances[msg.sender]
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_9', '_value'] 
REF_8(uint256) (->balances) := TMP_29(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_11(uint256) -> balances[_to]
REF_12(uint256) -> balances[_to]
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_12', '_value'] 
REF_11(uint256) (->balances) := TMP_30(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data))

IRs:
TMP_32(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback)
TMP_33 = CONVERT TMP_32 to bytes4
TMP_34(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_33', 'msg.sender', '_value', '_data'] value:0 
TMP_35(None) = SOLIDITY_CALL assert(bool)(TMP_34)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: RETURN 11

EXPRESSION:
transferToAddress(_to,_value,_data)

IRs:
TMP_38(bool) = INTERNAL_CALL, ArtifactCoin.transferToAddress(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_38"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
canTrans()

IRs:
MODIFIER_CALL, ArtifactCoin.canTrans()()"];
13->1;
14[label="Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1216.sol-ArtifactCoin-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0) && _value > 0 && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && blacklist[_from] == false && blacklist[_to] == false)

IRs:
TMP_154 = CONVERT 0 to address
TMP_155(bool) = _to != TMP_154
TMP_156(bool) = _value > 0
TMP_157(bool) = TMP_155 && TMP_156
REF_62(uint256) -> balances[_from]
TMP_158(bool) = REF_62 >= _value
TMP_159(bool) = TMP_157 && TMP_158
REF_63(mapping(address => uint256)) -> allowed[_from]
REF_64(uint256) -> REF_63[msg.sender]
TMP_160(bool) = REF_64 >= _value
TMP_161(bool) = TMP_159 && TMP_160
REF_65(bool) -> blacklist[_from]
TMP_162(bool) = REF_65 == False
TMP_163(bool) = TMP_161 && TMP_162
REF_66(bool) -> blacklist[_to]
TMP_164(bool) = REF_66 == False
TMP_165(bool) = TMP_163 && TMP_164
TMP_166(None) = SOLIDITY_CALL require(bool)(TMP_165)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_67(uint256) -> balances[_from]
REF_68(uint256) -> balances[_from]
TMP_167(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_68', '_value'] 
REF_67(uint256) (->balances) := TMP_167(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_70(uint256) -> balances[_to]
REF_71(uint256) -> balances[_to]
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_value'] 
REF_70(uint256) (->balances) := TMP_168(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_73(mapping(address => uint256)) -> allowed[_from]
REF_74(uint256) -> REF_73[msg.sender]
REF_75(mapping(address => uint256)) -> allowed[_from]
REF_76(uint256) -> REF_75[msg.sender]
TMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_76', '_value'] 
REF_74(uint256) (->allowed) := TMP_169(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canTrans()

IRs:
MODIFIER_CALL, ArtifactCoin.canTrans()()"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1216.sol-ArtifactCoin-transferToAddress(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_49(uint256) = INTERNAL_CALL, ArtifactCoin.balanceOf(address)(msg.sender)
TMP_50(bool) = TMP_49 < _value
CONDITION TMP_50"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_51(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_16(uint256) -> balances[msg.sender]
REF_17(uint256) -> balances[msg.sender]
TMP_52(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_17', '_value'] 
REF_16(uint256) (->balances) := TMP_52(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_19(uint256) -> balances[_to]
REF_20(uint256) -> balances[_to]
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_53(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1216.sol-ArtifactCoin-transferToContract(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_56(uint256) = INTERNAL_CALL, ArtifactCoin.balanceOf(address)(msg.sender)
TMP_57(bool) = TMP_56 < _value
CONDITION TMP_57"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_58(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_22(uint256) -> balances[msg.sender]
REF_23(uint256) -> balances[msg.sender]
TMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_59(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_25(uint256) -> balances[_to]
REF_26(uint256) -> balances[_to]
TMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_26', '_value'] 
REF_25(uint256) (->balances) := TMP_60(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
receiver = ContractReceiver(_to)

IRs:
TMP_61 = CONVERT _to to ContractReceiver
receiver(ContractReceiver) := TMP_61(ContractReceiver)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ContractReceiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1216.sol-ArtifactCoin-withdraw(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
etherBalance = address(this).balance

IRs:
TMP_175 = CONVERT this to address
TMP_176(uint256) = SOLIDITY_CALL balance(address)(TMP_175)
etherBalance(uint256) := TMP_176(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! receiveAddress.send(etherBalance)

IRs:
TMP_177 = SEND dest:receiveAddress value:etherBalance
TMP_178 = UnaryType.BANG TMP_177 
CONDITION TMP_178"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_179(None) = SOLIDITY_CALL revert()()"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
5->1;
}
// Function: 1216.sol-ArtifactCoin-withdrawForeignTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
token = ForeignToken(_tokenContract)

IRs:
TMP_188 = CONVERT _tokenContract to ForeignToken
token(ForeignToken) := TMP_188(ForeignToken)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
amount = token.balanceOf(address(this))

IRs:
TMP_189 = CONVERT this to address
TMP_190(uint256) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:balanceOf, arguments:['TMP_189']  
amount(uint256) := TMP_190(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
token.transfer(owner,amount)

IRs:
TMP_191(bool) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:transfer, arguments:['owner', 'amount']  
RETURN TMP_191"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ArtifactCoin.onlyOwner()()"];
4->1;
}
// Function: 1216.sol-ContractReceiver-tokenFallback(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_13 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_14 = CONVERT REF_4 to uint32
TMP_15(uint32) = TMP_14 << 8
TMP_16(uint32) = TMP_13 + TMP_15
REF_5(None) -> _data[1]
TMP_17 = CONVERT REF_5 to uint32
TMP_18(uint32) = TMP_17 << 16
TMP_19(uint32) = TMP_16 + TMP_18
REF_6(None) -> _data[0]
TMP_20 = CONVERT REF_6 to uint32
TMP_21(uint32) = TMP_20 << 24
TMP_22(uint32) = TMP_19 + TMP_21
u(uint32) := TMP_22(uint32)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_23 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_23(bytes4)"];
}
// Function: 1216.sol-ERC223-balanceOf(address)
digraph{
}
// Function: 1216.sol-ERC223-decimals()
digraph{
}
// Function: 1216.sol-ERC223-name()
digraph{
}
// Function: 1216.sol-ERC223-symbol()
digraph{
}
// Function: 1216.sol-ERC223-totalSupply()
digraph{
}
// Function: 1216.sol-ERC223-transfer(address,uint256)
digraph{
}
// Function: 1216.sol-ERC223-transfer(address,uint256,bytes)
digraph{
}
// Function: 1216.sol-ERC223-transfer(address,uint256,bytes,string)
digraph{
}
// Function: 1216.sol-ForeignToken-balanceOf(address)
digraph{
}
// Function: 1216.sol-ForeignToken-transfer(address,uint256)
digraph{
}
// Function: 1216.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1216.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_6(uint256) = a / b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1216.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1216.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_7(bool) = b <= a
TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_9(uint256) = a - b
RETURN TMP_9"];
}
}
