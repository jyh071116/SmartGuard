digraph G {
// Function: 21144.sol-BinaryOption-BinaryOption(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_namiCrowdSale != 0x0 && _escrow != 0x0)

IRs:
TMP_356(bool) = _namiCrowdSale != 0
TMP_357(bool) = _escrow != 0
TMP_358(bool) = TMP_356 && TMP_357
TMP_359(None) = SOLIDITY_CALL require(bool)(TMP_358)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
namiCrowdSaleAddr = _namiCrowdSale

IRs:
namiCrowdSaleAddr(address) := _namiCrowdSale(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
escrow = _escrow

IRs:
escrow(address) := _escrow(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
namiMultiSigWallet = _namiMultiSigWallet

IRs:
namiMultiSigWallet(address) := _namiMultiSigWallet(address)"];
}
// Function: 21144.sol-BinaryOption-changeEscrow(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_escrow != 0x0)

IRs:
TMP_360(bool) = _escrow != 0
TMP_361(None) = SOLIDITY_CALL require(bool)(TMP_360)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
escrow = _escrow

IRs:
escrow(address) := _escrow(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyNamiMultisig()

IRs:
MODIFIER_CALL, BinaryOption.onlyNamiMultisig()()"];
3->1;
}
// Function: 21144.sol-BinaryOption-changeMinEth(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_minimunEth != 0)

IRs:
TMP_363(bool) = _minimunEth != 0
TMP_364(None) = SOLIDITY_CALL require(bool)(TMP_363)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minimunEth = _minimunEth

IRs:
minimunEth(uint256) := _minimunEth(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-BinaryOption-changeRateFee(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! session.isOpen)

IRs:
REF_318(bool) -> session.isOpen
TMP_382 = UnaryType.BANG REF_318 
TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
rateFee = _rateFee

IRs:
rateFee(uint256) := _rateFee(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-BinaryOption-changeRateLoss(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! session.isOpen)

IRs:
REF_317(bool) -> session.isOpen
TMP_379 = UnaryType.BANG REF_317 
TMP_380(None) = SOLIDITY_CALL require(bool)(TMP_379)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
rateLoss = _rateLoss

IRs:
rateLoss(uint256) := _rateLoss(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-BinaryOption-changeRateWin(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! session.isOpen)

IRs:
REF_316(bool) -> session.isOpen
TMP_376 = UnaryType.BANG REF_316 
TMP_377(None) = SOLIDITY_CALL require(bool)(TMP_376)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
rateWin = _rateWin

IRs:
rateWin(uint256) := _rateWin(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-BinaryOption-changeTimeInvest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! session.isOpen && _timeInvest < timeOneSession)

IRs:
REF_314(bool) -> session.isOpen
TMP_366 = UnaryType.BANG REF_314 
TMP_367(bool) = _timeInvest < timeOneSession
TMP_368(bool) = TMP_366 && TMP_367
TMP_369(None) = SOLIDITY_CALL require(bool)(TMP_368)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
timeInvestInMinute = _timeInvest

IRs:
timeInvestInMinute(uint256) := _timeInvest(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-BinaryOption-changeTimeOneSession(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! session.isOpen && _timeOneSession > timeInvestInMinute)

IRs:
REF_315(bool) -> session.isOpen
TMP_371 = UnaryType.BANG REF_315 
TMP_372(bool) = _timeOneSession > timeInvestInMinute
TMP_373(bool) = TMP_371 && TMP_372
TMP_374(None) = SOLIDITY_CALL require(bool)(TMP_373)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
timeOneSession = _timeOneSession

IRs:
timeOneSession(uint256) := _timeOneSession(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-BinaryOption-closeInvest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_priceOpen != 0 && session.investOpen)

IRs:
TMP_422(bool) = _priceOpen != 0
REF_365(bool) -> session.investOpen
TMP_423(bool) = TMP_422 && REF_365
TMP_424(None) = SOLIDITY_CALL require(bool)(TMP_423)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now > (session.timeOpen + timeInvestInMinute * 60))

IRs:
REF_366(uint256) -> session.timeOpen
TMP_425(uint256) = timeInvestInMinute * 60
TMP_426(uint256) = REF_366 + TMP_425
TMP_427(bool) = now > TMP_426
TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
session.investOpen = false

IRs:
REF_367(bool) -> session.investOpen
REF_367(bool) (->session) := False(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
session.priceOpen = _priceOpen

IRs:
REF_368(uint256) -> session.priceOpen
REF_368(uint256) (->session) := _priceOpen(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
InvestClose(now,_priceOpen,sessionId)

IRs:
Emit InvestClose(now,_priceOpen,sessionId)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
6->1;
}
// Function: 21144.sol-BinaryOption-closeSession(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->32;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_priceClose != 0 && now > (session.timeOpen + timeOneSession * 60))

IRs:
TMP_435(bool) = _priceClose != 0
REF_369(uint256) -> session.timeOpen
TMP_436(uint256) = timeOneSession * 60
TMP_437(uint256) = REF_369 + TMP_436
TMP_438(bool) = now > TMP_437
TMP_439(bool) = TMP_435 && TMP_438
TMP_440(None) = SOLIDITY_CALL require(bool)(TMP_439)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! session.investOpen && session.isOpen)

IRs:
REF_370(bool) -> session.investOpen
TMP_441 = UnaryType.BANG REF_370 
REF_371(bool) -> session.isOpen
TMP_442(bool) = TMP_441 && REF_371
TMP_443(None) = SOLIDITY_CALL require(bool)(TMP_442)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
session.priceClose = _priceClose

IRs:
REF_372(uint256) -> session.priceClose
REF_372(uint256) (->session) := _priceClose(uint256)"];
3->33;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
namiContract = NamiCrowdSale(namiCrowdSaleAddr)

IRs:
TMP_444 = CONVERT namiCrowdSaleAddr to NamiCrowdSale
namiContract(NamiCrowdSale) := TMP_444(NamiCrowdSale)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
price = namiContract.getPrice()

IRs:
TMP_445(uint256) = HIGH_LEVEL_CALL, dest:namiContract(NamiCrowdSale), function:getPrice, arguments:[]  
price(uint256) := TMP_445(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(price != 0)

IRs:
TMP_446(bool) = price != 0
TMP_447(None) = SOLIDITY_CALL require(bool)(TMP_446)"];
8->11;
9[label="Node Type: BEGIN_LOOP 9
"];
9->12;
10[label="Node Type: END_LOOP 10
"];
10->24;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
11->9;
12[label="Node Type: IF_LOOP 12

EXPRESSION:
i < session.investorCount

IRs:
REF_374(uint256) -> session.investorCount
TMP_448(bool) = i < REF_374
CONDITION TMP_448"];
12->13[label="True"];
12->10[label="False"];
13[label="Node Type: IF 13

EXPRESSION:
session.win[i] == result

IRs:
REF_375(mapping(uint256 => bool)) -> session.win
REF_376(bool) -> REF_375[i]
TMP_449(bool) = REF_376 == result
CONDITION TMP_449"];
13->14[label="True"];
13->17[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
etherToBuy = (session.amountInvest[i] - session.amountInvest[i] * rateFee / 100) * rateWin / 100

IRs:
REF_377(mapping(uint256 => uint256)) -> session.amountInvest
REF_378(uint256) -> REF_377[i]
REF_379(mapping(uint256 => uint256)) -> session.amountInvest
REF_380(uint256) -> REF_379[i]
TMP_450(uint256) = REF_380 * rateFee
TMP_451(uint256) = TMP_450 / 100
TMP_452(uint256) = REF_378 - TMP_451
TMP_453(uint256) = TMP_452 * rateWin
TMP_454(uint256) = TMP_453 / 100
etherToBuy(uint256) := TMP_454(uint256)"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
etherReturn = session.amountInvest[i] - session.amountInvest[i] * rateFee / 100

IRs:
REF_381(mapping(uint256 => uint256)) -> session.amountInvest
REF_382(uint256) -> REF_381[i]
REF_383(mapping(uint256 => uint256)) -> session.amountInvest
REF_384(uint256) -> REF_383[i]
TMP_455(uint256) = REF_384 * rateFee
TMP_456(uint256) = TMP_455 / 100
TMP_457(uint256) = REF_382 - TMP_456
etherReturn(uint256) := TMP_457(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
(session.investor[i]).transfer(etherReturn)

IRs:
REF_385(mapping(uint256 => address)) -> session.investor
REF_386(address) -> REF_385[i]
Transfer dest:REF_386 value:etherReturn"];
16->18;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
etherToBuy = (session.amountInvest[i] - session.amountInvest[i] * rateFee / 100) * rateLoss / 100

IRs:
REF_388(mapping(uint256 => uint256)) -> session.amountInvest
REF_389(uint256) -> REF_388[i]
REF_390(mapping(uint256 => uint256)) -> session.amountInvest
REF_391(uint256) -> REF_390[i]
TMP_459(uint256) = REF_391 * rateFee
TMP_460(uint256) = TMP_459 / 100
TMP_461(uint256) = REF_389 - TMP_460
TMP_462(uint256) = TMP_461 * rateLoss
TMP_463(uint256) = TMP_462 / 100
etherToBuy(uint256) := TMP_463(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
namiContract.buy.value(etherToBuy)(session.investor[i])

IRs:
REF_394(mapping(uint256 => address)) -> session.investor
REF_395(address) -> REF_394[i]
HIGH_LEVEL_CALL, dest:namiContract(NamiCrowdSale), function:buy, arguments:['REF_395'] value:etherToBuy "];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
session.investor[i] = 0x0

IRs:
REF_396(mapping(uint256 => address)) -> session.investor
REF_397(address) -> REF_396[i]
REF_397(address) (->session) := 0(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
session.win[i] = false

IRs:
REF_398(mapping(uint256 => bool)) -> session.win
REF_399(bool) -> REF_398[i]
REF_399(bool) (->session) := False(bool)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
session.amountInvest[i] = 0

IRs:
REF_400(mapping(uint256 => uint256)) -> session.amountInvest
REF_401(uint256) -> REF_400[i]
REF_401(uint256) (->session) := 0(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
i ++

IRs:
TMP_466(uint256) := i(uint256)
i(uint256) = i + 1"];
23->12;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
session.isOpen = false

IRs:
REF_402(bool) -> session.isOpen
REF_402(bool) (->session) := False(bool)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
SessionClose(now,sessionId,_priceClose,price,rateWin,rateLoss,rateFee)

IRs:
Emit SessionClose(now,sessionId,_priceClose,price,rateWin,rateLoss,rateFee)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
sessionId += 1

IRs:
sessionId(uint256) = sessionId + 1"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
session.priceOpen = 0

IRs:
REF_403(uint256) -> session.priceOpen
REF_403(uint256) (->session) := 0(uint256)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
session.priceClose = 0

IRs:
REF_404(uint256) -> session.priceClose
REF_404(uint256) (->session) := 0(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
session.isReset = true

IRs:
REF_405(bool) -> session.isReset
REF_405(bool) (->session) := True(bool)"];
29->30;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
session.investOpen = false

IRs:
REF_406(bool) -> session.investOpen
REF_406(bool) (->session) := False(bool)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
session.investorCount = 0

IRs:
REF_407(uint256) -> session.investorCount
REF_407(uint256) (->session) := 0(uint256)"];
32[label="Node Type: EXPRESSION 32

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
32->1;
33[label="Node Type: IF 33

EXPRESSION:
(_priceClose > session.priceOpen)

IRs:
REF_408(uint256) -> session.priceOpen
TMP_469(bool) = _priceClose > REF_408
CONDITION TMP_469"];
33->34[label="True"];
33->35[label="False"];
34[label="Node Type: EXPRESSION 34

EXPRESSION:
result = true

IRs:
result(bool) := True(bool)"];
34->36;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
result = false

IRs:
result(bool) := False(bool)"];
35->36;
36[label="Node Type: END_IF 36
"];
36->5;
}
// Function: 21144.sol-BinaryOption-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_354(bool) = msg.value > 0
CONDITION TMP_354"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 21144.sol-BinaryOption-getAmount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->8;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < MAX_INVESTOR

IRs:
TMP_398(bool) = i < MAX_INVESTOR
CONDITION TMP_398"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
listAmount[i] = session.amountInvest[i]

IRs:
REF_329(uint256) -> listAmount[i]
REF_330(mapping(uint256 => uint256)) -> session.amountInvest
REF_331(uint256) -> REF_330[i]
REF_329(uint256) (->listAmount) := REF_331(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_399(uint256) := i(uint256)
i(uint256) = i + 1"];
7->5;
8[label="Node Type: RETURN 8

EXPRESSION:
listAmount

IRs:
RETURN listAmount"];
}
// Function: 21144.sol-BinaryOption-getChooses()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->8;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < MAX_INVESTOR

IRs:
TMP_396(bool) = i < MAX_INVESTOR
CONDITION TMP_396"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
listChooses[i] = session.win[i]

IRs:
REF_326(bool) -> listChooses[i]
REF_327(mapping(uint256 => bool)) -> session.win
REF_328(bool) -> REF_327[i]
REF_326(bool) (->listChooses) := REF_328(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_397(uint256) := i(uint256)
i(uint256) = i + 1"];
7->5;
8[label="Node Type: RETURN 8

EXPRESSION:
listChooses

IRs:
RETURN listChooses"];
}
// Function: 21144.sol-BinaryOption-getEtherToBuy(uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_status

IRs:
CONDITION _status"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
_ether * rateWin / 100

IRs:
TMP_431(uint256) = _ether * rateWin
TMP_432(uint256) = TMP_431 / 100
RETURN TMP_432"];
3[label="Node Type: RETURN 3

EXPRESSION:
_ether * rateLoss / 100

IRs:
TMP_433(uint256) = _ether * rateLoss
TMP_434(uint256) = TMP_433 / 100
RETURN TMP_434"];
}
// Function: 21144.sol-BinaryOption-getInvestors()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->8;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < MAX_INVESTOR

IRs:
TMP_394(bool) = i < MAX_INVESTOR
CONDITION TMP_394"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
listInvestor[i] = session.investor[i]

IRs:
REF_323(address) -> listInvestor[i]
REF_324(mapping(uint256 => address)) -> session.investor
REF_325(address) -> REF_324[i]
REF_323(address) (->listInvestor) := REF_325(address)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_395(uint256) := i(uint256)
i(uint256) = i + 1"];
7->5;
8[label="Node Type: RETURN 8

EXPRESSION:
listInvestor

IRs:
RETURN listInvestor"];
}
// Function: 21144.sol-BinaryOption-invest(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= minimunEth && session.investOpen)

IRs:
TMP_412(bool) = msg.value >= minimunEth
REF_352(bool) -> session.investOpen
TMP_413(bool) = TMP_412 && REF_352
TMP_414(None) = SOLIDITY_CALL require(bool)(TMP_413)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now < (session.timeOpen + timeInvestInMinute * 60))

IRs:
REF_353(uint256) -> session.timeOpen
TMP_415(uint256) = timeInvestInMinute * 60
TMP_416(uint256) = REF_353 + TMP_415
TMP_417(bool) = now < TMP_416
TMP_418(None) = SOLIDITY_CALL require(bool)(TMP_417)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(session.investorCount < MAX_INVESTOR)

IRs:
REF_354(uint256) -> session.investorCount
TMP_419(bool) = REF_354 < MAX_INVESTOR
TMP_420(None) = SOLIDITY_CALL require(bool)(TMP_419)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
session.investor[session.investorCount] = msg.sender

IRs:
REF_355(mapping(uint256 => address)) -> session.investor
REF_356(uint256) -> session.investorCount
REF_357(address) -> REF_355[REF_356]
REF_357(address) (->session) := msg.sender(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
session.win[session.investorCount] = _choose

IRs:
REF_358(mapping(uint256 => bool)) -> session.win
REF_359(uint256) -> session.investorCount
REF_360(bool) -> REF_358[REF_359]
REF_360(bool) (->session) := _choose(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
session.amountInvest[session.investorCount] = msg.value

IRs:
REF_361(mapping(uint256 => uint256)) -> session.amountInvest
REF_362(uint256) -> session.investorCount
REF_363(uint256) -> REF_361[REF_362]
REF_363(uint256) (->session) := msg.value(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
session.investorCount += 1

IRs:
REF_364(uint256) -> session.investorCount
REF_364(-> session) = REF_364 + 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Invest(msg.sender,_choose,msg.value,now,sessionId)

IRs:
Emit Invest(msg.sender,_choose,msg.value,now,sessionId)"];
}
// Function: 21144.sol-BinaryOption-onlyEscrow()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == escrow)

IRs:
TMP_470(bool) = msg.sender == escrow
TMP_471(None) = SOLIDITY_CALL require(bool)(TMP_470)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-BinaryOption-onlyNamiMultisig()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == namiMultiSigWallet)

IRs:
TMP_472(bool) = msg.sender == namiMultiSigWallet
TMP_473(None) = SOLIDITY_CALL require(bool)(TMP_472)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-BinaryOption-openSession()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(session.isReset && ! session.isOpen)

IRs:
REF_346(bool) -> session.isReset
REF_347(bool) -> session.isOpen
TMP_407 = UnaryType.BANG REF_347 
TMP_408(bool) = REF_346 && TMP_407
TMP_409(None) = SOLIDITY_CALL require(bool)(TMP_408)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
session.isReset = false

IRs:
REF_348(bool) -> session.isReset
REF_348(bool) (->session) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
session.investOpen = true

IRs:
REF_349(bool) -> session.investOpen
REF_349(bool) (->session) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
session.timeOpen = now

IRs:
REF_350(uint256) -> session.timeOpen
REF_350(uint256) (->session) := now(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
session.isOpen = true

IRs:
REF_351(bool) -> session.isOpen
REF_351(bool) (->session) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
SessionOpen(now,sessionId)

IRs:
Emit SessionOpen(now,sessionId)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
7->1;
}
// Function: 21144.sol-BinaryOption-resetSession()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! session.isReset && ! session.isOpen)

IRs:
REF_332(bool) -> session.isReset
TMP_400 = UnaryType.BANG REF_332 
REF_333(bool) -> session.isOpen
TMP_401 = UnaryType.BANG REF_333 
TMP_402(bool) = TMP_400 && TMP_401
TMP_403(None) = SOLIDITY_CALL require(bool)(TMP_402)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
session.priceOpen = 0

IRs:
REF_334(uint256) -> session.priceOpen
REF_334(uint256) (->session) := 0(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
session.priceClose = 0

IRs:
REF_335(uint256) -> session.priceClose
REF_335(uint256) (->session) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
session.isReset = true

IRs:
REF_336(bool) -> session.isReset
REF_336(bool) (->session) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
session.isOpen = false

IRs:
REF_337(bool) -> session.isOpen
REF_337(bool) (->session) := False(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
session.investOpen = false

IRs:
REF_338(bool) -> session.investOpen
REF_338(bool) (->session) := False(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
session.investorCount = 0

IRs:
REF_339(uint256) -> session.investorCount
REF_339(uint256) (->session) := 0(uint256)"];
7->10;
8[label="Node Type: BEGIN_LOOP 8
"];
8->11;
9[label="Node Type: END_LOOP 9
"];
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
10->8;
11[label="Node Type: IF_LOOP 11

EXPRESSION:
i < MAX_INVESTOR

IRs:
TMP_404(bool) = i < MAX_INVESTOR
CONDITION TMP_404"];
11->12[label="True"];
11->9[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
session.investor[i] = 0x0

IRs:
REF_340(mapping(uint256 => address)) -> session.investor
REF_341(address) -> REF_340[i]
REF_341(address) (->session) := 0(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
session.win[i] = false

IRs:
REF_342(mapping(uint256 => bool)) -> session.win
REF_343(bool) -> REF_342[i]
REF_343(bool) (->session) := False(bool)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
session.amountInvest[i] = 0

IRs:
REF_344(mapping(uint256 => uint256)) -> session.amountInvest
REF_345(uint256) -> REF_344[i]
REF_345(uint256) (->session) := 0(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
i ++

IRs:
TMP_405(uint256) := i(uint256)
i(uint256) = i + 1"];
15->11;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
16->1;
}
// Function: 21144.sol-BinaryOption-safeWithdraw(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
namiWallet = NamiMultiSigWallet(namiMultiSigWallet)

IRs:
TMP_390 = CONVERT namiMultiSigWallet to NamiMultiSigWallet
namiWallet(NamiMultiSigWallet) := TMP_390(NamiMultiSigWallet)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
namiWallet.isOwner(_withdraw)

IRs:
TMP_391(bool) = HIGH_LEVEL_CALL, dest:namiWallet(NamiMultiSigWallet), function:isOwner, arguments:['_withdraw']  
CONDITION TMP_391"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_withdraw.transfer(_amount)

IRs:
Transfer dest:_withdraw value:_amount"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
5->1;
}
// Function: 21144.sol-BinaryOption-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_INVESTOR = 20

IRs:
MAX_INVESTOR(uint256) := 20(uint256)"];
}
// Function: 21144.sol-BinaryOption-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
timeInvestInMinute = 15

IRs:
timeInvestInMinute(uint256) := 15(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
timeOneSession = 20

IRs:
timeOneSession(uint256) := 20(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
sessionId = 1

IRs:
sessionId(uint256) := 1(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
rateWin = 100

IRs:
rateWin(uint256) := 100(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
rateLoss = 20

IRs:
rateLoss(uint256) := 20(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
rateFee = 5

IRs:
rateFee(uint256) := 5(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
minimunEth = 10000000000000000

IRs:
minimunEth(uint256) := 10000000000000000(uint256)"];
}
// Function: 21144.sol-BinaryOption-withdrawEther(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(namiMultiSigWallet != 0x0)

IRs:
TMP_385(bool) = namiMultiSigWallet != 0
TMP_386(None) = SOLIDITY_CALL require(bool)(TMP_385)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
this.balance > 0

IRs:
REF_319(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_387(bool) = REF_319 > 0
CONDITION TMP_387"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
namiMultiSigWallet.transfer(_amount)

IRs:
Transfer dest:namiMultiSigWallet value:_amount"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, BinaryOption.onlyEscrow()()"];
5->1;
}
// Function: 21144.sol-ERC223ReceivingContract-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 21144.sol-ERC223ReceivingContract-tokenFallbackBuyer(address,uint256,address)
digraph{
}
// Function: 21144.sol-ERC223ReceivingContract-tokenFallbackExchange(address,uint256,uint256)
digraph{
}
// Function: 21144.sol-ERC23-balanceOf(address)
digraph{
}
// Function: 21144.sol-ERC23-transfer(address,uint256)
digraph{
}
// Function: 21144.sol-NamiCrowdSale-NamiCrowdSale(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_namiMultiSigWallet != 0x0)

IRs:
TMP_191(bool) = _namiMultiSigWallet != 0
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
escrow = _escrow

IRs:
escrow(address) := _escrow(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
namiMultiSigWallet = _namiMultiSigWallet

IRs:
namiMultiSigWallet(address) := _namiMultiSigWallet(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
namiPresale = _namiPresale

IRs:
namiPresale(address) := _namiPresale(address)"];
}
// Function: 21144.sol-NamiCrowdSale-_migrateToken(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
presale = PresaleToken(namiPresale)

IRs:
TMP_319 = CONVERT namiPresale to PresaleToken
presale(PresaleToken) := TMP_319(PresaleToken)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newToken = presale.balanceOf(_from)

IRs:
TMP_320(uint256) = HIGH_LEVEL_CALL, dest:presale(PresaleToken), function:balanceOf, arguments:['_from']  
newToken(uint256) := TMP_320(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(newToken > 0)

IRs:
TMP_321(bool) = newToken > 0
TMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
presale.burnTokens(_from)

IRs:
HIGH_LEVEL_CALL, dest:presale(PresaleToken), function:burnTokens, arguments:['_from']  "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_to] = balanceOf[_to].add(newToken)

IRs:
REF_295(uint256) -> balanceOf[_to]
REF_296(uint256) -> balanceOf[_to]
TMP_324(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_296', 'newToken'] 
REF_295(uint256) (->balanceOf) := TMP_324(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalSupply = totalSupply.add(newToken)

IRs:
TMP_325(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', 'newToken'] 
totalSupply(uint256) := TMP_325(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
LogMigrate(_from,_to,newToken)

IRs:
Emit LogMigrate(_from,_to,newToken)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(this,_to,newToken)

IRs:
Emit Transfer(this,_to,newToken)"];
}
// Function: 21144.sol-NamiCrowdSale-_transfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_193(bool) = _to != 0
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_251(uint256) -> balanceOf[_from]
TMP_195(bool) = REF_251 >= _value
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_252(uint256) -> balanceOf[_to]
TMP_197(uint256) = REF_252 + _value
REF_253(uint256) -> balanceOf[_to]
TMP_198(bool) = TMP_197 > REF_253
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_254(uint256) -> balanceOf[_from]
REF_255(uint256) -> balanceOf[_to]
TMP_200(uint256) = REF_254 + REF_255
previousBalances(uint256) := TMP_200(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_256(uint256) -> balanceOf[_from]
REF_256(-> balanceOf) = REF_256 - _value"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_257(uint256) -> balanceOf[_to]
REF_257(-> balanceOf) = REF_257 + _value"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_258(uint256) -> balanceOf[_from]
REF_259(uint256) -> balanceOf[_to]
TMP_202(uint256) = REF_258 + REF_259
TMP_203(bool) = TMP_202 == previousBalances
TMP_204(None) = SOLIDITY_CALL assert(bool)(TMP_203)"];
}
// Function: 21144.sol-NamiCrowdSale-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowance[msg.sender][_spender] = _value

IRs:
REF_264(mapping(address => uint256)) -> allowance[msg.sender]
REF_265(uint256) -> REF_264[_spender]
REF_265(uint256) (->allowance) := _value(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyTranferable()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyTranferable()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 21144.sol-NamiCrowdSale-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_214 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_214(tokenRecipient)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_215(bool) = INTERNAL_CALL, NamiCrowdSale.approve(address,uint256)(_spender,_value)
CONDITION TMP_215"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  "];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: END_IF 5
"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyTranferable()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyTranferable()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 21144.sol-NamiCrowdSale-burnTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(currentPhase == Phase.Migrating)

IRs:
REF_272(NamiCrowdSale.Phase) -> Phase.Migrating
TMP_270(bool) = currentPhase == REF_272
TMP_271(None) = SOLIDITY_CALL require(bool)(TMP_270)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tokens = balanceOf[_owner]

IRs:
REF_273(uint256) -> balanceOf[_owner]
tokens(uint256) := REF_273(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(tokens != 0)

IRs:
TMP_272(bool) = tokens != 0
TMP_273(None) = SOLIDITY_CALL require(bool)(TMP_272)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[_owner] = 0

IRs:
REF_274(uint256) -> balanceOf[_owner]
REF_274(uint256) (->balanceOf) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= tokens

IRs:
totalSupply(uint256) = totalSupply - tokens"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
LogBurn(_owner,tokens)

IRs:
Emit LogBurn(_owner,tokens)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_owner,crowdsaleManager,tokens)

IRs:
Emit Transfer(_owner,crowdsaleManager,tokens)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
totalSupply == 0

IRs:
TMP_276(bool) = totalSupply == 0
CONDITION TMP_276"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
currentPhase = Phase.Migrated

IRs:
REF_275(NamiCrowdSale.Phase) -> Phase.Migrated
currentPhase(NamiCrowdSale.Phase) := REF_275(NamiCrowdSale.Phase)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
LogPhaseSwitch(Phase.Migrated)

IRs:
REF_276(NamiCrowdSale.Phase) -> Phase.Migrated
Emit LogPhaseSwitch(REF_276)"];
10->11;
11[label="Node Type: END_IF 11
"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onlyCrowdsaleManager()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyCrowdsaleManager()()"];
12->1;
}
// Function: 21144.sol-NamiCrowdSale-buy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(currentPhase == Phase.Running)

IRs:
REF_267(NamiCrowdSale.Phase) -> Phase.Running
TMP_253(bool) = currentPhase == REF_267
TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now <= 1522281600 || msg.sender == binaryAddress)

IRs:
TMP_255(bool) = now <= 1522281600
TMP_256(bool) = msg.sender == binaryAddress
TMP_257(bool) = TMP_255 || TMP_256
TMP_258(None) = SOLIDITY_CALL require(bool)(TMP_257)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value != 0)

IRs:
TMP_259(bool) = msg.value != 0
TMP_260(None) = SOLIDITY_CALL require(bool)(TMP_259)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
newTokens = msg.value * getPrice()

IRs:
TMP_261(uint256) = INTERNAL_CALL, NamiCrowdSale.getPrice()()
TMP_262(uint256) = msg.value * TMP_261
newTokens(uint256) := TMP_262(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(totalSupply + newTokens < TOKEN_SUPPLY_LIMIT)

IRs:
TMP_263(uint256) = totalSupply + newTokens
TMP_264(bool) = TMP_263 < TOKEN_SUPPLY_LIMIT
TMP_265(None) = SOLIDITY_CALL require(bool)(TMP_264)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_buyer] = balanceOf[_buyer].add(newTokens)

IRs:
REF_268(uint256) -> balanceOf[_buyer]
REF_269(uint256) -> balanceOf[_buyer]
TMP_266(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_269', 'newTokens'] 
REF_268(uint256) (->balanceOf) := TMP_266(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
totalSupply = totalSupply.add(newTokens)

IRs:
TMP_267(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', 'newTokens'] 
totalSupply(uint256) := TMP_267(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
LogBuy(_buyer,newTokens)

IRs:
Emit LogBuy(_buyer,newTokens)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(this,_buyer,newTokens)

IRs:
Emit Transfer(this,_buyer,newTokens)"];
}
// Function: 21144.sol-NamiCrowdSale-changeBinary(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
binary = _binary

IRs:
binary(uint256) := _binary(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
2->1;
}
// Function: 21144.sol-NamiCrowdSale-changeBinaryAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_binaryAddress != 0x0)

IRs:
TMP_224(bool) = _binaryAddress != 0
TMP_225(None) = SOLIDITY_CALL require(bool)(TMP_224)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
binaryAddress = _binaryAddress

IRs:
binaryAddress(address) := _binaryAddress(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-NamiCrowdSale-changeEscrow(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_escrow != 0x0)

IRs:
TMP_220(bool) = _escrow != 0
TMP_221(None) = SOLIDITY_CALL require(bool)(TMP_220)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
escrow = _escrow

IRs:
escrow(address) := _escrow(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyNamiMultisig()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyNamiMultisig()()"];
3->1;
}
// Function: 21144.sol-NamiCrowdSale-changeTransferable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
TRANSFERABLE = ! TRANSFERABLE

IRs:
TMP_218 = UnaryType.BANG TRANSFERABLE 
TRANSFERABLE(bool) := TMP_218(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
2->1;
}
// Function: 21144.sol-NamiCrowdSale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buy(msg.sender)

IRs:
INTERNAL_CALL, NamiCrowdSale.buy(address)(msg.sender)"];
}
// Function: 21144.sol-NamiCrowdSale-getPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
now < 1517443200

IRs:
TMP_227(bool) = now < 1517443200
CONDITION TMP_227"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
3450

IRs:
RETURN 3450"];
3[label="Node Type: IF 3

EXPRESSION:
1517443200 < now && now <= 1518048000

IRs:
TMP_228(bool) = 1517443200 < now
TMP_229(bool) = now <= 1518048000
TMP_230(bool) = TMP_228 && TMP_229
CONDITION TMP_230"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
2400

IRs:
RETURN 2400"];
5[label="Node Type: IF 5

EXPRESSION:
1518048000 < now && now <= 1518652800

IRs:
TMP_231(bool) = 1518048000 < now
TMP_232(bool) = now <= 1518652800
TMP_233(bool) = TMP_231 && TMP_232
CONDITION TMP_233"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
2300

IRs:
RETURN 2300"];
7[label="Node Type: IF 7

EXPRESSION:
1518652800 < now && now <= 1519257600

IRs:
TMP_234(bool) = 1518652800 < now
TMP_235(bool) = now <= 1519257600
TMP_236(bool) = TMP_234 && TMP_235
CONDITION TMP_236"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
2200

IRs:
RETURN 2200"];
9[label="Node Type: IF 9

EXPRESSION:
1519257600 < now && now <= 1519862400

IRs:
TMP_237(bool) = 1519257600 < now
TMP_238(bool) = now <= 1519862400
TMP_239(bool) = TMP_237 && TMP_238
CONDITION TMP_239"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
2100

IRs:
RETURN 2100"];
11[label="Node Type: IF 11

EXPRESSION:
1519862400 < now && now <= 1520467200

IRs:
TMP_240(bool) = 1519862400 < now
TMP_241(bool) = now <= 1520467200
TMP_242(bool) = TMP_240 && TMP_241
CONDITION TMP_242"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: RETURN 12

EXPRESSION:
2000

IRs:
RETURN 2000"];
13[label="Node Type: IF 13

EXPRESSION:
1520467200 < now && now <= 1521072000

IRs:
TMP_243(bool) = 1520467200 < now
TMP_244(bool) = now <= 1521072000
TMP_245(bool) = TMP_243 && TMP_244
CONDITION TMP_245"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: RETURN 14

EXPRESSION:
1900

IRs:
RETURN 1900"];
15[label="Node Type: IF 15

EXPRESSION:
1521072000 < now && now <= 1521676800

IRs:
TMP_246(bool) = 1521072000 < now
TMP_247(bool) = now <= 1521676800
TMP_248(bool) = TMP_246 && TMP_247
CONDITION TMP_248"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: RETURN 16

EXPRESSION:
1800

IRs:
RETURN 1800"];
17[label="Node Type: IF 17

EXPRESSION:
1521676800 < now && now <= 1522281600

IRs:
TMP_249(bool) = 1521676800 < now
TMP_250(bool) = now <= 1522281600
TMP_251(bool) = TMP_249 && TMP_250
CONDITION TMP_251"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: RETURN 18

EXPRESSION:
1700

IRs:
RETURN 1700"];
19[label="Node Type: RETURN 19

EXPRESSION:
binary

IRs:
RETURN binary"];
29[label="Node Type: RETURN 29

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 21144.sol-NamiCrowdSale-migrateForInvestor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_migrateToken(msg.sender,msg.sender)

IRs:
INTERNAL_CALL, NamiCrowdSale._migrateToken(address,address)(msg.sender,msg.sender)"];
}
// Function: 21144.sol-NamiCrowdSale-migrateToken(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_migrateToken(_from,_to)

IRs:
INTERNAL_CALL, NamiCrowdSale._migrateToken(address,address)(_from,_to)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
2->1;
}
// Function: 21144.sol-NamiCrowdSale-onlyCrowdsaleManager()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == crowdsaleManager)

IRs:
TMP_347(bool) = msg.sender == crowdsaleManager
TMP_348(None) = SOLIDITY_CALL require(bool)(TMP_347)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiCrowdSale-onlyEscrow()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == escrow)

IRs:
TMP_349(bool) = msg.sender == escrow
TMP_350(None) = SOLIDITY_CALL require(bool)(TMP_349)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiCrowdSale-onlyNamiMultisig()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == namiMultiSigWallet)

IRs:
TMP_352(bool) = msg.sender == namiMultiSigWallet
TMP_353(None) = SOLIDITY_CALL require(bool)(TMP_352)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiCrowdSale-onlyTranferable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(TRANSFERABLE)

IRs:
TMP_351(None) = SOLIDITY_CALL require(bool)(TRANSFERABLE)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiCrowdSale-safeWithdraw(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
namiWallet = NamiMultiSigWallet(namiMultiSigWallet)

IRs:
TMP_312 = CONVERT namiMultiSigWallet to NamiMultiSigWallet
namiWallet(NamiMultiSigWallet) := TMP_312(NamiMultiSigWallet)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
namiWallet.isOwner(_withdraw)

IRs:
TMP_313(bool) = HIGH_LEVEL_CALL, dest:namiWallet(NamiMultiSigWallet), function:isOwner, arguments:['_withdraw']  
CONDITION TMP_313"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_withdraw.transfer(_amount)

IRs:
Transfer dest:_withdraw value:_amount"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
5->1;
}
// Function: 21144.sol-NamiCrowdSale-setCrowdsaleManager(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(currentPhase != Phase.Migrating)

IRs:
REF_292(NamiCrowdSale.Phase) -> Phase.Migrating
TMP_316(bool) = currentPhase != REF_292
TMP_317(None) = SOLIDITY_CALL require(bool)(TMP_316)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
crowdsaleManager = _mgr

IRs:
crowdsaleManager(address) := _mgr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-NamiCrowdSale-setPresalePhase(NamiCrowdSale.Phase)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
canSwitchPhase = (currentPhase == Phase.Created && _nextPhase == Phase.Running) || (currentPhase == Phase.Running && _nextPhase == Phase.Paused) || ((currentPhase == Phase.Running || currentPhase == Phase.Paused) && _nextPhase == Phase.Migrating && crowdsaleManager != 0x0) || (currentPhase == Phase.Paused && _nextPhase == Phase.Running) || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated && totalSupply == 0)

IRs:
REF_277(NamiCrowdSale.Phase) -> Phase.Created
TMP_279(bool) = currentPhase == REF_277
REF_278(NamiCrowdSale.Phase) -> Phase.Running
TMP_280(bool) = _nextPhase == REF_278
TMP_281(bool) = TMP_279 && TMP_280
REF_279(NamiCrowdSale.Phase) -> Phase.Running
TMP_282(bool) = currentPhase == REF_279
REF_280(NamiCrowdSale.Phase) -> Phase.Paused
TMP_283(bool) = _nextPhase == REF_280
TMP_284(bool) = TMP_282 && TMP_283
TMP_285(bool) = TMP_281 || TMP_284
REF_281(NamiCrowdSale.Phase) -> Phase.Running
TMP_286(bool) = currentPhase == REF_281
REF_282(NamiCrowdSale.Phase) -> Phase.Paused
TMP_287(bool) = currentPhase == REF_282
TMP_288(bool) = TMP_286 || TMP_287
REF_283(NamiCrowdSale.Phase) -> Phase.Migrating
TMP_289(bool) = _nextPhase == REF_283
TMP_290(bool) = TMP_288 && TMP_289
TMP_291(bool) = crowdsaleManager != 0
TMP_292(bool) = TMP_290 && TMP_291
TMP_293(bool) = TMP_285 || TMP_292
REF_284(NamiCrowdSale.Phase) -> Phase.Paused
TMP_294(bool) = currentPhase == REF_284
REF_285(NamiCrowdSale.Phase) -> Phase.Running
TMP_295(bool) = _nextPhase == REF_285
TMP_296(bool) = TMP_294 && TMP_295
TMP_297(bool) = TMP_293 || TMP_296
REF_286(NamiCrowdSale.Phase) -> Phase.Migrating
TMP_298(bool) = currentPhase == REF_286
REF_287(NamiCrowdSale.Phase) -> Phase.Migrated
TMP_299(bool) = _nextPhase == REF_287
TMP_300(bool) = TMP_298 && TMP_299
TMP_301(bool) = totalSupply == 0
TMP_302(bool) = TMP_300 && TMP_301
TMP_303(bool) = TMP_297 || TMP_302
canSwitchPhase(bool) := TMP_303(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(canSwitchPhase)

IRs:
TMP_304(None) = SOLIDITY_CALL require(bool)(canSwitchPhase)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
currentPhase = _nextPhase

IRs:
currentPhase(NamiCrowdSale.Phase) := _nextPhase(NamiCrowdSale.Phase)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
LogPhaseSwitch(_nextPhase)

IRs:
Emit LogPhaseSwitch(_nextPhase)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
5->1;
}
// Function: 21144.sol-NamiCrowdSale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
TOKEN_SUPPLY_LIMIT = 1000000000 * (1000000000000000000 / 1)

IRs:
TMP_345(uint256) = 1000000000000000000 / 1
TMP_346(uint256) = 1000000000 * TMP_345
TOKEN_SUPPLY_LIMIT(uint256) := TMP_346(uint256)"];
}
// Function: 21144.sol-NamiCrowdSale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Nami ICO

IRs:
name(string) := Nami ICO(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = NAC

IRs:
symbol(string) := NAC(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint256) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TRANSFERABLE = false

IRs:
TRANSFERABLE(bool) := False(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
binary = 0

IRs:
binary(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
currentPhase = Phase.Created

IRs:
REF_313(NamiCrowdSale.Phase) -> Phase.Created
currentPhase(NamiCrowdSale.Phase) := REF_313(NamiCrowdSale.Phase)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
}
// Function: 21144.sol-NamiCrowdSale-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transfer(msg.sender,_to,_value)

IRs:
INTERNAL_CALL, NamiCrowdSale._transfer(address,address,uint256)(msg.sender,_to,_value)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyTranferable()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyTranferable()()"];
2->1;
}
// Function: 21144.sol-NamiCrowdSale-transferForTeam(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transfer(msg.sender,_to,_value)

IRs:
INTERNAL_CALL, NamiCrowdSale._transfer(address,address,uint256)(msg.sender,_to,_value)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
2->1;
}
// Function: 21144.sol-NamiCrowdSale-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_260(mapping(address => uint256)) -> allowance[_from]
REF_261(uint256) -> REF_260[msg.sender]
TMP_209(bool) = _value <= REF_261
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_262(mapping(address => uint256)) -> allowance[_from]
REF_263(uint256) -> REF_262[msg.sender]
REF_263(-> allowance) = REF_263 - _value"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_transfer(_from,_to,_value)

IRs:
INTERNAL_CALL, NamiCrowdSale._transfer(address,address,uint256)(_from,_to,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyTranferable()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyTranferable()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 21144.sol-NamiCrowdSale-transferToBuyer(address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value)

IRs:
REF_306(uint256) -> balanceOf[msg.sender]
REF_307(uint256) -> balanceOf[msg.sender]
TMP_338(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_307', '_value'] 
REF_306(uint256) (->balanceOf) := TMP_338(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_to] = balanceOf[_to].add(_value)

IRs:
REF_309(uint256) -> balanceOf[_to]
REF_310(uint256) -> balanceOf[_to]
TMP_339(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_310', '_value'] 
REF_309(uint256) (->balanceOf) := TMP_339(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
codeLength > 0

IRs:
TMP_341(bool) = codeLength > 0
CONDITION TMP_341"];
7->8[label="True"];
7->11[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_342 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_342(ERC223ReceivingContract)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
receiver.tokenFallbackBuyer(msg.sender,_value,_buyer)

IRs:
TMP_343(bool) = HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallbackBuyer, arguments:['msg.sender', '_value', '_buyer']  "];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
TransferToBuyer(msg.sender,_to,_value,_buyer)

IRs:
Emit TransferToBuyer(msg.sender,_to,_value,_buyer)"];
10->11;
11[label="Node Type: END_IF 11
"];
}
// Function: 21144.sol-NamiCrowdSale-transferToExchange(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value)

IRs:
REF_299(uint256) -> balanceOf[msg.sender]
REF_300(uint256) -> balanceOf[msg.sender]
TMP_331(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_300', '_value'] 
REF_299(uint256) (->balanceOf) := TMP_331(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_to] = balanceOf[_to].add(_value)

IRs:
REF_302(uint256) -> balanceOf[_to]
REF_303(uint256) -> balanceOf[_to]
TMP_332(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_303', '_value'] 
REF_302(uint256) (->balanceOf) := TMP_332(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
codeLength > 0

IRs:
TMP_334(bool) = codeLength > 0
CONDITION TMP_334"];
7->8[label="True"];
7->11[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_335 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_335(ERC223ReceivingContract)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
receiver.tokenFallbackExchange(msg.sender,_value,_price)

IRs:
TMP_336(bool) = HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallbackExchange, arguments:['msg.sender', '_value', '_price']  "];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
TransferToExchange(msg.sender,_to,_value,_price)

IRs:
Emit TransferToExchange(msg.sender,_to,_value,_price)"];
10->11;
11[label="Node Type: END_IF 11
"];
}
// Function: 21144.sol-NamiCrowdSale-withdrawEther(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(namiMultiSigWallet != 0x0)

IRs:
TMP_307(bool) = namiMultiSigWallet != 0
TMP_308(None) = SOLIDITY_CALL require(bool)(TMP_307)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
this.balance > 0

IRs:
REF_288(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_309(bool) = REF_288 > 0
CONDITION TMP_309"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
namiMultiSigWallet.transfer(_amount)

IRs:
Transfer dest:namiMultiSigWallet value:_amount"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiCrowdSale.onlyEscrow()()"];
5->1;
}
// Function: 21144.sol-NamiExchange-NamiExchange(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
NamiAddr = _namiAddress

IRs:
NamiAddr(address) := _namiAddress(address)"];
}
// Function: 21144.sol-NamiExchange-buyNac(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)

IRs:
TMP_544(bool) = msg.value > 0
REF_492(NamiExchange.OrderAsk) -> ask[_seller]
REF_493(uint256) -> REF_492.volume
TMP_545(bool) = REF_493 > 0
TMP_546(bool) = TMP_544 && TMP_545
REF_494(NamiExchange.OrderAsk) -> ask[_seller]
REF_495(uint256) -> REF_494.price
TMP_547(bool) = REF_495 > 0
TMP_548(bool) = TMP_546 && TMP_547
TMP_549(None) = SOLIDITY_CALL require(bool)(TMP_548)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_price == ask[_seller].price && _seller != msg.sender)

IRs:
REF_496(NamiExchange.OrderAsk) -> ask[_seller]
REF_497(uint256) -> REF_496.price
TMP_550(bool) = _price == REF_497
TMP_551(bool) = _seller != msg.sender
TMP_552(bool) = TMP_550 && TMP_551
TMP_553(None) = SOLIDITY_CALL require(bool)(TMP_552)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
namiToken = NamiCrowdSale(NamiAddr)

IRs:
TMP_554 = CONVERT NamiAddr to NamiCrowdSale
namiToken(NamiCrowdSale) := TMP_554(NamiCrowdSale)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
maxEth = (ask[_seller].volume).div(ask[_seller].price)

IRs:
REF_498(NamiExchange.OrderAsk) -> ask[_seller]
REF_499(uint256) -> REF_498.volume
REF_501(NamiExchange.OrderAsk) -> ask[_seller]
REF_502(uint256) -> REF_501.price
TMP_555(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_499', 'REF_502'] 
maxEth(uint256) := TMP_555(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
previousBalances = namiToken.balanceOf(msg.sender)

IRs:
TMP_556(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['msg.sender']  
previousBalances(uint256) := TMP_556(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
msg.value > maxEth

IRs:
TMP_557(bool) = msg.value > maxEth
CONDITION TMP_557"];
6->7[label="True"];
6->16[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
_seller.send(maxEth) && msg.sender.send(msg.value.sub(maxEth))

IRs:
TMP_558 = SEND dest:_seller value:maxEth
TMP_559(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'maxEth'] 
TMP_560 = SEND dest:msg.sender value:TMP_559
TMP_561(bool) = TMP_558 && TMP_560
CONDITION TMP_561"];
7->8[label="True"];
7->14[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
namiToken.transfer(msg.sender,ask[_seller].volume)

IRs:
REF_508(NamiExchange.OrderAsk) -> ask[_seller]
REF_509(uint256) -> REF_508.volume
HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:transfer, arguments:['msg.sender', 'REF_509']  "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
SellHistory(_seller,msg.sender,ask[_seller].price,ask[_seller].volume,now)

IRs:
REF_510(NamiExchange.OrderAsk) -> ask[_seller]
REF_511(uint256) -> REF_510.price
REF_512(NamiExchange.OrderAsk) -> ask[_seller]
REF_513(uint256) -> REF_512.volume
Emit SellHistory(_seller,msg.sender,REF_511,REF_513,now)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
ask[_seller].volume = 0

IRs:
REF_514(NamiExchange.OrderAsk) -> ask[_seller]
REF_515(uint256) -> REF_514.volume
REF_515(uint256) (->ask) := 0(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
UpdateAsk(_seller,ask[_seller].price,0)

IRs:
REF_516(NamiExchange.OrderAsk) -> ask[_seller]
REF_517(uint256) -> REF_516.price
Emit UpdateAsk(_seller,REF_517,0)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
assert(bool)(previousBalances < namiToken.balanceOf(msg.sender))

IRs:
TMP_565(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['msg.sender']  
TMP_566(bool) = previousBalances < TMP_565
TMP_567(None) = SOLIDITY_CALL assert(bool)(TMP_566)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
revert()()

IRs:
TMP_568(None) = SOLIDITY_CALL revert()()"];
14->15;
15[label="Node Type: END_IF 15
"];
15->26;
16[label="Node Type: NEW VARIABLE 16

EXPRESSION:
nac = (msg.value).mul(ask[_seller].price)

IRs:
REF_520(NamiExchange.OrderAsk) -> ask[_seller]
REF_521(uint256) -> REF_520.price
TMP_569(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'REF_521'] 
nac(uint256) := TMP_569(uint256)"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
_seller.send(msg.value)

IRs:
TMP_570 = SEND dest:_seller value:msg.value
CONDITION TMP_570"];
17->18[label="True"];
17->24[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
namiToken.transfer(msg.sender,nac)

IRs:
HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:transfer, arguments:['msg.sender', 'nac']  "];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
ask[_seller].volume = (ask[_seller].volume).sub(nac)

IRs:
REF_524(NamiExchange.OrderAsk) -> ask[_seller]
REF_525(uint256) -> REF_524.volume
REF_526(NamiExchange.OrderAsk) -> ask[_seller]
REF_527(uint256) -> REF_526.volume
TMP_572(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_527', 'nac'] 
REF_525(uint256) (->ask) := TMP_572(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
UpdateAsk(_seller,ask[_seller].price,ask[_seller].volume)

IRs:
REF_529(NamiExchange.OrderAsk) -> ask[_seller]
REF_530(uint256) -> REF_529.price
REF_531(NamiExchange.OrderAsk) -> ask[_seller]
REF_532(uint256) -> REF_531.volume
Emit UpdateAsk(_seller,REF_530,REF_532)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
SellHistory(_seller,msg.sender,ask[_seller].price,nac,now)

IRs:
REF_533(NamiExchange.OrderAsk) -> ask[_seller]
REF_534(uint256) -> REF_533.price
Emit SellHistory(_seller,msg.sender,REF_534,nac,now)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
assert(bool)(previousBalances < namiToken.balanceOf(msg.sender))

IRs:
TMP_575(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['msg.sender']  
TMP_576(bool) = previousBalances < TMP_575
TMP_577(None) = SOLIDITY_CALL assert(bool)(TMP_576)"];
22->23;
23[label="Node Type: RETURN 23

EXPRESSION:
true

IRs:
RETURN True"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
revert()()

IRs:
TMP_578(None) = SOLIDITY_CALL revert()()"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: RETURN 27

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 21144.sol-NamiExchange-closeAskOrder()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ask[msg.sender].volume > 0 && ask[msg.sender].price > 0)

IRs:
REF_479(NamiExchange.OrderAsk) -> ask[msg.sender]
REF_480(uint256) -> REF_479.volume
TMP_533(bool) = REF_480 > 0
REF_481(NamiExchange.OrderAsk) -> ask[msg.sender]
REF_482(uint256) -> REF_481.price
TMP_534(bool) = REF_482 > 0
TMP_535(bool) = TMP_533 && TMP_534
TMP_536(None) = SOLIDITY_CALL require(bool)(TMP_535)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
namiToken = NamiCrowdSale(NamiAddr)

IRs:
TMP_537 = CONVERT NamiAddr to NamiCrowdSale
namiToken(NamiCrowdSale) := TMP_537(NamiCrowdSale)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalances = namiToken.balanceOf(msg.sender)

IRs:
TMP_538(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['msg.sender']  
previousBalances(uint256) := TMP_538(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
namiToken.transfer(msg.sender,ask[msg.sender].volume)

IRs:
REF_485(NamiExchange.OrderAsk) -> ask[msg.sender]
REF_486(uint256) -> REF_485.volume
HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:transfer, arguments:['msg.sender', 'REF_486']  "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ask[msg.sender].volume = 0

IRs:
REF_487(NamiExchange.OrderAsk) -> ask[msg.sender]
REF_488(uint256) -> REF_487.volume
REF_488(uint256) (->ask) := 0(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
UpdateAsk(msg.sender,ask[msg.sender].price,0)

IRs:
REF_489(NamiExchange.OrderAsk) -> ask[msg.sender]
REF_490(uint256) -> REF_489.price
Emit UpdateAsk(msg.sender,REF_490,0)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(previousBalances < namiToken.balanceOf(msg.sender))

IRs:
TMP_541(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['msg.sender']  
TMP_542(bool) = previousBalances < TMP_541
TMP_543(None) = SOLIDITY_CALL assert(bool)(TMP_542)"];
}
// Function: 21144.sol-NamiExchange-closeBidOrder()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bid[msg.sender].eth > 0 && bid[msg.sender].price > 0)

IRs:
REF_455(NamiExchange.OrderBid) -> bid[msg.sender]
REF_456(uint256) -> REF_455.eth
TMP_517(bool) = REF_456 > 0
REF_457(NamiExchange.OrderBid) -> bid[msg.sender]
REF_458(uint256) -> REF_457.price
TMP_518(bool) = REF_458 > 0
TMP_519(bool) = TMP_517 && TMP_518
TMP_520(None) = SOLIDITY_CALL require(bool)(TMP_519)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(bid[msg.sender].eth)

IRs:
REF_460(NamiExchange.OrderBid) -> bid[msg.sender]
REF_461(uint256) -> REF_460.eth
Transfer dest:msg.sender value:REF_461"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bid[msg.sender].eth = 0

IRs:
REF_462(NamiExchange.OrderBid) -> bid[msg.sender]
REF_463(uint256) -> REF_462.eth
REF_463(uint256) (->bid) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
UpdateBid(msg.sender,bid[msg.sender].price,bid[msg.sender].eth)

IRs:
REF_464(NamiExchange.OrderBid) -> bid[msg.sender]
REF_465(uint256) -> REF_464.price
REF_466(NamiExchange.OrderBid) -> bid[msg.sender]
REF_467(uint256) -> REF_466.eth
Emit UpdateBid(msg.sender,REF_465,REF_467)"];
}
// Function: 21144.sol-NamiExchange-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.data.length != 0)

IRs:
REF_409 -> LENGTH msg.data
TMP_474(bool) = REF_409 != 0
TMP_475(None) = SOLIDITY_CALL require(bool)(TMP_474)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value == 0)

IRs:
TMP_476(bool) = msg.value == 0
TMP_477(None) = SOLIDITY_CALL require(bool)(TMP_476)"];
}
// Function: 21144.sol-NamiExchange-onlyNami()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == NamiAddr)

IRs:
TMP_579(bool) = msg.sender == NamiAddr
TMP_580(None) = SOLIDITY_CALL require(bool)(TMP_579)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiExchange-placeBuyOrder(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_price > 0 && msg.value > 0 && bid[msg.sender].eth == 0)

IRs:
TMP_478(bool) = _price > 0
TMP_479(bool) = msg.value > 0
TMP_480(bool) = TMP_478 && TMP_479
REF_410(NamiExchange.OrderBid) -> bid[msg.sender]
REF_411(uint256) -> REF_410.eth
TMP_481(bool) = REF_411 == 0
TMP_482(bool) = TMP_480 && TMP_481
TMP_483(None) = SOLIDITY_CALL require(bool)(TMP_482)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
msg.value > 0

IRs:
TMP_484(bool) = msg.value > 0
CONDITION TMP_484"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bid[msg.sender].eth = (bid[msg.sender].eth).add(msg.value)

IRs:
REF_412(NamiExchange.OrderBid) -> bid[msg.sender]
REF_413(uint256) -> REF_412.eth
REF_414(NamiExchange.OrderBid) -> bid[msg.sender]
REF_415(uint256) -> REF_414.eth
TMP_485(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_415', 'msg.value'] 
REF_413(uint256) (->bid) := TMP_485(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bid[msg.sender].price = _price

IRs:
REF_417(NamiExchange.OrderBid) -> bid[msg.sender]
REF_418(uint256) -> REF_417.price
REF_418(uint256) (->bid) := _price(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
UpdateBid(msg.sender,_price,bid[msg.sender].eth)

IRs:
REF_419(NamiExchange.OrderBid) -> bid[msg.sender]
REF_420(uint256) -> REF_419.eth
Emit UpdateBid(msg.sender,_price,REF_420)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 21144.sol-NamiExchange-sellNac(uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_price == bid[_buyer].price && _buyer != msg.sender)

IRs:
REF_421(NamiExchange.OrderBid) -> bid[_buyer]
REF_422(uint256) -> REF_421.price
TMP_487(bool) = _price == REF_422
TMP_488(bool) = _buyer != msg.sender
TMP_489(bool) = TMP_487 && TMP_488
TMP_490(None) = SOLIDITY_CALL require(bool)(TMP_489)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
namiToken = NamiCrowdSale(NamiAddr)

IRs:
TMP_491 = CONVERT NamiAddr to NamiCrowdSale
namiToken(NamiCrowdSale) := TMP_491(NamiCrowdSale)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
ethOfBuyer = bid[_buyer].eth

IRs:
REF_423(NamiExchange.OrderBid) -> bid[_buyer]
REF_424(uint256) -> REF_423.eth
ethOfBuyer(uint256) := REF_424(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
maxToken = ethOfBuyer.mul(bid[_buyer].price)

IRs:
REF_426(NamiExchange.OrderBid) -> bid[_buyer]
REF_427(uint256) -> REF_426.price
TMP_492(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['ethOfBuyer', 'REF_427'] 
maxToken(uint256) := TMP_492(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(namiToken.allowance(msg.sender,this) >= _value && _value > 0 && ethOfBuyer != 0 && _buyer != 0x0)

IRs:
TMP_493(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:allowance, arguments:['msg.sender', 'this']  
TMP_494(bool) = TMP_493 >= _value
TMP_495(bool) = _value > 0
TMP_496(bool) = TMP_494 && TMP_495
TMP_497(bool) = ethOfBuyer != 0
TMP_498(bool) = TMP_496 && TMP_497
TMP_499(bool) = _buyer != 0
TMP_500(bool) = TMP_498 && TMP_499
TMP_501(None) = SOLIDITY_CALL require(bool)(TMP_500)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
_value > maxToken

IRs:
TMP_502(bool) = _value > maxToken
CONDITION TMP_502"];
6->7[label="True"];
6->14[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
msg.sender.send(ethOfBuyer) && namiToken.transferFrom(msg.sender,_buyer,maxToken)

IRs:
TMP_503 = SEND dest:msg.sender value:ethOfBuyer
TMP_504(bool) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:transferFrom, arguments:['msg.sender', '_buyer', 'maxToken']  
TMP_505(bool) = TMP_503 && TMP_504
CONDITION TMP_505"];
7->8[label="True"];
7->12[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
bid[_buyer].eth = 0

IRs:
REF_431(NamiExchange.OrderBid) -> bid[_buyer]
REF_432(uint256) -> REF_431.eth
REF_432(uint256) (->bid) := 0(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth)

IRs:
REF_433(NamiExchange.OrderBid) -> bid[_buyer]
REF_434(uint256) -> REF_433.price
REF_435(NamiExchange.OrderBid) -> bid[_buyer]
REF_436(uint256) -> REF_435.eth
Emit UpdateBid(_buyer,REF_434,REF_436)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
BuyHistory(_buyer,msg.sender,bid[_buyer].price,maxToken,now)

IRs:
REF_437(NamiExchange.OrderBid) -> bid[_buyer]
REF_438(uint256) -> REF_437.price
Emit BuyHistory(_buyer,msg.sender,REF_438,maxToken,now)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
revert()()

IRs:
TMP_508(None) = SOLIDITY_CALL revert()()"];
12->13;
13[label="Node Type: END_IF 13
"];
13->22;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
eth = _value.div(bid[_buyer].price)

IRs:
REF_440(NamiExchange.OrderBid) -> bid[_buyer]
REF_441(uint256) -> REF_440.price
TMP_509(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_value', 'REF_441'] 
eth(uint256) := TMP_509(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
msg.sender.send(eth) && namiToken.transferFrom(msg.sender,_buyer,_value)

IRs:
TMP_510 = SEND dest:msg.sender value:eth
TMP_511(bool) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:transferFrom, arguments:['msg.sender', '_buyer', '_value']  
TMP_512(bool) = TMP_510 && TMP_511
CONDITION TMP_512"];
15->16[label="True"];
15->20[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
bid[_buyer].eth = (bid[_buyer].eth).sub(eth)

IRs:
REF_444(NamiExchange.OrderBid) -> bid[_buyer]
REF_445(uint256) -> REF_444.eth
REF_446(NamiExchange.OrderBid) -> bid[_buyer]
REF_447(uint256) -> REF_446.eth
TMP_513(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_447', 'eth'] 
REF_445(uint256) (->bid) := TMP_513(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth)

IRs:
REF_449(NamiExchange.OrderBid) -> bid[_buyer]
REF_450(uint256) -> REF_449.price
REF_451(NamiExchange.OrderBid) -> bid[_buyer]
REF_452(uint256) -> REF_451.eth
Emit UpdateBid(_buyer,REF_450,REF_452)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
BuyHistory(_buyer,msg.sender,bid[_buyer].price,_value,now)

IRs:
REF_453(NamiExchange.OrderBid) -> bid[_buyer]
REF_454(uint256) -> REF_453.price
Emit BuyHistory(_buyer,msg.sender,REF_454,_value,now)"];
18->19;
19[label="Node Type: RETURN 19

EXPRESSION:
true

IRs:
RETURN True"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
revert()()

IRs:
TMP_516(None) = SOLIDITY_CALL revert()()"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: RETURN 23

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 21144.sol-NamiExchange-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = NacExchange

IRs:
name(string) := NacExchange(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
price = 1

IRs:
price(uint256) := 1(uint256)"];
}
// Function: 21144.sol-NamiExchange-tokenFallbackExchange(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_price > 0 && _value > 0 && ask[_from].volume == 0)

IRs:
TMP_523(bool) = _price > 0
TMP_524(bool) = _value > 0
TMP_525(bool) = TMP_523 && TMP_524
REF_468(NamiExchange.OrderAsk) -> ask[_from]
REF_469(uint256) -> REF_468.volume
TMP_526(bool) = REF_469 == 0
TMP_527(bool) = TMP_525 && TMP_526
TMP_528(None) = SOLIDITY_CALL require(bool)(TMP_527)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_value > 0

IRs:
TMP_529(bool) = _value > 0
CONDITION TMP_529"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ask[_from].volume = (ask[_from].volume).add(_value)

IRs:
REF_470(NamiExchange.OrderAsk) -> ask[_from]
REF_471(uint256) -> REF_470.volume
REF_472(NamiExchange.OrderAsk) -> ask[_from]
REF_473(uint256) -> REF_472.volume
TMP_530(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_473', '_value'] 
REF_471(uint256) (->ask) := TMP_530(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ask[_from].price = _price

IRs:
REF_475(NamiExchange.OrderAsk) -> ask[_from]
REF_476(uint256) -> REF_475.price
REF_476(uint256) (->ask) := _price(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
UpdateAsk(_from,_price,ask[_from].volume)

IRs:
REF_477(NamiExchange.OrderAsk) -> ask[_from]
REF_478(uint256) -> REF_477.volume
Emit UpdateAsk(_from,_price,REF_478)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyNami()

IRs:
MODIFIER_CALL, NamiExchange.onlyNami()()"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 21144.sol-NamiMultiSigWallet-NamiMultiSigWallet(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->8;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_536 -> LENGTH _owners
TMP_583(bool) = i < REF_536
CONDITION TMP_583"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(! (isOwner[_owners[i]] || _owners[i] == 0))

IRs:
REF_537(address) -> _owners[i]
REF_538(bool) -> isOwner[REF_537]
REF_539(address) -> _owners[i]
TMP_584(bool) = REF_539 == 0
TMP_585(bool) = REF_538 || TMP_584
TMP_586 = UnaryType.BANG TMP_585 
TMP_587(None) = SOLIDITY_CALL require(bool)(TMP_586)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_540(address) -> _owners[i]
REF_541(bool) -> isOwner[REF_540]
REF_541(bool) (->isOwner) := True(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_588(uint256) := i(uint256)
i(uint256) = i + 1"];
7->4;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_542 -> LENGTH _owners
MODIFIER_CALL, NamiMultiSigWallet.validRequirement(uint256,uint256)(REF_542,_required)"];
10->3;
}
// Function: 21144.sol-NamiMultiSigWallet-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_543(bool) -> isOwner[owner]
REF_543(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_545 -> LENGTH owners
TMP_591(uint256) := REF_545(uint256)
TMP_592(uint256) = TMP_591 + 1
REF_545(uint256) (->owners) := TMP_592(uint256)
REF_546(address) -> owners[TMP_591]
REF_546(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, NamiMultiSigWallet.onlyWallet()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.ownerDoesNotExist(address)(owner)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notNull(owner)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.notNull(address)(owner)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
validRequirement(owners.length + 1,required)

IRs:
REF_547 -> LENGTH owners
TMP_597(uint256) = REF_547 + 1
MODIFIER_CALL, NamiMultiSigWallet.validRequirement(uint256,uint256)(TMP_597,required)"];
7->1;
}
// Function: 21144.sol-NamiMultiSigWallet-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = transactionCount

IRs:
transactionId(uint256) := transactionCount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId] = Transaction({destination:destination,value:value,data:data,executed:false})

IRs:
REF_583(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
TMP_640(NamiMultiSigWallet.Transaction) = new Transaction(destination,value,data,False)
REF_583(NamiMultiSigWallet.Transaction) (->transactions) := TMP_640(NamiMultiSigWallet.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactionCount += 1

IRs:
transactionCount(uint256) = transactionCount + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.notNull(address)(destination)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 21144.sol-NamiMultiSigWallet-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, NamiMultiSigWallet.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_562 -> LENGTH owners
MODIFIER_CALL, NamiMultiSigWallet.validRequirement(uint256,uint256)(REF_562,_required)"];
4->1;
}
// Function: 21144.sol-NamiMultiSigWallet-confirmTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_563(mapping(address => bool)) -> confirmations[transactionId]
REF_564(bool) -> REF_563[msg.sender]
REF_564(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, NamiMultiSigWallet.executeTransaction(uint256)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transactionExists(transactionId)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.transactionExists(uint256)(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.notConfirmed(uint256,address)(transactionId,msg.sender)"];
6->1;
}
// Function: 21144.sol-NamiMultiSigWallet-confirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(confirmations[transactionId][owner])

IRs:
REF_612(mapping(address => bool)) -> confirmations[transactionId]
REF_613(bool) -> REF_612[owner]
TMP_681(None) = SOLIDITY_CALL require(bool)(REF_613)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-executeTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_631(bool) = INTERNAL_CALL, NamiMultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_631"];
1->2[label="True"];
1->8[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId].executed = true

IRs:
REF_567(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_568(bool) -> REF_567.executed
REF_568(bool) (->transactions) := True(bool)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)

IRs:
REF_569(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_570(address) -> REF_569.destination
REF_573(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_574(uint256) -> REF_573.value
REF_575(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_576(bytes) -> REF_575.data
TMP_633(bool) = LOW_LEVEL_CALL, dest:REF_570, function:call, arguments:['REF_576'] value:REF_574 
CONDITION TMP_633"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)"];
4->7;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
transactions[transactionId].executed = false

IRs:
REF_577(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_578(bool) -> REF_577.executed
REF_578(bool) (->transactions) := False(bool)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: END_IF 8
"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.notExecuted(uint256)(transactionId)"];
9->1;
}
// Function: 21144.sol-NamiMultiSigWallet-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_581(bool) = msg.value > 0
CONDITION TMP_581"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 21144.sol-NamiMultiSigWallet-getConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_584 -> LENGTH owners
TMP_643(bool) = i < REF_584
CONDITION TMP_643"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_585(mapping(address => bool)) -> confirmations[transactionId]
REF_586(address) -> owners[i]
REF_587(bool) -> REF_585[REF_586]
CONDITION REF_587"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_644(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 21144.sol-NamiMultiSigWallet-getConfirmations(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
confirmationsTemp = new address[](owners.length)

IRs:
REF_592 -> LENGTH owners
TMP_652(address[])  = new address[](REF_592)
confirmationsTemp(address[]) = ['TMP_652(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length

IRs:
REF_593 -> LENGTH owners
TMP_653(bool) = i < REF_593
CONDITION TMP_653"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_594(mapping(address => bool)) -> confirmations[transactionId]
REF_595(address) -> owners[i]
REF_596(bool) -> REF_594[REF_595]
CONDITION REF_596"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
confirmationsTemp[count] = owners[i]

IRs:
REF_597(address) -> confirmationsTemp[count]
REF_598(address) -> owners[i]
REF_597(address) (->confirmationsTemp) := REF_598(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_654(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_confirmations = new address[](count)

IRs:
TMP_656(address[])  = new address[](count)
_confirmations(address[]) = ['TMP_656(address[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < count

IRs:
TMP_657(bool) = i < count
CONDITION TMP_657"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_confirmations[i] = confirmationsTemp[i]

IRs:
REF_599(address) -> _confirmations[i]
REF_600(address) -> confirmationsTemp[i]
REF_599(address) (->_confirmations) := REF_600(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_658(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_confirmations

IRs:
RETURN _confirmations"];
}
// Function: 21144.sol-NamiMultiSigWallet-getOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owners

IRs:
RETURN owners"];
}
// Function: 21144.sol-NamiMultiSigWallet-getTransactionCount(bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < transactionCount

IRs:
TMP_645(bool) = i < transactionCount
CONDITION TMP_645"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_588(NamiMultiSigWallet.Transaction) -> transactions[i]
REF_589(bool) -> REF_588.executed
TMP_646 = UnaryType.BANG REF_589 
TMP_647(bool) = pending && TMP_646
REF_590(NamiMultiSigWallet.Transaction) -> transactions[i]
REF_591(bool) -> REF_590.executed
TMP_648(bool) = executed && REF_591
TMP_649(bool) = TMP_647 || TMP_648
CONDITION TMP_649"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_650(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 21144.sol-NamiMultiSigWallet-getTransactionIds(uint256,uint256,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
transactionIdsTemp = new uint256[](transactionCount)

IRs:
TMP_660(uint256[])  = new uint256[](transactionCount)
transactionIdsTemp(uint256[]) = ['TMP_660(uint256[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < transactionCount

IRs:
TMP_661(bool) = i < transactionCount
CONDITION TMP_661"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_601(NamiMultiSigWallet.Transaction) -> transactions[i]
REF_602(bool) -> REF_601.executed
TMP_662 = UnaryType.BANG REF_602 
TMP_663(bool) = pending && TMP_662
REF_603(NamiMultiSigWallet.Transaction) -> transactions[i]
REF_604(bool) -> REF_603.executed
TMP_664(bool) = executed && REF_604
TMP_665(bool) = TMP_663 || TMP_664
CONDITION TMP_665"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transactionIdsTemp[count] = i

IRs:
REF_605(uint256) -> transactionIdsTemp[count]
REF_605(uint256) (->transactionIdsTemp) := i(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_666(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_transactionIds = new uint256[](to - from)

IRs:
TMP_668(uint256) = to - from
TMP_669(uint256[])  = new uint256[](TMP_668)
_transactionIds(uint256[]) = ['TMP_669(uint256[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < to

IRs:
TMP_670(bool) = i < to
CONDITION TMP_670"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionIds[i - from] = transactionIdsTemp[i]

IRs:
TMP_671(uint256) = i - from
REF_606(uint256) -> _transactionIds[TMP_671]
REF_607(uint256) -> transactionIdsTemp[i]
REF_606(uint256) (->_transactionIds) := REF_607(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_672(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_transactionIds

IRs:
RETURN _transactionIds"];
}
// Function: 21144.sol-NamiMultiSigWallet-isConfirmed(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_579 -> LENGTH owners
TMP_637(bool) = i < REF_579
CONDITION TMP_637"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_580(mapping(address => bool)) -> confirmations[transactionId]
REF_581(address) -> owners[i]
REF_582(bool) -> REF_580[REF_581]
CONDITION REF_582"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_638(bool) = count == required
CONDITION TMP_638"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_639(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
}
// Function: 21144.sol-NamiMultiSigWallet-notConfirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! confirmations[transactionId][owner])

IRs:
REF_614(mapping(address => bool)) -> confirmations[transactionId]
REF_615(bool) -> REF_614[owner]
TMP_682 = UnaryType.BANG REF_615 
TMP_683(None) = SOLIDITY_CALL require(bool)(TMP_682)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-notExecuted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! transactions[transactionId].executed)

IRs:
REF_616(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_617(bool) -> REF_616.executed
TMP_684 = UnaryType.BANG REF_617 
TMP_685(None) = SOLIDITY_CALL require(bool)(TMP_684)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0)

IRs:
TMP_686(bool) = _address != 0
TMP_687(None) = SOLIDITY_CALL require(bool)(TMP_686)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(this))

IRs:
TMP_673 = CONVERT this to address
TMP_674(bool) = msg.sender == TMP_673
TMP_675(None) = SOLIDITY_CALL require(bool)(TMP_674)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isOwner[owner])

IRs:
REF_608(bool) -> isOwner[owner]
TMP_676 = UnaryType.BANG REF_608 
TMP_677(None) = SOLIDITY_CALL require(bool)(TMP_676)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isOwner[owner])

IRs:
REF_609(bool) -> isOwner[owner]
TMP_678(None) = SOLIDITY_CALL require(bool)(REF_609)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = false

IRs:
REF_548(bool) -> isOwner[owner]
REF_548(bool) (->isOwner) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_549 -> LENGTH owners
TMP_599(uint256) = REF_549 - 1
TMP_600(bool) = i < TMP_599
CONDITION TMP_600"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
owners[i] == owner

IRs:
REF_550(address) -> owners[i]
TMP_601(bool) = REF_550 == owner
CONDITION TMP_601"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_551(address) -> owners[i]
REF_552 -> LENGTH owners
TMP_602(uint256) = REF_552 - 1
REF_553(address) -> owners[TMP_602]
REF_551(address) (->owners) := REF_553(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_603(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
owners.length -= 1

IRs:
REF_554 -> LENGTH owners
REF_554(-> owners) = REF_554 - 1"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
required > owners.length

IRs:
REF_555 -> LENGTH owners
TMP_604(bool) = required > REF_555
CONDITION TMP_604"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
changeRequirement(owners.length)

IRs:
REF_556 -> LENGTH owners
INTERNAL_CALL, NamiMultiSigWallet.changeRequirement(uint256)(REF_556)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, NamiMultiSigWallet.onlyWallet()()"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.ownerExists(address)(owner)"];
17->1;
}
// Function: 21144.sol-NamiMultiSigWallet-replaceOwner(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_557 -> LENGTH owners
TMP_609(bool) = i < REF_557
CONDITION TMP_609"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
owners[i] == owner

IRs:
REF_558(address) -> owners[i]
TMP_610(bool) = REF_558 == owner
CONDITION TMP_610"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
owners[i] = newOwner

IRs:
REF_559(address) -> owners[i]
REF_559(address) (->owners) := newOwner(address)"];
6->7;
7[label="Node Type: BREAK 7
"];
7->2;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_611(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
isOwner[owner] = false

IRs:
REF_560(bool) -> isOwner[owner]
REF_560(bool) (->isOwner) := False(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isOwner[newOwner] = true

IRs:
REF_561(bool) -> isOwner[newOwner]
REF_561(bool) (->isOwner) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerAddition(newOwner)

IRs:
Emit OwnerAddition(newOwner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, NamiMultiSigWallet.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.ownerExists(address)(owner)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerDoesNotExist(newOwner)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.ownerDoesNotExist(address)(newOwner)"];
16->3;
}
// Function: 21144.sol-NamiMultiSigWallet-revokeConfirmation(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_565(mapping(address => bool)) -> confirmations[transactionId]
REF_566(bool) -> REF_565[msg.sender]
REF_566(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.confirmed(uint256,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.notExecuted(uint256)(transactionId)"];
5->1;
}
// Function: 21144.sol-NamiMultiSigWallet-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_OWNER_COUNT = 50

IRs:
MAX_OWNER_COUNT(uint256) := 50(uint256)"];
}
// Function: 21144.sol-NamiMultiSigWallet-submitTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data)

IRs:
TMP_620(uint256) = INTERNAL_CALL, NamiMultiSigWallet.addTransaction(address,uint256,bytes)(destination,value,data)
transactionId(uint256) := TMP_620(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, NamiMultiSigWallet.confirmTransaction(uint256)(transactionId)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 21144.sol-NamiMultiSigWallet-transactionExists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transactions[transactionId].destination != 0)

IRs:
REF_610(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_611(address) -> REF_610.destination
TMP_679(bool) = REF_611 != 0
TMP_680(None) = SOLIDITY_CALL require(bool)(TMP_679)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiMultiSigWallet-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! (ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0))

IRs:
TMP_688(bool) = ownerCount > MAX_OWNER_COUNT
TMP_689(bool) = _required > ownerCount
TMP_690(bool) = TMP_688 || TMP_689
TMP_691(bool) = _required == 0
TMP_692(bool) = TMP_690 || TMP_691
TMP_693(bool) = ownerCount == 0
TMP_694(bool) = TMP_692 || TMP_693
TMP_695 = UnaryType.BANG TMP_694 
TMP_696(None) = SOLIDITY_CALL require(bool)(TMP_695)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiPool-NamiPool(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_namiMultiSigWallet != 0x0)

IRs:
TMP_17(bool) = _namiMultiSigWallet != 0
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
escrow = _escrow

IRs:
escrow(address) := _escrow(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
namiMultiSigWallet = _namiMultiSigWallet

IRs:
namiMultiSigWallet(address) := _namiMultiSigWallet(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
NamiAddr = _namiAddress

IRs:
NamiAddr(address) := _namiAddress(address)"];
}
// Function: 21144.sol-NamiPool-_withdrawNAC(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(namiPool[_roundIndex][_shareAddress].stake > 0)

IRs:
REF_130(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_131(NamiPool.ShareHolder) -> REF_130[_shareAddress]
REF_132(uint256) -> REF_131.stake
TMP_122(bool) = REF_132 > 0
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
namiToken = NamiCrowdSale(NamiAddr)

IRs:
TMP_124 = CONVERT NamiAddr to NamiCrowdSale
namiToken(NamiCrowdSale) := TMP_124(NamiCrowdSale)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalances = namiToken.balanceOf(this)

IRs:
TMP_125(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['this']  
previousBalances(uint256) := TMP_125(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
namiToken.transfer(_shareAddress,namiPool[_roundIndex][_shareAddress].stake)

IRs:
REF_135(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_136(NamiPool.ShareHolder) -> REF_135[_shareAddress]
REF_137(uint256) -> REF_136.stake
HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:transfer, arguments:['_shareAddress', 'REF_137']  "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
round[_roundIndex].currentNAC = round[_roundIndex].currentNAC.sub(namiPool[_roundIndex][_shareAddress].stake)

IRs:
REF_138(NamiPool.Round) -> round[_roundIndex]
REF_139(uint256) -> REF_138.currentNAC
REF_140(NamiPool.Round) -> round[_roundIndex]
REF_141(uint256) -> REF_140.currentNAC
REF_143(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_144(NamiPool.ShareHolder) -> REF_143[_shareAddress]
REF_145(uint256) -> REF_144.stake
TMP_127(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_141', 'REF_145'] 
REF_139(uint256) (->round) := TMP_127(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
namiPool[_roundIndex][_shareAddress].stake = 0

IRs:
REF_146(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_147(NamiPool.ShareHolder) -> REF_146[_shareAddress]
REF_148(uint256) -> REF_147.stake
REF_148(uint256) (->namiPool) := 0(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(previousBalances > namiToken.balanceOf(this))

IRs:
TMP_128(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['this']  
TMP_129(bool) = previousBalances > TMP_128
TMP_130(None) = SOLIDITY_CALL assert(bool)(TMP_129)"];
}
// Function: 21144.sol-NamiPool-activateRound(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isOpen == false && round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isCompleteActive == false)

IRs:
REF_4(NamiPool.Round) -> round[_roundIndex]
REF_5(bool) -> REF_4.isOpen
TMP_36(bool) = REF_5 == False
REF_6(NamiPool.Round) -> round[_roundIndex]
REF_7(bool) -> REF_6.isCloseEthPool
TMP_37(bool) = REF_7 == False
TMP_38(bool) = TMP_36 && TMP_37
REF_8(NamiPool.Round) -> round[_roundIndex]
REF_9(bool) -> REF_8.isCompleteActive
TMP_39(bool) = REF_9 == False
TMP_40(bool) = TMP_38 && TMP_39
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
round[_roundIndex].isOpen = true

IRs:
REF_10(NamiPool.Round) -> round[_roundIndex]
REF_11(bool) -> REF_10.isOpen
REF_11(bool) (->round) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
currentRound = _roundIndex

IRs:
currentRound(uint256) := _roundIndex(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ActivateRound(_roundIndex,now)

IRs:
Emit ActivateRound(_roundIndex,now)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
5->1;
}
// Function: 21144.sol-NamiPool-activateUser(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(namiPool[_roundId][_shareAddress].isActive == false && namiPool[_roundId][_shareAddress].stake > 0)

IRs:
REF_33(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_34(NamiPool.ShareHolder) -> REF_33[_shareAddress]
REF_35(bool) -> REF_34.isActive
TMP_55(bool) = REF_35 == False
REF_36(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_37(NamiPool.ShareHolder) -> REF_36[_shareAddress]
REF_38(uint256) -> REF_37.stake
TMP_56(bool) = REF_38 > 0
TMP_57(bool) = TMP_55 && TMP_56
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round[_roundId].isCompleteActive == false && round[_roundId].isOpen == false)

IRs:
REF_39(NamiPool.Round) -> round[_roundId]
REF_40(bool) -> REF_39.isCompleteActive
TMP_59(bool) = REF_40 == False
REF_41(NamiPool.Round) -> round[_roundId]
REF_42(bool) -> REF_41.isOpen
TMP_60(bool) = REF_42 == False
TMP_61(bool) = TMP_59 && TMP_60
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
namiPool[_roundId][_shareAddress].isActive = true

IRs:
REF_43(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_44(NamiPool.ShareHolder) -> REF_43[_shareAddress]
REF_45(bool) -> REF_44.isActive
REF_45(bool) (->namiPool) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
round[_roundId].finalNAC = round[_roundId].finalNAC.add(namiPool[_roundId][_shareAddress].stake)

IRs:
REF_46(NamiPool.Round) -> round[_roundId]
REF_47(uint256) -> REF_46.finalNAC
REF_48(NamiPool.Round) -> round[_roundId]
REF_49(uint256) -> REF_48.finalNAC
REF_51(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_52(NamiPool.ShareHolder) -> REF_51[_shareAddress]
REF_53(uint256) -> REF_52.stake
TMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_49', 'REF_53'] 
REF_47(uint256) (->round) := TMP_63(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
UpdateActive(_shareAddress,_roundId,namiPool[_roundId][_shareAddress].isActive,now)

IRs:
REF_54(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_55(NamiPool.ShareHolder) -> REF_54[_shareAddress]
REF_56(bool) -> REF_55.isActive
Emit UpdateActive(_shareAddress,_roundId,REF_56,now)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
6->1;
}
// Function: 21144.sol-NamiPool-changeEscrow(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_escrow != 0x0)

IRs:
TMP_19(bool) = _escrow != 0
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
escrow = _escrow

IRs:
escrow(address) := _escrow(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyNamiMultisig()

IRs:
MODIFIER_CALL, NamiPool.onlyNamiMultisig()()"];
3->1;
}
// Function: 21144.sol-NamiPool-changeTopWithdrawable(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false)

IRs:
REF_95(NamiPool.Round) -> round[_roundIndex]
REF_96(bool) -> REF_95.isCompleteActive
TMP_88(bool) = REF_96 == True
REF_97(NamiPool.Round) -> round[_roundIndex]
REF_98(bool) -> REF_97.isOpen
TMP_89(bool) = REF_98 == False
TMP_90(bool) = TMP_88 && TMP_89
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
round[_roundIndex].topWithdrawable = ! round[_roundIndex].topWithdrawable

IRs:
REF_99(NamiPool.Round) -> round[_roundIndex]
REF_100(bool) -> REF_99.topWithdrawable
REF_101(NamiPool.Round) -> round[_roundIndex]
REF_102(bool) -> REF_101.topWithdrawable
TMP_92 = UnaryType.BANG REF_102 
REF_100(bool) (->round) := TMP_92(bool)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-NamiPool-changeWithdrawable(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false)

IRs:
REF_87(NamiPool.Round) -> round[_roundIndex]
REF_88(bool) -> REF_87.isCompleteActive
TMP_82(bool) = REF_88 == True
REF_89(NamiPool.Round) -> round[_roundIndex]
REF_90(bool) -> REF_89.isOpen
TMP_83(bool) = REF_90 == False
TMP_84(bool) = TMP_82 && TMP_83
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
round[_roundIndex].withdrawable = ! round[_roundIndex].withdrawable

IRs:
REF_91(NamiPool.Round) -> round[_roundIndex]
REF_92(bool) -> REF_91.withdrawable
REF_93(NamiPool.Round) -> round[_roundIndex]
REF_94(bool) -> REF_93.withdrawable
TMP_86 = UnaryType.BANG REF_94 
REF_92(bool) (->round) := TMP_86(bool)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-NamiPool-closeActive(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundId].isCompleteActive == false && round[_roundId].isOpen == false)

IRs:
REF_81(NamiPool.Round) -> round[_roundId]
REF_82(bool) -> REF_81.isCompleteActive
TMP_77(bool) = REF_82 == False
REF_83(NamiPool.Round) -> round[_roundId]
REF_84(bool) -> REF_83.isOpen
TMP_78(bool) = REF_84 == False
TMP_79(bool) = TMP_77 && TMP_78
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
round[_roundId].isCompleteActive = true

IRs:
REF_85(NamiPool.Round) -> round[_roundId]
REF_86(bool) -> REF_85.isCompleteActive
REF_86(bool) (->round) := True(bool)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-NamiPool-closeEthPool(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false)

IRs:
REF_122(NamiPool.Round) -> round[_roundIndex]
REF_123(bool) -> REF_122.isCloseEthPool
TMP_115(bool) = REF_123 == False
REF_124(NamiPool.Round) -> round[_roundIndex]
REF_125(bool) -> REF_124.isCompleteActive
TMP_116(bool) = REF_125 == True
TMP_117(bool) = TMP_115 && TMP_116
REF_126(NamiPool.Round) -> round[_roundIndex]
REF_127(bool) -> REF_126.isOpen
TMP_118(bool) = REF_127 == False
TMP_119(bool) = TMP_117 && TMP_118
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
round[_roundIndex].isCloseEthPool = true

IRs:
REF_128(NamiPool.Round) -> round[_roundIndex]
REF_129(bool) -> REF_128.isCloseEthPool
REF_129(bool) (->round) := True(bool)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-NamiPool-deactivateRound(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isOpen == true)

IRs:
REF_12(NamiPool.Round) -> round[_roundIndex]
REF_13(bool) -> REF_12.isOpen
TMP_44(bool) = REF_13 == True
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
round[_roundIndex].isOpen = false

IRs:
REF_14(NamiPool.Round) -> round[_roundIndex]
REF_15(bool) -> REF_14.isOpen
REF_15(bool) (->round) := False(bool)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
3->1;
}
// Function: 21144.sol-NamiPool-deactivateUser(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(namiPool[_roundId][_shareAddress].isActive == true && namiPool[_roundId][_shareAddress].stake > 0)

IRs:
REF_57(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_58(NamiPool.ShareHolder) -> REF_57[_shareAddress]
REF_59(bool) -> REF_58.isActive
TMP_66(bool) = REF_59 == True
REF_60(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_61(NamiPool.ShareHolder) -> REF_60[_shareAddress]
REF_62(uint256) -> REF_61.stake
TMP_67(bool) = REF_62 > 0
TMP_68(bool) = TMP_66 && TMP_67
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round[_roundId].isCompleteActive == false && round[_roundId].isOpen == false)

IRs:
REF_63(NamiPool.Round) -> round[_roundId]
REF_64(bool) -> REF_63.isCompleteActive
TMP_70(bool) = REF_64 == False
REF_65(NamiPool.Round) -> round[_roundId]
REF_66(bool) -> REF_65.isOpen
TMP_71(bool) = REF_66 == False
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
namiPool[_roundId][_shareAddress].isActive = false

IRs:
REF_67(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_68(NamiPool.ShareHolder) -> REF_67[_shareAddress]
REF_69(bool) -> REF_68.isActive
REF_69(bool) (->namiPool) := False(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
round[_roundId].finalNAC = round[_roundId].finalNAC.sub(namiPool[_roundId][_shareAddress].stake)

IRs:
REF_70(NamiPool.Round) -> round[_roundId]
REF_71(uint256) -> REF_70.finalNAC
REF_72(NamiPool.Round) -> round[_roundId]
REF_73(uint256) -> REF_72.finalNAC
REF_75(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_76(NamiPool.ShareHolder) -> REF_75[_shareAddress]
REF_77(uint256) -> REF_76.stake
TMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_73', 'REF_77'] 
REF_71(uint256) (->round) := TMP_74(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
UpdateActive(_shareAddress,_roundId,namiPool[_roundId][_shareAddress].isActive,now)

IRs:
REF_78(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundId]
REF_79(NamiPool.ShareHolder) -> REF_78[_shareAddress]
REF_80(bool) -> REF_79.isActive
Emit UpdateActive(_shareAddress,_roundId,REF_80,now)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
6->1;
}
// Function: 21144.sol-NamiPool-depositEthPool(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0 && round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isOpen == false)

IRs:
TMP_94(bool) = msg.value > 0
REF_103(NamiPool.Round) -> round[_roundIndex]
REF_104(bool) -> REF_103.isCloseEthPool
TMP_95(bool) = REF_104 == False
TMP_96(bool) = TMP_94 && TMP_95
REF_105(NamiPool.Round) -> round[_roundIndex]
REF_106(bool) -> REF_105.isOpen
TMP_97(bool) = REF_106 == False
TMP_98(bool) = TMP_96 && TMP_97
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
msg.value > 0

IRs:
TMP_100(bool) = msg.value > 0
CONDITION TMP_100"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
round[_roundIndex].ethBalance = round[_roundIndex].ethBalance.add(msg.value)

IRs:
REF_107(NamiPool.Round) -> round[_roundIndex]
REF_108(uint256) -> REF_107.ethBalance
REF_109(NamiPool.Round) -> round[_roundIndex]
REF_110(uint256) -> REF_109.ethBalance
TMP_101(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_110', 'msg.value'] 
REF_108(uint256) (->round) := TMP_101(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Deposit(msg.sender,_roundIndex,msg.value)

IRs:
Emit Deposit(msg.sender,_roundIndex,msg.value)"];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
6->1;
}
// Function: 21144.sol-NamiPool-onlyEscrow()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == escrow)

IRs:
TMP_185(bool) = msg.sender == escrow
TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiPool-onlyNami()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == NamiAddr)

IRs:
TMP_187(bool) = msg.sender == NamiAddr
TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiPool-onlyNamiMultisig()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == namiMultiSigWallet)

IRs:
TMP_189(bool) = msg.sender == namiMultiSigWallet
TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 21144.sol-NamiPool-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Nami Pool

IRs:
name(string) := Nami Pool(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
currentRound = 1

IRs:
currentRound(uint256) := 1(uint256)"];
}
// Function: 21144.sol-NamiPool-tokenFallbackExchange(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_price].isOpen == true && _value > 0)

IRs:
REF_16(NamiPool.Round) -> round[_price]
REF_17(bool) -> REF_16.isOpen
TMP_47(bool) = REF_17 == True
TMP_48(bool) = _value > 0
TMP_49(bool) = TMP_47 && TMP_48
TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
namiPool[_price][_from].stake = namiPool[_price][_from].stake.add(_value)

IRs:
REF_18(mapping(address => NamiPool.ShareHolder)) -> namiPool[_price]
REF_19(NamiPool.ShareHolder) -> REF_18[_from]
REF_20(uint256) -> REF_19.stake
REF_21(mapping(address => NamiPool.ShareHolder)) -> namiPool[_price]
REF_22(NamiPool.ShareHolder) -> REF_21[_from]
REF_23(uint256) -> REF_22.stake
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_20(uint256) (->namiPool) := TMP_51(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
round[_price].currentNAC = round[_price].currentNAC.add(_value)

IRs:
REF_25(NamiPool.Round) -> round[_price]
REF_26(uint256) -> REF_25.currentNAC
REF_27(NamiPool.Round) -> round[_price]
REF_28(uint256) -> REF_27.currentNAC
TMP_52(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->round) := TMP_52(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
UpdateShareHolder(_from,_price,namiPool[_price][_from].stake,now)

IRs:
REF_30(mapping(address => NamiPool.ShareHolder)) -> namiPool[_price]
REF_31(NamiPool.ShareHolder) -> REF_30[_from]
REF_32(uint256) -> REF_31.stake
Emit UpdateShareHolder(_from,_price,REF_32,now)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyNami()

IRs:
MODIFIER_CALL, NamiPool.onlyNami()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 21144.sol-NamiPool-withdrawEthPool(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isOpen == false)

IRs:
REF_112(NamiPool.Round) -> round[_roundIndex]
REF_113(bool) -> REF_112.isCloseEthPool
TMP_104(bool) = REF_113 == False
REF_114(NamiPool.Round) -> round[_roundIndex]
REF_115(bool) -> REF_114.isOpen
TMP_105(bool) = REF_115 == False
TMP_106(bool) = TMP_104 && TMP_105
TMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(namiMultiSigWallet != 0x0)

IRs:
TMP_108(bool) = namiMultiSigWallet != 0
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_amount > 0

IRs:
TMP_110(bool) = _amount > 0
CONDITION TMP_110"];
3->4[label="True"];
3->7[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
namiMultiSigWallet.transfer(_amount)

IRs:
Transfer dest:namiMultiSigWallet value:_amount"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
round[_roundIndex].ethBalance = round[_roundIndex].ethBalance.sub(_amount)

IRs:
REF_117(NamiPool.Round) -> round[_roundIndex]
REF_118(uint256) -> REF_117.ethBalance
REF_119(NamiPool.Round) -> round[_roundIndex]
REF_120(uint256) -> REF_119.ethBalance
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_120', '_amount'] 
REF_118(uint256) (->round) := TMP_112(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
WithdrawPool(_amount,now)

IRs:
Emit WithdrawPool(_amount,now)"];
6->7;
7[label="Node Type: END_IF 7
"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
8->1;
}
// Function: 21144.sol-NamiPool-withdrawEther(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(namiMultiSigWallet != 0x0)

IRs:
TMP_22(bool) = namiMultiSigWallet != 0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
this.balance > 0

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_24(bool) = REF_0 > 0
CONDITION TMP_24"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
namiMultiSigWallet.transfer(_amount)

IRs:
Transfer dest:namiMultiSigWallet value:_amount"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
5->1;
}
// Function: 21144.sol-NamiPool-withdrawNAC(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(namiMultiSigWallet != 0x0 && _amount != 0)

IRs:
TMP_27(bool) = namiMultiSigWallet != 0
TMP_28(bool) = _amount != 0
TMP_29(bool) = TMP_27 && TMP_28
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
namiToken = NamiCrowdSale(NamiAddr)

IRs:
TMP_31 = CONVERT NamiAddr to NamiCrowdSale
namiToken(NamiCrowdSale) := TMP_31(NamiCrowdSale)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
namiToken.balanceOf(this) > 0

IRs:
TMP_32(uint256) = HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:balanceOf, arguments:['this']  
TMP_33(bool) = TMP_32 > 0
CONDITION TMP_33"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
namiToken.transfer(namiMultiSigWallet,_amount)

IRs:
HIGH_LEVEL_CALL, dest:namiToken(NamiCrowdSale), function:transfer, arguments:['namiMultiSigWallet', '_amount']  "];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
6->1;
}
// Function: 21144.sol-NamiPool-withdrawNonTop(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false)

IRs:
REF_233(NamiPool.Round) -> round[_roundIndex]
REF_234(bool) -> REF_233.isCompleteActive
TMP_175(bool) = REF_234 == True
REF_235(NamiPool.Round) -> round[_roundIndex]
REF_236(bool) -> REF_235.isOpen
TMP_176(bool) = REF_236 == False
TMP_177(bool) = TMP_175 && TMP_176
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round[_roundIndex].withdrawable)

IRs:
REF_237(NamiPool.Round) -> round[_roundIndex]
REF_238(bool) -> REF_237.withdrawable
TMP_179(None) = SOLIDITY_CALL require(bool)(REF_238)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
namiPool[_roundIndex][msg.sender].isActive == false

IRs:
REF_239(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_240(NamiPool.ShareHolder) -> REF_239[msg.sender]
REF_241(bool) -> REF_240.isActive
TMP_180(bool) = REF_241 == False
CONDITION TMP_180"];
3->4[label="True"];
3->8[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(namiPool[_roundIndex][msg.sender].isWithdrawn == false)

IRs:
REF_242(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_243(NamiPool.ShareHolder) -> REF_242[msg.sender]
REF_244(bool) -> REF_243.isWithdrawn
TMP_181(bool) = REF_244 == False
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
namiPool[_roundIndex][msg.sender].isWithdrawn = true

IRs:
REF_245(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_246(NamiPool.ShareHolder) -> REF_245[msg.sender]
REF_247(bool) -> REF_246.isWithdrawn
REF_247(bool) (->namiPool) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Withdraw(msg.sender,_roundIndex,0,namiPool[_roundIndex][msg.sender].stake,now)

IRs:
REF_248(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_249(NamiPool.ShareHolder) -> REF_248[msg.sender]
REF_250(uint256) -> REF_249.stake
Emit Withdraw(msg.sender,_roundIndex,0,REF_250,now)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_withdrawNAC(msg.sender,_roundIndex)

IRs:
INTERNAL_CALL, NamiPool._withdrawNAC(address,uint256)(msg.sender,_roundIndex)"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 21144.sol-NamiPool-withdrawNonTopForTeam(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false)

IRs:
REF_185(NamiPool.Round) -> round[_roundIndex]
REF_186(bool) -> REF_185.isCompleteActive
TMP_149(bool) = REF_186 == True
REF_187(NamiPool.Round) -> round[_roundIndex]
REF_188(bool) -> REF_187.isOpen
TMP_150(bool) = REF_188 == False
TMP_151(bool) = TMP_149 && TMP_150
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round[_roundIndex].withdrawable)

IRs:
REF_189(NamiPool.Round) -> round[_roundIndex]
REF_190(bool) -> REF_189.withdrawable
TMP_153(None) = SOLIDITY_CALL require(bool)(REF_190)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
namiPool[_roundIndex][_shareAddress].isActive == false

IRs:
REF_191(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_192(NamiPool.ShareHolder) -> REF_191[_shareAddress]
REF_193(bool) -> REF_192.isActive
TMP_154(bool) = REF_193 == False
CONDITION TMP_154"];
3->4[label="True"];
3->8[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(namiPool[_roundIndex][_shareAddress].isWithdrawn == false)

IRs:
REF_194(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_195(NamiPool.ShareHolder) -> REF_194[_shareAddress]
REF_196(bool) -> REF_195.isWithdrawn
TMP_155(bool) = REF_196 == False
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
namiPool[_roundIndex][_shareAddress].isWithdrawn = true

IRs:
REF_197(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_198(NamiPool.ShareHolder) -> REF_197[_shareAddress]
REF_199(bool) -> REF_198.isWithdrawn
REF_199(bool) (->namiPool) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Withdraw(_shareAddress,_roundIndex,0,namiPool[_roundIndex][_shareAddress].stake,now)

IRs:
REF_200(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_201(NamiPool.ShareHolder) -> REF_200[_shareAddress]
REF_202(uint256) -> REF_201.stake
Emit Withdraw(_shareAddress,_roundIndex,0,REF_202,now)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_withdrawNAC(_shareAddress,_roundIndex)

IRs:
INTERNAL_CALL, NamiPool._withdrawNAC(address,uint256)(_shareAddress,_roundIndex)"];
7->8;
8[label="Node Type: END_IF 8
"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
9->1;
}
// Function: 21144.sol-NamiPool-withdrawTop(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isCloseEthPool == true && round[_roundIndex].isOpen == false)

IRs:
REF_203(NamiPool.Round) -> round[_roundIndex]
REF_204(bool) -> REF_203.isCompleteActive
TMP_160(bool) = REF_204 == True
REF_205(NamiPool.Round) -> round[_roundIndex]
REF_206(bool) -> REF_205.isCloseEthPool
TMP_161(bool) = REF_206 == True
TMP_162(bool) = TMP_160 && TMP_161
REF_207(NamiPool.Round) -> round[_roundIndex]
REF_208(bool) -> REF_207.isOpen
TMP_163(bool) = REF_208 == False
TMP_164(bool) = TMP_162 && TMP_163
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round[_roundIndex].topWithdrawable)

IRs:
REF_209(NamiPool.Round) -> round[_roundIndex]
REF_210(bool) -> REF_209.topWithdrawable
TMP_166(None) = SOLIDITY_CALL require(bool)(REF_210)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
namiPool[_roundIndex][msg.sender].isActive == true

IRs:
REF_211(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_212(NamiPool.ShareHolder) -> REF_211[msg.sender]
REF_213(bool) -> REF_212.isActive
TMP_167(bool) = REF_213 == True
CONDITION TMP_167"];
3->4[label="True"];
3->10[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(namiPool[_roundIndex][msg.sender].isWithdrawn == false)

IRs:
REF_214(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_215(NamiPool.ShareHolder) -> REF_214[msg.sender]
REF_216(bool) -> REF_215.isWithdrawn
TMP_168(bool) = REF_216 == False
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
ethReturn = (round[_roundIndex].ethBalance.mul(namiPool[_roundIndex][msg.sender].stake)).div(round[_roundIndex].finalNAC)

IRs:
REF_217(NamiPool.Round) -> round[_roundIndex]
REF_218(uint256) -> REF_217.ethBalance
REF_220(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_221(NamiPool.ShareHolder) -> REF_220[msg.sender]
REF_222(uint256) -> REF_221.stake
TMP_170(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_218', 'REF_222'] 
REF_224(NamiPool.Round) -> round[_roundIndex]
REF_225(uint256) -> REF_224.finalNAC
TMP_171(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_170', 'REF_225'] 
ethReturn(uint256) := TMP_171(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(ethReturn)

IRs:
Transfer dest:msg.sender value:ethReturn"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
namiPool[_roundIndex][msg.sender].isWithdrawn = true

IRs:
REF_227(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_228(NamiPool.ShareHolder) -> REF_227[msg.sender]
REF_229(bool) -> REF_228.isWithdrawn
REF_229(bool) (->namiPool) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Withdraw(msg.sender,_roundIndex,ethReturn,namiPool[_roundIndex][msg.sender].stake,now)

IRs:
REF_230(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_231(NamiPool.ShareHolder) -> REF_230[msg.sender]
REF_232(uint256) -> REF_231.stake
Emit Withdraw(msg.sender,_roundIndex,ethReturn,REF_232,now)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_withdrawNAC(msg.sender,_roundIndex)

IRs:
INTERNAL_CALL, NamiPool._withdrawNAC(address,uint256)(msg.sender,_roundIndex)"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 21144.sol-NamiPool-withdrawTopForTeam(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isCloseEthPool == true && round[_roundIndex].isOpen == false)

IRs:
REF_150(NamiPool.Round) -> round[_roundIndex]
REF_151(bool) -> REF_150.isCompleteActive
TMP_131(bool) = REF_151 == True
REF_152(NamiPool.Round) -> round[_roundIndex]
REF_153(bool) -> REF_152.isCloseEthPool
TMP_132(bool) = REF_153 == True
TMP_133(bool) = TMP_131 && TMP_132
REF_154(NamiPool.Round) -> round[_roundIndex]
REF_155(bool) -> REF_154.isOpen
TMP_134(bool) = REF_155 == False
TMP_135(bool) = TMP_133 && TMP_134
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round[_roundIndex].topWithdrawable)

IRs:
REF_156(NamiPool.Round) -> round[_roundIndex]
REF_157(bool) -> REF_156.topWithdrawable
TMP_137(None) = SOLIDITY_CALL require(bool)(REF_157)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
namiPool[_roundIndex][_shareAddress].isActive == true

IRs:
REF_158(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_159(NamiPool.ShareHolder) -> REF_158[_shareAddress]
REF_160(bool) -> REF_159.isActive
TMP_138(bool) = REF_160 == True
CONDITION TMP_138"];
3->4[label="True"];
3->11[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(namiPool[_roundIndex][_shareAddress].isWithdrawn == false)

IRs:
REF_161(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_162(NamiPool.ShareHolder) -> REF_161[_shareAddress]
REF_163(bool) -> REF_162.isWithdrawn
TMP_139(bool) = REF_163 == False
TMP_140(None) = SOLIDITY_CALL require(bool)(TMP_139)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(round[_roundIndex].finalNAC > namiPool[_roundIndex][_shareAddress].stake)

IRs:
REF_164(NamiPool.Round) -> round[_roundIndex]
REF_165(uint256) -> REF_164.finalNAC
REF_166(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_167(NamiPool.ShareHolder) -> REF_166[_shareAddress]
REF_168(uint256) -> REF_167.stake
TMP_141(bool) = REF_165 > REF_168
TMP_142(None) = SOLIDITY_CALL assert(bool)(TMP_141)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
ethReturn = (round[_roundIndex].ethBalance.mul(namiPool[_roundIndex][_shareAddress].stake)).div(round[_roundIndex].finalNAC)

IRs:
REF_169(NamiPool.Round) -> round[_roundIndex]
REF_170(uint256) -> REF_169.ethBalance
REF_172(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_173(NamiPool.ShareHolder) -> REF_172[_shareAddress]
REF_174(uint256) -> REF_173.stake
TMP_143(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_170', 'REF_174'] 
REF_176(NamiPool.Round) -> round[_roundIndex]
REF_177(uint256) -> REF_176.finalNAC
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_143', 'REF_177'] 
ethReturn(uint256) := TMP_144(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_shareAddress.transfer(ethReturn)

IRs:
Transfer dest:_shareAddress value:ethReturn"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
namiPool[_roundIndex][_shareAddress].isWithdrawn = true

IRs:
REF_179(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_180(NamiPool.ShareHolder) -> REF_179[_shareAddress]
REF_181(bool) -> REF_180.isWithdrawn
REF_181(bool) (->namiPool) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Withdraw(_shareAddress,_roundIndex,ethReturn,namiPool[_roundIndex][_shareAddress].stake,now)

IRs:
REF_182(mapping(address => NamiPool.ShareHolder)) -> namiPool[_roundIndex]
REF_183(NamiPool.ShareHolder) -> REF_182[_shareAddress]
REF_184(uint256) -> REF_183.stake
Emit Withdraw(_shareAddress,_roundIndex,ethReturn,REF_184,now)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_withdrawNAC(_shareAddress,_roundIndex)

IRs:
INTERNAL_CALL, NamiPool._withdrawNAC(address,uint256)(_shareAddress,_roundIndex)"];
10->11;
11[label="Node Type: END_IF 11
"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onlyEscrow()

IRs:
MODIFIER_CALL, NamiPool.onlyEscrow()()"];
12->1;
}
// Function: 21144.sol-PresaleToken-burnTokens(address)
digraph{
}
// Function: 21144.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 21144.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_6(uint256) = a / b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 21144.sol-SafeMath-max256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_15(bool) = a >= b
CONDITION TMP_15"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 21144.sol-SafeMath-max64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_13(bool) = a >= b
CONDITION TMP_13"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 21144.sol-SafeMath-min256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_16(bool) = a < b
CONDITION TMP_16"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 21144.sol-SafeMath-min64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_14(bool) = a < b
CONDITION TMP_14"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 21144.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 21144.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_7(bool) = b <= a
TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_9(uint256) = a - b
RETURN TMP_9"];
}
// Function: 21144.sol-tokenRecipient-receiveApproval(address,uint256,address,bytes)
digraph{
}
}
