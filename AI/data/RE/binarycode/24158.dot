digraph G {
// Function: 24158.sol-IToken-executeSettingsChange(uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
}
// Function: 24158.sol-MultiSigWallet-MultiSigWallet(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->8;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_0 -> LENGTH _owners
TMP_2(bool) = i < REF_0
CONDITION TMP_2"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(! isOwner[_owners[i]] && _owners[i] != 0)

IRs:
REF_1(address) -> _owners[i]
REF_2(bool) -> isOwner[REF_1]
TMP_3 = UnaryType.BANG REF_2 
REF_3(address) -> _owners[i]
TMP_4(bool) = REF_3 != 0
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_4(address) -> _owners[i]
REF_5(bool) -> isOwner[REF_4]
REF_5(bool) (->isOwner) := True(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_7(uint256) := i(uint256)
i(uint256) = i + 1"];
7->4;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_6 -> LENGTH _owners
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(REF_6,_required)"];
11->3;
}
// Function: 24158.sol-MultiSigWallet-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_41(bool) -> isOwner[owner]
REF_41(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_43 -> LENGTH owners
TMP_37(uint256) := REF_43(uint256)
TMP_38(uint256) = TMP_37 + 1
REF_43(uint256) (->owners) := TMP_38(uint256)
REF_44(address) -> owners[TMP_37]
REF_44(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerDoesNotExist(address)(owner)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notNull(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(owner)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
validRequirement(owners.length + 1,required)

IRs:
REF_45 -> LENGTH owners
TMP_43(uint256) = REF_45 + 1
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(TMP_43,required)"];
7->1;
}
// Function: 24158.sol-MultiSigWallet-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = transactionCount

IRs:
transactionId(uint256) := transactionCount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId] = Transaction({destination:destination,value:value,data:data,executed:false})

IRs:
REF_77(MultiSigWallet.Transaction) -> transactions[transactionId]
TMP_100(MultiSigWallet.Transaction) = new Transaction(destination,value,data,False)
REF_77(MultiSigWallet.Transaction) (->transactions) := TMP_100(MultiSigWallet.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactionCount += 1

IRs:
transactionCount(uint256) = transactionCount + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 24158.sol-MultiSigWallet-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_60 -> LENGTH owners
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(REF_60,_required)"];
4->1;
}
// Function: 24158.sol-MultiSigWallet-confirmSettingsChange(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(settingsRequests[_txIndex].executed == false)

IRs:
REF_8(MultiSigWallet.SettingsRequest) -> settingsRequests[_txIndex]
REF_9(bool) -> REF_8.executed
TMP_24(bool) = REF_9 == False
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
settingsRequests[_txIndex].confirmations[msg.sender] = true

IRs:
REF_10(MultiSigWallet.SettingsRequest) -> settingsRequests[_txIndex]
REF_11(mapping(address => bool)) -> REF_10.confirmations
REF_12(bool) -> REF_11[msg.sender]
REF_12(bool) (->settingsRequests) := True(bool)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
isConfirmedSettingsRequest(_txIndex)

IRs:
TMP_26(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmedSettingsRequest(uint256)(_txIndex)
CONDITION TMP_26"];
3->4[label="True"];
3->8[label="False"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
request = settingsRequests[_txIndex]

IRs:
REF_13(MultiSigWallet.SettingsRequest) -> settingsRequests[_txIndex]
request(MultiSigWallet.SettingsRequest) := REF_13(MultiSigWallet.SettingsRequest)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
request.executed = true

IRs:
REF_14(bool) -> request.executed
REF_14(bool) (->request) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
IToken(token).executeSettingsChange(request.amount,request.partInvestor,request.partProject,request.partFounders,request.blocksPerStage,request.partInvestorIncreasePerStage,request.maxStages)

IRs:
TMP_27 = CONVERT token to IToken
REF_16(uint256) -> request.amount
REF_17(uint256) -> request.partInvestor
REF_18(uint256) -> request.partProject
REF_19(uint256) -> request.partFounders
REF_20(uint256) -> request.blocksPerStage
REF_21(uint256) -> request.partInvestorIncreasePerStage
REF_22(uint256) -> request.maxStages
HIGH_LEVEL_CALL, dest:TMP_27(IToken), function:executeSettingsChange, arguments:['REF_16', 'REF_17', 'REF_18', 'REF_19', 'REF_20', 'REF_21', 'REF_22']  "];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
10->1;
11[label="Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 24158.sol-MultiSigWallet-confirmTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_61(mapping(address => bool)) -> confirmations[transactionId]
REF_62(bool) -> REF_61[msg.sender]
REF_62(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.executeTransaction(uint256)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transactionExists(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.transactionExists(uint256)(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.notConfirmed(uint256,address)(transactionId,msg.sender)"];
6->1;
}
// Function: 24158.sol-MultiSigWallet-confirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(confirmations[transactionId][owner])

IRs:
REF_106(mapping(address => bool)) -> confirmations[transactionId]
REF_107(bool) -> REF_106[owner]
TMP_142(None) = SOLIDITY_CALL require(bool)(REF_107)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-executeTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_91(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_91"];
1->2[label="True"];
1->9[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tx = transactions[transactionId]

IRs:
REF_65(MultiSigWallet.Transaction) -> transactions[transactionId]
tx(MultiSigWallet.Transaction) := REF_65(MultiSigWallet.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tx.executed = true

IRs:
REF_66(bool) -> tx.executed
REF_66(bool) (->tx) := True(bool)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
tx.destination.call.value(tx.value)(tx.data)

IRs:
REF_67(address) -> tx.destination
REF_70(uint256) -> tx.value
REF_71(bytes) -> tx.data
TMP_93(bool) = LOW_LEVEL_CALL, dest:REF_67, function:call, arguments:['REF_71'] value:REF_70 
CONDITION TMP_93"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)"];
5->8;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tx.executed = false

IRs:
REF_72(bool) -> tx.executed
REF_72(bool) (->tx) := False(bool)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)"];
10->1;
}
// Function: 24158.sol-MultiSigWallet-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_0(bool) = msg.value > 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 24158.sol-MultiSigWallet-getConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_78 -> LENGTH owners
TMP_102(bool) = i < REF_78
CONDITION TMP_102"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_79(mapping(address => bool)) -> confirmations[transactionId]
REF_80(address) -> owners[i]
REF_81(bool) -> REF_79[REF_80]
CONDITION REF_81"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_103(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 24158.sol-MultiSigWallet-getConfirmations(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
confirmationsTemp = new address[](owners.length)

IRs:
REF_86 -> LENGTH owners
TMP_111(address[])  = new address[](REF_86)
confirmationsTemp(address[]) = ['TMP_111(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length

IRs:
REF_87 -> LENGTH owners
TMP_112(bool) = i < REF_87
CONDITION TMP_112"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_88(mapping(address => bool)) -> confirmations[transactionId]
REF_89(address) -> owners[i]
REF_90(bool) -> REF_88[REF_89]
CONDITION REF_90"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
confirmationsTemp[count] = owners[i]

IRs:
REF_91(address) -> confirmationsTemp[count]
REF_92(address) -> owners[i]
REF_91(address) (->confirmationsTemp) := REF_92(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_113(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_confirmations = new address[](count)

IRs:
TMP_115(address[])  = new address[](count)
_confirmations(address[]) = ['TMP_115(address[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < count

IRs:
TMP_116(bool) = i < count
CONDITION TMP_116"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_confirmations[i] = confirmationsTemp[i]

IRs:
REF_93(address) -> _confirmations[i]
REF_94(address) -> confirmationsTemp[i]
REF_93(address) (->_confirmations) := REF_94(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_117(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_confirmations

IRs:
RETURN _confirmations"];
}
// Function: 24158.sol-MultiSigWallet-getOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owners

IRs:
RETURN owners"];
}
// Function: 24158.sol-MultiSigWallet-getSettingChangeConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_28 -> LENGTH owners
TMP_33(bool) = i < REF_28
CONDITION TMP_33"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
settingsRequests[_txIndex].confirmations[owners[i]]

IRs:
REF_29(MultiSigWallet.SettingsRequest) -> settingsRequests[_txIndex]
REF_30(mapping(address => bool)) -> REF_29.confirmations
REF_31(address) -> owners[i]
REF_32(bool) -> REF_30[REF_31]
CONDITION REF_32"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_34(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 24158.sol-MultiSigWallet-getTransactionCount(bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < transactionCount

IRs:
TMP_104(bool) = i < transactionCount
CONDITION TMP_104"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_82(MultiSigWallet.Transaction) -> transactions[i]
REF_83(bool) -> REF_82.executed
TMP_105 = UnaryType.BANG REF_83 
TMP_106(bool) = pending && TMP_105
REF_84(MultiSigWallet.Transaction) -> transactions[i]
REF_85(bool) -> REF_84.executed
TMP_107(bool) = executed && REF_85
TMP_108(bool) = TMP_106 || TMP_107
CONDITION TMP_108"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_109(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 24158.sol-MultiSigWallet-getTransactionIds(uint256,uint256,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
transactionIdsTemp = new uint256[](transactionCount)

IRs:
TMP_119(uint256[])  = new uint256[](transactionCount)
transactionIdsTemp(uint256[]) = ['TMP_119(uint256[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < transactionCount

IRs:
TMP_120(bool) = i < transactionCount
CONDITION TMP_120"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_95(MultiSigWallet.Transaction) -> transactions[i]
REF_96(bool) -> REF_95.executed
TMP_121 = UnaryType.BANG REF_96 
TMP_122(bool) = pending && TMP_121
REF_97(MultiSigWallet.Transaction) -> transactions[i]
REF_98(bool) -> REF_97.executed
TMP_123(bool) = executed && REF_98
TMP_124(bool) = TMP_122 || TMP_123
CONDITION TMP_124"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transactionIdsTemp[count] = i

IRs:
REF_99(uint256) -> transactionIdsTemp[count]
REF_99(uint256) (->transactionIdsTemp) := i(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_125(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_transactionIds = new uint256[](to - from)

IRs:
TMP_127(uint256) = to - from
TMP_128(uint256[])  = new uint256[](TMP_127)
_transactionIds(uint256[]) = ['TMP_128(uint256[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < to

IRs:
TMP_129(bool) = i < to
CONDITION TMP_129"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionIds[i - from] = transactionIdsTemp[i]

IRs:
TMP_130(uint256) = i - from
REF_100(uint256) -> _transactionIds[TMP_130]
REF_101(uint256) -> transactionIdsTemp[i]
REF_100(uint256) (->_transactionIds) := REF_101(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_131(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_transactionIds

IRs:
RETURN _transactionIds"];
}
// Function: 24158.sol-MultiSigWallet-isConfirmed(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->13;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_73 -> LENGTH owners
TMP_97(bool) = i < REF_73
CONDITION TMP_97"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_74(mapping(address => bool)) -> confirmations[transactionId]
REF_75(address) -> owners[i]
REF_76(bool) -> REF_74[REF_75]
CONDITION REF_76"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_98(bool) = count == required
CONDITION TMP_98"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_99(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
13[label="Node Type: RETURN 13

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 24158.sol-MultiSigWallet-isConfirmedSettingsRequest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->13;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_23 -> LENGTH owners
TMP_30(bool) = i < REF_23
CONDITION TMP_30"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
settingsRequests[transactionId].confirmations[owners[i]]

IRs:
REF_24(MultiSigWallet.SettingsRequest) -> settingsRequests[transactionId]
REF_25(mapping(address => bool)) -> REF_24.confirmations
REF_26(address) -> owners[i]
REF_27(bool) -> REF_25[REF_26]
CONDITION REF_27"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_31(bool) = count == required
CONDITION TMP_31"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_32(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
13[label="Node Type: RETURN 13

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 24158.sol-MultiSigWallet-notConfirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! confirmations[transactionId][owner])

IRs:
REF_108(mapping(address => bool)) -> confirmations[transactionId]
REF_109(bool) -> REF_108[owner]
TMP_143 = UnaryType.BANG REF_109 
TMP_144(None) = SOLIDITY_CALL require(bool)(TMP_143)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-notExecuted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! transactions[transactionId].executed)

IRs:
REF_110(MultiSigWallet.Transaction) -> transactions[transactionId]
REF_111(bool) -> REF_110.executed
TMP_145 = UnaryType.BANG REF_111 
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0)

IRs:
TMP_147(bool) = _address != 0
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_135(bool) = msg.sender == owner
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(this))

IRs:
TMP_132 = CONVERT this to address
TMP_133(bool) = msg.sender == TMP_132
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isOwner[owner])

IRs:
REF_102(bool) -> isOwner[owner]
TMP_137 = UnaryType.BANG REF_102 
TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isOwner[owner])

IRs:
REF_103(bool) -> isOwner[owner]
TMP_139(None) = SOLIDITY_CALL require(bool)(REF_103)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = false

IRs:
REF_46(bool) -> isOwner[owner]
REF_46(bool) (->isOwner) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_47 -> LENGTH owners
TMP_45(uint256) = REF_47 - 1
TMP_46(bool) = i < TMP_45
CONDITION TMP_46"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
owners[i] == owner

IRs:
REF_48(address) -> owners[i]
TMP_47(bool) = REF_48 == owner
CONDITION TMP_47"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_49(address) -> owners[i]
REF_50 -> LENGTH owners
TMP_48(uint256) = REF_50 - 1
REF_51(address) -> owners[TMP_48]
REF_49(address) (->owners) := REF_51(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_49(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
owners.length -= 1

IRs:
REF_52 -> LENGTH owners
REF_52(-> owners) = REF_52 - 1"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
required > owners.length

IRs:
REF_53 -> LENGTH owners
TMP_50(bool) = required > REF_53
CONDITION TMP_50"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
changeRequirement(owners.length)

IRs:
REF_54 -> LENGTH owners
INTERNAL_CALL, MultiSigWallet.changeRequirement(uint256)(REF_54)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(owner)"];
17->1;
}
// Function: 24158.sol-MultiSigWallet-replaceOwner(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_55 -> LENGTH owners
TMP_55(bool) = i < REF_55
CONDITION TMP_55"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
owners[i] == owner

IRs:
REF_56(address) -> owners[i]
TMP_56(bool) = REF_56 == owner
CONDITION TMP_56"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
owners[i] = newOwner

IRs:
REF_57(address) -> owners[i]
REF_57(address) (->owners) := newOwner(address)"];
6->7;
7[label="Node Type: BREAK 7
"];
7->2;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_57(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
isOwner[owner] = false

IRs:
REF_58(bool) -> isOwner[owner]
REF_58(bool) (->isOwner) := False(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isOwner[newOwner] = true

IRs:
REF_59(bool) -> isOwner[newOwner]
REF_59(bool) (->isOwner) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerAddition(newOwner)

IRs:
Emit OwnerAddition(newOwner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(owner)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerDoesNotExist(newOwner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerDoesNotExist(address)(newOwner)"];
16->3;
}
// Function: 24158.sol-MultiSigWallet-revokeConfirmation(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_63(mapping(address => bool)) -> confirmations[transactionId]
REF_64(bool) -> REF_63[msg.sender]
REF_64(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.confirmed(uint256,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)"];
5->1;
}
// Function: 24158.sol-MultiSigWallet-setFinishedTx(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,0,0x64f65cc0)

IRs:
TMP_70(uint256) = INTERNAL_CALL, MultiSigWallet.addTransaction(address,uint256,bytes)(destination,0,0x64f65cc0)
transactionId(uint256) := TMP_70(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.confirmTransaction(uint256)(transactionId)"];
2->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(destination)"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 24158.sol-MultiSigWallet-setFreezeTx(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,0,0x2c8cbe40)

IRs:
TMP_78(uint256) = INTERNAL_CALL, MultiSigWallet.addTransaction(address,uint256,bytes)(destination,0,0x2c8cbe40)
transactionId(uint256) := TMP_78(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.confirmTransaction(uint256)(transactionId)"];
2->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(destination)"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 24158.sol-MultiSigWallet-setLiveTx(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,0,0x9d0714b2)

IRs:
TMP_74(uint256) = INTERNAL_CALL, MultiSigWallet.addTransaction(address,uint256,bytes)(destination,0,0x9d0714b2)
transactionId(uint256) := TMP_74(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.confirmTransaction(uint256)(transactionId)"];
2->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(destination)"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 24158.sol-MultiSigWallet-setToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token == address(0))

IRs:
TMP_9 = CONVERT 0 to address
TMP_10(bool) = token == TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token = IToken(_token)

IRs:
TMP_12 = CONVERT _token to IToken
token(IToken) := TMP_12(IToken)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyOwner()()"];
3->1;
}
// Function: 24158.sol-MultiSigWallet-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_OWNER_COUNT = 50

IRs:
MAX_OWNER_COUNT(uint256) := 50(uint256)"];
}
// Function: 24158.sol-MultiSigWallet-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
settingsRequestsCount = 0

IRs:
settingsRequestsCount(uint256) := 0(uint256)"];
}
// Function: 24158.sol-MultiSigWallet-submitTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data)

IRs:
TMP_66(uint256) = INTERNAL_CALL, MultiSigWallet.addTransaction(address,uint256,bytes)(destination,value,data)
transactionId(uint256) := TMP_66(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.confirmTransaction(uint256)(transactionId)"];
2->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(destination)"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 24158.sol-MultiSigWallet-tgeSettingsChangeRequest(uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(amount * partInvestor * partProject * blocksPerStage * partInvestorIncreasePerStage * maxStages != 0)

IRs:
TMP_14(uint256) = amount * partInvestor
TMP_15(uint256) = TMP_14 * partProject
TMP_16(uint256) = TMP_15 * blocksPerStage
TMP_17(uint256) = TMP_16 * partInvestorIncreasePerStage
TMP_18(uint256) = TMP_17 * maxStages
TMP_19(bool) = TMP_18 != 0
TMP_20(None) = SOLIDITY_CALL assert(bool)(TMP_19)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_txIndex = settingsRequestsCount

IRs:
_txIndex(uint256) := settingsRequestsCount(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
settingsRequests[_txIndex] = SettingsRequest({amount:amount,partInvestor:partInvestor,partProject:partProject,partFounders:partFounders,blocksPerStage:blocksPerStage,partInvestorIncreasePerStage:partInvestorIncreasePerStage,maxStages:maxStages,executed:false})

IRs:
REF_7(MultiSigWallet.SettingsRequest) -> settingsRequests[_txIndex]
TMP_21(MultiSigWallet.SettingsRequest) = new SettingsRequest(amount,partInvestor,partProject,partFounders,blocksPerStage,partInvestorIncreasePerStage,maxStages,False)
REF_7(MultiSigWallet.SettingsRequest) (->settingsRequests) := TMP_21(MultiSigWallet.SettingsRequest)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
settingsRequestsCount ++

IRs:
TMP_22(uint256) := settingsRequestsCount(uint256)
settingsRequestsCount(uint256) = settingsRequestsCount + 1"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_txIndex

IRs:
RETURN _txIndex"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
_txIndex

IRs:
RETURN _txIndex"];
}
// Function: 24158.sol-MultiSigWallet-transactionExists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transactions[transactionId].destination != 0)

IRs:
REF_104(MultiSigWallet.Transaction) -> transactions[transactionId]
REF_105(address) -> REF_104.destination
TMP_140(bool) = REF_105 != 0
TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ownerCount < MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0)

IRs:
TMP_149(bool) = ownerCount < MAX_OWNER_COUNT
TMP_150(bool) = _required <= ownerCount
TMP_151(bool) = TMP_149 && TMP_150
TMP_152(bool) = _required != 0
TMP_153(bool) = TMP_151 && TMP_152
TMP_154(bool) = ownerCount != 0
TMP_155(bool) = TMP_153 && TMP_154
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 24158.sol-MultiSigWallet-viewSettingsChange(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
request = settingsRequests[_txIndex]

IRs:
REF_33(MultiSigWallet.SettingsRequest) -> settingsRequests[_txIndex]
request(MultiSigWallet.SettingsRequest) := REF_33(MultiSigWallet.SettingsRequest)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
(request.amount,request.partInvestor,request.partProject,request.partFounders,request.blocksPerStage,request.partInvestorIncreasePerStage,request.maxStages)

IRs:
REF_34(uint256) -> request.amount
REF_35(uint256) -> request.partInvestor
REF_36(uint256) -> request.partProject
REF_37(uint256) -> request.partFounders
REF_38(uint256) -> request.blocksPerStage
REF_39(uint256) -> request.partInvestorIncreasePerStage
REF_40(uint256) -> request.maxStages
RETURN REF_34,REF_35,REF_36,REF_37,REF_38,REF_39,REF_40"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
(amount,partInvestor,partProject,partFounders,blocksPerStage,partInvestorIncreasePerStage,maxStages)

IRs:
RETURN amount,partInvestor,partProject,partFounders,blocksPerStage,partInvestorIncreasePerStage,maxStages"];
}
}
