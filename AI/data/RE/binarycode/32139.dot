digraph G {
// Function: 32139.sol-ERC20Interface-allowance(address,address)
digraph{
}
// Function: 32139.sol-ERC20Interface-approve(address,uint256)
digraph{
}
// Function: 32139.sol-ERC20Interface-balanceOf(address)
digraph{
}
// Function: 32139.sol-ERC20Interface-totalSupply()
digraph{
}
// Function: 32139.sol-ERC20Interface-transfer(address,uint256)
digraph{
}
// Function: 32139.sol-ERC20Interface-transferFrom(address,address,uint256)
digraph{
}
// Function: 32139.sol-GTO-GTO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[owner] = _totalSupply

IRs:
REF_6(uint256) -> balances[owner]
REF_6(uint256) (->balances) := _totalSupply(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0x0,owner,_totalSupply)

IRs:
Emit Transfer(0,owner,_totalSupply)"];
}
// Function: 32139.sol-GTO-addInvestorList(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < newInvestorList.length

IRs:
REF_10 -> LENGTH newInvestorList
TMP_22(bool) = i < REF_10
CONDITION TMP_22"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
approvedInvestorList[newInvestorList[i]] = true

IRs:
REF_11(address) -> newInvestorList[i]
REF_12(bool) -> approvedInvestorList[REF_11]
REF_12(bool) (->approvedInvestorList) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_23(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
7->3;
}
// Function: 32139.sol-GTO-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_43(mapping(address => uint256)) -> allowed[_owner]
REF_44(uint256) -> REF_43[_spender]
RETURN REF_44"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 32139.sol-GTO-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _amount

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
REF_42(uint256) (->allowed) := _amount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_amount)

IRs:
Emit Approval(msg.sender,_spender,_amount)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 32139.sol-GTO-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_addr]

IRs:
REF_7(uint256) -> balances[_addr]
RETURN REF_7"];
}
// Function: 32139.sol-GTO-buyGifto()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: IF 1

EXPRESSION:
deposit[msg.sender] == 0

IRs:
REF_0(uint256) -> deposit[msg.sender]
TMP_1(bool) = REF_0 == 0
CONDITION TMP_1"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
buyers.push(msg.sender)

IRs:
REF_2 -> LENGTH buyers
TMP_3(uint256) := REF_2(uint256)
TMP_4(uint256) = TMP_3 + 1
REF_2(uint256) (->buyers) := TMP_4(uint256)
REF_3(address) -> buyers[TMP_3]
REF_3(address) (->buyers) := msg.sender(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
deposit[msg.sender] += msg.value

IRs:
REF_4(uint256) -> deposit[msg.sender]
REF_4(-> deposit) = REF_4 + msg.value"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onSale()

IRs:
MODIFIER_CALL, GTO.onSale()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
validValue()

IRs:
MODIFIER_CALL, GTO.validValue()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
validInvestor()

IRs:
MODIFIER_CALL, GTO.validInvestor()()"];
8->1;
}
// Function: 32139.sol-GTO-deliveryToken(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->17;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[owner] >= _icoSupply)

IRs:
REF_16(uint256) -> balances[owner]
TMP_28(bool) = REF_16 >= _icoSupply
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = a

IRs:
i(uint256) := a(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i <= b

IRs:
TMP_30(bool) = i <= b
CONDITION TMP_30"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
approvedInvestorList[buyers[i]]

IRs:
REF_17(address) -> buyers[i]
REF_18(bool) -> approvedInvestorList[REF_17]
CONDITION REF_18"];
6->7[label="True"];
6->15[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
requestedUnits = (deposit[buyers[i]] * _originalBuyPrice) / 10 ** 18

IRs:
REF_19(address) -> buyers[i]
REF_20(uint256) -> deposit[REF_19]
TMP_31(uint256) = REF_20 * _originalBuyPrice
TMP_32(uint256) = 10 ** 18
TMP_33(uint256) = TMP_31 / TMP_32
requestedUnits(uint256) := TMP_33(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
requestedUnits <= _icoSupply && requestedUnits > 0

IRs:
TMP_34(bool) = requestedUnits <= _icoSupply
TMP_35(bool) = requestedUnits > 0
TMP_36(bool) = TMP_34 && TMP_35
CONDITION TMP_36"];
8->9[label="True"];
8->14[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[owner] -= requestedUnits

IRs:
REF_21(uint256) -> balances[owner]
REF_21(-> balances) = REF_21 - requestedUnits"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
balances[buyers[i]] += requestedUnits

IRs:
REF_22(address) -> buyers[i]
REF_23(uint256) -> balances[REF_22]
REF_23(-> balances) = REF_23 + requestedUnits"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_icoSupply -= requestedUnits

IRs:
_icoSupply(uint256) = _icoSupply - requestedUnits"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(owner,buyers[i],requestedUnits)

IRs:
REF_24(address) -> buyers[i]
Emit Transfer(owner,REF_24,requestedUnits)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
deposit[buyers[i]] = 0

IRs:
REF_25(address) -> buyers[i]
REF_26(uint256) -> deposit[REF_25]
REF_26(uint256) (->deposit) := 0(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_38(uint256) := i(uint256)
i(uint256) = i + 1"];
16->5;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
validRange(a,b)

IRs:
MODIFIER_CALL, GTO.validRange(uint256,uint256)(a,b)"];
18->1;
}
// Function: 32139.sol-GTO-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyGifto()

IRs:
INTERNAL_CALL, GTO.buyGifto()()"];
}
// Function: 32139.sol-GTO-getBuyers()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
buyers

IRs:
RETURN buyers"];
}
// Function: 32139.sol-GTO-getDeposit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
deposit[_addr]

IRs:
REF_9(uint256) -> deposit[_addr]
RETURN REF_9"];
}
// Function: 32139.sol-GTO-isApprovedInvestor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
approvedInvestorList[_addr]

IRs:
REF_8(bool) -> approvedInvestorList[_addr]
RETURN REF_8"];
}
// Function: 32139.sol-GTO-onSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_selling && (_icoSupply > 0))

IRs:
TMP_71(bool) = _icoSupply > 0
TMP_72(bool) = _selling && TMP_71
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 32139.sol-GTO-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_69(bool) = msg.sender == owner
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 32139.sol-GTO-removeInvestorList(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < investorList.length

IRs:
REF_13 -> LENGTH investorList
TMP_25(bool) = i < REF_13
CONDITION TMP_25"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
approvedInvestorList[investorList[i]] = false

IRs:
REF_14(address) -> investorList[i]
REF_15(bool) -> approvedInvestorList[REF_14]
REF_15(bool) (->approvedInvestorList) := False(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_26(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
7->3;
}
// Function: 32139.sol-GTO-setBuyPrice(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newBuyPrice > 0)

IRs:
TMP_16(bool) = newBuyPrice > 0
TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_originalBuyPrice = newBuyPrice

IRs:
_originalBuyPrice(uint256) := newBuyPrice(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_maximumBuy = 10 ** 18 * 10000000000 / _originalBuyPrice

IRs:
TMP_18(uint256) = 10 ** 18
TMP_19(uint256) = TMP_18 * 10000000000
TMP_20(uint256) = TMP_19 / _originalBuyPrice
_maximumBuy(uint256) := TMP_20(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
4->1;
}
// Function: 32139.sol-GTO-setIcoPercent(uint8)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_icoPercent = newIcoPercent

IRs:
_icoPercent(uint8) := newIcoPercent(uint8)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_icoSupply = _totalSupply * _icoPercent / 100

IRs:
TMP_12(uint256) = _totalSupply * _icoPercent
TMP_13(uint256) = TMP_12 / 100
_icoSupply(uint256) := TMP_13(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
3->1;
}
// Function: 32139.sol-GTO-setMaximumBuy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_maximumBuy = newMaximumBuy

IRs:
_maximumBuy(uint256) := newMaximumBuy(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
2->1;
}
// Function: 32139.sol-GTO-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 5

IRs:
decimals(uint8) := 5(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = GTO

IRs:
symbol(string) := GTO(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
name = GTO

IRs:
name(string) := GTO(string)"];
}
// Function: 32139.sol-GTO-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
_selling = false

IRs:
_selling(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
_totalSupply = 10 ** 14

IRs:
TMP_60(uint256) = 10 ** 14
_totalSupply(uint256) := TMP_60(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
_originalBuyPrice = 45 * 10 ** 7

IRs:
TMP_61(uint256) = 10 ** 7
TMP_62(uint256) = 45 * TMP_61
_originalBuyPrice(uint256) := TMP_62(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
_icoPercent = 10

IRs:
_icoPercent(uint8) := 10(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
_icoSupply = _totalSupply * _icoPercent / 100

IRs:
TMP_63(uint256) = _totalSupply * _icoPercent
TMP_64(uint256) = TMP_63 / 100
_icoSupply(uint256) := TMP_64(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
_minimumBuy = 3 * 10 ** 17

IRs:
TMP_65(uint256) = 10 ** 17
TMP_66(uint256) = 3 * TMP_65
_minimumBuy(uint256) := TMP_66(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
_maximumBuy = 30 * 10 ** 18

IRs:
TMP_67(uint256) = 10 ** 18
TMP_68(uint256) = 30 * TMP_67
_maximumBuy(uint256) := TMP_68(uint256)"];
}
// Function: 32139.sol-GTO-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply"];
}
// Function: 32139.sol-GTO-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[msg.sender] >= _amount) && (_amount >= 0) && (balances[_to] + _amount > balances[_to])

IRs:
REF_27(uint256) -> balances[msg.sender]
TMP_41(bool) = REF_27 >= _amount
TMP_42(bool) = _amount >= 0
TMP_43(bool) = TMP_41 && TMP_42
REF_28(uint256) -> balances[_to]
TMP_44(uint256) = REF_28 + _amount
REF_29(uint256) -> balances[_to]
TMP_45(bool) = TMP_44 > REF_29
TMP_46(bool) = TMP_43 && TMP_45
CONDITION TMP_46"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _amount

IRs:
REF_30(uint256) -> balances[msg.sender]
REF_30(-> balances) = REF_30 - _amount"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _amount

IRs:
REF_31(uint256) -> balances[_to]
REF_31(-> balances) = REF_31 + _amount"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 32139.sol-GTO-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]

IRs:
REF_32(uint256) -> balances[_from]
TMP_48(bool) = REF_32 >= _amount
REF_33(mapping(address => uint256)) -> allowed[_from]
REF_34(uint256) -> REF_33[msg.sender]
TMP_49(bool) = REF_34 >= _amount
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = _amount > 0
TMP_52(bool) = TMP_50 && TMP_51
REF_35(uint256) -> balances[_to]
TMP_53(uint256) = REF_35 + _amount
REF_36(uint256) -> balances[_to]
TMP_54(bool) = TMP_53 > REF_36
TMP_55(bool) = TMP_52 && TMP_54
CONDITION TMP_55"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] -= _amount

IRs:
REF_37(uint256) -> balances[_from]
REF_37(-> balances) = REF_37 - _amount"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_38(mapping(address => uint256)) -> allowed[_from]
REF_39(uint256) -> REF_38[msg.sender]
REF_39(-> allowed) = REF_39 - _amount"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _amount

IRs:
REF_40(uint256) -> balances[_to]
REF_40(-> balances) = REF_40 + _amount"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 32139.sol-GTO-turnOffSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_selling = false

IRs:
_selling(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
2->1;
}
// Function: 32139.sol-GTO-turnOnSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_selling = true

IRs:
_selling(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
2->1;
}
// Function: 32139.sol-GTO-validInvestor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approvedInvestorList[msg.sender])

IRs:
REF_47(bool) -> approvedInvestorList[msg.sender]
TMP_74(None) = SOLIDITY_CALL require(bool)(REF_47)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 32139.sol-GTO-validRange(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((a >= 0 && a <= b) && (b < buyers.length))

IRs:
TMP_80(bool) = a >= 0
TMP_81(bool) = a <= b
TMP_82(bool) = TMP_80 && TMP_81
REF_49 -> LENGTH buyers
TMP_83(bool) = b < REF_49
TMP_84(bool) = TMP_82 && TMP_83
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 32139.sol-GTO-validValue()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((msg.value >= _minimumBuy) && ((deposit[msg.sender] + msg.value) <= _maximumBuy))

IRs:
TMP_75(bool) = msg.value >= _minimumBuy
REF_48(uint256) -> deposit[msg.sender]
TMP_76(uint256) = REF_48 + msg.value
TMP_77(bool) = TMP_76 <= _maximumBuy
TMP_78(bool) = TMP_75 && TMP_77
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 32139.sol-GTO-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
owner.send(this.balance)

IRs:
REF_46(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_58 = SEND dest:owner value:REF_46
RETURN TMP_58"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GTO.onlyOwner()()"];
2->1;
}
// Function: 32139.sol-MultiSigWallet-MultiSigWallet(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_50 -> LENGTH _owners
TMP_88(bool) = i < REF_50
CONDITION TMP_88"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
isOwner[_owners[i]] || _owners[i] == 0

IRs:
REF_51(address) -> _owners[i]
REF_52(bool) -> isOwner[REF_51]
REF_53(address) -> _owners[i]
TMP_89(bool) = REF_53 == 0
TMP_90(bool) = REF_52 || TMP_89
CONDITION TMP_90"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_91(None) = SOLIDITY_CALL revert()()"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_54(address) -> _owners[i]
REF_55(bool) -> isOwner[REF_54]
REF_55(bool) (->isOwner) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_92(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_56 -> LENGTH _owners
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(REF_56,_required)"];
12->3;
}
// Function: 32139.sol-MultiSigWallet-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_57(bool) -> isOwner[owner]
REF_57(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_59 -> LENGTH owners
TMP_95(uint256) := REF_59(uint256)
TMP_96(uint256) = TMP_95 + 1
REF_59(uint256) (->owners) := TMP_96(uint256)
REF_60(address) -> owners[TMP_95]
REF_60(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerDoesNotExist(address)(owner)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notNull(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(owner)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
validRequirement(owners.length + 1,required)

IRs:
REF_61 -> LENGTH owners
TMP_101(uint256) = REF_61 + 1
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(TMP_101,required)"];
7->1;
}
// Function: 32139.sol-MultiSigWallet-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = transactionCount

IRs:
transactionId(uint256) := transactionCount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId] = Transaction({destination:destination,value:value,data:data,executed:false})

IRs:
REF_93(MultiSigWallet.Transaction) -> transactions[transactionId]
TMP_144(MultiSigWallet.Transaction) = new Transaction(destination,value,data,False)
REF_93(MultiSigWallet.Transaction) (->transactions) := TMP_144(MultiSigWallet.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactionCount += 1

IRs:
transactionCount(uint256) = transactionCount + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(destination)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 32139.sol-MultiSigWallet-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_76 -> LENGTH owners
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(REF_76,_required)"];
4->1;
}
// Function: 32139.sol-MultiSigWallet-confirmTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_77(mapping(address => bool)) -> confirmations[transactionId]
REF_78(bool) -> REF_77[msg.sender]
REF_78(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.executeTransaction(uint256)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transactionExists(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.transactionExists(uint256)(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.notConfirmed(uint256,address)(transactionId,msg.sender)"];
6->1;
}
// Function: 32139.sol-MultiSigWallet-confirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! confirmations[transactionId][owner]

IRs:
REF_122(mapping(address => bool)) -> confirmations[transactionId]
REF_123(bool) -> REF_122[owner]
TMP_191 = UnaryType.BANG REF_123 
CONDITION TMP_191"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_192(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-createCoin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(flag == true)

IRs:
TMP_177(bool) = flag == True
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
CoinCreation(new GTO())

IRs:
TMP_180(GTO) = new GTO() 
Emit CoinCreation(TMP_180)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
flag = false

IRs:
flag(bool) := False(bool)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
4->1;
}
// Function: 32139.sol-MultiSigWallet-executeTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_135(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_135"];
1->2[label="True"];
1->9[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tx = transactions[transactionId]

IRs:
REF_81(MultiSigWallet.Transaction) -> transactions[transactionId]
tx(MultiSigWallet.Transaction) := REF_81(MultiSigWallet.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tx.executed = true

IRs:
REF_82(bool) -> tx.executed
REF_82(bool) (->tx) := True(bool)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
tx.destination.call.value(tx.value)(tx.data)

IRs:
REF_83(address) -> tx.destination
REF_86(uint256) -> tx.value
REF_87(bytes) -> tx.data
TMP_137(bool) = LOW_LEVEL_CALL, dest:REF_83, function:call, arguments:['REF_87'] value:REF_86 
CONDITION TMP_137"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)"];
5->8;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tx.executed = false

IRs:
REF_88(bool) -> tx.executed
REF_88(bool) (->tx) := False(bool)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)"];
10->1;
}
// Function: 32139.sol-MultiSigWallet-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_86(bool) = msg.value > 0
CONDITION TMP_86"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 32139.sol-MultiSigWallet-getConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_94 -> LENGTH owners
TMP_147(bool) = i < REF_94
CONDITION TMP_147"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_95(mapping(address => bool)) -> confirmations[transactionId]
REF_96(address) -> owners[i]
REF_97(bool) -> REF_95[REF_96]
CONDITION REF_97"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_148(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 32139.sol-MultiSigWallet-getConfirmations(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
confirmationsTemp = new address[](owners.length)

IRs:
REF_102 -> LENGTH owners
TMP_156(address[])  = new address[](REF_102)
confirmationsTemp(address[]) = ['TMP_156(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length

IRs:
REF_103 -> LENGTH owners
TMP_157(bool) = i < REF_103
CONDITION TMP_157"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_104(mapping(address => bool)) -> confirmations[transactionId]
REF_105(address) -> owners[i]
REF_106(bool) -> REF_104[REF_105]
CONDITION REF_106"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
confirmationsTemp[count] = owners[i]

IRs:
REF_107(address) -> confirmationsTemp[count]
REF_108(address) -> owners[i]
REF_107(address) (->confirmationsTemp) := REF_108(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_158(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_confirmations = new address[](count)

IRs:
TMP_160(address[])  = new address[](count)
_confirmations(address[]) = ['TMP_160(address[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < count

IRs:
TMP_161(bool) = i < count
CONDITION TMP_161"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_confirmations[i] = confirmationsTemp[i]

IRs:
REF_109(address) -> _confirmations[i]
REF_110(address) -> confirmationsTemp[i]
REF_109(address) (->_confirmations) := REF_110(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_162(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_confirmations

IRs:
RETURN _confirmations"];
}
// Function: 32139.sol-MultiSigWallet-getOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owners

IRs:
RETURN owners"];
}
// Function: 32139.sol-MultiSigWallet-getTransactionCount(bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < transactionCount

IRs:
TMP_149(bool) = i < transactionCount
CONDITION TMP_149"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_98(MultiSigWallet.Transaction) -> transactions[i]
REF_99(bool) -> REF_98.executed
TMP_150 = UnaryType.BANG REF_99 
TMP_151(bool) = pending && TMP_150
REF_100(MultiSigWallet.Transaction) -> transactions[i]
REF_101(bool) -> REF_100.executed
TMP_152(bool) = executed && REF_101
TMP_153(bool) = TMP_151 || TMP_152
CONDITION TMP_153"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_154(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 32139.sol-MultiSigWallet-getTransactionIds(uint256,uint256,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
transactionIdsTemp = new uint256[](transactionCount)

IRs:
TMP_164(uint256[])  = new uint256[](transactionCount)
transactionIdsTemp(uint256[]) = ['TMP_164(uint256[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < transactionCount

IRs:
TMP_165(bool) = i < transactionCount
CONDITION TMP_165"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_111(MultiSigWallet.Transaction) -> transactions[i]
REF_112(bool) -> REF_111.executed
TMP_166 = UnaryType.BANG REF_112 
TMP_167(bool) = pending && TMP_166
REF_113(MultiSigWallet.Transaction) -> transactions[i]
REF_114(bool) -> REF_113.executed
TMP_168(bool) = executed && REF_114
TMP_169(bool) = TMP_167 || TMP_168
CONDITION TMP_169"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transactionIdsTemp[count] = i

IRs:
REF_115(uint256) -> transactionIdsTemp[count]
REF_115(uint256) (->transactionIdsTemp) := i(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_170(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_transactionIds = new uint256[](to - from)

IRs:
TMP_172(uint256) = to - from
TMP_173(uint256[])  = new uint256[](TMP_172)
_transactionIds(uint256[]) = ['TMP_173(uint256[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < to

IRs:
TMP_174(bool) = i < to
CONDITION TMP_174"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionIds[i - from] = transactionIdsTemp[i]

IRs:
TMP_175(uint256) = i - from
REF_116(uint256) -> _transactionIds[TMP_175]
REF_117(uint256) -> transactionIdsTemp[i]
REF_116(uint256) (->_transactionIds) := REF_117(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_176(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_transactionIds

IRs:
RETURN _transactionIds"];
}
// Function: 32139.sol-MultiSigWallet-isConfirmed(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_89 -> LENGTH owners
TMP_141(bool) = i < REF_89
CONDITION TMP_141"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_90(mapping(address => bool)) -> confirmations[transactionId]
REF_91(address) -> owners[i]
REF_92(bool) -> REF_90[REF_91]
CONDITION REF_92"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_142(bool) = count == required
CONDITION TMP_142"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_143(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
}
// Function: 32139.sol-MultiSigWallet-notConfirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
confirmations[transactionId][owner]

IRs:
REF_124(mapping(address => bool)) -> confirmations[transactionId]
REF_125(bool) -> REF_124[owner]
CONDITION REF_125"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_193(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-notExecuted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].executed

IRs:
REF_126(MultiSigWallet.Transaction) -> transactions[transactionId]
REF_127(bool) -> REF_126.executed
CONDITION REF_127"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_194(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_address == 0

IRs:
TMP_195(bool) = _address == 0
CONDITION TMP_195"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_196(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != address(this)

IRs:
TMP_183 = CONVERT this to address
TMP_184(bool) = msg.sender != TMP_183
CONDITION TMP_184"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_185(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isOwner[owner]

IRs:
REF_118(bool) -> isOwner[owner]
CONDITION REF_118"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_186(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isOwner[owner]

IRs:
REF_119(bool) -> isOwner[owner]
TMP_187 = UnaryType.BANG REF_119 
CONDITION TMP_187"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_188(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = false

IRs:
REF_62(bool) -> isOwner[owner]
REF_62(bool) (->isOwner) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_63 -> LENGTH owners
TMP_103(uint256) = REF_63 - 1
TMP_104(bool) = i < TMP_103
CONDITION TMP_104"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
owners[i] == owner

IRs:
REF_64(address) -> owners[i]
TMP_105(bool) = REF_64 == owner
CONDITION TMP_105"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_65(address) -> owners[i]
REF_66 -> LENGTH owners
TMP_106(uint256) = REF_66 - 1
REF_67(address) -> owners[TMP_106]
REF_65(address) (->owners) := REF_67(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_107(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
owners.length -= 1

IRs:
REF_68 -> LENGTH owners
REF_68(-> owners) = REF_68 - 1"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
required > owners.length

IRs:
REF_69 -> LENGTH owners
TMP_108(bool) = required > REF_69
CONDITION TMP_108"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
changeRequirement(owners.length)

IRs:
REF_70 -> LENGTH owners
INTERNAL_CALL, MultiSigWallet.changeRequirement(uint256)(REF_70)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(owner)"];
17->1;
}
// Function: 32139.sol-MultiSigWallet-replaceOwner(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_71 -> LENGTH owners
TMP_113(bool) = i < REF_71
CONDITION TMP_113"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
owners[i] == owner

IRs:
REF_72(address) -> owners[i]
TMP_114(bool) = REF_72 == owner
CONDITION TMP_114"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
owners[i] = newOwner

IRs:
REF_73(address) -> owners[i]
REF_73(address) (->owners) := newOwner(address)"];
6->7;
7[label="Node Type: BREAK 7
"];
7->2;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_115(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
isOwner[owner] = false

IRs:
REF_74(bool) -> isOwner[owner]
REF_74(bool) (->isOwner) := False(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isOwner[newOwner] = true

IRs:
REF_75(bool) -> isOwner[newOwner]
REF_75(bool) (->isOwner) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerAddition(newOwner)

IRs:
Emit OwnerAddition(newOwner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(owner)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerDoesNotExist(newOwner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerDoesNotExist(address)(newOwner)"];
16->3;
}
// Function: 32139.sol-MultiSigWallet-revokeConfirmation(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_79(mapping(address => bool)) -> confirmations[transactionId]
REF_80(bool) -> REF_79[msg.sender]
REF_80(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.confirmed(uint256,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)"];
5->1;
}
// Function: 32139.sol-MultiSigWallet-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_OWNER_COUNT = 50

IRs:
MAX_OWNER_COUNT(uint256) := 50(uint256)"];
}
// Function: 32139.sol-MultiSigWallet-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
flag = true

IRs:
flag(bool) := True(bool)"];
}
// Function: 32139.sol-MultiSigWallet-submitTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data)

IRs:
TMP_124(uint256) = INTERNAL_CALL, MultiSigWallet.addTransaction(address,uint256,bytes)(destination,value,data)
transactionId(uint256) := TMP_124(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.confirmTransaction(uint256)(transactionId)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 32139.sol-MultiSigWallet-transactionExists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].destination == 0

IRs:
REF_120(MultiSigWallet.Transaction) -> transactions[transactionId]
REF_121(address) -> REF_120.destination
TMP_189(bool) = REF_121 == 0
CONDITION TMP_189"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_190(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 32139.sol-MultiSigWallet-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0

IRs:
TMP_197(bool) = ownerCount > MAX_OWNER_COUNT
TMP_198(bool) = _required > ownerCount
TMP_199(bool) = TMP_197 || TMP_198
TMP_200(bool) = _required == 0
TMP_201(bool) = TMP_199 || TMP_200
TMP_202(bool) = ownerCount == 0
TMP_203(bool) = TMP_201 || TMP_202
CONDITION TMP_203"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_204(None) = SOLIDITY_CALL revert()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
}
