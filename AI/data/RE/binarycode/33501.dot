digraph G {
// Function: 33501.sol-ERC20Interface-balanceOf(address)
digraph{
}
// Function: 33501.sol-ERC20Interface-totalSupply()
digraph{
}
// Function: 33501.sol-ERC20Interface-transfer(address,uint256)
digraph{
}
// Function: 33501.sol-Gifto-Gifto()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[owner] = _totalSupply

IRs:
REF_5(uint256) -> balances[owner]
REF_5(uint256) (->balances) := _totalSupply(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0x0,owner,_totalSupply)

IRs:
Emit Transfer(0,owner,_totalSupply)"];
}
// Function: 33501.sol-Gifto-addInvestorList(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < newInvestorList.length

IRs:
REF_49 -> LENGTH newInvestorList
TMP_55(bool) = i < REF_49
CONDITION TMP_55"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
approvedInvestorList[newInvestorList[i]] = true

IRs:
REF_50(address) -> newInvestorList[i]
REF_51(bool) -> approvedInvestorList[REF_50]
REF_51(bool) (->approvedInvestorList) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_56(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
7->3;
}
// Function: 33501.sol-Gifto-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_addr]

IRs:
REF_6(uint256) -> balances[_addr]
RETURN REF_6"];
}
// Function: 33501.sol-Gifto-buy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
requestedUnits = msg.value / _originalBuyPrice

IRs:
TMP_61(uint256) = msg.value / _originalBuyPrice
requestedUnits(uint256) := TMP_61(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(requestedUnits <= _icoSupply)

IRs:
TMP_62(bool) = requestedUnits <= _icoSupply
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] -= requestedUnits

IRs:
REF_55(uint256) -> balances[owner]
REF_55(-> balances) = REF_55 - requestedUnits"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] += requestedUnits

IRs:
REF_56(uint256) -> balances[msg.sender]
REF_56(-> balances) = REF_56 + requestedUnits"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_icoSupply -= requestedUnits

IRs:
_icoSupply(uint256) = _icoSupply - requestedUnits"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(owner,msg.sender,requestedUnits)

IRs:
Emit Transfer(owner,msg.sender,requestedUnits)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
requestedUnits

IRs:
RETURN requestedUnits"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyNotOwner()

IRs:
MODIFIER_CALL, Gifto.onlyNotOwner()()"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
validOriginalBuyPrice()

IRs:
MODIFIER_CALL, Gifto.validOriginalBuyPrice()()"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
validInvestor()

IRs:
MODIFIER_CALL, Gifto.validInvestor()()"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onSale()

IRs:
MODIFIER_CALL, Gifto.onSale()()"];
12->1;
13[label="Node Type: RETURN 13

EXPRESSION:
amount

IRs:
RETURN amount"];
}
// Function: 33501.sol-Gifto-deliveryToken(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->19;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sum = 0

IRs:
sum(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->18;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < buyers.length

IRs:
REF_21 -> LENGTH buyers
TMP_28(bool) = i < REF_21
CONDITION TMP_28"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
approvedInvestorList[buyers[i]] == isInvestor

IRs:
REF_22(address) -> buyers[i]
REF_23(bool) -> approvedInvestorList[REF_22]
TMP_29(bool) = REF_23 == isInvestor
CONDITION TMP_29"];
6->7[label="True"];
6->16[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
requestedUnits = deposit[buyers[i]] / _originalBuyPrice

IRs:
REF_24(address) -> buyers[i]
REF_25(uint256) -> deposit[REF_24]
TMP_30(uint256) = REF_25 / _originalBuyPrice
requestedUnits(uint256) := TMP_30(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
requestedUnits <= _icoSupply && requestedUnits > 0

IRs:
TMP_31(bool) = requestedUnits <= _icoSupply
TMP_32(bool) = requestedUnits > 0
TMP_33(bool) = TMP_31 && TMP_32
CONDITION TMP_33"];
8->9[label="True"];
8->15[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[owner] -= requestedUnits

IRs:
REF_26(uint256) -> balances[owner]
REF_26(-> balances) = REF_26 - requestedUnits"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
balances[buyers[i]] += requestedUnits

IRs:
REF_27(address) -> buyers[i]
REF_28(uint256) -> balances[REF_27]
REF_28(-> balances) = REF_28 + requestedUnits"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_icoSupply -= requestedUnits

IRs:
_icoSupply(uint256) = _icoSupply - requestedUnits"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(owner,buyers[i],requestedUnits)

IRs:
REF_29(address) -> buyers[i]
Emit Transfer(owner,REF_29,requestedUnits)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
sum += deposit[buyers[i]]

IRs:
REF_30(address) -> buyers[i]
REF_31(uint256) -> deposit[REF_30]
sum(uint256) = sum + REF_31"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
deposit[buyers[i]] = 0

IRs:
REF_32(address) -> buyers[i]
REF_33(uint256) -> deposit[REF_32]
REF_33(uint256) (->deposit) := 0(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_35(uint256) := i(uint256)
i(uint256) = i + 1"];
17->5;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
owner.transfer(sum)

IRs:
Transfer dest:owner value:sum"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
validOriginalBuyPrice()

IRs:
MODIFIER_CALL, Gifto.validOriginalBuyPrice()()"];
20->1;
}
// Function: 33501.sol-Gifto-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
deposit[msg.sender] == 0 && msg.value != 0

IRs:
REF_0(uint256) -> deposit[msg.sender]
TMP_0(bool) = REF_0 == 0
TMP_1(bool) = msg.value != 0
TMP_2(bool) = TMP_0 && TMP_1
CONDITION TMP_2"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
buyers.push(msg.sender)

IRs:
REF_2 -> LENGTH buyers
TMP_4(uint256) := REF_2(uint256)
TMP_5(uint256) = TMP_4 + 1
REF_2(uint256) (->buyers) := TMP_5(uint256)
REF_3(address) -> buyers[TMP_4]
REF_3(address) (->buyers) := msg.sender(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
deposit[msg.sender] += msg.value

IRs:
REF_4(uint256) -> deposit[msg.sender]
REF_4(-> deposit) = REF_4 + msg.value"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
validValue()

IRs:
MODIFIER_CALL, Gifto.validValue()()"];
5->1;
}
// Function: 33501.sol-Gifto-filterBuyers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
filterTmp = new address[](buyers.length)

IRs:
REF_8 -> LENGTH buyers
TMP_14(address[])  = new address[](REF_8)
filterTmp(address[]) = ['TMP_14(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->12;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < buyers.length

IRs:
REF_9 -> LENGTH buyers
TMP_15(bool) = i < REF_9
CONDITION TMP_15"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
approvedInvestorList[buyers[i]] == isInvestor

IRs:
REF_10(address) -> buyers[i]
REF_11(bool) -> approvedInvestorList[REF_10]
TMP_16(bool) = REF_11 == isInvestor
CONDITION TMP_16"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
filterTmp[count] = buyers[i]

IRs:
REF_12(address) -> filterTmp[count]
REF_13(address) -> buyers[i]
REF_12(address) (->filterTmp) := REF_13(address)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
count ++

IRs:
TMP_17(uint256) := count(uint256)
count(uint256) = count + 1"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_18(uint256) := i(uint256)
i(uint256) = i + 1"];
11->6;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
filterList = new address[](count)

IRs:
TMP_20(address[])  = new address[](count)
filterList(address[]) = ['TMP_20(address[])']"];
12->15;
13[label="Node Type: BEGIN_LOOP 13
"];
13->16;
14[label="Node Type: END_LOOP 14
"];
14->21;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
15->13;
16[label="Node Type: IF_LOOP 16

EXPRESSION:
i < count

IRs:
TMP_21(bool) = i < count
CONDITION TMP_21"];
16->17[label="True"];
16->14[label="False"];
17[label="Node Type: IF 17

EXPRESSION:
filterTmp[i] != 0x0

IRs:
REF_14(address) -> filterTmp[i]
TMP_22(bool) = REF_14 != 0
CONDITION TMP_22"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
filterList[i] = filterTmp[i]

IRs:
REF_15(address) -> filterList[i]
REF_16(address) -> filterTmp[i]
REF_15(address) (->filterList) := REF_16(address)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
i ++

IRs:
TMP_23(uint256) := i(uint256)
i(uint256) = i + 1"];
20->16;
21[label="Node Type: RETURN 21

EXPRESSION:
filterList

IRs:
RETURN filterList"];
}
// Function: 33501.sol-Gifto-getDeposit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
deposit[_addr]

IRs:
REF_17(uint256) -> deposit[_addr]
RETURN REF_17"];
}
// Function: 33501.sol-Gifto-getInvestorBuyers()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
filterBuyers(true)

IRs:
TMP_24(address[]) = INTERNAL_CALL, Gifto.filterBuyers(bool)(True)
RETURN TMP_24"];
}
// Function: 33501.sol-Gifto-getNormalBuyers()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
filterBuyers(false)

IRs:
TMP_25(address[]) = INTERNAL_CALL, Gifto.filterBuyers(bool)(False)
RETURN TMP_25"];
}
// Function: 33501.sol-Gifto-getTotalDeposit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalDeposit = 0

IRs:
totalDeposit(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->8;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < buyers.length

IRs:
REF_18 -> LENGTH buyers
TMP_26(bool) = i < REF_18
CONDITION TMP_26"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalDeposit += deposit[buyers[i]]

IRs:
REF_19(address) -> buyers[i]
REF_20(uint256) -> deposit[REF_19]
totalDeposit(uint256) = totalDeposit + REF_20"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_27(uint256) := i(uint256)
i(uint256) = i + 1"];
7->5;
8[label="Node Type: RETURN 8

EXPRESSION:
totalDeposit

IRs:
RETURN totalDeposit"];
}
// Function: 33501.sol-Gifto-isApprovedInvestor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
approvedInvestorList[_addr]

IRs:
REF_7(bool) -> approvedInvestorList[_addr]
RETURN REF_7"];
}
// Function: 33501.sol-Gifto-isSellingNow()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_selling

IRs:
RETURN _selling"];
}
// Function: 33501.sol-Gifto-onSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_selling && (_icoSupply > 0))

IRs:
TMP_83(bool) = _icoSupply > 0
TMP_84(bool) = _selling && TMP_83
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-Gifto-onlyNotOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender != owner)

IRs:
TMP_81(bool) = msg.sender != owner
TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-Gifto-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_79(bool) = msg.sender == owner
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-Gifto-removeInvestorList(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < investorList.length

IRs:
REF_52 -> LENGTH investorList
TMP_58(bool) = i < REF_52
CONDITION TMP_58"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
approvedInvestorList[investorList[i]] = false

IRs:
REF_53(address) -> investorList[i]
REF_54(bool) -> approvedInvestorList[REF_53]
REF_54(bool) (->approvedInvestorList) := False(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_59(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
7->3;
}
// Function: 33501.sol-Gifto-returnETHforNormalBuyers()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < buyers.length

IRs:
REF_35 -> LENGTH buyers
TMP_39(bool) = i < REF_35
CONDITION TMP_39"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
! approvedInvestorList[buyers[i]]

IRs:
REF_36(address) -> buyers[i]
REF_37(bool) -> approvedInvestorList[REF_36]
TMP_40 = UnaryType.BANG REF_37 
CONDITION TMP_40"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
buyerDeposit = deposit[buyers[i]]

IRs:
REF_38(address) -> buyers[i]
REF_39(uint256) -> deposit[REF_38]
buyerDeposit(uint256) := REF_39(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
deposit[buyers[i]] = 0

IRs:
REF_40(address) -> buyers[i]
REF_41(uint256) -> deposit[REF_40]
REF_41(uint256) (->deposit) := 0(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
buyers[i].transfer(buyerDeposit)

IRs:
REF_42(address) -> buyers[i]
Transfer dest:REF_42 value:buyerDeposit"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_42(uint256) := i(uint256)
i(uint256) = i + 1"];
10->4;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
11->3;
}
// Function: 33501.sol-Gifto-setBuyPrice(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_originalBuyPrice = newBuyPrice

IRs:
_originalBuyPrice(uint256) := newBuyPrice(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
2->1;
}
// Function: 33501.sol-Gifto-setIcoPercent(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_icoPercent = newIcoPercent

IRs:
_icoPercent(uint256) := newIcoPercent(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_icoSupply = _totalSupply * _icoPercent / 100

IRs:
TMP_8(uint256) = _totalSupply * _icoPercent
TMP_9(uint256) = TMP_8 / 100
_icoSupply(uint256) := TMP_9(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
3->1;
}
// Function: 33501.sol-Gifto-setMaximumBuy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_maximumBuy = newMaximumBuy

IRs:
_maximumBuy(uint256) := newMaximumBuy(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
2->1;
}
// Function: 33501.sol-Gifto-setMinimumBuy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_minimumBuy = newMinimumBuy

IRs:
_minimumBuy(uint256) := newMinimumBuy(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
2->1;
}
// Function: 33501.sol-Gifto-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 5

IRs:
decimals(uint256) := 5(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = Gifto

IRs:
symbol(string) := Gifto(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
name = Gifto

IRs:
name(string) := Gifto(string)"];
}
// Function: 33501.sol-Gifto-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
_selling = false

IRs:
_selling(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
_totalSupply = 10 ** 14

IRs:
TMP_72(uint256) = 10 ** 14
_totalSupply(uint256) := TMP_72(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
_originalBuyPrice = 10 ** 10

IRs:
TMP_73(uint256) = 10 ** 10
_originalBuyPrice(uint256) := TMP_73(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
_icoPercent = 10

IRs:
_icoPercent(uint256) := 10(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
_icoSupply = _totalSupply * _icoPercent / 100

IRs:
TMP_74(uint256) = _totalSupply * _icoPercent
TMP_75(uint256) = TMP_74 / 100
_icoSupply(uint256) := TMP_75(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
_minimumBuy = 10 ** 17

IRs:
TMP_76(uint256) = 10 ** 17
_minimumBuy(uint256) := TMP_76(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
_maximumBuy = 30 * 10 ** 18

IRs:
TMP_77(uint256) = 10 ** 18
TMP_78(uint256) = 30 * TMP_77
_maximumBuy(uint256) := TMP_78(uint256)"];
}
// Function: 33501.sol-Gifto-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply"];
}
// Function: 33501.sol-Gifto-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(balances[msg.sender] >= _amount) && (_amount >= 0) && (balances[_to] + _amount > balances[_to])

IRs:
REF_44(uint256) -> balances[msg.sender]
TMP_44(bool) = REF_44 >= _amount
TMP_45(bool) = _amount >= 0
TMP_46(bool) = TMP_44 && TMP_45
REF_45(uint256) -> balances[_to]
TMP_47(uint256) = REF_45 + _amount
REF_46(uint256) -> balances[_to]
TMP_48(bool) = TMP_47 > REF_46
TMP_49(bool) = TMP_46 && TMP_48
CONDITION TMP_49"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _amount

IRs:
REF_47(uint256) -> balances[msg.sender]
REF_47(-> balances) = REF_47 - _amount"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _amount

IRs:
REF_48(uint256) -> balances[_to]
REF_48(-> balances) = REF_48 + _amount"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_51(None) = SOLIDITY_CALL revert()()"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 33501.sol-Gifto-turnOffSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_selling = false

IRs:
_selling(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
2->1;
}
// Function: 33501.sol-Gifto-turnOnSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_selling = true

IRs:
_selling(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
2->1;
}
// Function: 33501.sol-Gifto-validInvestor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approvedInvestorList[msg.sender])

IRs:
REF_60(bool) -> approvedInvestorList[msg.sender]
TMP_88(None) = SOLIDITY_CALL require(bool)(REF_60)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-Gifto-validOriginalBuyPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_originalBuyPrice > 0)

IRs:
TMP_86(bool) = _originalBuyPrice > 0
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-Gifto-validValue()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((msg.value >= _minimumBuy) && ((deposit[msg.sender] + msg.value) <= _maximumBuy))

IRs:
TMP_89(bool) = msg.value >= _minimumBuy
REF_61(uint256) -> deposit[msg.sender]
TMP_90(uint256) = REF_61 + msg.value
TMP_91(bool) = TMP_90 <= _maximumBuy
TMP_92(bool) = TMP_89 && TMP_91
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-Gifto-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
owner.send(this.balance)

IRs:
REF_59(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_70 = SEND dest:owner value:REF_59
RETURN TMP_70"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Gifto.onlyOwner()()"];
2->1;
}
// Function: 33501.sol-MultiSigWallet-MultiSigWallet(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_62 -> LENGTH _owners
TMP_94(bool) = i < REF_62
CONDITION TMP_94"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
isOwner[_owners[i]] || _owners[i] == 0

IRs:
REF_63(address) -> _owners[i]
REF_64(bool) -> isOwner[REF_63]
REF_65(address) -> _owners[i]
TMP_95(bool) = REF_65 == 0
TMP_96(bool) = REF_64 || TMP_95
CONDITION TMP_96"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_97(None) = SOLIDITY_CALL revert()()"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_66(address) -> _owners[i]
REF_67(bool) -> isOwner[REF_66]
REF_67(bool) (->isOwner) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_98(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_68 -> LENGTH _owners
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(REF_68,_required)"];
12->3;
}
// Function: 33501.sol-MultiSigWallet-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_69(bool) -> isOwner[owner]
REF_69(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_71 -> LENGTH owners
TMP_103(uint256) := REF_71(uint256)
TMP_104(uint256) = TMP_103 + 1
REF_71(uint256) (->owners) := TMP_104(uint256)
REF_72(address) -> owners[TMP_103]
REF_72(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerDoesNotExist(address)(owner)"];
5->1;
}
// Function: 33501.sol-MultiSigWallet-addTransaction(address,uint256,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = keccak256()(destination,value,data,nonce)

IRs:
TMP_123(bytes32) = SOLIDITY_CALL keccak256()(destination,value,data,nonce)
transactionId(bytes32) := TMP_123(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
transactions[transactionId].destination == 0

IRs:
REF_84(MultiSigWallet.Transaction) -> transactions[transactionId]
REF_85(address) -> REF_84.destination
TMP_124(bool) = REF_85 == 0
CONDITION TMP_124"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactions[transactionId] = Transaction({destination:destination,value:value,data:data,nonce:nonce,executed:false})

IRs:
REF_86(MultiSigWallet.Transaction) -> transactions[transactionId]
TMP_125(MultiSigWallet.Transaction) = new Transaction(destination,value,data,nonce,False)
REF_86(MultiSigWallet.Transaction) (->transactions) := TMP_125(MultiSigWallet.Transaction)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
transactionList.push(transactionId)

IRs:
REF_88 -> LENGTH transactionList
TMP_127(uint256) := REF_88(uint256)
TMP_128(uint256) = TMP_127 + 1
REF_88(uint256) (->transactionList) := TMP_128(uint256)
REF_89(bytes32) -> transactionList[TMP_127]
REF_89(bytes32) (->transactionList) := transactionId(bytes32)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSigWallet.notNull(address)(destination)"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 33501.sol-MultiSigWallet-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_83 -> LENGTH owners
MODIFIER_CALL, MultiSigWallet.validRequirement(uint256,uint256)(REF_83,_required)"];
4->1;
}
// Function: 33501.sol-MultiSigWallet-confirmTransaction(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_90(mapping(address => bool)) -> confirmations[transactionId]
REF_91(bool) -> REF_90[msg.sender]
REF_91(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.executeTransaction(bytes32)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.notConfirmed(bytes32,address)(transactionId,msg.sender)"];
5->1;
}
// Function: 33501.sol-MultiSigWallet-confirmationCount(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_105 -> LENGTH owners
TMP_152(bool) = i < REF_105
CONDITION TMP_152"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_106(mapping(address => bool)) -> confirmations[transactionId]
REF_107(address) -> owners[i]
REF_108(bool) -> REF_106[REF_107]
CONDITION REF_108"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_153(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 33501.sol-MultiSigWallet-confirmed(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(confirmations[transactionId][owner])

IRs:
REF_121(mapping(address => bool)) -> confirmations[transactionId]
REF_122(bool) -> REF_121[owner]
TMP_176(None) = SOLIDITY_CALL require(bool)(REF_122)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-MultiSigWallet-createCoin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
CoinCreation(new Gifto())

IRs:
TMP_167(Gifto) = new Gifto() 
Emit CoinCreation(TMP_167)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
2->1;
}
// Function: 33501.sol-MultiSigWallet-executeTransaction(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_138(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(bytes32)(transactionId)
CONDITION TMP_138"];
1->2[label="True"];
1->8[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
txn = transactions[transactionId]

IRs:
REF_92(MultiSigWallet.Transaction) -> transactions[transactionId]
txn(MultiSigWallet.Transaction) := REF_92(MultiSigWallet.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
txn.executed = true

IRs:
REF_93(bool) -> txn.executed
REF_93(bool) (->txn) := True(bool)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
! txn.destination.call.value(txn.value)(txn.data)

IRs:
REF_94(address) -> txn.destination
REF_97(uint256) -> txn.value
REF_98(bytes) -> txn.data
TMP_140(bool) = LOW_LEVEL_CALL, dest:REF_94, function:call, arguments:['REF_98'] value:REF_97 
TMP_141 = UnaryType.BANG TMP_140 
CONDITION TMP_141"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_142(None) = SOLIDITY_CALL revert()()"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)"];
7->8;
8[label="Node Type: END_IF 8
"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(bytes32)(transactionId)"];
9->1;
}
// Function: 33501.sol-MultiSigWallet-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_100(bool) = msg.value > 0
CONDITION TMP_100"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 33501.sol-MultiSigWallet-filterTransactions(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_transactionListTemp = new bytes32[](transactionList.length)

IRs:
REF_109 -> LENGTH transactionList
TMP_155(bytes32[])  = new bytes32[](REF_109)
_transactionListTemp(bytes32[]) = ['TMP_155(bytes32[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->12;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < transactionList.length

IRs:
REF_110 -> LENGTH transactionList
TMP_156(bool) = i < REF_110
CONDITION TMP_156"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
transactions[transactionList[i]].executed != isPending

IRs:
REF_111(bytes32) -> transactionList[i]
REF_112(MultiSigWallet.Transaction) -> transactions[REF_111]
REF_113(bool) -> REF_112.executed
TMP_157(bool) = REF_113 != isPending
CONDITION TMP_157"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_transactionListTemp[count] = transactionList[i]

IRs:
REF_114(bytes32) -> _transactionListTemp[count]
REF_115(bytes32) -> transactionList[i]
REF_114(bytes32) (->_transactionListTemp) := REF_115(bytes32)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_158(uint256) := i(uint256)
i(uint256) = i + 1"];
11->6;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_transactionList = new bytes32[](count)

IRs:
TMP_160(bytes32[])  = new bytes32[](count)
_transactionList(bytes32[]) = ['TMP_160(bytes32[])']"];
12->15;
13[label="Node Type: BEGIN_LOOP 13
"];
13->16;
14[label="Node Type: END_LOOP 14
"];
14->21;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
15->13;
16[label="Node Type: IF_LOOP 16

EXPRESSION:
i < count

IRs:
TMP_161(bool) = i < count
CONDITION TMP_161"];
16->17[label="True"];
16->14[label="False"];
17[label="Node Type: IF 17

EXPRESSION:
_transactionListTemp[i] > 0

IRs:
REF_116(bytes32) -> _transactionListTemp[i]
TMP_162(bool) = REF_116 > 0
CONDITION TMP_162"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionList[i] = _transactionListTemp[i]

IRs:
REF_117(bytes32) -> _transactionList[i]
REF_118(bytes32) -> _transactionListTemp[i]
REF_117(bytes32) (->_transactionList) := REF_118(bytes32)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
i ++

IRs:
TMP_163(uint256) := i(uint256)
i(uint256) = i + 1"];
20->16;
21[label="Node Type: RETURN 21

EXPRESSION:
_transactionList

IRs:
RETURN _transactionList"];
}
// Function: 33501.sol-MultiSigWallet-getExecutedTransactions()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
filterTransactions(false)

IRs:
TMP_165(bytes32[]) = INTERNAL_CALL, MultiSigWallet.filterTransactions(bool)(False)
RETURN TMP_165"];
}
// Function: 33501.sol-MultiSigWallet-getPendingTransactions()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
filterTransactions(true)

IRs:
TMP_164(bytes32[]) = INTERNAL_CALL, MultiSigWallet.filterTransactions(bool)(True)
RETURN TMP_164"];
}
// Function: 33501.sol-MultiSigWallet-isConfirmed(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->10;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_101 -> LENGTH owners
TMP_149(bool) = i < REF_101
CONDITION TMP_149"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_102(mapping(address => bool)) -> confirmations[transactionId]
REF_103(address) -> owners[i]
REF_104(bool) -> REF_102[REF_103]
CONDITION REF_104"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_150(uint256) := i(uint256)
i(uint256) = i + 1"];
9->5;
10[label="Node Type: IF 10

EXPRESSION:
count == required

IRs:
TMP_151(bool) = count == required
CONDITION TMP_151"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: END_IF 12
"];
}
// Function: 33501.sol-MultiSigWallet-notConfirmed(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! confirmations[transactionId][owner])

IRs:
REF_123(mapping(address => bool)) -> confirmations[transactionId]
REF_124(bool) -> REF_123[owner]
TMP_177 = UnaryType.BANG REF_124 
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-MultiSigWallet-notExecuted(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! transactions[transactionId].executed)

IRs:
REF_125(MultiSigWallet.Transaction) -> transactions[transactionId]
REF_126(bool) -> REF_125.executed
TMP_179 = UnaryType.BANG REF_126 
TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-MultiSigWallet-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(destination != 0)

IRs:
TMP_181(bool) = destination != 0
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-MultiSigWallet-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(this))

IRs:
TMP_170 = CONVERT this to address
TMP_171(bool) = msg.sender == TMP_170
TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-MultiSigWallet-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isOwner[owner])

IRs:
REF_119(bool) -> isOwner[owner]
TMP_173 = UnaryType.BANG REF_119 
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-MultiSigWallet-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isOwner[owner])

IRs:
REF_120(bool) -> isOwner[owner]
TMP_175(None) = SOLIDITY_CALL require(bool)(REF_120)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33501.sol-MultiSigWallet-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->17;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owners.length > 1)

IRs:
REF_73 -> LENGTH owners
TMP_108(bool) = REF_73 > 1
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isOwner[owner] = false

IRs:
REF_74(bool) -> isOwner[owner]
REF_74(bool) (->isOwner) := False(bool)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->12;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < owners.length - 1

IRs:
REF_75 -> LENGTH owners
TMP_110(uint256) = REF_75 - 1
TMP_111(bool) = i < TMP_110
CONDITION TMP_111"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
owners[i] == owner

IRs:
REF_76(address) -> owners[i]
TMP_112(bool) = REF_76 == owner
CONDITION TMP_112"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_77(address) -> owners[i]
REF_78 -> LENGTH owners
TMP_113(uint256) = REF_78 - 1
REF_79(address) -> owners[TMP_113]
REF_77(address) (->owners) := REF_79(address)"];
8->9;
9[label="Node Type: BREAK 9
"];
9->4;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_114(uint256) := i(uint256)
i(uint256) = i + 1"];
11->6;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
owners.length -= 1

IRs:
REF_80 -> LENGTH owners
REF_80(-> owners) = REF_80 - 1"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
required > owners.length

IRs:
REF_81 -> LENGTH owners
TMP_115(bool) = required > REF_81
CONDITION TMP_115"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
changeRequirement(owners.length)

IRs:
REF_82 -> LENGTH owners
INTERNAL_CALL, MultiSigWallet.changeRequirement(uint256)(REF_82)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigWallet.onlyWallet()()"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(owner)"];
18->1;
}
// Function: 33501.sol-MultiSigWallet-revokeConfirmation(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_99(mapping(address => bool)) -> confirmations[transactionId]
REF_100(bool) -> REF_99[msg.sender]
REF_100(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.confirmed(bytes32,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(bytes32)(transactionId)"];
5->1;
}
// Function: 33501.sol-MultiSigWallet-submitTransaction(address,uint256,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data,nonce)

IRs:
TMP_131(bytes32) = INTERNAL_CALL, MultiSigWallet.addTransaction(address,uint256,bytes,uint256)(destination,value,data,nonce)
transactionId(bytes32) := TMP_131(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.confirmTransaction(bytes32)(transactionId)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 33501.sol-MultiSigWallet-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_required <= _ownerCount && _required > 0)

IRs:
TMP_183(bool) = _required <= _ownerCount
TMP_184(bool) = _required > 0
TMP_185(bool) = TMP_183 && TMP_184
TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185)"];
1->2;
2[label="Node Type: _ 2
"];
}
}
