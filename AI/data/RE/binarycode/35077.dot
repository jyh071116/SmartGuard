digraph G {
// Function: 35077.sol-Coin-Coin(string,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
changeOwner(_minter)

IRs:
INTERNAL_CALL, owned.changeOwner(address)(_minter)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
mint = I_minter(_minter)

IRs:
TMP_126 = CONVERT _minter to I_minter
mint(I_minter) := TMP_126(I_minter)"];
}
// Function: 35077.sol-Coin-StandardToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.init(INITIAL_SUPPLY)

IRs:
LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.init(ERC20Lib.TokenStorage,uint256), arguments:['token', 'INITIAL_SUPPLY'] "];
}
// Function: 35077.sol-Coin-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.allowance(owner,_spender)

IRs:
TMP_114(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.allowance(ERC20Lib.TokenStorage,address,address), arguments:['token', 'owner', '_spender'] 
RETURN TMP_114"];
}
// Function: 35077.sol-Coin-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approve(_spender,value)

IRs:
TMP_117(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approve(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', 'value'] 
RETURN TMP_117"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-Coin-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approveAndCall(_spender,_value,_extraData)

IRs:
TMP_120(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approveAndCall(ERC20Lib.TokenStorage,address,uint256,bytes), arguments:['token', '_spender', '_value', '_extraData'] 
RETURN TMP_120"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-Coin-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.balanceOf(who)

IRs:
TMP_113(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.balanceOf(ERC20Lib.TokenStorage,address), arguments:['token', 'who'] 
RETURN TMP_113"];
}
// Function: 35077.sol-Coin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35077.sol-Coin-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.decreaseApproval(_spender,_subtractedValue)

IRs:
TMP_119(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.decreaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_subtractedValue'] 
RETURN TMP_119"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-Coin-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.increaseApproval(_spender,_addedValue)

IRs:
TMP_118(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.increaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_addedValue'] 
RETURN TMP_118"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-Coin-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_108(bool) = msg.sender == owner
CONDITION TMP_108"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_109(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35077.sol-Coin-meltCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.meltCoin(target,meltedAmount,owner)

IRs:
TMP_123(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.meltCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'meltedAmount', 'owner'] 
RETURN TMP_123"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-Coin-mintCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.mintCoin(target,mintedAmount,owner)

IRs:
TMP_121(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.mintCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'mintedAmount', 'owner'] 
RETURN TMP_121"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-Coin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_127(bool) = msg.sender == owner
CONDITION TMP_127"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35077.sol-Coin-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35077.sol-Coin-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = H0.1

IRs:
version(string) := H0.1(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
INITIAL_SUPPLY = 0

IRs:
INITIAL_SUPPLY(uint256) := 0(uint256)"];
}
// Function: 35077.sol-Coin-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.totalSupply

IRs:
REF_101(uint256) -> token.totalSupply
RETURN REF_101"];
}
// Function: 35077.sol-Coin-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transfer(to,value)

IRs:
TMP_115(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transfer(ERC20Lib.TokenStorage,address,uint256), arguments:['token', 'to', 'value'] 
RETURN TMP_115"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-Coin-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transferFrom(_from,_to,_value)

IRs:
TMP_116(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transferFrom(ERC20Lib.TokenStorage,address,address,uint256), arguments:['token', '_from', '_to', '_value'] 
RETURN TMP_116"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-ERC20Lib-IsWallet(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(codeLength == 0)

IRs:
TMP_91(bool) = codeLength == 0
TMP_92(None) = SOLIDITY_CALL assert(bool)(TMP_91)"];
4->5;
5[label="Node Type: _ 5
"];
}
// Function: 35077.sol-ERC20Lib-allowance(ERC20Lib.TokenStorage,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
self.allowed[_owner][_spender]

IRs:
REF_48(mapping(address => mapping(address => uint256))) -> self.allowed
REF_49(mapping(address => uint256)) -> REF_48[_owner]
REF_50(uint256) -> REF_49[_spender]
RETURN REF_50"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyPayloadSize(3)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(3)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
validAddress(_owner)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_owner)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_spender)"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 35077.sol-ERC20Lib-approve(ERC20Lib.TokenStorage,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
(_value != 0) && (self.allowed[msg.sender][_spender] != 0)

IRs:
TMP_45(bool) = _value != 0
REF_42(mapping(address => mapping(address => uint256))) -> self.allowed
REF_43(mapping(address => uint256)) -> REF_42[msg.sender]
REF_44(uint256) -> REF_43[_spender]
TMP_46(bool) = REF_44 != 0
TMP_47(bool) = TMP_45 && TMP_46
CONDITION TMP_47"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
self.allowed[msg.sender][_spender] = _value

IRs:
REF_45(mapping(address => mapping(address => uint256))) -> self.allowed
REF_46(mapping(address => uint256)) -> REF_45[msg.sender]
REF_47(uint256) -> REF_46[_spender]
REF_47(uint256) (->self) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyPayloadSize(3)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(3)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_spender)"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-approveAndCall(ERC20Lib.TokenStorage,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: IF 1

EXPRESSION:
(_value != 0) && (self.allowed[msg.sender][_spender] != 0)

IRs:
TMP_61(bool) = _value != 0
REF_66(mapping(address => mapping(address => uint256))) -> self.allowed
REF_67(mapping(address => uint256)) -> REF_66[msg.sender]
REF_68(uint256) -> REF_67[_spender]
TMP_62(bool) = REF_68 != 0
TMP_63(bool) = TMP_61 && TMP_62
CONDITION TMP_63"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
self.allowed[msg.sender][_spender] = _value

IRs:
REF_69(mapping(address => mapping(address => uint256))) -> self.allowed
REF_70(mapping(address => uint256)) -> REF_69[msg.sender]
REF_71(uint256) -> REF_70[_spender]
REF_71(uint256) (->self) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! _spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)

IRs:
TMP_65(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes))
TMP_66 = CONVERT TMP_65 to bytes32
TMP_67 = CONVERT TMP_66 to bytes4
TMP_68(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_67', 'msg.sender', '_value', 'this', '_extraData']  
TMP_69 = UnaryType.BANG TMP_68 
CONDITION TMP_69"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_70(None) = SOLIDITY_CALL revert()()"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyPayloadSize(4)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(4)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_spender)"];
11->1;
12[label="Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-balanceOf(ERC20Lib.TokenStorage,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
self.balances[_owner]

IRs:
REF_40(mapping(address => uint256)) -> self.balances
REF_41(uint256) -> REF_40[_owner]
RETURN REF_41"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyPayloadSize(2)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(2)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
validAddress(_owner)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_owner)"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 35077.sol-ERC20Lib-decreaseApproval(ERC20Lib.TokenStorage,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = self.allowed[msg.sender][_spender]

IRs:
REF_57(mapping(address => mapping(address => uint256))) -> self.allowed
REF_58(mapping(address => uint256)) -> REF_57[msg.sender]
REF_59(uint256) -> REF_58[_spender]
oldValue(uint256) := REF_59(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_57(bool) = _subtractedValue > oldValue
CONDITION TMP_57"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
self.allowed[msg.sender][_spender] = 0

IRs:
REF_60(mapping(address => mapping(address => uint256))) -> self.allowed
REF_61(mapping(address => uint256)) -> REF_60[msg.sender]
REF_62(uint256) -> REF_61[_spender]
REF_62(uint256) (->self) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
self.allowed[msg.sender][_spender] = safeSub(oldValue,_subtractedValue)

IRs:
REF_63(mapping(address => mapping(address => uint256))) -> self.allowed
REF_64(mapping(address => uint256)) -> REF_63[msg.sender]
REF_65(uint256) -> REF_64[_spender]
TMP_58(uint256) = INTERNAL_CALL, ERC20Lib.safeSub(uint256,uint256)(oldValue,_subtractedValue)
REF_65(uint256) (->self) := TMP_58(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyPayloadSize(3)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(3)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_spender)"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-increaseApproval(ERC20Lib.TokenStorage,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = self.allowed[msg.sender][_spender]

IRs:
REF_51(mapping(address => mapping(address => uint256))) -> self.allowed
REF_52(mapping(address => uint256)) -> REF_51[msg.sender]
REF_53(uint256) -> REF_52[_spender]
oldValue(uint256) := REF_53(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
self.allowed[msg.sender][_spender] = safeAdd(oldValue,_addedValue)

IRs:
REF_54(mapping(address => mapping(address => uint256))) -> self.allowed
REF_55(mapping(address => uint256)) -> REF_54[msg.sender]
REF_56(uint256) -> REF_55[_spender]
TMP_54(uint256) = INTERNAL_CALL, ERC20Lib.safeAdd(uint256,uint256)(oldValue,_addedValue)
REF_56(uint256) (->self) := TMP_54(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyPayloadSize(3)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(3)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_spender)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-init(ERC20Lib.TokenStorage,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
self.totalSupply = _initial_supply

IRs:
REF_0(uint256) -> self.totalSupply
REF_0(uint256) (->self) := _initial_supply(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
self.balances[msg.sender] = _initial_supply

IRs:
REF_1(mapping(address => uint256)) -> self.balances
REF_2(uint256) -> REF_1[msg.sender]
REF_2(uint256) (->self) := _initial_supply(uint256)"];
}
// Function: 35077.sol-ERC20Lib-meltCoin(ERC20Lib.TokenStorage,address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
self.balances[target] < meltedAmount

IRs:
REF_79(mapping(address => uint256)) -> self.balances
REF_80(uint256) -> REF_79[target]
TMP_77(bool) = REF_80 < meltedAmount
CONDITION TMP_77"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
self.balances[target] = safeSub(self.balances[target],meltedAmount)

IRs:
REF_81(mapping(address => uint256)) -> self.balances
REF_82(uint256) -> REF_81[target]
REF_83(mapping(address => uint256)) -> self.balances
REF_84(uint256) -> REF_83[target]
TMP_78(uint256) = INTERNAL_CALL, ERC20Lib.safeSub(uint256,uint256)(REF_84,meltedAmount)
REF_82(uint256) (->self) := TMP_78(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
self.totalSupply = safeSub(self.totalSupply,meltedAmount)

IRs:
REF_85(uint256) -> self.totalSupply
REF_86(uint256) -> self.totalSupply
TMP_79(uint256) = INTERNAL_CALL, ERC20Lib.safeSub(uint256,uint256)(REF_86,meltedAmount)
REF_85(uint256) (->self) := TMP_79(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(target,owner,meltedAmount)

IRs:
Emit Transfer(target,owner,meltedAmount)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(owner,0,meltedAmount)

IRs:
Emit Transfer(owner,0,meltedAmount)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-mintCoin(ERC20Lib.TokenStorage,address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
self.balances[target] = safeAdd(self.balances[target],mintedAmount)

IRs:
REF_73(mapping(address => uint256)) -> self.balances
REF_74(uint256) -> REF_73[target]
REF_75(mapping(address => uint256)) -> self.balances
REF_76(uint256) -> REF_75[target]
TMP_73(uint256) = INTERNAL_CALL, ERC20Lib.safeAdd(uint256,uint256)(REF_76,mintedAmount)
REF_74(uint256) (->self) := TMP_73(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
self.totalSupply = safeAdd(self.totalSupply,mintedAmount)

IRs:
REF_77(uint256) -> self.totalSupply
REF_78(uint256) -> self.totalSupply
TMP_74(uint256) = INTERNAL_CALL, ERC20Lib.safeAdd(uint256,uint256)(REF_78,mintedAmount)
REF_77(uint256) (->self) := TMP_74(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.data.length >= numwords * 32 + 4)

IRs:
REF_87 -> LENGTH msg.data
TMP_82(uint256) = numwords * 32
TMP_83(uint256) = TMP_82 + 4
TMP_84(bool) = REF_87 >= TMP_83
TMP_85(None) = SOLIDITY_CALL assert(bool)(TMP_84)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35077.sol-ERC20Lib-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_16(uint256) = a + b
c(uint256) := TMP_16(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a && c >= b)

IRs:
TMP_17(bool) = c >= a
TMP_18(bool) = c >= b
TMP_19(bool) = TMP_17 && TMP_18
TMP_20(None) = SOLIDITY_CALL assert(bool)(TMP_19)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 35077.sol-ERC20Lib-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_7(uint256) = a * b
c(uint256) := TMP_7(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_8(bool) = a == 0
TMP_9(uint256) = c / a
TMP_10(bool) = TMP_9 == b
TMP_11(bool) = TMP_8 || TMP_10
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 35077.sol-ERC20Lib-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_13(bool) = b <= a
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_15(uint256) = a - b
RETURN TMP_15"];
}
// Function: 35077.sol-ERC20Lib-transfer(ERC20Lib.TokenStorage,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: IF 1

EXPRESSION:
self.balances[msg.sender] >= _value && self.balances[_to] + _value > self.balances[_to]

IRs:
REF_3(mapping(address => uint256)) -> self.balances
REF_4(uint256) -> REF_3[msg.sender]
TMP_21(bool) = REF_4 >= _value
REF_5(mapping(address => uint256)) -> self.balances
REF_6(uint256) -> REF_5[_to]
TMP_22(uint256) = REF_6 + _value
REF_7(mapping(address => uint256)) -> self.balances
REF_8(uint256) -> REF_7[_to]
TMP_23(bool) = TMP_22 > REF_8
TMP_24(bool) = TMP_21 && TMP_23
CONDITION TMP_24"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
self.balances[msg.sender] = safeSub(self.balances[msg.sender],_value)

IRs:
REF_9(mapping(address => uint256)) -> self.balances
REF_10(uint256) -> REF_9[msg.sender]
REF_11(mapping(address => uint256)) -> self.balances
REF_12(uint256) -> REF_11[msg.sender]
TMP_25(uint256) = INTERNAL_CALL, ERC20Lib.safeSub(uint256,uint256)(REF_12,_value)
REF_10(uint256) (->self) := TMP_25(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
self.balances[_to] = safeAdd(self.balances[_to],_value)

IRs:
REF_13(mapping(address => uint256)) -> self.balances
REF_14(uint256) -> REF_13[_to]
REF_15(mapping(address => uint256)) -> self.balances
REF_16(uint256) -> REF_15[_to]
TMP_26(uint256) = INTERNAL_CALL, ERC20Lib.safeAdd(uint256,uint256)(REF_16,_value)
REF_14(uint256) (->self) := TMP_26(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyPayloadSize(3)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(3)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
IsWallet(_to)

IRs:
MODIFIER_CALL, ERC20Lib.IsWallet(address)(_to)"];
9->1;
10[label="Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-transferFrom(ERC20Lib.TokenStorage,address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: IF 1

EXPRESSION:
self.balances[_from] >= _value && self.allowed[_from][msg.sender] >= _value && self.balances[_to] + _value > self.balances[_to]

IRs:
REF_17(mapping(address => uint256)) -> self.balances
REF_18(uint256) -> REF_17[_from]
TMP_30(bool) = REF_18 >= _value
REF_19(mapping(address => mapping(address => uint256))) -> self.allowed
REF_20(mapping(address => uint256)) -> REF_19[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_31(bool) = REF_21 >= _value
TMP_32(bool) = TMP_30 && TMP_31
REF_22(mapping(address => uint256)) -> self.balances
REF_23(uint256) -> REF_22[_to]
TMP_33(uint256) = REF_23 + _value
REF_24(mapping(address => uint256)) -> self.balances
REF_25(uint256) -> REF_24[_to]
TMP_34(bool) = TMP_33 > REF_25
TMP_35(bool) = TMP_32 && TMP_34
CONDITION TMP_35"];
1->2[label="True"];
1->8[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_allowance = self.allowed[_from][msg.sender]

IRs:
REF_26(mapping(address => mapping(address => uint256))) -> self.allowed
REF_27(mapping(address => uint256)) -> REF_26[_from]
REF_28(uint256) -> REF_27[msg.sender]
_allowance(uint256) := REF_28(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
self.balances[_to] = safeAdd(self.balances[_to],_value)

IRs:
REF_29(mapping(address => uint256)) -> self.balances
REF_30(uint256) -> REF_29[_to]
REF_31(mapping(address => uint256)) -> self.balances
REF_32(uint256) -> REF_31[_to]
TMP_36(uint256) = INTERNAL_CALL, ERC20Lib.safeAdd(uint256,uint256)(REF_32,_value)
REF_30(uint256) (->self) := TMP_36(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
self.balances[_from] = safeSub(self.balances[_from],_value)

IRs:
REF_33(mapping(address => uint256)) -> self.balances
REF_34(uint256) -> REF_33[_from]
REF_35(mapping(address => uint256)) -> self.balances
REF_36(uint256) -> REF_35[_from]
TMP_37(uint256) = INTERNAL_CALL, ERC20Lib.safeSub(uint256,uint256)(REF_36,_value)
REF_34(uint256) (->self) := TMP_37(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
self.allowed[_from][msg.sender] = safeSub(_allowance,_value)

IRs:
REF_37(mapping(address => mapping(address => uint256))) -> self.allowed
REF_38(mapping(address => uint256)) -> REF_37[_from]
REF_39(uint256) -> REF_38[msg.sender]
TMP_38(uint256) = INTERNAL_CALL, ERC20Lib.safeSub(uint256,uint256)(_allowance,_value)
REF_39(uint256) (->self) := TMP_38(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyPayloadSize(4)

IRs:
MODIFIER_CALL, ERC20Lib.onlyPayloadSize(uint256)(4)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
validAddress(_from)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_from)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
validAddress(_to)

IRs:
MODIFIER_CALL, ERC20Lib.validAddress(address)(_to)"];
12->1;
13[label="Node Type: RETURN 13

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-ERC20Lib-validAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != 0x0)

IRs:
TMP_86(bool) = _address != 0
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_address != address(msg.sender))

IRs:
TMP_88 = CONVERT msg.sender to address
TMP_89(bool) = _address != TMP_88
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)"];
2->3;
3[label="Node Type: _ 3
"];
}
// Function: 35077.sol-I_coin-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 35077.sol-I_coin-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-I_coin-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35077.sol-I_coin-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 35077.sol-I_coin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35077.sol-I_coin-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-I_coin-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-I_coin-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_174(bool) = msg.sender == owner
CONDITION TMP_174"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_175(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35077.sol-I_coin-meltCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-I_coin-mintCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-I_coin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_178(bool) = msg.sender == owner
CONDITION TMP_178"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35077.sol-I_coin-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35077.sol-I_coin-setMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35077.sol-I_coin-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = 

IRs:
version(string) := (string)"];
}
// Function: 35077.sol-I_coin-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-I_coin-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35077.sol-I_minter-Leverage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35077.sol-I_minter-NewRisk()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35077.sol-I_minter-NewRiskAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35077.sol-I_minter-NewStatic()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35077.sol-I_minter-NewStaticAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35077.sol-I_minter-PriceReturn(uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35077.sol-I_minter-RetRisk(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35077.sol-I_minter-RetStatic(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35077.sol-I_minter-RiskPrice(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35077.sol-I_minter-RiskPrice(uint128,uint128,uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35077.sol-I_minter-Strike()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35077.sol-RiskCoin-Coin(string,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
changeOwner(_minter)

IRs:
INTERNAL_CALL, owned.changeOwner(address)(_minter)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
mint = I_minter(_minter)

IRs:
TMP_129 = CONVERT _minter to I_minter
mint(I_minter) := TMP_129(I_minter)"];
}
// Function: 35077.sol-RiskCoin-RiskCoin(string,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Coin(_tokenName,_tokenSymbol,_minter)

IRs:
INTERNAL_CALL, Coin.Coin(string,string,address)(_tokenName,_tokenSymbol,_minter)"];
}
// Function: 35077.sol-RiskCoin-StandardToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.init(INITIAL_SUPPLY)

IRs:
LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.init(ERC20Lib.TokenStorage,uint256), arguments:['token', 'INITIAL_SUPPLY'] "];
}
// Function: 35077.sol-RiskCoin-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.allowance(owner,_spender)

IRs:
TMP_136(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.allowance(ERC20Lib.TokenStorage,address,address), arguments:['token', 'owner', '_spender'] 
RETURN TMP_136"];
}
// Function: 35077.sol-RiskCoin-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approve(_spender,value)

IRs:
TMP_139(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approve(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', 'value'] 
RETURN TMP_139"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-RiskCoin-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approveAndCall(_spender,_value,_extraData)

IRs:
TMP_142(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approveAndCall(ERC20Lib.TokenStorage,address,uint256,bytes), arguments:['token', '_spender', '_value', '_extraData'] 
RETURN TMP_142"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-RiskCoin-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.balanceOf(who)

IRs:
TMP_135(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.balanceOf(ERC20Lib.TokenStorage,address), arguments:['token', 'who'] 
RETURN TMP_135"];
}
// Function: 35077.sol-RiskCoin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35077.sol-RiskCoin-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.decreaseApproval(_spender,_subtractedValue)

IRs:
TMP_141(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.decreaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_subtractedValue'] 
RETURN TMP_141"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-RiskCoin-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mint.NewRiskAdr.value(msg.value)(msg.sender)

IRs:
TMP_149(uint256) = HIGH_LEVEL_CALL, dest:mint(I_minter), function:NewRiskAdr, arguments:['msg.sender'] value:msg.value "];
}
// Function: 35077.sol-RiskCoin-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.increaseApproval(_spender,_addedValue)

IRs:
TMP_140(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.increaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_addedValue'] 
RETURN TMP_140"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-RiskCoin-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_130(bool) = msg.sender == owner
CONDITION TMP_130"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_131(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35077.sol-RiskCoin-meltCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.meltCoin(target,meltedAmount,owner)

IRs:
TMP_145(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.meltCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'meltedAmount', 'owner'] 
RETURN TMP_145"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-RiskCoin-mintCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.mintCoin(target,mintedAmount,owner)

IRs:
TMP_143(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.mintCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'mintedAmount', 'owner'] 
RETURN TMP_143"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-RiskCoin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_150(bool) = msg.sender == owner
CONDITION TMP_150"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35077.sol-RiskCoin-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35077.sol-RiskCoin-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = H0.1

IRs:
version(string) := H0.1(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
INITIAL_SUPPLY = 0

IRs:
INITIAL_SUPPLY(uint256) := 0(uint256)"];
}
// Function: 35077.sol-RiskCoin-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.totalSupply

IRs:
REF_113(uint256) -> token.totalSupply
RETURN REF_113"];
}
// Function: 35077.sol-RiskCoin-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transfer(to,value)

IRs:
TMP_137(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transfer(ERC20Lib.TokenStorage,address,uint256), arguments:['token', 'to', 'value'] 
RETURN TMP_137"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-RiskCoin-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transferFrom(_from,_to,_value)

IRs:
TMP_138(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transferFrom(ERC20Lib.TokenStorage,address,address,uint256), arguments:['token', '_from', '_to', '_value'] 
RETURN TMP_138"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-StandardToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.init(INITIAL_SUPPLY)

IRs:
LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.init(ERC20Lib.TokenStorage,uint256), arguments:['token', 'INITIAL_SUPPLY'] "];
}
// Function: 35077.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.allowance(owner,_spender)

IRs:
TMP_96(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.allowance(ERC20Lib.TokenStorage,address,address), arguments:['token', 'owner', '_spender'] 
RETURN TMP_96"];
}
// Function: 35077.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approve(_spender,value)

IRs:
TMP_99(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approve(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', 'value'] 
RETURN TMP_99"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approveAndCall(_spender,_value,_extraData)

IRs:
TMP_102(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approveAndCall(ERC20Lib.TokenStorage,address,uint256,bytes), arguments:['token', '_spender', '_value', '_extraData'] 
RETURN TMP_102"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.balanceOf(who)

IRs:
TMP_95(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.balanceOf(ERC20Lib.TokenStorage,address), arguments:['token', 'who'] 
RETURN TMP_95"];
}
// Function: 35077.sol-StandardToken-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35077.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.decreaseApproval(_spender,_subtractedValue)

IRs:
TMP_101(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.decreaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_subtractedValue'] 
RETURN TMP_101"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.increaseApproval(_spender,_addedValue)

IRs:
TMP_100(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.increaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_addedValue'] 
RETURN TMP_100"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-meltCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.meltCoin(target,meltedAmount,owner)

IRs:
TMP_105(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.meltCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'meltedAmount', 'owner'] 
RETURN TMP_105"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-mintCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.mintCoin(target,mintedAmount,owner)

IRs:
TMP_103(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.mintCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'mintedAmount', 'owner'] 
RETURN TMP_103"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_107(bool) = msg.sender == owner
CONDITION TMP_107"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35077.sol-StandardToken-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35077.sol-StandardToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = H0.1

IRs:
version(string) := H0.1(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
INITIAL_SUPPLY = 0

IRs:
INITIAL_SUPPLY(uint256) := 0(uint256)"];
}
// Function: 35077.sol-StandardToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.totalSupply

IRs:
REF_89(uint256) -> token.totalSupply
RETURN REF_89"];
}
// Function: 35077.sol-StandardToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transfer(to,value)

IRs:
TMP_97(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transfer(ERC20Lib.TokenStorage,address,uint256), arguments:['token', 'to', 'value'] 
RETURN TMP_97"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transferFrom(_from,_to,_value)

IRs:
TMP_98(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transferFrom(ERC20Lib.TokenStorage,address,address,uint256), arguments:['token', '_from', '_to', '_value'] 
RETURN TMP_98"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-Coin(string,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
changeOwner(_minter)

IRs:
INTERNAL_CALL, owned.changeOwner(address)(_minter)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
mint = I_minter(_minter)

IRs:
TMP_152 = CONVERT _minter to I_minter
mint(I_minter) := TMP_152(I_minter)"];
}
// Function: 35077.sol-StatiCoin-StandardToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.init(INITIAL_SUPPLY)

IRs:
LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.init(ERC20Lib.TokenStorage,uint256), arguments:['token', 'INITIAL_SUPPLY'] "];
}
// Function: 35077.sol-StatiCoin-StatiCoin(string,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Coin(_tokenName,_tokenSymbol,_minter)

IRs:
INTERNAL_CALL, Coin.Coin(string,string,address)(_tokenName,_tokenSymbol,_minter)"];
}
// Function: 35077.sol-StatiCoin-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.allowance(owner,_spender)

IRs:
TMP_159(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.allowance(ERC20Lib.TokenStorage,address,address), arguments:['token', 'owner', '_spender'] 
RETURN TMP_159"];
}
// Function: 35077.sol-StatiCoin-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approve(_spender,value)

IRs:
TMP_162(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approve(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', 'value'] 
RETURN TMP_162"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.approveAndCall(_spender,_value,_extraData)

IRs:
TMP_165(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.approveAndCall(ERC20Lib.TokenStorage,address,uint256,bytes), arguments:['token', '_spender', '_value', '_extraData'] 
RETURN TMP_165"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.balanceOf(who)

IRs:
TMP_158(uint256) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.balanceOf(ERC20Lib.TokenStorage,address), arguments:['token', 'who'] 
RETURN TMP_158"];
}
// Function: 35077.sol-StatiCoin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35077.sol-StatiCoin-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.decreaseApproval(_spender,_subtractedValue)

IRs:
TMP_164(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.decreaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_subtractedValue'] 
RETURN TMP_164"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mint.NewStaticAdr.value(msg.value)(msg.sender)

IRs:
TMP_172(uint256) = HIGH_LEVEL_CALL, dest:mint(I_minter), function:NewStaticAdr, arguments:['msg.sender'] value:msg.value "];
}
// Function: 35077.sol-StatiCoin-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.increaseApproval(_spender,_addedValue)

IRs:
TMP_163(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.increaseApproval(ERC20Lib.TokenStorage,address,uint256), arguments:['token', '_spender', '_addedValue'] 
RETURN TMP_163"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_153(bool) = msg.sender == owner
CONDITION TMP_153"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_154(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35077.sol-StatiCoin-meltCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.meltCoin(target,meltedAmount,owner)

IRs:
TMP_168(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.meltCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'meltedAmount', 'owner'] 
RETURN TMP_168"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-mintCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
token.mintCoin(target,mintedAmount,owner)

IRs:
TMP_166(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.mintCoin(ERC20Lib.TokenStorage,address,uint256,address), arguments:['token', 'target', 'mintedAmount', 'owner'] 
RETURN TMP_166"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_173(bool) = msg.sender == owner
CONDITION TMP_173"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35077.sol-StatiCoin-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35077.sol-StatiCoin-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = H0.1

IRs:
version(string) := H0.1(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
INITIAL_SUPPLY = 0

IRs:
INITIAL_SUPPLY(uint256) := 0(uint256)"];
}
// Function: 35077.sol-StatiCoin-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.totalSupply

IRs:
REF_127(uint256) -> token.totalSupply
RETURN REF_127"];
}
// Function: 35077.sol-StatiCoin-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transfer(to,value)

IRs:
TMP_160(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transfer(ERC20Lib.TokenStorage,address,uint256), arguments:['token', 'to', 'value'] 
RETURN TMP_160"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-StatiCoin-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
token.transferFrom(_from,_to,_value)

IRs:
TMP_161(bool) = LIBRARY_CALL, dest:ERC20Lib, function:ERC20Lib.transferFrom(ERC20Lib.TokenStorage,address,address,uint256), arguments:['token', '_from', '_to', '_value'] 
RETURN TMP_161"];
2[label="Node Type: RETURN 2

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 35077.sol-mortal-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35077.sol-mortal-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_3(bool) = msg.sender == owner
CONDITION TMP_3"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_4(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35077.sol-mortal-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_6(bool) = msg.sender == owner
CONDITION TMP_6"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35077.sol-mortal-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35077.sol-owned-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35077.sol-owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_1(bool) = msg.sender == owner
CONDITION TMP_1"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35077.sol-owned-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
}
