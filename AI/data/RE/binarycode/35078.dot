digraph G {
// Function: 35078.sol-DSBaseActor-exec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(tryExec(target,calldata,value))

IRs:
TMP_58(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(target,calldata,value)
TMP_59(None) = SOLIDITY_CALL assert(bool)(TMP_58)"];
}
// Function: 35078.sol-DSBaseActor-mutex()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(! _ds_mutex)

IRs:
TMP_60 = UnaryType.BANG _ds_mutex 
TMP_61(None) = SOLIDITY_CALL assert(bool)(TMP_60)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_ds_mutex = true

IRs:
_ds_mutex(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_ds_mutex = false

IRs:
_ds_mutex(bool) := False(bool)"];
}
// Function: 35078.sol-DSBaseActor-tryExec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
target.call.value(value)(calldata)

IRs:
TMP_56(bool) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['calldata'] value:value 
RETURN TMP_56"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
mutex()

IRs:
MODIFIER_CALL, DSBaseActor.mutex()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
call_ret

IRs:
RETURN call_ret"];
}
// Function: 35078.sol-DSMath-cast(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)((z = uint128(x)) == x)

IRs:
TMP_44 = CONVERT x to uint128
z(uint128) := TMP_44(uint128)
TMP_45(bool) = z == x
TMP_46(None) = SOLIDITY_CALL assert(bool)(TMP_45)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-hadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x + y) >= x)

IRs:
TMP_11(uint128) = x + y
z(uint128) := TMP_11(uint128)
TMP_12(bool) = z >= x
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-hdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = x / y

IRs:
TMP_23(uint128) = x / y
z(uint128) := TMP_23(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-hless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x < y

IRs:
TMP_10(bool) = x < y
RETURN TMP_10"];
}
// Function: 35078.sol-DSMath-hmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_25(bool) = x >= y
CONDITION TMP_25"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-hmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_24(bool) = x <= y
CONDITION TMP_24"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-hmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x > y

IRs:
TMP_9(bool) = x > y
RETURN TMP_9"];
}
// Function: 35078.sol-DSMath-hmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(y == 0 || (z = x * y) / y == x)

IRs:
TMP_17(bool) = y == 0
TMP_18(uint128) = x * y
z(uint128) := TMP_18(uint128)
TMP_19(uint128) = z / y
TMP_20(bool) = TMP_19 == x
TMP_21(bool) = TMP_17 || TMP_20
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-hsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x - y) <= x)

IRs:
TMP_14(uint128) = x - y
z(uint128) := TMP_14(uint128)
TMP_15(bool) = z <= x
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
WAD_Dec = 18

IRs:
WAD_Dec(uint64) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
WAD = 10 ** 18

IRs:
TMP_47(uint256) = 10 ** 18
WAD(uint128) := TMP_47(uint256)"];
}
// Function: 35078.sol-DSMath-wadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hadd(x,y)

IRs:
TMP_28(uint128) = INTERNAL_CALL, DSMath.hadd(uint128,uint128)(x,y)
RETURN TMP_28"];
}
// Function: 35078.sol-DSMath-wdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * WAD + y / 2) / y)

IRs:
TMP_36 = CONVERT x to uint256
TMP_37(uint256) = TMP_36 * WAD
TMP_38(uint128) = y / 2
TMP_39(uint256) = TMP_37 + TMP_38
TMP_40(uint256) = TMP_39 / y
TMP_41(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_40)
z(uint128) := TMP_41(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-wless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hless(x,y)

IRs:
TMP_27(bool) = INTERNAL_CALL, DSMath.hless(uint128,uint128)(x,y)
RETURN TMP_27"];
}
// Function: 35078.sol-DSMath-wmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmax(x,y)

IRs:
TMP_43(uint128) = INTERNAL_CALL, DSMath.hmax(uint128,uint128)(x,y)
RETURN TMP_43"];
}
// Function: 35078.sol-DSMath-wmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmin(x,y)

IRs:
TMP_42(uint128) = INTERNAL_CALL, DSMath.hmin(uint128,uint128)(x,y)
RETURN TMP_42"];
}
// Function: 35078.sol-DSMath-wmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmore(x,y)

IRs:
TMP_26(bool) = INTERNAL_CALL, DSMath.hmore(uint128,uint128)(x,y)
RETURN TMP_26"];
}
// Function: 35078.sol-DSMath-wmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * y + WAD / 2) / WAD)

IRs:
TMP_30 = CONVERT x to uint256
TMP_31(uint256) = TMP_30 * y
TMP_32(uint128) = WAD / 2
TMP_33(uint256) = TMP_31 + TMP_32
TMP_34(uint256) = TMP_33 / WAD
TMP_35(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_34)
z(uint128) := TMP_35(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-DSMath-wsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hsub(x,y)

IRs:
TMP_29(uint128) = INTERNAL_CALL, DSMath.hsub(uint128,uint128)(x,y)
RETURN TMP_29"];
}
// Function: 35078.sol-I_Pricer-QuickPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-I_Pricer-__callback(bytes32,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-I_Pricer-collectFee()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-I_Pricer-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_48(None) = SOLIDITY_CALL revert()()"];
}
// Function: 35078.sol-I_Pricer-queryCost()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_value

IRs:
RETURN _value"];
}
// Function: 35078.sol-I_Pricer-requestPrice(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TrasID

IRs:
RETURN _TrasID"];
}
// Function: 35078.sol-I_coin-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 35078.sol-I_coin-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35078.sol-I_coin-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-I_coin-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 35078.sol-I_coin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-I_coin-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35078.sol-I_coin-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35078.sol-I_coin-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_49(bool) = msg.sender == owner
CONDITION TMP_49"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_50(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35078.sol-I_coin-meltCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35078.sol-I_coin-mintCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35078.sol-I_coin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_53(bool) = msg.sender == owner
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-I_coin-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35078.sol-I_coin-setMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-I_coin-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = 

IRs:
version(string) := (string)"];
}
// Function: 35078.sol-I_coin-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35078.sol-I_coin-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35078.sol-I_minter-Leverage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-I_minter-NewRisk()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-I_minter-NewRiskAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-I_minter-NewStatic()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-I_minter-NewStaticAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-I_minter-PriceReturn(uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-I_minter-RetRisk(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-I_minter-RetStatic(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-I_minter-RiskPrice(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35078.sol-I_minter-RiskPrice(uint128,uint128,uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35078.sol-I_minter-Strike()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-canFreeze-Freeze()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-canFreeze-LockIfFrozen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! frozen

IRs:
TMP_66 = UnaryType.BANG frozen 
CONDITION TMP_66"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35078.sol-canFreeze-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-canFreeze-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_64(bool) = msg.sender == owner
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-canFreeze-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35078.sol-canFreeze-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
}
// Function: 35078.sol-minter-ActionNewRisk(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
wless(cast(this.balance),PendingETH)

IRs:
REF_46(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_233(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_46)
TMP_234(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(TMP_233,PendingETH)
CONDITION TMP_234"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
CurRiskPrice = 0

IRs:
CurRiskPrice(uint128) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
CurRiskPrice = RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),wsub(cast(this.balance),PendingETH))

IRs:
TMP_235(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_236(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_235)
TMP_237(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_238(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_237)
REF_49(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_239(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_49)
TMP_240(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(TMP_239,PendingETH)
TMP_241(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128,uint128,uint128,uint128)(_Price,TMP_236,TMP_238,TMP_240)
CurRiskPrice(uint128) := TMP_241(uint128)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
CurRiskPrice > 0

IRs:
TMP_242(bool) = CurRiskPrice > 0
CONDITION TMP_242"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
quantity = wdiv(wmul(_details.amount,_Price),CurRiskPrice)

IRs:
REF_50(uint128) -> _details.amount
TMP_243(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(REF_50,_Price)
TMP_244(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_243,CurRiskPrice)
quantity(uint128) := TMP_244(uint128)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Risk.mintCoin(_details.holder,uint256(quantity))

IRs:
REF_52(address) -> _details.holder
TMP_245 = CONVERT quantity to uint256
TMP_246(bool) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:mintCoin, arguments:['REF_52', 'TMP_245']  "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
EventCreateRisk(_details.holder,quantity,_TransID,_Price)

IRs:
REF_53(address) -> _details.holder
Emit EventCreateRisk(REF_53,quantity,_TransID,_Price)"];
9->12;
10[label="Node Type: NEW VARIABLE 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
exec(_details.holder,calldata,_details.amount)

IRs:
REF_54(address) -> _details.holder
REF_55(uint128) -> _details.amount
INTERNAL_CALL, DSBaseActor.exec(address,bytes,uint256)(REF_54,calldata,REF_55)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
PendingETH = wsub(PendingETH,_details.amount)

IRs:
REF_56(uint128) -> _details.amount
TMP_249(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(PendingETH,REF_56)
PendingETH(uint128) := TMP_249(uint128)"];
}
// Function: 35078.sol-minter-ActionNewStatic(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
CurRiskPrice = RiskPrice(_Price)

IRs:
TMP_212(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128)(_Price)
CurRiskPrice(uint128) := TMP_212(uint128)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
StaticAvail = StaticEthAvailable(cast(Risk.totalSupply()),wsub(cast(this.balance),PendingETH))

IRs:
TMP_213(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_214(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_213)
REF_37(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_215(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_37)
TMP_216(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(TMP_215,PendingETH)
TMP_217(uint128) = INTERNAL_CALL, minter.StaticEthAvailable(uint128,uint128)(TMP_214,TMP_216)
StaticAvail(uint128) := TMP_217(uint128)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
wless(_details.amount,StaticAvail)

IRs:
REF_38(uint128) -> _details.amount
TMP_218(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(REF_38,StaticAvail)
CONDITION TMP_218"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
AmountMint = _details.amount

IRs:
REF_39(uint128) -> _details.amount
AmountMint(uint128) := REF_39(uint128)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
AmountReturn = 0

IRs:
AmountReturn(uint128) := 0(uint256)"];
7->10;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
AmountMint = StaticAvail

IRs:
AmountMint(uint128) := StaticAvail(uint128)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
AmountReturn = wsub(_details.amount,StaticAvail)

IRs:
REF_40(uint128) -> _details.amount
TMP_219(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(REF_40,StaticAvail)
AmountReturn(uint128) := TMP_219(uint128)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
0 == CurRiskPrice

IRs:
TMP_220(bool) = 0 == CurRiskPrice
CONDITION TMP_220"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
AmountReturn = _details.amount

IRs:
REF_41(uint128) -> _details.amount
AmountReturn(uint128) := REF_41(uint128)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
CurRiskPrice > 0 && StaticAvail > 0

IRs:
TMP_221(bool) = CurRiskPrice > 0
TMP_222(bool) = StaticAvail > 0
TMP_223(bool) = TMP_221 && TMP_222
CONDITION TMP_223"];
14->15[label="True"];
14->18[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Static.mintCoin(_details.holder,uint256(wmul(AmountMint,_Price)))

IRs:
REF_43(address) -> _details.holder
TMP_224(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(AmountMint,_Price)
TMP_225 = CONVERT TMP_224 to uint256
TMP_226(bool) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:mintCoin, arguments:['REF_43', 'TMP_225']  "];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
EventCreateStatic(_details.holder,wmul(AmountMint,_Price),_TransID,_Price)

IRs:
REF_44(address) -> _details.holder
TMP_227(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(AmountMint,_Price)
Emit EventCreateStatic(REF_44,TMP_227,_TransID,_Price)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
PendingETH = wsub(PendingETH,AmountMint)

IRs:
TMP_229(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(PendingETH,AmountMint)
PendingETH(uint128) := TMP_229(uint128)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: IF 19

EXPRESSION:
AmountReturn > 0

IRs:
TMP_230(bool) = AmountReturn > 0
CONDITION TMP_230"];
19->20[label="True"];
19->23[label="False"];
20[label="Node Type: NEW VARIABLE 20
"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
exec(_details.holder,calldata,AmountReturn)

IRs:
REF_45(address) -> _details.holder
INTERNAL_CALL, DSBaseActor.exec(address,bytes,uint256)(REF_45,calldata,AmountReturn)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
PendingETH = wsub(PendingETH,AmountReturn)

IRs:
TMP_232(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(PendingETH,AmountReturn)
PendingETH(uint128) := TMP_232(uint128)"];
22->23;
23[label="Node Type: END_IF 23
"];
}
// Function: 35078.sol-minter-ActionRetRisk(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
CurRiskPrice = RiskPrice(_Price)

IRs:
TMP_263(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128)(_Price)
CurRiskPrice(uint128) := TMP_263(uint128)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
CurRiskPrice > 0

IRs:
TMP_264(bool) = CurRiskPrice > 0
CONDITION TMP_264"];
4->5[label="True"];
4->17[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_ETHReturned = wdiv(wmul(_details.amount,CurRiskPrice),_Price)

IRs:
REF_73(uint128) -> _details.amount
TMP_265(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(REF_73,CurRiskPrice)
TMP_266(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_265,_Price)
_ETHReturned(uint128) := TMP_266(uint128)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
Risk.meltCoin(_details.holder,_details.amount)

IRs:
REF_75(address) -> _details.holder
REF_76(uint128) -> _details.amount
TMP_267(bool) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:meltCoin, arguments:['REF_75', 'REF_76']  
CONDITION TMP_267"];
6->7[label="True"];
6->16[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
EventRedeemRisk(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_77(address) -> _details.holder
REF_78(uint128) -> _details.amount
Emit EventRedeemRisk(REF_77,REF_78,_TransID,_Price)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
wless(cast(this.balance),_ETHReturned)

IRs:
REF_79(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_269(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_79)
TMP_270(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(TMP_269,_ETHReturned)
CONDITION TMP_270"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_ETHReturned = cast(this.balance)

IRs:
REF_80(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_271(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_80)
_ETHReturned(uint128) := TMP_271(uint128)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
tryExec(_details.holder,calldata,_ETHReturned)

IRs:
REF_81(address) -> _details.holder
TMP_272(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(REF_81,calldata,_ETHReturned)
CONDITION TMP_272"];
12->13[label="True"];
12->15[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
Risk.mintCoin(_details.holder,_details.amount)

IRs:
REF_83(address) -> _details.holder
REF_84(uint128) -> _details.amount
TMP_273(bool) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:mintCoin, arguments:['REF_83', 'REF_84']  "];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
EventCreateRisk(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_85(address) -> _details.holder
REF_86(uint128) -> _details.amount
Emit EventCreateRisk(REF_85,REF_86,_TransID,_Price)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
}
// Function: 35078.sol-minter-ActionRetStatic(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
0 == Risk.totalSupply()

IRs:
TMP_250(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_251(bool) = 0 == TMP_250
CONDITION TMP_251"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_Price = lastPrice

IRs:
_Price(uint128) := lastPrice(uint128)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_ETHReturned = wdiv(_details.amount,_Price)

IRs:
REF_58(uint128) -> _details.amount
TMP_252(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(REF_58,_Price)
_ETHReturned(uint128) := TMP_252(uint128)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
Static.meltCoin(_details.holder,_details.amount)

IRs:
REF_60(address) -> _details.holder
REF_61(uint128) -> _details.amount
TMP_253(bool) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:meltCoin, arguments:['REF_60', 'REF_61']  
CONDITION TMP_253"];
6->7[label="True"];
6->19[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
EventRedeemStatic(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_62(address) -> _details.holder
REF_63(uint128) -> _details.amount
Emit EventRedeemStatic(REF_62,REF_63,_TransID,_Price)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
wless(cast(this.balance),_ETHReturned)

IRs:
REF_64(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_255(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_64)
TMP_256(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(TMP_255,_ETHReturned)
CONDITION TMP_256"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_ETHReturned = cast(this.balance)

IRs:
REF_65(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_257(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_65)
_ETHReturned(uint128) := TMP_257(uint128)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
tryExec(_details.holder,calldata,_ETHReturned)

IRs:
REF_66(address) -> _details.holder
TMP_258(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(REF_66,calldata,_ETHReturned)
CONDITION TMP_258"];
12->13[label="True"];
12->15[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
Static.mintCoin(_details.holder,_details.amount)

IRs:
REF_68(address) -> _details.holder
REF_69(uint128) -> _details.amount
TMP_259(bool) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:mintCoin, arguments:['REF_68', 'REF_69']  "];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
EventCreateStatic(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_70(address) -> _details.holder
REF_71(uint128) -> _details.amount
Emit EventCreateStatic(REF_70,REF_71,_TransID,_Price)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: IF 16

EXPRESSION:
0 == this.balance

IRs:
REF_72(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_261(bool) = 0 == REF_72
CONDITION TMP_261"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
Bankrupt()

IRs:
INTERNAL_CALL, minter.Bankrupt()()"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
}
// Function: 35078.sol-minter-Bailout()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35078.sol-minter-Bankrupt()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
EventBankrupt()

IRs:
Emit EventBankrupt()"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Static.kill()

IRs:
HIGH_LEVEL_CALL, dest:Static(I_coin), function:kill, arguments:[]  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Risk.kill()

IRs:
HIGH_LEVEL_CALL, dest:Risk(I_coin), function:kill, arguments:[]  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35078.sol-minter-Freeze()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-minter-IsWallet(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(0 == codeLength)

IRs:
TMP_275(bool) = 0 == codeLength
RETURN TMP_275"];
}
// Function: 35078.sol-minter-LastRiskPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
RiskPrice(lastPrice)

IRs:
TMP_178(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128)(lastPrice)
RETURN TMP_178"];
2[label="Node Type: RETURN 2

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35078.sol-minter-Leverage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
Risk.totalSupply() > 0

IRs:
TMP_179(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_180(bool) = TMP_179 > 0
CONDITION TMP_180"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
wdiv(cast(this.balance),cast(Risk.totalSupply()))

IRs:
REF_18(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_181(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_18)
TMP_182(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_183(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_182)
TMP_184(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_181,TMP_183)
RETURN TMP_184"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 35078.sol-minter-LockIfFrozen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! frozen

IRs:
TMP_334 = UnaryType.BANG frozen 
CONDITION TMP_334"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35078.sol-minter-LockIfUnwritten()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
written

IRs:
CONDITION written"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35078.sol-minter-NewCoinInternal(address,uint128,minter.Action)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(IsWallet(_user))

IRs:
TMP_296(bool) = INTERNAL_CALL, minter.IsWallet(address)(_user)
TMP_297(None) = SOLIDITY_CALL require(bool)(TMP_296)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
Fee = wmax(wmul(_amount,mintFee),pricer.queryCost())

IRs:
TMP_298(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_amount,mintFee)
TMP_299(uint128) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:queryCost, arguments:[]  
TMP_300(uint128) = INTERNAL_CALL, DSMath.wmax(uint128,uint128)(TMP_298,TMP_299)
Fee(uint128) := TMP_300(uint128)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
wless(_amount,Fee)

IRs:
TMP_301(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(_amount,Fee)
CONDITION TMP_301"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_302(None) = SOLIDITY_CALL revert()()"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TransID ++

IRs:
TMP_303(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
PricerID = pricer.requestPrice.value(uint256(Fee))(TransID)

IRs:
TMP_304 = CONVERT Fee to uint256
TMP_306(uint256) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:requestPrice, arguments:['TransID'] value:TMP_304 
PricerID(uint256) := TMP_306(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
toCredit = wsub(_amount,Fee)

IRs:
TMP_307(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(_amount,Fee)
toCredit(uint128) := TMP_307(uint128)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
pending[TransID].push(Trans(toCredit,_user,_action,bytes32(PricerID)))

IRs:
REF_98(minter.Trans[]) -> pending[TransID]
TMP_308 = CONVERT PricerID to bytes32
TMP_309(minter.Trans) = new Trans(toCredit,_user,_action,TMP_308)
REF_100 -> LENGTH REF_98
TMP_311(uint256) := REF_100(uint256)
TMP_312(uint256) = TMP_311 + 1
REF_100(uint256) (->pending) := TMP_312(uint256)
REF_101(minter.Trans) -> REF_98[TMP_311]
REF_101(minter.Trans) (->pending) := TMP_309(minter.Trans)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
PendingETH = wadd(PendingETH,toCredit)

IRs:
TMP_313(uint128) = INTERNAL_CALL, DSMath.wadd(uint128,uint128)(PendingETH,toCredit)
PendingETH(uint128) := TMP_313(uint128)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
12->16;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
updates()

IRs:
MODIFIER_CALL, pricerControl.updates()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
LockIfUnwritten()

IRs:
MODIFIER_CALL, oneWrite.LockIfUnwritten()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
LockIfFrozen()

IRs:
MODIFIER_CALL, canFreeze.LockIfFrozen()()"];
15->1;
16[label="Node Type: RETURN 16

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-NewRisk()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(msg.sender,cast(msg.value),Action.NewRisk)

IRs:
TMP_138(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_6(minter.Action) -> Action.NewRisk
TMP_139(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(msg.sender,TMP_138,REF_6)
_TransID(uint256) := TMP_139(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-NewRiskAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(_user,cast(msg.value),Action.NewRisk)

IRs:
TMP_140(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_7(minter.Action) -> Action.NewRisk
TMP_141(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(_user,TMP_140,REF_7)
_TransID(uint256) := TMP_141(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-NewStatic()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(msg.sender,cast(msg.value),Action.NewStatic)

IRs:
TMP_134(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_4(minter.Action) -> Action.NewStatic
TMP_135(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(msg.sender,TMP_134,REF_4)
_TransID(uint256) := TMP_135(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-NewStaticAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(_user,cast(msg.value),Action.NewStatic)

IRs:
TMP_136(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_5(minter.Action) -> Action.NewStatic
TMP_137(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(_user,TMP_136,REF_5)
_TransID(uint256) := TMP_137(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-PriceReturn(uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->22;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
details = pending[_TransID][0]

IRs:
REF_23(minter.Trans[]) -> pending[_TransID]
REF_24(minter.Trans) -> REF_23[0]
details(minter.Trans) := REF_24(minter.Trans)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
0 == _Price || frozen

IRs:
TMP_196(bool) = 0 == _Price
TMP_197(bool) = TMP_196 || frozen
CONDITION TMP_197"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_Price = lastPrice

IRs:
_Price(uint128) := lastPrice(uint128)"];
3->7;
4[label="Node Type: IF 4

EXPRESSION:
Static.totalSupply() > 0 && Risk.totalSupply() > 0

IRs:
TMP_198(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_199(bool) = TMP_198 > 0
TMP_200(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_201(bool) = TMP_200 > 0
TMP_202(bool) = TMP_199 && TMP_201
CONDITION TMP_202"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
lastPrice = _Price

IRs:
lastPrice(uint128) := _Price(uint128)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
Action.NewStatic == details.action

IRs:
REF_27(minter.Action) -> Action.NewStatic
REF_28(minter.Action) -> details.action
TMP_203(bool) = REF_27 == REF_28
CONDITION TMP_203"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
ActionNewStatic(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionNewStatic(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
Action.RetStatic == details.action

IRs:
REF_29(minter.Action) -> Action.RetStatic
REF_30(minter.Action) -> details.action
TMP_205(bool) = REF_29 == REF_30
CONDITION TMP_205"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
ActionRetStatic(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionRetStatic(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
Action.NewRisk == details.action

IRs:
REF_31(minter.Action) -> Action.NewRisk
REF_32(minter.Action) -> details.action
TMP_207(bool) = REF_31 == REF_32
CONDITION TMP_207"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ActionNewRisk(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionNewRisk(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
Action.RetRisk == details.action

IRs:
REF_33(minter.Action) -> Action.RetRisk
REF_34(minter.Action) -> details.action
TMP_209(bool) = REF_33 == REF_34
CONDITION TMP_209"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
ActionRetRisk(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionRetRisk(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
TransCompleted = _TransID

IRs:
TransCompleted(uint256) := _TransID(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
delete pending[_TransID]

IRs:
REF_35(minter.Trans[]) -> pending[_TransID]
pending = delete REF_35 "];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
onlyPricer()

IRs:
MODIFIER_CALL, pricerControl.onlyPricer()()"];
22->1;
}
// Function: 35078.sol-minter-RetCoinInternal(uint128,uint128,address,minter.Action)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(IsWallet(_user))

IRs:
TMP_276(bool) = INTERNAL_CALL, minter.IsWallet(address)(_user)
TMP_277(None) = SOLIDITY_CALL require(bool)(TMP_276)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
Fee = pricer.queryCost()

IRs:
TMP_278(uint128) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:queryCost, arguments:[]  
Fee(uint128) := TMP_278(uint128)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
wless(_AmountETH,Fee)

IRs:
TMP_279(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(_AmountETH,Fee)
CONDITION TMP_279"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_280(None) = SOLIDITY_CALL revert()()"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
refund = wsub(_AmountETH,Fee)

IRs:
TMP_281(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(_AmountETH,Fee)
refund(uint128) := TMP_281(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
0 == _Quantity

IRs:
TMP_282(bool) = 0 == _Quantity
CONDITION TMP_282"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
revert()()

IRs:
TMP_283(None) = SOLIDITY_CALL revert()()"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
TransID ++

IRs:
TMP_284(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
PricerID = pricer.requestPrice.value(uint256(Fee))(TransID)

IRs:
TMP_285 = CONVERT Fee to uint256
TMP_287(uint256) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:requestPrice, arguments:['TransID'] value:TMP_285 
PricerID(uint256) := TMP_287(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
pending[TransID].push(Trans(_Quantity,_user,_action,bytes32(PricerID)))

IRs:
REF_90(minter.Trans[]) -> pending[TransID]
TMP_288 = CONVERT PricerID to bytes32
TMP_289(minter.Trans) = new Trans(_Quantity,_user,_action,TMP_288)
REF_92 -> LENGTH REF_90
TMP_291(uint256) := REF_92(uint256)
TMP_292(uint256) = TMP_291 + 1
REF_92(uint256) (->pending) := TMP_292(uint256)
REF_93(minter.Trans) -> REF_90[TMP_291]
REF_93(minter.Trans) (->pending) := TMP_289(minter.Trans)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_user.transfer(uint256(refund))

IRs:
TMP_293 = CONVERT refund to uint256
Transfer dest:_user value:TMP_293"];
15->17;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
updates()

IRs:
MODIFIER_CALL, pricerControl.updates()()"];
16->1;
17[label="Node Type: RETURN 17

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-RetRisk(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
TransID ++

IRs:
TMP_142(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ActionRetRisk(Trans(_Quantity,msg.sender,Action.RetRisk,0),TransID,lastPrice)

IRs:
REF_8(minter.Action) -> Action.RetRisk
TMP_143(minter.Trans) = new Trans(_Quantity,msg.sender,REF_8,0)
INTERNAL_CALL, minter.ActionRetRisk(minter.Trans,uint256,uint128)(TMP_143,TransID,lastPrice)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_TransID = RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetRisk)

IRs:
TMP_145(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_9(minter.Action) -> Action.RetRisk
TMP_146(uint256) = INTERNAL_CALL, minter.RetCoinInternal(uint128,uint128,address,minter.Action)(_Quantity,TMP_145,msg.sender,REF_9)
_TransID(uint256) := TMP_146(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
LockIfUnwritten()

IRs:
MODIFIER_CALL, oneWrite.LockIfUnwritten()()"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-RetStatic(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
TransID ++

IRs:
TMP_148(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ActionRetStatic(Trans(_Quantity,msg.sender,Action.RetStatic,0),TransID,lastPrice)

IRs:
REF_10(minter.Action) -> Action.RetStatic
TMP_149(minter.Trans) = new Trans(_Quantity,msg.sender,REF_10,0)
INTERNAL_CALL, minter.ActionRetStatic(minter.Trans,uint256,uint128)(TMP_149,TransID,lastPrice)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_TransID = RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetStatic)

IRs:
TMP_151(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_11(minter.Action) -> Action.RetStatic
TMP_152(uint256) = INTERNAL_CALL, minter.RetCoinInternal(uint128,uint128,address,minter.Action)(_Quantity,TMP_151,msg.sender,REF_11)
_TransID(uint256) := TMP_152(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
LockIfUnwritten()

IRs:
MODIFIER_CALL, oneWrite.LockIfUnwritten()()"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35078.sol-minter-RiskPrice(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
RiskPrice(_currentPrice,cast(Static.totalSupply()),cast(Risk.totalSupply()),wsub(cast(this.balance),PendingETH))

IRs:
TMP_171(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_172(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_171)
TMP_173(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_174(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_173)
REF_16(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_175(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_16)
TMP_176(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(TMP_175,PendingETH)
TMP_177(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128,uint128,uint128,uint128)(_currentPrice,TMP_172,TMP_174,TMP_176)
RETURN TMP_177"];
2[label="Node Type: RETURN 2

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35078.sol-minter-RiskPrice(uint128,uint128,uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_ETHTotal == 0 || _RiskTotal == 0

IRs:
TMP_162(bool) = _ETHTotal == 0
TMP_163(bool) = _RiskTotal == 0
TMP_164(bool) = TMP_162 || TMP_163
CONDITION TMP_164"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
wmul(_currentPrice,Multiplier)

IRs:
TMP_165(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_currentPrice,Multiplier)
RETURN TMP_165"];
3[label="Node Type: IF 3

EXPRESSION:
hmore(wmul(_ETHTotal,_currentPrice),_StaticTotal)

IRs:
TMP_166(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_ETHTotal,_currentPrice)
TMP_167(bool) = INTERNAL_CALL, DSMath.hmore(uint128,uint128)(TMP_166,_StaticTotal)
CONDITION TMP_167"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
wdiv(wsub(wmul(_ETHTotal,_currentPrice),_StaticTotal),_RiskTotal)

IRs:
TMP_168(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_ETHTotal,_currentPrice)
TMP_169(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(TMP_168,_StaticTotal)
TMP_170(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_169,_RiskTotal)
RETURN TMP_170"];
5[label="Node Type: RETURN 5

EXPRESSION:
0

IRs:
RETURN 0"];
8[label="Node Type: RETURN 8

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35078.sol-minter-StaticEthAvailable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
StaticEthAvailable(cast(Risk.totalSupply()),cast(this.balance))

IRs:
TMP_154(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_155(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_154)
REF_13(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_156(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_13)
TMP_157(uint128) = INTERNAL_CALL, minter.StaticEthAvailable(uint128,uint128)(TMP_155,TMP_156)
RETURN TMP_157"];
}
// Function: 35078.sol-minter-StaticEthAvailable(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
temp = wmul(wadd(Multiplier,levToll),_RiskTotal)

IRs:
TMP_158(uint128) = INTERNAL_CALL, DSMath.wadd(uint128,uint128)(Multiplier,levToll)
TMP_159(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(TMP_158,_RiskTotal)
temp(uint128) := TMP_159(uint128)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
wless(_TotalETH,temp)

IRs:
TMP_160(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(_TotalETH,temp)
CONDITION TMP_160"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
wsub(temp,_TotalETH)

IRs:
TMP_161(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(temp,_TotalETH)
RETURN TMP_161"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 35078.sol-minter-Strike()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
this.balance > 0

IRs:
REF_20(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_185(bool) = REF_20 > 0
CONDITION TMP_185"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
wdiv(cast(Static.totalSupply()),cast(this.balance))

IRs:
TMP_186(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_187(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_186)
REF_22(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_188(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_22)
TMP_189(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_187,TMP_188)
RETURN TMP_189"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 35078.sol-minter-cast(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)((z = uint128(x)) == x)

IRs:
TMP_119 = CONVERT x to uint128
z(uint128) := TMP_119(uint128)
TMP_120(bool) = z == x
TMP_121(None) = SOLIDITY_CALL assert(bool)(TMP_120)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-minter-exec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(tryExec(target,calldata,value))

IRs:
TMP_131(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(target,calldata,value)
TMP_132(None) = SOLIDITY_CALL assert(bool)(TMP_131)"];
}
// Function: 35078.sol-minter-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_133(None) = SOLIDITY_CALL revert()()"];
}
// Function: 35078.sol-minter-hadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x + y) >= x)

IRs:
TMP_86(uint128) = x + y
z(uint128) := TMP_86(uint128)
TMP_87(bool) = z >= x
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-hdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = x / y

IRs:
TMP_98(uint128) = x / y
z(uint128) := TMP_98(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-hless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x < y

IRs:
TMP_85(bool) = x < y
RETURN TMP_85"];
}
// Function: 35078.sol-minter-hmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_100(bool) = x >= y
CONDITION TMP_100"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-hmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_99(bool) = x <= y
CONDITION TMP_99"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-hmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x > y

IRs:
TMP_84(bool) = x > y
RETURN TMP_84"];
}
// Function: 35078.sol-minter-hmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(y == 0 || (z = x * y) / y == x)

IRs:
TMP_92(bool) = y == 0
TMP_93(uint128) = x * y
z(uint128) := TMP_93(uint128)
TMP_94(uint128) = z / y
TMP_95(bool) = TMP_94 == x
TMP_96(bool) = TMP_92 || TMP_95
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-hsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x - y) <= x)

IRs:
TMP_89(uint128) = x - y
z(uint128) := TMP_89(uint128)
TMP_90(bool) = z <= x
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-minter(string,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Currency = _currency

IRs:
Currency(string) := _currency(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Multiplier = _Multiplier

IRs:
Multiplier(uint128) := _Multiplier(uint128)"];
}
// Function: 35078.sol-minter-mutex()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(! _ds_mutex)

IRs:
TMP_338 = UnaryType.BANG _ds_mutex 
TMP_339(None) = SOLIDITY_CALL assert(bool)(TMP_338)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_ds_mutex = true

IRs:
_ds_mutex(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_ds_mutex = false

IRs:
_ds_mutex(bool) := False(bool)"];
}
// Function: 35078.sol-minter-oneWrite()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35078.sol-minter-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_335(bool) = msg.sender == owner
TMP_336(None) = SOLIDITY_CALL require(bool)(TMP_335)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-minter-onlyPricer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(pricer))

IRs:
TMP_331 = CONVERT pricer to address
TMP_332(bool) = msg.sender == TMP_331
TMP_333(None) = SOLIDITY_CALL require(bool)(TMP_332)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-minter-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35078.sol-minter-setCoins(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Risk = I_coin(newRisk)

IRs:
TMP_191 = CONVERT newRisk to I_coin
Risk(I_coin) := TMP_191(I_coin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Static = I_coin(newStatic)

IRs:
TMP_192 = CONVERT newStatic to I_coin
Static(I_coin) := TMP_192(I_coin)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
PRICER_DELAY = 172800

IRs:
PRICER_DELAY(uint256) := 172800(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
updates()

IRs:
MODIFIER_CALL, pricerControl.updates()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
writeOnce()

IRs:
MODIFIER_CALL, oneWrite.writeOnce()()"];
6->1;
}
// Function: 35078.sol-minter-setFee(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintFee = _newFee

IRs:
mintFee(uint128) := _newFee(uint128)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-minter-setPricer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
releaseTime = now + PRICER_DELAY

IRs:
TMP_122(uint256) = now + PRICER_DELAY
releaseTime(uint256) := TMP_122(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
future = newAddress

IRs:
future(address) := newAddress(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
EventAddressChange(pricer,future,releaseTime)

IRs:
Emit EventAddressChange(pricer,future,releaseTime)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35078.sol-minter-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
WAD_Dec = 18

IRs:
WAD_Dec(uint64) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
WAD = 10 ** 18

IRs:
TMP_326(uint256) = 10 ** 18
WAD(uint128) := TMP_326(uint256)"];
}
// Function: 35078.sol-minter-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
PRICER_DELAY = 2

IRs:
PRICER_DELAY(uint256) := 2(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TransID = 0

IRs:
TransID(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
levToll = 5 * 10 ** (18 - 1)

IRs:
TMP_320(uint256) = 18 - 1
TMP_321(uint256) = 10 ** TMP_320
TMP_322(uint256) = 5 * TMP_321
levToll(uint128) := TMP_322(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
mintFee = 2 * 10 ** (18 - 3)

IRs:
TMP_323(uint256) = 18 - 3
TMP_324(uint256) = 10 ** TMP_323
TMP_325(uint256) = 2 * TMP_324
mintFee(uint128) := TMP_325(uint256)"];
}
// Function: 35078.sol-minter-tryExec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
target.call.value(value)(calldata)

IRs:
TMP_129(bool) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['calldata'] value:value 
RETURN TMP_129"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
mutex()

IRs:
MODIFIER_CALL, DSBaseActor.mutex()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
call_ret

IRs:
RETURN call_ret"];
}
// Function: 35078.sol-minter-update()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pricer = I_Pricer(future)

IRs:
TMP_125 = CONVERT future to I_Pricer
pricer(I_Pricer) := TMP_125(I_Pricer)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
}
// Function: 35078.sol-minter-updates()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
now > releaseTime && pricer != future

IRs:
TMP_327(bool) = now > releaseTime
TMP_328(bool) = pricer != future
TMP_329(bool) = TMP_327 && TMP_328
CONDITION TMP_329"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
update()

IRs:
INTERNAL_CALL, pricerControl.update()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 35078.sol-minter-wadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hadd(x,y)

IRs:
TMP_103(uint128) = INTERNAL_CALL, DSMath.hadd(uint128,uint128)(x,y)
RETURN TMP_103"];
}
// Function: 35078.sol-minter-wdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * WAD + y / 2) / y)

IRs:
TMP_111 = CONVERT x to uint256
TMP_112(uint256) = TMP_111 * WAD
TMP_113(uint128) = y / 2
TMP_114(uint256) = TMP_112 + TMP_113
TMP_115(uint256) = TMP_114 / y
TMP_116(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_115)
z(uint128) := TMP_116(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-wless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hless(x,y)

IRs:
TMP_102(bool) = INTERNAL_CALL, DSMath.hless(uint128,uint128)(x,y)
RETURN TMP_102"];
}
// Function: 35078.sol-minter-wmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmax(x,y)

IRs:
TMP_118(uint128) = INTERNAL_CALL, DSMath.hmax(uint128,uint128)(x,y)
RETURN TMP_118"];
}
// Function: 35078.sol-minter-wmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmin(x,y)

IRs:
TMP_117(uint128) = INTERNAL_CALL, DSMath.hmin(uint128,uint128)(x,y)
RETURN TMP_117"];
}
// Function: 35078.sol-minter-wmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmore(x,y)

IRs:
TMP_101(bool) = INTERNAL_CALL, DSMath.hmore(uint128,uint128)(x,y)
RETURN TMP_101"];
}
// Function: 35078.sol-minter-wmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * y + WAD / 2) / WAD)

IRs:
TMP_105 = CONVERT x to uint256
TMP_106(uint256) = TMP_105 * y
TMP_107(uint128) = WAD / 2
TMP_108(uint256) = TMP_106 + TMP_107
TMP_109(uint256) = TMP_108 / WAD
TMP_110(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_109)
z(uint128) := TMP_110(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35078.sol-minter-writeOnce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! written

IRs:
TMP_337 = UnaryType.BANG written 
CONDITION TMP_337"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
written = true

IRs:
written(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 35078.sol-minter-wsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hsub(x,y)

IRs:
TMP_104(uint128) = INTERNAL_CALL, DSMath.hsub(uint128,uint128)(x,y)
RETURN TMP_104"];
}
// Function: 35078.sol-mortal-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-mortal-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_4(bool) = msg.sender == owner
CONDITION TMP_4"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_5(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35078.sol-mortal-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_7(bool) = msg.sender == owner
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-mortal-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35078.sol-oneWrite-LockIfUnwritten()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
written

IRs:
CONDITION written"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35078.sol-oneWrite-oneWrite()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35078.sol-oneWrite-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35078.sol-oneWrite-writeOnce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! written

IRs:
TMP_67 = UnaryType.BANG written 
CONDITION TMP_67"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
written = true

IRs:
written(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 35078.sol-owned-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_1(bool) = msg.sender == owner
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-owned-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35078.sol-pricerControl-Freeze()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-pricerControl-LockIfFrozen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! frozen

IRs:
TMP_74 = UnaryType.BANG frozen 
CONDITION TMP_74"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35078.sol-pricerControl-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35078.sol-pricerControl-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_75(bool) = msg.sender == owner
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-pricerControl-onlyPricer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(pricer))

IRs:
TMP_81 = CONVERT pricer to address
TMP_82(bool) = msg.sender == TMP_81
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 35078.sol-pricerControl-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35078.sol-pricerControl-setPricer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
releaseTime = now + PRICER_DELAY

IRs:
TMP_70(uint256) = now + PRICER_DELAY
releaseTime(uint256) := TMP_70(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
future = newAddress

IRs:
future(address) := newAddress(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
EventAddressChange(pricer,future,releaseTime)

IRs:
Emit EventAddressChange(pricer,future,releaseTime)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35078.sol-pricerControl-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
PRICER_DELAY = 2

IRs:
PRICER_DELAY(uint256) := 2(uint256)"];
}
// Function: 35078.sol-pricerControl-update()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pricer = I_Pricer(future)

IRs:
TMP_73 = CONVERT future to I_Pricer
pricer(I_Pricer) := TMP_73(I_Pricer)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
}
// Function: 35078.sol-pricerControl-updates()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
now > releaseTime && pricer != future

IRs:
TMP_77(bool) = now > releaseTime
TMP_78(bool) = pricer != future
TMP_79(bool) = TMP_77 && TMP_78
CONDITION TMP_79"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
update()

IRs:
INTERNAL_CALL, pricerControl.update()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
}
