digraph G {
// Function: 38531.sol-Base-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_addr == 0

IRs:
TMP_2(bool) = _addr == 0
CONDITION TMP_2"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(size > 0)

IRs:
TMP_3(bool) = size > 0
RETURN TMP_3"];
}
// Function: 38531.sol-Base-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_0(bool) = a >= b
CONDITION TMP_0"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-Base-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a <= b

IRs:
TMP_1(bool) = a <= b
CONDITION TMP_1"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-Base-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks > 0

IRs:
TMP_13(bool) = _locks > 0
CONDITION TMP_13"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_14(uint256) = 0 - 1
TMP_15 = CONVERT TMP_14 to uint256
bitlocks(uint256) := TMP_15(uint256)"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-Base-noReentrancy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks & m > 0

IRs:
TMP_11(uint256) = _locks & m
TMP_12(bool) = TMP_11 > 0
CONDITION TMP_12"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks |= m

IRs:
bitlocks(uint256) = bitlocks | m"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-Base-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != allowed

IRs:
TMP_10(bool) = msg.sender != allowed
CONDITION TMP_10"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-Base-reentrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: _ 1
"];
}
// Function: 38531.sol-Base-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
L00 = 2 ** 0

IRs:
TMP_4(uint256) = 2 ** 0
L00(uint256) := TMP_4(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
L01 = 2 ** 1

IRs:
TMP_5(uint256) = 2 ** 1
L01(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
L02 = 2 ** 2

IRs:
TMP_6(uint256) = 2 ** 2
L02(uint256) := TMP_6(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
L03 = 2 ** 3

IRs:
TMP_7(uint256) = 2 ** 3
L03(uint256) := TMP_7(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
L04 = 2 ** 4

IRs:
TMP_8(uint256) = 2 ** 4
L04(uint256) := TMP_8(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
L05 = 2 ** 5

IRs:
TMP_9(uint256) = 2 ** 5
L05(uint256) := TMP_9(uint256)"];
}
// Function: 38531.sol-Base-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
bitlocks = 0

IRs:
bitlocks(uint256) := 0(uint256)"];
}
// Function: 38531.sol-ERC20-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 38531.sol-ERC20-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
only(newOwner)

IRs:
MODIFIER_CALL, Base.only(address)(newOwner)"];
3->1;
}
// Function: 38531.sol-ERC20-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_17(mapping(address => uint256)) -> allowed[_owner]
REF_18(uint256) -> REF_17[_spender]
RETURN REF_18"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 38531.sol-ERC20-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_15(mapping(address => uint256)) -> allowed[msg.sender]
REF_16(uint256) -> REF_15[_spender]
REF_16(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isStartedOnly()

IRs:
MODIFIER_CALL, ERC20.isStartedOnly()()"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-ERC20-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_14(uint256) -> balances[_owner]
RETURN REF_14"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 38531.sol-ERC20-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_addr == 0

IRs:
TMP_40(bool) = _addr == 0
CONDITION TMP_40"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(size > 0)

IRs:
TMP_41(bool) = size > 0
RETURN TMP_41"];
}
// Function: 38531.sol-ERC20-isStartedOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isStarted

IRs:
TMP_72 = UnaryType.BANG isStarted 
CONDITION TMP_72"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-ERC20-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_38(bool) = a >= b
CONDITION TMP_38"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-ERC20-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a <= b

IRs:
TMP_39(bool) = a <= b
CONDITION TMP_39"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-ERC20-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks > 0

IRs:
TMP_67(bool) = _locks > 0
CONDITION TMP_67"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_68(uint256) = 0 - 1
TMP_69 = CONVERT TMP_68 to uint256
bitlocks(uint256) := TMP_69(uint256)"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-ERC20-noReentrancy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks & m > 0

IRs:
TMP_65(uint256) = _locks & m
TMP_66(bool) = TMP_65 > 0
CONDITION TMP_66"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks |= m

IRs:
bitlocks(uint256) = bitlocks | m"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-ERC20-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != allowed

IRs:
TMP_64(bool) = msg.sender != allowed
CONDITION TMP_64"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-ERC20-onlyHolder(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balanceOf(holder) == 0

IRs:
TMP_70(uint256) = INTERNAL_CALL, ERC20.balanceOf(address)(holder)
TMP_71(bool) = TMP_70 == 0
CONDITION TMP_71"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-ERC20-reentrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: _ 1
"];
}
// Function: 38531.sol-ERC20-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
L00 = 2 ** 0

IRs:
TMP_58(uint256) = 2 ** 0
L00(uint256) := TMP_58(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
L01 = 2 ** 1

IRs:
TMP_59(uint256) = 2 ** 1
L01(uint256) := TMP_59(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
L02 = 2 ** 2

IRs:
TMP_60(uint256) = 2 ** 2
L02(uint256) := TMP_60(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
L03 = 2 ** 3

IRs:
TMP_61(uint256) = 2 ** 3
L03(uint256) := TMP_61(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
L04 = 2 ** 4

IRs:
TMP_62(uint256) = 2 ** 4
L04(uint256) := TMP_62(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
L05 = 2 ** 5

IRs:
TMP_63(uint256) = 2 ** 5
L05(uint256) := TMP_63(uint256)"];
}
// Function: 38531.sol-ERC20-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isStarted = false

IRs:
isStarted(bool) := False(bool)"];
}
// Function: 38531.sol-ERC20-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: IF 1

EXPRESSION:
balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_42(bool) = REF_0 >= _value
REF_1(uint256) -> balances[_to]
TMP_43(uint256) = REF_1 + _value
REF_2(uint256) -> balances[_to]
TMP_44(bool) = TMP_43 > REF_2
TMP_45(bool) = TMP_42 && TMP_44
CONDITION TMP_45"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isStartedOnly()

IRs:
MODIFIER_CALL, ERC20.isStartedOnly()()"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-ERC20-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]

IRs:
REF_5(uint256) -> balances[_from]
TMP_48(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_49(bool) = REF_7 >= _value
TMP_50(bool) = TMP_48 && TMP_49
REF_8(uint256) -> balances[_to]
TMP_51(uint256) = REF_8 + _value
REF_9(uint256) -> balances[_to]
TMP_52(bool) = TMP_51 > REF_9
TMP_53(bool) = TMP_50 && TMP_52
CONDITION TMP_53"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_11(uint256) -> balances[_from]
REF_11(-> balances) = REF_11 - _value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_12(mapping(address => uint256)) -> allowed[_from]
REF_13(uint256) -> REF_12[msg.sender]
REF_13(-> allowed) = REF_13 - _value"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
isStartedOnly()

IRs:
MODIFIER_CALL, ERC20.isStartedOnly()()"];
9->1;
10[label="Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-ERC20-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
only(owner)

IRs:
MODIFIER_CALL, Base.only(address)(owner)"];
2->1;
}
// Function: 38531.sol-ERC20ModuleSupport-_burnForDeposit(address,uint256)
digraph{
}
// Function: 38531.sol-ERC20ModuleSupport-_fulfillPayment(address,address,uint256,uint256,address)
digraph{
}
// Function: 38531.sol-ERC20ModuleSupport-_fulfillPreapprovedPayment(address,address,uint256,address)
digraph{
}
// Function: 38531.sol-ERC20ModuleSupport-_mintFromDeposit(address,uint256)
digraph{
}
// Function: 38531.sol-Owned-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 38531.sol-Owned-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
only(newOwner)

IRs:
MODIFIER_CALL, Base.only(address)(newOwner)"];
3->1;
}
// Function: 38531.sol-Owned-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_addr == 0

IRs:
TMP_18(bool) = _addr == 0
CONDITION TMP_18"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(size > 0)

IRs:
TMP_19(bool) = size > 0
RETURN TMP_19"];
}
// Function: 38531.sol-Owned-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_16(bool) = a >= b
CONDITION TMP_16"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-Owned-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a <= b

IRs:
TMP_17(bool) = a <= b
CONDITION TMP_17"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-Owned-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks > 0

IRs:
TMP_32(bool) = _locks > 0
CONDITION TMP_32"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_33(uint256) = 0 - 1
TMP_34 = CONVERT TMP_33 to uint256
bitlocks(uint256) := TMP_34(uint256)"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-Owned-noReentrancy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks & m > 0

IRs:
TMP_30(uint256) = _locks & m
TMP_31(bool) = TMP_30 > 0
CONDITION TMP_31"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks |= m

IRs:
bitlocks(uint256) = bitlocks | m"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-Owned-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != allowed

IRs:
TMP_29(bool) = msg.sender != allowed
CONDITION TMP_29"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-Owned-reentrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: _ 1
"];
}
// Function: 38531.sol-Owned-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
L00 = 2 ** 0

IRs:
TMP_23(uint256) = 2 ** 0
L00(uint256) := TMP_23(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
L01 = 2 ** 1

IRs:
TMP_24(uint256) = 2 ** 1
L01(uint256) := TMP_24(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
L02 = 2 ** 2

IRs:
TMP_25(uint256) = 2 ** 2
L02(uint256) := TMP_25(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
L03 = 2 ** 3

IRs:
TMP_26(uint256) = 2 ** 3
L03(uint256) := TMP_26(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
L04 = 2 ** 4

IRs:
TMP_27(uint256) = 2 ** 4
L04(uint256) := TMP_27(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
L05 = 2 ** 5

IRs:
TMP_28(uint256) = 2 ** 5
L05(uint256) := TMP_28(uint256)"];
}
// Function: 38531.sol-Owned-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
only(owner)

IRs:
MODIFIER_CALL, Base.only(address)(owner)"];
2->1;
}
// Function: 38531.sol-ServiceProvider-info()
digraph{
}
// Function: 38531.sol-ServiceProvider-onPayment(address,uint256,bytes)
digraph{
}
// Function: 38531.sol-ServiceProvider-onSubCanceled(uint256,address)
digraph{
}
// Function: 38531.sol-ServiceProvider-onSubExecuted(uint256)
digraph{
}
// Function: 38531.sol-ServiceProvider-onSubNew(uint256,uint256)
digraph{
}
// Function: 38531.sol-ServiceProvider-onSubUnHold(uint256,address,bool)
digraph{
}
// Function: 38531.sol-SubscriptionBase-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
SUB_STATES = (NOT_EXIST,BEFORE_START,PAID,CHARGEABLE,ON_HOLD,CANCELED,EXPIRED,FINALIZED)

IRs:
SUB_STATES(string[]) = ['NOT_EXIST(string)', 'BEFORE_START(string)', 'PAID(string)', 'CHARGEABLE(string)', 'ON_HOLD(string)', 'CANCELED(string)', 'EXPIRED(string)', 'FINALIZED(string)']"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
OFFER_STATES = (NOT_EXIST,BEFORE_START,ACTIVE,SOLD_OUT,ON_HOLD,EXPIRED)

IRs:
OFFER_STATES(string[]) = ['NOT_EXIST(string)', 'BEFORE_START(string)', 'ACTIVE(string)', 'SOLD_OUT(string)', 'ON_HOLD(string)', 'EXPIRED(string)']"];
}
// Function: 38531.sol-SubscriptionModule-attachToken(address)
digraph{
}
// Function: 38531.sol-SubscriptionModule-cancelSubscription(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-cancelSubscription(uint256,uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-cancelSubscriptionOffer(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-claimDeposit(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-claimSubscriptionDeposit(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-createDeposit(uint256,uint256,bytes)
digraph{
}
// Function: 38531.sol-SubscriptionModule-createSubscription(uint256,uint256,uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)
digraph{
}
// Function: 38531.sol-SubscriptionModule-disableServiceProvider(ServiceProvider,bytes)
digraph{
}
// Function: 38531.sol-SubscriptionModule-enableServiceProvider(ServiceProvider,bytes)
digraph{
}
// Function: 38531.sol-SubscriptionModule-executeSubscription(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-holdSubscription(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-holdSubscriptionOffer(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_addr == 0

IRs:
TMP_75(bool) = _addr == 0
CONDITION TMP_75"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(size > 0)

IRs:
TMP_76(bool) = size > 0
RETURN TMP_76"];
}
// Function: 38531.sol-SubscriptionModule-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_73(bool) = a >= b
CONDITION TMP_73"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-SubscriptionModule-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a <= b

IRs:
TMP_74(bool) = a <= b
CONDITION TMP_74"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-SubscriptionModule-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks > 0

IRs:
TMP_86(bool) = _locks > 0
CONDITION TMP_86"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_87(uint256) = 0 - 1
TMP_88 = CONVERT TMP_87 to uint256
bitlocks(uint256) := TMP_88(uint256)"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-SubscriptionModule-noReentrancy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks & m > 0

IRs:
TMP_84(uint256) = _locks & m
TMP_85(bool) = TMP_84 > 0
CONDITION TMP_85"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks |= m

IRs:
bitlocks(uint256) = bitlocks | m"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-SubscriptionModule-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != allowed

IRs:
TMP_83(bool) = msg.sender != allowed
CONDITION TMP_83"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-SubscriptionModule-paymentFrom(uint256,bytes,address,ServiceProvider)
digraph{
}
// Function: 38531.sol-SubscriptionModule-paymentTo(uint256,bytes,ServiceProvider)
digraph{
}
// Function: 38531.sol-SubscriptionModule-postponeDueDate(uint256,uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-reentrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: _ 1
"];
}
// Function: 38531.sol-SubscriptionModule-registerXRateProvider(XRateProvider)
digraph{
}
// Function: 38531.sol-SubscriptionModule-returnSubscriptionDesposit(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
L00 = 2 ** 0

IRs:
TMP_77(uint256) = 2 ** 0
L00(uint256) := TMP_77(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
L01 = 2 ** 1

IRs:
TMP_78(uint256) = 2 ** 1
L01(uint256) := TMP_78(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
L02 = 2 ** 2

IRs:
TMP_79(uint256) = 2 ** 2
L02(uint256) := TMP_79(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
L03 = 2 ** 3

IRs:
TMP_80(uint256) = 2 ** 3
L03(uint256) := TMP_80(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
L04 = 2 ** 4

IRs:
TMP_81(uint256) = 2 ** 4
L04(uint256) := TMP_81(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
L05 = 2 ** 5

IRs:
TMP_82(uint256) = 2 ** 5
L05(uint256) := TMP_82(uint256)"];
}
// Function: 38531.sol-SubscriptionModule-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
SUB_STATES = (NOT_EXIST,BEFORE_START,PAID,CHARGEABLE,ON_HOLD,CANCELED,EXPIRED,FINALIZED)

IRs:
SUB_STATES(string[]) = ['NOT_EXIST(string)', 'BEFORE_START(string)', 'PAID(string)', 'CHARGEABLE(string)', 'ON_HOLD(string)', 'CANCELED(string)', 'EXPIRED(string)', 'FINALIZED(string)']"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
OFFER_STATES = (NOT_EXIST,BEFORE_START,ACTIVE,SOLD_OUT,ON_HOLD,EXPIRED)

IRs:
OFFER_STATES(string[]) = ['NOT_EXIST(string)', 'BEFORE_START(string)', 'ACTIVE(string)', 'SOLD_OUT(string)', 'ON_HOLD(string)', 'EXPIRED(string)']"];
}
// Function: 38531.sol-SubscriptionModule-state(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-stateCode(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-subscriptionDetails(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-subscriptionStatus(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-unholdSubscription(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-unholdSubscriptionOffer(uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModule-updateSubscriptionOffer(uint256,uint256)
digraph{
}
// Function: 38531.sol-SubscriptionModuleImpl-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-SubscriptionModuleImpl()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
xrateProviders.push(XRateProvider(this))

IRs:
TMP_97 = CONVERT this to XRateProvider
REF_20 -> LENGTH xrateProviders
TMP_99(uint256) := REF_20(uint256)
TMP_100(uint256) = TMP_99 + 1
REF_20(uint256) (->xrateProviders) := TMP_100(uint256)
REF_21(XRateProvider) -> xrateProviders[TMP_99]
REF_21(XRateProvider) (->xrateProviders) := TMP_97(XRateProvider)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-_amountToCharge(SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
_applyXchangeRate(sub.pricePerHour * sub.chargePeriod,sub) / 3600

IRs:
REF_181(uint256) -> sub.pricePerHour
REF_182(uint256) -> sub.chargePeriod
TMP_350(uint256) = REF_181 * REF_182
TMP_351(uint256) = INTERNAL_CALL, SubscriptionModuleImpl._applyXchangeRate(uint256,SubscriptionBase.Subscription)(TMP_350,sub)
TMP_352(uint256) = TMP_351 / 3600
RETURN TMP_352"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
reentrant()

IRs:
MODIFIER_CALL, Base.reentrant()()"];
2->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-_applyXchangeRate(uint256,SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: IF 1

EXPRESSION:
sub.xrateProviderId > 0

IRs:
REF_183(uint16) -> sub.xrateProviderId
TMP_354(bool) = REF_183 > 0
CONDITION TMP_354"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
(xrate_n,xrate_d) = XRateProvider(xrateProviders[sub.xrateProviderId]).getRate()

IRs:
REF_184(uint16) -> sub.xrateProviderId
REF_185(XRateProvider) -> xrateProviders[REF_184]
TMP_355 = CONVERT REF_185 to XRateProvider
TUPLE_1(uint32,uint32) = HIGH_LEVEL_CALL, dest:TMP_355(XRateProvider), function:getRate, arguments:[]  
xrate_n(uint32)= UNPACK TUPLE_1 index: 0 
xrate_d(uint32)= UNPACK TUPLE_1 index: 1 "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
amount = amount * sub.initialXrate_n * xrate_d / sub.initialXrate_d / xrate_n

IRs:
REF_187(uint32) -> sub.initialXrate_n
TMP_356(uint256) = amount * REF_187
TMP_357(uint256) = TMP_356 * xrate_d
REF_188(uint32) -> sub.initialXrate_d
TMP_358(uint256) = TMP_357 / REF_188
TMP_359(uint256) = TMP_358 / xrate_n
amount(uint256) := TMP_359(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
amount

IRs:
RETURN amount"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
reentrant()

IRs:
MODIFIER_CALL, Base.reentrant()()"];
8->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-_exists(SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
sub.transferTo != 0

IRs:
REF_193(address) -> sub.transferTo
TMP_367(bool) = REF_193 != 0
RETURN TMP_367"];
}
// Function: 38531.sol-SubscriptionModuleImpl-_isOffer(SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
sub.transferFrom == 0 && sub.transferTo != 0

IRs:
REF_189(address) -> sub.transferFrom
TMP_361(bool) = REF_189 == 0
REF_190(address) -> sub.transferTo
TMP_362(bool) = REF_190 != 0
TMP_363(bool) = TMP_361 && TMP_362
RETURN TMP_363"];
}
// Function: 38531.sol-SubscriptionModuleImpl-_isSubscription(SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
sub.transferFrom != 0 && sub.transferTo != 0

IRs:
REF_191(address) -> sub.transferFrom
TMP_364(bool) = REF_191 != 0
REF_192(address) -> sub.transferTo
TMP_365(bool) = REF_192 != 0
TMP_366(bool) = TMP_364 && TMP_365
RETURN TMP_366"];
}
// Function: 38531.sol-SubscriptionModuleImpl-_offerState(SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! _isOffer(sub)

IRs:
TMP_170(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(sub)
TMP_171 = UnaryType.BANG TMP_170 
CONDITION TMP_171"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
OfferState.NOT_EXIST

IRs:
REF_70(SubscriptionBase.OfferState) -> OfferState.NOT_EXIST
RETURN REF_70"];
3[label="Node Type: IF 3

EXPRESSION:
sub.startOn > now

IRs:
REF_71(uint256) -> sub.startOn
TMP_172(bool) = REF_71 > now
CONDITION TMP_172"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
OfferState.BEFORE_START

IRs:
REF_72(SubscriptionBase.OfferState) -> OfferState.BEFORE_START
RETURN REF_72"];
5[label="Node Type: IF 5

EXPRESSION:
sub.onHoldSince > 0

IRs:
REF_73(uint256) -> sub.onHoldSince
TMP_173(bool) = REF_73 > 0
CONDITION TMP_173"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
OfferState.ON_HOLD

IRs:
REF_74(SubscriptionBase.OfferState) -> OfferState.ON_HOLD
RETURN REF_74"];
7[label="Node Type: IF 7

EXPRESSION:
now <= sub.expireOn

IRs:
REF_75(uint256) -> sub.expireOn
TMP_174(bool) = now <= REF_75
CONDITION TMP_174"];
7->14[label="True"];
7->9[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
OfferState.EXPIRED

IRs:
REF_76(SubscriptionBase.OfferState) -> OfferState.EXPIRED
RETURN REF_76"];
14[label="Node Type: IF 14

EXPRESSION:
sub.execCounter > 0

IRs:
REF_77(uint256) -> sub.execCounter
TMP_175(bool) = REF_77 > 0
CONDITION TMP_175"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: RETURN 15

EXPRESSION:
OfferState.ACTIVE

IRs:
REF_78(SubscriptionBase.OfferState) -> OfferState.ACTIVE
RETURN REF_78"];
16[label="Node Type: RETURN 16

EXPRESSION:
OfferState.SOLD_OUT

IRs:
REF_79(SubscriptionBase.OfferState) -> OfferState.SOLD_OUT
RETURN REF_79"];
18[label="Node Type: RETURN 18

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 38531.sol-SubscriptionModuleImpl-_returnSubscriptionDesposit(uint256,SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
depositAmount = sub.depositAmount

IRs:
REF_165(uint256) -> sub.depositAmount
depositAmount(uint256) := REF_165(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
sub.depositAmount = 0

IRs:
REF_166(uint256) -> sub.depositAmount
REF_166(uint256) (->sub) := 0(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
san._mintFromDeposit(sub.transferFrom,depositAmount)

IRs:
REF_168(address) -> sub.transferFrom
HIGH_LEVEL_CALL, dest:san(ERC20ModuleSupport), function:_mintFromDeposit, arguments:['REF_168', 'depositAmount']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
SubscriptionDepositReturned(subId,depositAmount,sub.transferFrom,msg.sender)

IRs:
REF_169(address) -> sub.transferFrom
Emit SubscriptionDepositReturned(subId,depositAmount,REF_169,msg.sender)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-_subscriptionState(SubscriptionBase.Subscription)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! _isSubscription(sub)

IRs:
TMP_176(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isSubscription(SubscriptionBase.Subscription)(sub)
TMP_177 = UnaryType.BANG TMP_176 
CONDITION TMP_177"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
SubState.NOT_EXIST

IRs:
REF_80(SubscriptionBase.SubState) -> SubState.NOT_EXIST
RETURN REF_80"];
3[label="Node Type: IF 3

EXPRESSION:
sub.startOn > now

IRs:
REF_81(uint256) -> sub.startOn
TMP_178(bool) = REF_81 > now
CONDITION TMP_178"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
SubState.BEFORE_START

IRs:
REF_82(SubscriptionBase.SubState) -> SubState.BEFORE_START
RETURN REF_82"];
5[label="Node Type: IF 5

EXPRESSION:
sub.onHoldSince > 0

IRs:
REF_83(uint256) -> sub.onHoldSince
TMP_179(bool) = REF_83 > 0
CONDITION TMP_179"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
SubState.ON_HOLD

IRs:
REF_84(SubscriptionBase.SubState) -> SubState.ON_HOLD
RETURN REF_84"];
7[label="Node Type: IF 7

EXPRESSION:
sub.paidUntil >= sub.expireOn

IRs:
REF_85(uint256) -> sub.paidUntil
REF_86(uint256) -> sub.expireOn
TMP_180(bool) = REF_85 >= REF_86
CONDITION TMP_180"];
7->17[label="True"];
7->9[label="False"];
9[label="Node Type: IF 9

EXPRESSION:
sub.paidUntil <= now

IRs:
REF_87(uint256) -> sub.paidUntil
TMP_181(bool) = REF_87 <= now
CONDITION TMP_181"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
SubState.CHARGEABLE

IRs:
REF_88(SubscriptionBase.SubState) -> SubState.CHARGEABLE
RETURN REF_88"];
11[label="Node Type: RETURN 11

EXPRESSION:
SubState.PAID

IRs:
REF_89(SubscriptionBase.SubState) -> SubState.PAID
RETURN REF_89"];
17[label="Node Type: IF 17

EXPRESSION:
now < sub.expireOn

IRs:
REF_90(uint256) -> sub.expireOn
TMP_182(bool) = now < REF_90
CONDITION TMP_182"];
17->18[label="True"];
17->21[label="False"];
18[label="Node Type: RETURN 18

EXPRESSION:
SubState.CANCELED

IRs:
REF_91(SubscriptionBase.SubState) -> SubState.CANCELED
RETURN REF_91"];
21[label="Node Type: IF 21

EXPRESSION:
sub.depositAmount > 0

IRs:
REF_92(uint256) -> sub.depositAmount
TMP_183(bool) = REF_92 > 0
CONDITION TMP_183"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: RETURN 22

EXPRESSION:
SubState.EXPIRED

IRs:
REF_93(SubscriptionBase.SubState) -> SubState.EXPIRED
RETURN REF_93"];
23[label="Node Type: RETURN 23

EXPRESSION:
SubState.FINALIZED

IRs:
REF_94(SubscriptionBase.SubState) -> SubState.FINALIZED
RETURN REF_94"];
25[label="Node Type: RETURN 25

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 38531.sol-SubscriptionModuleImpl-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
only(newOwner)

IRs:
MODIFIER_CALL, Base.only(address)(newOwner)"];
3->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-attachToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(address(san) == 0)

IRs:
TMP_101 = CONVERT san to address
TMP_102(bool) = TMP_101 == 0
TMP_103(None) = SOLIDITY_CALL assert(bool)(TMP_102)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
san = ERC20ModuleSupport(token)

IRs:
TMP_104 = CONVERT token to ERC20ModuleSupport
san(ERC20ModuleSupport) := TMP_104(ERC20ModuleSupport)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-cancelSubscription(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
cancelSubscription(subId,0)

IRs:
INTERNAL_CALL, SubscriptionModuleImpl.cancelSubscription(uint256,uint256)(subId,0)
RETURN TMP_239"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
2->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-cancelSubscription(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_127(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_127(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(sub.transferFrom == msg.sender || owner == msg.sender)

IRs:
REF_128(address) -> sub.transferFrom
TMP_241(bool) = REF_128 == msg.sender
TMP_242(bool) = owner == msg.sender
TMP_243(bool) = TMP_241 || TMP_242
TMP_244(None) = SOLIDITY_CALL assert(bool)(TMP_243)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(_isSubscription(sub))

IRs:
TMP_245(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isSubscription(SubscriptionBase.Subscription)(sub)
TMP_246(None) = SOLIDITY_CALL assert(bool)(TMP_245)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_to = sub.transferTo

IRs:
REF_129(address) -> sub.transferTo
_to(address) := REF_129(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
sub.expireOn = max(now,sub.paidUntil)

IRs:
REF_130(uint256) -> sub.expireOn
REF_131(uint256) -> sub.paidUntil
TMP_247(uint256) = INTERNAL_CALL, Base.max(uint256,uint256)(now,REF_131)
REF_130(uint256) (->sub) := TMP_247(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
msg.sender != _to

IRs:
TMP_248(bool) = msg.sender != _to
CONDITION TMP_248"];
6->7[label="True"];
6->11[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
gasReserve = max(gasReserve,10000)

IRs:
TMP_249(uint256) = INTERNAL_CALL, Base.max(uint256,uint256)(gasReserve,10000)
gasReserve(uint256) := TMP_249(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(msg.gas > gasReserve)

IRs:
TMP_250(bool) = msg.gas > gasReserve
TMP_251(None) = SOLIDITY_CALL assert(bool)(TMP_250)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
_to.call.gas(msg.gas - gasReserve)(bytes4(sha3()(onSubCanceled(uint256,address))),subId,msg.sender)

IRs:
TMP_252(uint256) = msg.gas - gasReserve
TMP_254(bytes32) = SOLIDITY_CALL sha3()(onSubCanceled(uint256,address))
TMP_255 = CONVERT TMP_254 to bytes4
TMP_256(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_255', 'subId', 'msg.sender']  gas:TMP_252
CONDITION TMP_256"];
9->10[label="True"];
9->10[label="False"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
SubCanceled(subId,msg.sender)

IRs:
Emit SubCanceled(subId,msg.sender)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
noReentrancy(L03)

IRs:
MODIFIER_CALL, Base.noReentrancy(uint256)(L03)"];
14->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-cancelSubscriptionOffer(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
offer = subscriptions[offerId]

IRs:
REF_123(SubscriptionBase.Subscription) -> subscriptions[offerId]
offer(SubscriptionBase.Subscription) := REF_123(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_isOffer(offer))

IRs:
TMP_229(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(offer)
TMP_230(None) = SOLIDITY_CALL assert(bool)(TMP_229)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(offer.transferTo == msg.sender || owner == msg.sender)

IRs:
REF_124(address) -> offer.transferTo
TMP_231(bool) = REF_124 == msg.sender
TMP_232(bool) = owner == msg.sender
TMP_233(bool) = TMP_231 || TMP_232
TMP_234(None) = SOLIDITY_CALL assert(bool)(TMP_233)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
offer.expireOn > now

IRs:
REF_125(uint256) -> offer.expireOn
TMP_235(bool) = REF_125 > now
CONDITION TMP_235"];
4->5[label="True"];
4->8[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
offer.expireOn = now

IRs:
REF_126(uint256) -> offer.expireOn
REF_126(uint256) (->offer) := now(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
OfferCanceled(offerId,msg.sender)

IRs:
Emit OfferCanceled(offerId,msg.sender)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_237(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_237"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
11[label="Node Type: THROW 11
"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
13->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-claimDeposit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
deposit = deposits[_depositId]

IRs:
REF_172(SubscriptionBase.Deposit) -> deposits[_depositId]
deposit(SubscriptionBase.Deposit) := REF_172(SubscriptionBase.Deposit)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(deposit.owner == msg.sender)

IRs:
REF_173(address) -> deposit.owner
TMP_340(bool) = REF_173 == msg.sender
TMP_341(None) = SOLIDITY_CALL require(bool)(TMP_340)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(deposit.lockTime == 0 || deposit.createdOn + deposit.lockTime < now)

IRs:
REF_174(uint256) -> deposit.lockTime
TMP_342(bool) = REF_174 == 0
REF_175(uint256) -> deposit.createdOn
REF_176(uint256) -> deposit.lockTime
TMP_343(uint256) = REF_175 + REF_176
TMP_344(bool) = TMP_343 < now
TMP_345(bool) = TMP_342 || TMP_344
TMP_346(None) = SOLIDITY_CALL assert(bool)(TMP_345)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
value = deposits[_depositId].value

IRs:
REF_177(SubscriptionBase.Deposit) -> deposits[_depositId]
REF_178(uint256) -> REF_177.value
value(uint256) := REF_178(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
delete deposits[_depositId]

IRs:
REF_179(SubscriptionBase.Deposit) -> deposits[_depositId]
deposits = delete REF_179 "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
san._mintFromDeposit(msg.sender,value)

IRs:
HIGH_LEVEL_CALL, dest:san(ERC20ModuleSupport), function:_mintFromDeposit, arguments:['msg.sender', 'value']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
DepositReturned(_depositId,msg.sender)

IRs:
Emit DepositReturned(_depositId,msg.sender)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
8->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-claimSubscriptionDeposit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_161(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_161(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_subscriptionState(sub) == SubState.EXPIRED)

IRs:
TMP_322(SubscriptionBase.SubState) = INTERNAL_CALL, SubscriptionModuleImpl._subscriptionState(SubscriptionBase.Subscription)(sub)
REF_162(SubscriptionBase.SubState) -> SubState.EXPIRED
TMP_323(bool) = TMP_322 == REF_162
TMP_324(None) = SOLIDITY_CALL assert(bool)(TMP_323)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(sub.transferFrom == msg.sender)

IRs:
REF_163(address) -> sub.transferFrom
TMP_325(bool) = REF_163 == msg.sender
TMP_326(None) = SOLIDITY_CALL assert(bool)(TMP_325)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(sub.depositAmount > 0)

IRs:
REF_164(uint256) -> sub.depositAmount
TMP_327(bool) = REF_164 > 0
TMP_328(None) = SOLIDITY_CALL assert(bool)(TMP_327)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_returnSubscriptionDesposit(subId,sub)

IRs:
INTERNAL_CALL, SubscriptionModuleImpl._returnSubscriptionDesposit(uint256,SubscriptionBase.Subscription)(subId,sub)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
6->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-createDeposit(uint256,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_333(bool) = _value > 0
TMP_334(None) = SOLIDITY_CALL require(bool)(TMP_333)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(san._burnForDeposit(msg.sender,_value))

IRs:
TMP_335(bool) = HIGH_LEVEL_CALL, dest:san(ERC20ModuleSupport), function:_burnForDeposit, arguments:['msg.sender', '_value']  
TMP_336(None) = SOLIDITY_CALL assert(bool)(TMP_335)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
deposits[++ depositCounter] = Deposit(msg.sender,_value,now,_lockTime,_descriptor)

IRs:
depositCounter(uint256) = depositCounter + 1
REF_171(SubscriptionBase.Deposit) -> deposits[depositCounter]
TMP_337(SubscriptionBase.Deposit) = new Deposit(msg.sender,_value,now,_lockTime,_descriptor)
REF_171(SubscriptionBase.Deposit) (->deposits) := TMP_337(SubscriptionBase.Deposit)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
NewDeposit(depositCounter,_value,_lockTime,msg.sender)

IRs:
Emit NewDeposit(depositCounter,_value,_lockTime,msg.sender)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
depositCounter

IRs:
RETURN depositCounter"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
depositId

IRs:
RETURN depositId"];
}
// Function: 38531.sol-SubscriptionModuleImpl-createSubscription(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->20;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(_startOn < _expireOn)

IRs:
TMP_203(bool) = _startOn < _expireOn
TMP_204(None) = SOLIDITY_CALL assert(bool)(TMP_203)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
offer = subscriptions[_offerId]

IRs:
REF_101(SubscriptionBase.Subscription) -> subscriptions[_offerId]
offer(SubscriptionBase.Subscription) := REF_101(SubscriptionBase.Subscription)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(_isOffer(offer))

IRs:
TMP_205(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(offer)
TMP_206(None) = SOLIDITY_CALL assert(bool)(TMP_205)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(offer.startOn == 0 || offer.startOn <= now)

IRs:
REF_102(uint256) -> offer.startOn
TMP_207(bool) = REF_102 == 0
REF_103(uint256) -> offer.startOn
TMP_208(bool) = REF_103 <= now
TMP_209(bool) = TMP_207 || TMP_208
TMP_210(None) = SOLIDITY_CALL assert(bool)(TMP_209)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(offer.expireOn == 0 || offer.expireOn >= now)

IRs:
REF_104(uint256) -> offer.expireOn
TMP_211(bool) = REF_104 == 0
REF_105(uint256) -> offer.expireOn
TMP_212(bool) = REF_105 >= now
TMP_213(bool) = TMP_211 || TMP_212
TMP_214(None) = SOLIDITY_CALL assert(bool)(TMP_213)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
assert(bool)(offer.onHoldSince == 0)

IRs:
REF_106(uint256) -> offer.onHoldSince
TMP_215(bool) = REF_106 == 0
TMP_216(None) = SOLIDITY_CALL assert(bool)(TMP_215)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(offer.execCounter > 0)

IRs:
REF_107(uint256) -> offer.execCounter
TMP_217(bool) = REF_107 > 0
TMP_218(None) = SOLIDITY_CALL assert(bool)(TMP_217)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
-- offer.execCounter

IRs:
REF_108(uint256) -> offer.execCounter
REF_108(-> offer) = REF_108 - 1"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
newSubId = ++ subscriptionCounter

IRs:
subscriptionCounter(uint256) = subscriptionCounter + 1
newSubId(uint256) := subscriptionCounter(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
newSub = subscriptions[newSubId] = offer

IRs:
REF_109(SubscriptionBase.Subscription) -> subscriptions[newSubId]
REF_109(SubscriptionBase.Subscription) (->subscriptions) := offer(SubscriptionBase.Subscription)
newSub(SubscriptionBase.Subscription) := REF_109(SubscriptionBase.Subscription)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
newSub.transferFrom = msg.sender

IRs:
REF_110(address) -> newSub.transferFrom
REF_110(address) (->newSub) := msg.sender(address)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
newSub.execCounter = 0

IRs:
REF_111(uint256) -> newSub.execCounter
REF_111(uint256) (->newSub) := 0(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
newSub.paidUntil = newSub.startOn = max(_startOn,now)

IRs:
REF_112(uint256) -> newSub.paidUntil
REF_113(uint256) -> newSub.startOn
TMP_219(uint256) = INTERNAL_CALL, Base.max(uint256,uint256)(_startOn,now)
REF_113(uint256) (->newSub) := TMP_219(uint256)
REF_112(uint256) (->newSub) := REF_113(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
newSub.expireOn = _expireOn

IRs:
REF_114(uint256) -> newSub.expireOn
REF_114(uint256) (->newSub) := _expireOn(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
newSub.depositAmount = _applyXchangeRate(newSub.depositAmount,newSub)

IRs:
REF_115(uint256) -> newSub.depositAmount
REF_116(uint256) -> newSub.depositAmount
TMP_220(uint256) = INTERNAL_CALL, SubscriptionModuleImpl._applyXchangeRate(uint256,SubscriptionBase.Subscription)(REF_116,newSub)
REF_115(uint256) (->newSub) := TMP_220(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
assert(bool)(san._burnForDeposit(msg.sender,newSub.depositAmount))

IRs:
REF_118(uint256) -> newSub.depositAmount
TMP_221(bool) = HIGH_LEVEL_CALL, dest:san(ERC20ModuleSupport), function:_burnForDeposit, arguments:['msg.sender', 'REF_118']  
TMP_222(None) = SOLIDITY_CALL assert(bool)(TMP_221)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
assert(bool)(ServiceProvider(newSub.transferTo).onSubNew(newSubId,_offerId))

IRs:
REF_119(address) -> newSub.transferTo
TMP_223 = CONVERT REF_119 to ServiceProvider
TMP_224(bool) = HIGH_LEVEL_CALL, dest:TMP_223(ServiceProvider), function:onSubNew, arguments:['newSubId', '_offerId']  
TMP_225(None) = SOLIDITY_CALL assert(bool)(TMP_224)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
NewSubscription(newSub.transferFrom,newSub.transferTo,_offerId,newSubId)

IRs:
REF_121(address) -> newSub.transferFrom
REF_122(address) -> newSub.transferTo
Emit NewSubscription(REF_121,REF_122,_offerId,newSubId)"];
18->19;
19[label="Node Type: RETURN 19

EXPRESSION:
newSubId

IRs:
RETURN newSubId"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
noReentrancy(L02)

IRs:
MODIFIER_CALL, Base.noReentrancy(uint256)(L02)"];
21->1;
22[label="Node Type: RETURN 22

EXPRESSION:
newSubId

IRs:
RETURN newSubId"];
}
// Function: 38531.sol-SubscriptionModuleImpl-createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(_startOn < _expireOn)

IRs:
TMP_184(bool) = _startOn < _expireOn
TMP_185(None) = SOLIDITY_CALL assert(bool)(TMP_184)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_chargePeriod <= 2207520000)

IRs:
TMP_186(bool) = _chargePeriod <= 2207520000
TMP_187(None) = SOLIDITY_CALL assert(bool)(TMP_186)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->12;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
assert(bool)(_xrate_n > 0 && _xrate_d > 0)

IRs:
TMP_188(bool) = _xrate_n > 0
TMP_189(bool) = _xrate_d > 0
TMP_190(bool) = TMP_188 && TMP_189
TMP_191(None) = SOLIDITY_CALL assert(bool)(TMP_190)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
subscriptions[++ subscriptionCounter] = Subscription(0,msg.sender,_pricePerHour,_xrateProviderId,_xrate_n,_xrate_d,0,_chargePeriod,_depositAmount,_startOn,_expireOn,_offerLimit,_descriptor,0)

IRs:
subscriptionCounter(uint256) = subscriptionCounter + 1
REF_95(SubscriptionBase.Subscription) -> subscriptions[subscriptionCounter]
TMP_192(SubscriptionBase.Subscription) = new Subscription(0,msg.sender,_pricePerHour,_xrateProviderId,_xrate_n,_xrate_d,0,_chargePeriod,_depositAmount,_startOn,_expireOn,_offerLimit,_descriptor,0)
REF_95(SubscriptionBase.Subscription) (->subscriptions) := TMP_192(SubscriptionBase.Subscription)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
subscriptionCounter

IRs:
RETURN subscriptionCounter"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
noReentrancy(L01)

IRs:
MODIFIER_CALL, Base.noReentrancy(uint256)(L01)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyRegisteredProvider()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.onlyRegisteredProvider()()"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
11->1;
12[label="Node Type: IF 12

EXPRESSION:
_xrateProviderId == 0

IRs:
TMP_196(bool) = _xrateProviderId == 0
CONDITION TMP_196"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
(_xrate_n,_xrate_d) = (1,1)

IRs:
_xrate_n(uint32) := 1(uint256)
_xrate_d(uint32) := 1(uint256)"];
13->15;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
(_xrate_n,_xrate_d) = XRateProvider(xrateProviders[_xrateProviderId]).getRate()

IRs:
REF_96(XRateProvider) -> xrateProviders[_xrateProviderId]
TMP_197 = CONVERT REF_96 to XRateProvider
TUPLE_0(uint32,uint32) = HIGH_LEVEL_CALL, dest:TMP_197(XRateProvider), function:getRate, arguments:[]  
_xrate_n(uint32)= UNPACK TUPLE_0 index: 0 
_xrate_d(uint32)= UNPACK TUPLE_0 index: 1 "];
14->15;
15[label="Node Type: END_IF 15
"];
15->6;
16[label="Node Type: RETURN 16

EXPRESSION:
subId

IRs:
RETURN subId"];
}
// Function: 38531.sol-SubscriptionModuleImpl-disableServiceProvider(ServiceProvider,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
delete providerRegistry[addr]

IRs:
REF_23(bool) -> providerRegistry[addr]
providerRegistry = delete REF_23 "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ServiceProviderDisabled(addr,moreInfo)

IRs:
Emit ServiceProviderDisabled(addr,moreInfo)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
only(owner)

IRs:
MODIFIER_CALL, Base.only(address)(owner)"];
4->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-enableServiceProvider(ServiceProvider,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
providerRegistry[addr] = true

IRs:
REF_22(bool) -> providerRegistry[addr]
REF_22(bool) (->providerRegistry) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ServiceProviderEnabled(addr,moreInfo)

IRs:
Emit ServiceProviderEnabled(addr,moreInfo)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
only(owner)

IRs:
MODIFIER_CALL, Base.only(address)(owner)"];
4->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-executeSubscription(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->18;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_49(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_49(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(msg.sender == sub.transferFrom || msg.sender == sub.transferTo || msg.sender == owner)

IRs:
REF_50(address) -> sub.transferFrom
TMP_135(bool) = msg.sender == REF_50
REF_51(address) -> sub.transferTo
TMP_136(bool) = msg.sender == REF_51
TMP_137(bool) = TMP_135 || TMP_136
TMP_138(bool) = msg.sender == owner
TMP_139(bool) = TMP_137 || TMP_138
TMP_140(None) = SOLIDITY_CALL assert(bool)(TMP_139)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_subscriptionState(sub) == SubState.CHARGEABLE

IRs:
TMP_141(SubscriptionBase.SubState) = INTERNAL_CALL, SubscriptionModuleImpl._subscriptionState(SubscriptionBase.Subscription)(sub)
REF_52(SubscriptionBase.SubState) -> SubState.CHARGEABLE
TMP_142(bool) = TMP_141 == REF_52
CONDITION TMP_142"];
3->4[label="True"];
3->13[label="False"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_from = sub.transferFrom

IRs:
REF_53(address) -> sub.transferFrom
_from(address) := REF_53(address)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_to = sub.transferTo

IRs:
REF_54(address) -> sub.transferTo
_to(address) := REF_54(address)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_value = _amountToCharge(sub)

IRs:
TMP_143(uint256) = INTERNAL_CALL, SubscriptionModuleImpl._amountToCharge(SubscriptionBase.Subscription)(sub)
_value(uint256) := TMP_143(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
san._fulfillPayment(_from,_to,_value,subId,msg.sender)

IRs:
TMP_144(bool) = HIGH_LEVEL_CALL, dest:san(ERC20ModuleSupport), function:_fulfillPayment, arguments:['_from', '_to', '_value', 'subId', 'msg.sender']  
CONDITION TMP_144"];
7->8[label="True"];
7->12[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
sub.paidUntil = max(sub.paidUntil,sub.startOn) + sub.chargePeriod

IRs:
REF_56(uint256) -> sub.paidUntil
REF_57(uint256) -> sub.paidUntil
REF_58(uint256) -> sub.startOn
TMP_145(uint256) = INTERNAL_CALL, Base.max(uint256,uint256)(REF_57,REF_58)
REF_59(uint256) -> sub.chargePeriod
TMP_146(uint256) = TMP_145 + REF_59
REF_56(uint256) (->sub) := TMP_146(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
++ sub.execCounter

IRs:
REF_60(uint256) -> sub.execCounter
REF_60(-> sub) = REF_60 + 1"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
assert(bool)(ServiceProvider(_to).onSubExecuted(subId))

IRs:
TMP_147 = CONVERT _to to ServiceProvider
TMP_148(bool) = HIGH_LEVEL_CALL, dest:TMP_147(ServiceProvider), function:onSubExecuted, arguments:['subId']  
TMP_149(None) = SOLIDITY_CALL assert(bool)(TMP_148)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_150(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_150"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: RETURN 15

EXPRESSION:
false

IRs:
RETURN False"];
16[label="Node Type: THROW 16
"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
noReentrancy(L00)

IRs:
MODIFIER_CALL, Base.noReentrancy(uint256)(L00)"];
19->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: THROW 1
"];
}
// Function: 38531.sol-SubscriptionModuleImpl-getXRateProviderLength()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
xrateProviders.length

IRs:
REF_28 -> LENGTH xrateProviders
RETURN REF_28"];
}
// Function: 38531.sol-SubscriptionModuleImpl-holdSubscription(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_142(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_142(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_isSubscription(sub))

IRs:
TMP_280(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isSubscription(SubscriptionBase.Subscription)(sub)
TMP_281(None) = SOLIDITY_CALL assert(bool)(TMP_280)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_to = sub.transferTo

IRs:
REF_143(address) -> sub.transferTo
_to(address) := REF_143(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender == _to || msg.sender == sub.transferFrom)

IRs:
TMP_282(bool) = msg.sender == _to
REF_144(address) -> sub.transferFrom
TMP_283(bool) = msg.sender == REF_144
TMP_284(bool) = TMP_282 || TMP_283
TMP_285(None) = SOLIDITY_CALL require(bool)(TMP_284)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
sub.onHoldSince == 0

IRs:
REF_145(uint256) -> sub.onHoldSince
TMP_286(bool) = REF_145 == 0
CONDITION TMP_286"];
5->6[label="True"];
5->11[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId,msg.sender,true)

IRs:
TMP_287(bool) = msg.sender == _to
TMP_288 = CONVERT _to to ServiceProvider
TMP_289(bool) = HIGH_LEVEL_CALL, dest:TMP_288(ServiceProvider), function:onSubUnHold, arguments:['subId', 'msg.sender', 'True']  
TMP_290(bool) = TMP_287 || TMP_289
CONDITION TMP_290"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
sub.onHoldSince = now

IRs:
REF_147(uint256) -> sub.onHoldSince
REF_147(uint256) (->sub) := now(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
SubOnHold(subId,true,msg.sender)

IRs:
Emit SubOnHold(subId,True,msg.sender)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_292(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_292"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: RETURN 13

EXPRESSION:
false

IRs:
RETURN False"];
14[label="Node Type: THROW 14
"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
noReentrancy(L04)

IRs:
MODIFIER_CALL, Base.noReentrancy(uint256)(L04)"];
17->1;
18[label="Node Type: RETURN 18

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-SubscriptionModuleImpl-holdSubscriptionOffer(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
offer = subscriptions[offerId]

IRs:
REF_134(SubscriptionBase.Subscription) -> subscriptions[offerId]
offer(SubscriptionBase.Subscription) := REF_134(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_isOffer(offer))

IRs:
TMP_260(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(offer)
TMP_261(None) = SOLIDITY_CALL assert(bool)(TMP_260)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.sender == offer.transferTo || msg.sender == owner)

IRs:
REF_135(address) -> offer.transferTo
TMP_262(bool) = msg.sender == REF_135
TMP_263(bool) = msg.sender == owner
TMP_264(bool) = TMP_262 || TMP_263
TMP_265(None) = SOLIDITY_CALL require(bool)(TMP_264)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
offer.onHoldSince == 0

IRs:
REF_136(uint256) -> offer.onHoldSince
TMP_266(bool) = REF_136 == 0
CONDITION TMP_266"];
4->5[label="True"];
4->8[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
offer.onHoldSince = now

IRs:
REF_137(uint256) -> offer.onHoldSince
REF_137(uint256) (->offer) := now(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
OfferOnHold(offerId,true,msg.sender)

IRs:
Emit OfferOnHold(offerId,True,msg.sender)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_268(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_268"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
11[label="Node Type: THROW 11
"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
13->1;
14[label="Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-SubscriptionModuleImpl-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_addr == 0

IRs:
TMP_94(bool) = _addr == 0
CONDITION TMP_94"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: INLINE ASM 5
"];
5->6;
6[label="Node Type: END INLINE ASM 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(size > 0)

IRs:
TMP_95(bool) = size > 0
RETURN TMP_95"];
}
// Function: 38531.sol-SubscriptionModuleImpl-isSuspended()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
suspendedUntil > now

IRs:
TMP_96(bool) = suspendedUntil > now
RETURN TMP_96"];
}
// Function: 38531.sol-SubscriptionModuleImpl-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_92(bool) = a >= b
CONDITION TMP_92"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-SubscriptionModuleImpl-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a <= b

IRs:
TMP_93(bool) = a <= b
CONDITION TMP_93"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 38531.sol-SubscriptionModuleImpl-noAnyReentrancy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks > 0

IRs:
TMP_377(bool) = _locks > 0
CONDITION TMP_377"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks = uint256(- 1)

IRs:
TMP_378(uint256) = 0 - 1
TMP_379 = CONVERT TMP_378 to uint256
bitlocks(uint256) := TMP_379(uint256)"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-noReentrancy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_locks = bitlocks

IRs:
_locks(uint256) := bitlocks(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_locks & m > 0

IRs:
TMP_375(uint256) = _locks & m
TMP_376(bool) = TMP_375 > 0
CONDITION TMP_376"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bitlocks |= m

IRs:
bitlocks(uint256) = bitlocks | m"];
5->6;
6[label="Node Type: _ 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
bitlocks = _locks

IRs:
bitlocks(uint256) := _locks(uint256)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-notSuspended()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
suspendedUntil > now

IRs:
TMP_381(bool) = suspendedUntil > now
CONDITION TMP_381"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-SubscriptionModuleImpl-only(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != allowed

IRs:
TMP_374(bool) = msg.sender != allowed
CONDITION TMP_374"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-SubscriptionModuleImpl-onlyRegisteredProvider()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! providerRegistry[msg.sender]

IRs:
REF_194(bool) -> providerRegistry[msg.sender]
TMP_380 = UnaryType.BANG REF_194 
CONDITION TMP_380"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38531.sol-SubscriptionModuleImpl-paymentFrom(uint256,bytes,address,ServiceProvider)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
san._fulfillPreapprovedPayment(_from,_to,_value,msg.sender)

IRs:
TMP_128(bool) = HIGH_LEVEL_CALL, dest:san(ERC20ModuleSupport), function:_fulfillPreapprovedPayment, arguments:['_from', '_to', '_value', 'msg.sender']  
CONDITION TMP_128"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(ServiceProvider(_to).onPayment(_from,_value,_paymentData))

IRs:
TMP_129 = CONVERT _to to ServiceProvider
TMP_130(bool) = HIGH_LEVEL_CALL, dest:TMP_129(ServiceProvider), function:onPayment, arguments:['_from', '_value', '_paymentData']  
TMP_131(None) = SOLIDITY_CALL assert(bool)(TMP_130)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_132(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_132"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: THROW 7
"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
reentrant()

IRs:
MODIFIER_CALL, Base.reentrant()()"];
10->1;
11[label="Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-SubscriptionModuleImpl-paymentTo(uint256,bytes,ServiceProvider)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: IF 1

EXPRESSION:
san._fulfillPayment(msg.sender,_to,_value,0,msg.sender)

IRs:
TMP_121(bool) = HIGH_LEVEL_CALL, dest:san(ERC20ModuleSupport), function:_fulfillPayment, arguments:['msg.sender', '_to', '_value', '0', 'msg.sender']  
CONDITION TMP_121"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(ServiceProvider(_to).onPayment(msg.sender,_value,_paymentData))

IRs:
TMP_122 = CONVERT _to to ServiceProvider
TMP_123(bool) = HIGH_LEVEL_CALL, dest:TMP_122(ServiceProvider), function:onPayment, arguments:['msg.sender', '_value', '_paymentData']  
TMP_124(None) = SOLIDITY_CALL assert(bool)(TMP_123)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_125(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_125"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: THROW 7
"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
reentrant()

IRs:
MODIFIER_CALL, Base.reentrant()()"];
10->1;
11[label="Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-SubscriptionModuleImpl-postponeDueDate(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_62(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_62(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_isSubscription(sub))

IRs:
TMP_153(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isSubscription(SubscriptionBase.Subscription)(sub)
TMP_154(None) = SOLIDITY_CALL assert(bool)(TMP_153)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(sub.transferTo == msg.sender)

IRs:
REF_63(address) -> sub.transferTo
TMP_155(bool) = REF_63 == msg.sender
TMP_156(None) = SOLIDITY_CALL assert(bool)(TMP_155)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
sub.paidUntil < newDueDate

IRs:
REF_64(uint256) -> sub.paidUntil
TMP_157(bool) = REF_64 < newDueDate
CONDITION TMP_157"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
sub.paidUntil = newDueDate

IRs:
REF_65(uint256) -> sub.paidUntil
REF_65(uint256) (->sub) := newDueDate(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: IF 7

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_158(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_158"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: THROW 9
"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
12->1;
13[label="Node Type: RETURN 13

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-SubscriptionModuleImpl-reentrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: _ 1
"];
}
// Function: 38531.sol-SubscriptionModuleImpl-registerXRateProvider(XRateProvider)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
xrateProviderId = uint16(xrateProviders.length)

IRs:
REF_24 -> LENGTH xrateProviders
TMP_114 = CONVERT REF_24 to uint16
xrateProviderId(uint16) := TMP_114(uint16)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
xrateProviders.push(addr)

IRs:
REF_26 -> LENGTH xrateProviders
TMP_116(uint256) := REF_26(uint256)
TMP_117(uint256) = TMP_116 + 1
REF_26(uint256) (->xrateProviders) := TMP_117(uint256)
REF_27(XRateProvider) -> xrateProviders[TMP_116]
REF_27(XRateProvider) (->xrateProviders) := addr(XRateProvider)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
NewXRateProvider(addr,xrateProviderId,msg.sender)

IRs:
Emit NewXRateProvider(addr,xrateProviderId,msg.sender)"];
3->6;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
only(owner)

IRs:
MODIFIER_CALL, Base.only(address)(owner)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
xrateProviderId

IRs:
RETURN xrateProviderId"];
}
// Function: 38531.sol-SubscriptionModuleImpl-returnSubscriptionDesposit(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_156(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_156(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_subscriptionState(sub) == SubState.CANCELED)

IRs:
TMP_311(SubscriptionBase.SubState) = INTERNAL_CALL, SubscriptionModuleImpl._subscriptionState(SubscriptionBase.Subscription)(sub)
REF_157(SubscriptionBase.SubState) -> SubState.CANCELED
TMP_312(bool) = TMP_311 == REF_157
TMP_313(None) = SOLIDITY_CALL assert(bool)(TMP_312)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(sub.depositAmount > 0)

IRs:
REF_158(uint256) -> sub.depositAmount
TMP_314(bool) = REF_158 > 0
TMP_315(None) = SOLIDITY_CALL assert(bool)(TMP_314)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(sub.transferTo == msg.sender || owner == msg.sender)

IRs:
REF_159(address) -> sub.transferTo
TMP_316(bool) = REF_159 == msg.sender
TMP_317(bool) = owner == msg.sender
TMP_318(bool) = TMP_316 || TMP_317
TMP_319(None) = SOLIDITY_CALL assert(bool)(TMP_318)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
sub.expireOn = now

IRs:
REF_160(uint256) -> sub.expireOn
REF_160(uint256) (->sub) := now(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_returnSubscriptionDesposit(subId,sub)

IRs:
INTERNAL_CALL, SubscriptionModuleImpl._returnSubscriptionDesposit(uint256,SubscriptionBase.Subscription)(subId,sub)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
7->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
L00 = 2 ** 0

IRs:
TMP_368(uint256) = 2 ** 0
L00(uint256) := TMP_368(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
L01 = 2 ** 1

IRs:
TMP_369(uint256) = 2 ** 1
L01(uint256) := TMP_369(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
L02 = 2 ** 2

IRs:
TMP_370(uint256) = 2 ** 2
L02(uint256) := TMP_370(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
L03 = 2 ** 3

IRs:
TMP_371(uint256) = 2 ** 3
L03(uint256) := TMP_371(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
L04 = 2 ** 4

IRs:
TMP_372(uint256) = 2 ** 4
L04(uint256) := TMP_372(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
L05 = 2 ** 5

IRs:
TMP_373(uint256) = 2 ** 5
L05(uint256) := TMP_373(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
VERSION = 0.2.0

IRs:
VERSION(string) := 0.2.0(string)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
SUB_STATES = (NOT_EXIST,BEFORE_START,PAID,CHARGEABLE,ON_HOLD,CANCELED,EXPIRED,FINALIZED)

IRs:
SUB_STATES(string[]) = ['NOT_EXIST(string)', 'BEFORE_START(string)', 'PAID(string)', 'CHARGEABLE(string)', 'ON_HOLD(string)', 'CANCELED(string)', 'EXPIRED(string)', 'FINALIZED(string)']"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
OFFER_STATES = (NOT_EXIST,BEFORE_START,ACTIVE,SOLD_OUT,ON_HOLD,EXPIRED)

IRs:
OFFER_STATES(string[]) = ['NOT_EXIST(string)', 'BEFORE_START(string)', 'ACTIVE(string)', 'SOLD_OUT(string)', 'ON_HOLD(string)', 'EXPIRED(string)']"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
suspendedUntil = 0

IRs:
suspendedUntil(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
subscriptionCounter = 0

IRs:
subscriptionCounter(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
depositCounter = 0

IRs:
depositCounter(uint256) := 0(uint256)"];
}
// Function: 38531.sol-SubscriptionModuleImpl-state(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
subOrOffer = subscriptions[subOrOfferId]

IRs:
REF_66(SubscriptionBase.Subscription) -> subscriptions[subOrOfferId]
subOrOffer(SubscriptionBase.Subscription) := REF_66(SubscriptionBase.Subscription)"];
1->3;
3[label="Node Type: IF 3

EXPRESSION:
_isOffer(subOrOffer)

IRs:
TMP_160(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(subOrOffer)
CONDITION TMP_160"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
OFFER_STATES[uint256(_offerState(subOrOffer))]

IRs:
TMP_161(SubscriptionBase.OfferState) = INTERNAL_CALL, SubscriptionModuleImpl._offerState(SubscriptionBase.Subscription)(subOrOffer)
TMP_162 = CONVERT TMP_161 to uint256
REF_67(string) -> OFFER_STATES[TMP_162]
RETURN REF_67"];
5[label="Node Type: RETURN 5

EXPRESSION:
SUB_STATES[uint256(_subscriptionState(subOrOffer))]

IRs:
TMP_163(SubscriptionBase.SubState) = INTERNAL_CALL, SubscriptionModuleImpl._subscriptionState(SubscriptionBase.Subscription)(subOrOffer)
TMP_164 = CONVERT TMP_163 to uint256
REF_68(string) -> SUB_STATES[TMP_164]
RETURN REF_68"];
7[label="Node Type: RETURN 7

EXPRESSION:
state

IRs:
RETURN state"];
}
// Function: 38531.sol-SubscriptionModuleImpl-stateCode(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
subOrOffer = subscriptions[subOrOfferId]

IRs:
REF_69(SubscriptionBase.Subscription) -> subscriptions[subOrOfferId]
subOrOffer(SubscriptionBase.Subscription) := REF_69(SubscriptionBase.Subscription)"];
1->3;
3[label="Node Type: IF 3

EXPRESSION:
_isOffer(subOrOffer)

IRs:
TMP_165(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(subOrOffer)
CONDITION TMP_165"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
uint256(_offerState(subOrOffer))

IRs:
TMP_166(SubscriptionBase.OfferState) = INTERNAL_CALL, SubscriptionModuleImpl._offerState(SubscriptionBase.Subscription)(subOrOffer)
TMP_167 = CONVERT TMP_166 to uint256
RETURN TMP_167"];
5[label="Node Type: RETURN 5

EXPRESSION:
uint256(_subscriptionState(subOrOffer))

IRs:
TMP_168(SubscriptionBase.SubState) = INTERNAL_CALL, SubscriptionModuleImpl._subscriptionState(SubscriptionBase.Subscription)(subOrOffer)
TMP_169 = CONVERT TMP_168 to uint256
RETURN TMP_169"];
7[label="Node Type: RETURN 7

EXPRESSION:
stateCode

IRs:
RETURN stateCode"];
}
// Function: 38531.sol-SubscriptionModuleImpl-subscriptionDetails(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_33(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_33(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
(sub.transferFrom,sub.transferTo,sub.pricePerHour,sub.initialXrate_n,sub.initialXrate_d,sub.xrateProviderId,sub.chargePeriod,sub.startOn,sub.descriptor)

IRs:
REF_34(address) -> sub.transferFrom
REF_35(address) -> sub.transferTo
REF_36(uint256) -> sub.pricePerHour
REF_37(uint32) -> sub.initialXrate_n
REF_38(uint32) -> sub.initialXrate_d
REF_39(uint16) -> sub.xrateProviderId
REF_40(uint256) -> sub.chargePeriod
REF_41(uint256) -> sub.startOn
REF_42(bytes) -> sub.descriptor
RETURN REF_34,REF_35,REF_36,REF_37,REF_38,REF_39,REF_40,REF_41,REF_42"];
3[label="Node Type: RETURN 3

EXPRESSION:
(transferFrom,transferTo,pricePerHour,initialXrate_n,initialXrate_d,xrateProviderId,chargePeriod,startOn,descriptor)

IRs:
RETURN transferFrom,transferTo,pricePerHour,initialXrate_n,initialXrate_d,xrateProviderId,chargePeriod,startOn,descriptor"];
}
// Function: 38531.sol-SubscriptionModuleImpl-subscriptionStatus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_43(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_43(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
(sub.depositAmount,sub.expireOn,sub.execCounter,sub.paidUntil,sub.onHoldSince)

IRs:
REF_44(uint256) -> sub.depositAmount
REF_45(uint256) -> sub.expireOn
REF_46(uint256) -> sub.execCounter
REF_47(uint256) -> sub.paidUntil
REF_48(uint256) -> sub.onHoldSince
RETURN REF_44,REF_45,REF_46,REF_47,REF_48"];
3[label="Node Type: RETURN 3

EXPRESSION:
(depositAmount,expireOn,execCounter,paidUntil,onHoldSince)

IRs:
RETURN depositAmount,expireOn,execCounter,paidUntil,onHoldSince"];
}
// Function: 38531.sol-SubscriptionModuleImpl-suspend(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
suspendedUntil = now + suspendTimeSec

IRs:
TMP_111(uint256) = now + suspendTimeSec
suspendedUntil(uint256) := TMP_111(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SubModuleSuspended(suspendedUntil)

IRs:
Emit SubModuleSuspended(suspendedUntil)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
only(owner)

IRs:
MODIFIER_CALL, Base.only(address)(owner)"];
3->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
only(owner)

IRs:
MODIFIER_CALL, Base.only(address)(owner)"];
2->1;
}
// Function: 38531.sol-SubscriptionModuleImpl-unholdSubscription(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->17;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
sub = subscriptions[subId]

IRs:
REF_148(SubscriptionBase.Subscription) -> subscriptions[subId]
sub(SubscriptionBase.Subscription) := REF_148(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_isSubscription(sub))

IRs:
TMP_295(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isSubscription(SubscriptionBase.Subscription)(sub)
TMP_296(None) = SOLIDITY_CALL assert(bool)(TMP_295)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_to = sub.transferTo

IRs:
REF_149(address) -> sub.transferTo
_to(address) := REF_149(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender == _to || msg.sender == sub.transferFrom)

IRs:
TMP_297(bool) = msg.sender == _to
REF_150(address) -> sub.transferFrom
TMP_298(bool) = msg.sender == REF_150
TMP_299(bool) = TMP_297 || TMP_298
TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
sub.onHoldSince > 0

IRs:
REF_151(uint256) -> sub.onHoldSince
TMP_301(bool) = REF_151 > 0
CONDITION TMP_301"];
5->6[label="True"];
5->12[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId,msg.sender,false)

IRs:
TMP_302(bool) = msg.sender == _to
TMP_303 = CONVERT _to to ServiceProvider
TMP_304(bool) = HIGH_LEVEL_CALL, dest:TMP_303(ServiceProvider), function:onSubUnHold, arguments:['subId', 'msg.sender', 'False']  
TMP_305(bool) = TMP_302 || TMP_304
CONDITION TMP_305"];
6->7[label="True"];
6->11[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
sub.paidUntil += now - sub.onHoldSince

IRs:
REF_153(uint256) -> sub.paidUntil
REF_154(uint256) -> sub.onHoldSince
TMP_306(uint256) = now - REF_154
REF_153(-> sub) = REF_153 + TMP_306"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
sub.onHoldSince = 0

IRs:
REF_155(uint256) -> sub.onHoldSince
REF_155(uint256) (->sub) := 0(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
SubOnHold(subId,false,msg.sender)

IRs:
Emit SubOnHold(subId,False,msg.sender)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_308(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_308"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: RETURN 14

EXPRESSION:
false

IRs:
RETURN False"];
15[label="Node Type: THROW 15
"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
noReentrancy(L05)

IRs:
MODIFIER_CALL, Base.noReentrancy(uint256)(L05)"];
18->1;
19[label="Node Type: RETURN 19

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-SubscriptionModuleImpl-unholdSubscriptionOffer(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
offer = subscriptions[offerId]

IRs:
REF_138(SubscriptionBase.Subscription) -> subscriptions[offerId]
offer(SubscriptionBase.Subscription) := REF_138(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_isOffer(offer))

IRs:
TMP_270(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(offer)
TMP_271(None) = SOLIDITY_CALL assert(bool)(TMP_270)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.sender == offer.transferTo || msg.sender == owner)

IRs:
REF_139(address) -> offer.transferTo
TMP_272(bool) = msg.sender == REF_139
TMP_273(bool) = msg.sender == owner
TMP_274(bool) = TMP_272 || TMP_273
TMP_275(None) = SOLIDITY_CALL require(bool)(TMP_274)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
offer.onHoldSince > 0

IRs:
REF_140(uint256) -> offer.onHoldSince
TMP_276(bool) = REF_140 > 0
CONDITION TMP_276"];
4->5[label="True"];
4->8[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
offer.onHoldSince = 0

IRs:
REF_141(uint256) -> offer.onHoldSince
REF_141(uint256) (->offer) := 0(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
OfferOnHold(offerId,false,msg.sender)

IRs:
Emit OfferOnHold(offerId,False,msg.sender)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
isContract(msg.sender)

IRs:
TMP_278(bool) = INTERNAL_CALL, Base.isContract(address)(msg.sender)
CONDITION TMP_278"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
11[label="Node Type: THROW 11
"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
13->1;
14[label="Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 38531.sol-SubscriptionModuleImpl-updateSubscriptionOffer(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
offer = subscriptions[_offerId]

IRs:
REF_98(SubscriptionBase.Subscription) -> subscriptions[_offerId]
offer(SubscriptionBase.Subscription) := REF_98(SubscriptionBase.Subscription)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_isOffer(offer))

IRs:
TMP_198(bool) = INTERNAL_CALL, SubscriptionModuleImpl._isOffer(SubscriptionBase.Subscription)(offer)
TMP_199(None) = SOLIDITY_CALL assert(bool)(TMP_198)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(offer.transferTo == msg.sender)

IRs:
REF_99(address) -> offer.transferTo
TMP_200(bool) = REF_99 == msg.sender
TMP_201(None) = SOLIDITY_CALL assert(bool)(TMP_200)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
offer.execCounter = _offerLimit

IRs:
REF_100(uint256) -> offer.execCounter
REF_100(uint256) (->offer) := _offerLimit(uint256)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notSuspended()

IRs:
MODIFIER_CALL, SubscriptionModuleImpl.notSuspended()()"];
5->1;
}
// Function: 38531.sol-XRateProvider-getCode()
digraph{
}
// Function: 38531.sol-XRateProvider-getRate()
digraph{
}
}
