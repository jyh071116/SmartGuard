digraph G {
// Function: 39469.sol-E4RowRewards-checkDividends(address)
digraph{
}
// Function: 39469.sol-E4RowRewards-withdrawDividends()
digraph{
}
// Function: 39469.sol-E4Token-E4Token()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developers = msg.sender

IRs:
developers(address) := msg.sender(address)"];
}
// Function: 39469.sol-E4Token-addAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
holderAccounts[_addr].alloced = true

IRs:
REF_13(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_14(bool) -> REF_13.alloced
REF_14(bool) (->holderAccounts) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
holderAccounts[_addr].tokens = (curPayoutId * (2 ** 48))

IRs:
REF_15(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_16(uint256) -> REF_15.tokens
TMP_23(uint256) = 2 ** 48
TMP_24(uint256) = curPayoutId * TMP_23
REF_16(uint256) (->holderAccounts) := TMP_24(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
holderIndexes[numAccounts ++] = _addr

IRs:
TMP_25(uint256) := numAccounts(uint256)
numAccounts(uint256) = numAccounts + 1
REF_17(address) -> holderIndexes[TMP_25]
REF_17(address) (->holderIndexes) := _addr(address)"];
}
// Function: 39469.sol-E4Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_50(mapping(address => uint256)) -> allowed[_owner]
REF_51(uint256) -> REF_50[_spender]
RETURN REF_51"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 39469.sol-E4Token-applySettings(E4Token.SettingStateValue,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_0(bool) = msg.sender != owner
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payoutThreshold = _threshold

IRs:
payoutThreshold(uint256) := _threshold(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
maxPaysPer = _mpp

IRs:
maxPaysPer(uint256) := _mpp(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
minPayInterval = _mpi

IRs:
minPayInterval(uint256) := _mpi(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
settingsState == SettingStateValue.lockedRelease

IRs:
REF_0(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_1(bool) = settingsState == REF_0
CONDITION TMP_1"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8
"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
settingsState = qState

IRs:
settingsState(E4Token.SettingStateValue) := qState(E4Token.SettingStateValue)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
qState == SettingStateValue.lockedRelease

IRs:
REF_1(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_2(bool) = qState == REF_1
CONDITION TMP_2"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
StatEvent(Locking!)

IRs:
Emit StatEvent(Locking!)"];
12->13;
13[label="Node Type: RETURN 13
"];
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
icoStatus = IcoStatusValue.anouncement

IRs:
REF_2(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
icoStatus(E4Token.IcoStatusValue) := REF_2(E4Token.IcoStatusValue)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
rmGas = 100000

IRs:
rmGas(uint256) := 100000(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
rwGas = 10000

IRs:
rwGas(uint256) := 10000(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
rfGas = 10000

IRs:
rfGas(uint256) := 10000(uint256)"];
18->19;
19[label="Node Type: IF 19

EXPRESSION:
totalTokensMinted > 0

IRs:
TMP_4(bool) = totalTokensMinted > 0
CONDITION TMP_4"];
19->22[label="True"];
19->30[label="False"];
20[label="Node Type: BEGIN_LOOP 20
"];
20->23;
21[label="Node Type: END_LOOP 21
"];
21->30;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
22->20;
23[label="Node Type: IF_LOOP 23

EXPRESSION:
i < numAccounts

IRs:
TMP_5(bool) = i < numAccounts
CONDITION TMP_5"];
23->24[label="True"];
23->21[label="False"];
24[label="Node Type: NEW VARIABLE 24

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_3(address) -> holderIndexes[i]
a(address) := REF_3(address)"];
24->25;
25[label="Node Type: IF 25

EXPRESSION:
a != address(0)

IRs:
TMP_6 = CONVERT 0 to address
TMP_7(bool) = a != TMP_6
CONDITION TMP_7"];
25->26[label="True"];
25->28[label="False"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
holderAccounts[a].tokens = 0

IRs:
REF_4(E4Token.tokenAccount) -> holderAccounts[a]
REF_5(uint256) -> REF_4.tokens
REF_5(uint256) (->holderAccounts) := 0(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
holderAccounts[a].balance = 0

IRs:
REF_6(E4Token.tokenAccount) -> holderAccounts[a]
REF_7(uint256) -> REF_6.balance
REF_7(uint256) (->holderAccounts) := 0(uint256)"];
27->28;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
i ++

IRs:
TMP_8(uint256) := i(uint256)
i(uint256) = i + 1"];
29->23;
30[label="Node Type: END_IF 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
totalTokensMinted = 0

IRs:
totalTokensMinted(uint256) := 0(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
totalTokenFundsReceived = 0

IRs:
totalTokenFundsReceived(uint256) := 0(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
e4_partner = address(0)

IRs:
TMP_9 = CONVERT 0 to address
e4_partner(address) := TMP_9(address)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
fundingStart = _saleStart

IRs:
fundingStart(uint256) := _saleStart(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
fundingDeadline = _saleEnd

IRs:
fundingDeadline(uint256) := _saleEnd(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
usageDeadline = _usageEnd

IRs:
usageDeadline(uint256) := _usageEnd(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
minUsageGoal = _minUsage

IRs:
minUsageGoal(uint256) := _minUsage(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
minIcoTokenGoal = _tokGoal

IRs:
minIcoTokenGoal(uint256) := _tokGoal(uint256)"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
maxMintableTokens = _maxMintable

IRs:
maxMintableTokens(uint256) := _maxMintable(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
tokenPrice = _price

IRs:
tokenPrice(uint256) := _price(uint256)"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
vestTime = fundingStart + (31536000)

IRs:
TMP_10(uint256) = fundingStart + 31536000
vestTime(uint256) := TMP_10(uint256)"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
numDevTokens = 0

IRs:
numDevTokens(uint256) := 0(uint256)"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
remunerationStage = 0

IRs:
remunerationStage(uint256) := 0(uint256)"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
developersGranted = false

IRs:
developersGranted(bool) := False(bool)"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
lastPayoutTime = 0

IRs:
lastPayoutTime(uint256) := 0(uint256)"];
51->52;
52[label="Node Type: IF 52

EXPRESSION:
this.balance > 0

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_11(bool) = REF_8 > 0
CONDITION TMP_11"];
52->53[label="True"];
52->56[label="False"];
53[label="Node Type: IF 53

EXPRESSION:
! owner.call.gas(rfGas).value(this.balance)()

IRs:
REF_12(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_14(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:[] value:REF_12 gas:rfGas
TMP_15 = UnaryType.BANG TMP_14 
CONDITION TMP_15"];
53->54[label="True"];
53->55[label="False"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
StatEvent(ERROR!)

IRs:
Emit StatEvent(ERROR!)"];
54->55;
55[label="Node Type: END_IF 55
"];
55->56;
56[label="Node Type: END_IF 56
"];
56->57;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
StatEvent(ok)

IRs:
Emit StatEvent(ok)"];
}
// Function: 39469.sol-E4Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
REF_49(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39469.sol-E4Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_owner].alloced

IRs:
REF_44(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_45(bool) -> REF_44.alloced
CONDITION REF_45"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance = getHeld(holderAccounts[_owner].tokens)

IRs:
REF_46(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_47(uint256) -> REF_46.tokens
TMP_59(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_47)
balance(uint256) := TMP_59(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 39469.sol-E4Token-changeAuxPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_247(bool) = msg.sender != owner
REF_126(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_248(bool) = settingsState == REF_126
TMP_249(bool) = TMP_247 || TMP_248
CONDITION TMP_249"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
auxPartner = _aux

IRs:
auxPartner(address) := _aux(address)"];
}
// Function: 39469.sol-E4Token-changeDevevoperAccont(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_241(bool) = msg.sender != owner
REF_124(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_242(bool) = settingsState == REF_124
TMP_243(bool) = TMP_241 || TMP_242
CONDITION TMP_243"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
developers = _addr

IRs:
developers(address) := _addr(address)"];
}
// Function: 39469.sol-E4Token-changeFounder(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_244(bool) = msg.sender != owner
REF_125(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_245(bool) = settingsState == REF_125
TMP_246(bool) = TMP_244 || TMP_245
CONDITION TMP_246"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
founderOrg = _addr

IRs:
founderOrg(address) := _addr(address)"];
}
// Function: 39469.sol-E4Token-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_238(bool) = msg.sender != owner
REF_123(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_239(bool) = settingsState == REF_123
TMP_240(bool) = TMP_238 || TMP_239
CONDITION TMP_240"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
owner = _addr

IRs:
owner(address) := _addr(address)"];
}
// Function: 39469.sol-E4Token-checkDividends(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_addr].alloced

IRs:
REF_111(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_112(bool) -> REF_111.alloced
CONDITION REF_112"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_amount = holderAccounts[_addr].balance

IRs:
REF_113(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_114(uint256) -> REF_113.balance
_amount(uint256) := REF_114(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39469.sol-E4Token-doDeveloperGrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! developersGranted

IRs:
TMP_264 = UnaryType.BANG developersGranted 
CONDITION TMP_264"];
1->2[label="True"];
1->10[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developersGranted = true

IRs:
developersGranted(bool) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
numDevTokens = totalTokensMinted / 10

IRs:
TMP_265(uint256) = totalTokensMinted / 10
numDevTokens(uint256) := TMP_265(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalTokensMinted += numDevTokens

IRs:
totalTokensMinted(uint256) = totalTokensMinted + numDevTokens"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_128(E4Token.tokenAccount) -> holderAccounts[developers]
REF_129(bool) -> REF_128.alloced
TMP_266 = UnaryType.BANG REF_129 
CONDITION TMP_266"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens

IRs:
REF_130(E4Token.tokenAccount) -> holderAccounts[developers]
REF_131(uint256) -> REF_130.tokens
TMP_268(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_131)
TMP_269(uint256) = TMP_268 + numDevTokens
newHeld(uint256) := TMP_269(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
holderAccounts[developers].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_132(E4Token.tokenAccount) -> holderAccounts[developers]
REF_133(uint256) -> REF_132.tokens
TMP_270(uint256) = 2 ** 48
TMP_271(uint256) = curPayoutId * TMP_270
TMP_272(uint256) = newHeld | TMP_271
REF_133(uint256) (->holderAccounts) := TMP_272(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 39469.sol-E4Token-doPayout(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
totalTokensMinted == 0

IRs:
TMP_154(bool) = totalTokensMinted == 0
CONDITION TMP_154"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
(holdoverBalance > 0) && (payoutBalance == 0) && (now > (lastPayoutTime + minPayInterval))

IRs:
TMP_155(bool) = holdoverBalance > 0
TMP_156(bool) = payoutBalance == 0
TMP_157(bool) = TMP_155 && TMP_156
TMP_158(uint256) = lastPayoutTime + minPayInterval
TMP_159(bool) = now > TMP_158
TMP_160(bool) = TMP_157 && TMP_159
CONDITION TMP_160"];
4->5[label="True"];
4->16[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
curPayoutId ++

IRs:
TMP_161(uint256) := curPayoutId(uint256)
curPayoutId(uint256) = curPayoutId + 1"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
curPayoutId >= 32768

IRs:
TMP_162(bool) = curPayoutId >= 32768
CONDITION TMP_162"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
lastPayoutTime = now

IRs:
lastPayoutTime(uint256) := now(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
payoutBalance = int256(holdoverBalance)

IRs:
TMP_163 = CONVERT holdoverBalance to int256
payoutBalance(int256) := TMP_163(int256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
prOrigPayoutBal = payoutBalance

IRs:
prOrigPayoutBal(int256) := payoutBalance(int256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
prOrigTokensMint = totalTokensMinted

IRs:
prOrigTokensMint(uint256) := totalTokensMinted(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
StatEventI(StartRun,uint256(curPayoutId))

IRs:
TMP_164 = CONVERT curPayoutId to uint256
Emit StatEventI(StartRun,TMP_164)"];
15->53;
16[label="Node Type: IF 16

EXPRESSION:
payoutBalance > 0

IRs:
TMP_166(bool) = payoutBalance > 0
CONDITION TMP_166"];
16->17[label="True"];
16->52[label="False"];
17[label="Node Type: NEW VARIABLE 17
"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
nPerTokDistrib = uint256(prOrigPayoutBal) / prOrigTokensMint

IRs:
TMP_167 = CONVERT prOrigPayoutBal to uint256
TMP_168(uint256) = TMP_167 / prOrigTokensMint
nPerTokDistrib(uint256) := TMP_168(uint256)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
paids = 0

IRs:
paids(uint256) := 0(uint256)"];
19->20;
20[label="Node Type: NEW VARIABLE 20
"];
20->23;
21[label="Node Type: BEGIN_LOOP 21
"];
21->24;
22[label="Node Type: END_LOOP 22
"];
22->42;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
i = lastPayoutIndex

IRs:
i(uint256) := lastPayoutIndex(uint256)"];
23->21;
24[label="Node Type: IF_LOOP 24

EXPRESSION:
(paids < _numPays) && (i < numAccounts) && (payoutBalance > 0)

IRs:
TMP_169(bool) = paids < _numPays
TMP_170(bool) = i < numAccounts
TMP_171(bool) = TMP_169 && TMP_170
TMP_172(bool) = payoutBalance > 0
TMP_173(bool) = TMP_171 && TMP_172
CONDITION TMP_173"];
24->25[label="True"];
24->22[label="False"];
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_95(address) -> holderIndexes[i]
a(address) := REF_95(address)"];
25->26;
26[label="Node Type: IF 26

EXPRESSION:
a == address(0)

IRs:
TMP_174 = CONVERT 0 to address
TMP_175(bool) = a == TMP_174
CONDITION TMP_175"];
26->27[label="True"];
26->28[label="False"];
27[label="Node Type: CONTINUE 27
"];
27->41;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: NEW VARIABLE 29
"];
29->30;
30[label="Node Type: NEW VARIABLE 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
(pid,held) = getPayIdAndHeld(holderAccounts[a].tokens)

IRs:
REF_96(E4Token.tokenAccount) -> holderAccounts[a]
REF_97(uint256) -> REF_96.tokens
TUPLE_2(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_97)
pid(uint256)= UNPACK TUPLE_2 index: 0 
held(uint256)= UNPACK TUPLE_2 index: 1 "];
31->32;
32[label="Node Type: IF 32

EXPRESSION:
(held > 0) && (pid != curPayoutId)

IRs:
TMP_176(bool) = held > 0
TMP_177(bool) = pid != curPayoutId
TMP_178(bool) = TMP_176 && TMP_177
CONDITION TMP_178"];
32->33[label="True"];
32->40[label="False"];
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nAmount = nPerTokDistrib * held

IRs:
TMP_179(uint256) = nPerTokDistrib * held
nAmount(uint256) := TMP_179(uint256)"];
33->34;
34[label="Node Type: IF 34

EXPRESSION:
int256(nAmount) <= payoutBalance

IRs:
TMP_180 = CONVERT nAmount to int256
TMP_181(bool) = TMP_180 <= payoutBalance
CONDITION TMP_181"];
34->35[label="True"];
34->39[label="False"];
35[label="Node Type: EXPRESSION 35

EXPRESSION:
holderAccounts[a].balance += nAmount

IRs:
REF_98(E4Token.tokenAccount) -> holderAccounts[a]
REF_99(uint256) -> REF_98.balance
REF_99(-> holderAccounts) = REF_99 + nAmount"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
holderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held

IRs:
REF_100(E4Token.tokenAccount) -> holderAccounts[a]
REF_101(uint256) -> REF_100.tokens
TMP_182(uint256) = 2 ** 48
TMP_183(uint256) = curPayoutId * TMP_182
TMP_184(uint256) = TMP_183 | held
REF_101(uint256) (->holderAccounts) := TMP_184(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
payoutBalance -= int256(nAmount)

IRs:
TMP_185 = CONVERT nAmount to int256
payoutBalance(int256) = payoutBalance - TMP_185"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
paids ++

IRs:
TMP_186(uint256) := paids(uint256)
paids(uint256) = paids + 1"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: END_IF 40
"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
i ++

IRs:
TMP_187(uint256) := i(uint256)
i(uint256) = i + 1"];
41->24;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
lastPayoutIndex = i

IRs:
lastPayoutIndex(uint256) := i(uint256)"];
42->43;
43[label="Node Type: IF 43

EXPRESSION:
lastPayoutIndex >= numAccounts || payoutBalance <= 0

IRs:
TMP_188(bool) = lastPayoutIndex >= numAccounts
TMP_189(bool) = payoutBalance <= 0
TMP_190(bool) = TMP_188 || TMP_189
CONDITION TMP_190"];
43->44[label="True"];
43->50[label="False"];
44[label="Node Type: EXPRESSION 44

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
44->45;
45[label="Node Type: IF 45

EXPRESSION:
payoutBalance > 0

IRs:
TMP_191(bool) = payoutBalance > 0
CONDITION TMP_191"];
45->46[label="True"];
45->47[label="False"];
46[label="Node Type: EXPRESSION 46

EXPRESSION:
holdoverBalance += uint256(payoutBalance)

IRs:
TMP_192 = CONVERT payoutBalance to uint256
holdoverBalance(uint256) = holdoverBalance + TMP_192"];
46->47;
47[label="Node Type: END_IF 47
"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
StatEventI(RunComplete,uint256(prOrigPayoutBal))

IRs:
TMP_193 = CONVERT prOrigPayoutBal to uint256
Emit StatEventI(RunComplete,TMP_193)"];
49->51;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
StatEventI(PayRun,paids)

IRs:
Emit StatEventI(PayRun,paids)"];
50->51;
51[label="Node Type: END_IF 51
"];
51->52;
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: END_IF 53
"];
}
// Function: 39469.sol-E4Token-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == e4_partner

IRs:
TMP_61(bool) = msg.sender == e4_partner
CONDITION TMP_61"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feePayment()

IRs:
INTERNAL_CALL, E4Token.feePayment()()"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
purchaseToken()

IRs:
INTERNAL_CALL, E4Token.purchaseToken()()"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 39469.sol-E4Token-feePayment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != e4_partner

IRs:
TMP_81(bool) = msg.sender != e4_partner
CONDITION TMP_81"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(forbidden)

IRs:
Emit StatEvent(forbidden)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
nfvalue = msg.value

IRs:
nfvalue(uint256) := msg.value(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
holdoverBalance += nfvalue

IRs:
holdoverBalance(uint256) = holdoverBalance + nfvalue"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
partnerCredits += nfvalue

IRs:
partnerCredits(uint256) = partnerCredits + nfvalue"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
StatEventI(Payment,nfvalue)

IRs:
Emit StatEventI(Payment,nfvalue)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
holdoverBalance > payoutThreshold || payoutBalance > 0

IRs:
TMP_85(bool) = holdoverBalance > payoutThreshold
TMP_86(bool) = payoutBalance > 0
TMP_87(bool) = TMP_85 || TMP_86
CONDITION TMP_87"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
doPayout(maxPaysPer)

IRs:
INTERNAL_CALL, E4Token.doPayout(uint256)(maxPaysPer)"];
11->12;
12[label="Node Type: END_IF 12
"];
}
// Function: 39469.sol-E4Token-flushDividends(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(_numPays == 0) || (_numPays > 1000)

IRs:
TMP_255(bool) = _numPays == 0
TMP_256(bool) = _numPays > 1000
TMP_257(bool) = TMP_255 || TMP_256
CONDITION TMP_257"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(Invalid.)

IRs:
Emit StatEvent(Invalid.)"];
2->7;
3[label="Node Type: IF 3

EXPRESSION:
holdoverBalance > 0 || payoutBalance > 0

IRs:
TMP_259(bool) = holdoverBalance > 0
TMP_260(bool) = payoutBalance > 0
TMP_261(bool) = TMP_259 || TMP_260
CONDITION TMP_261"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
doPayout(_numPays)

IRs:
INTERNAL_CALL, E4Token.doPayout(uint256)(_numPays)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(Nothing to do.)

IRs:
Emit StatEvent(Nothing to do.)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 39469.sol-E4Token-getHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_22(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_22(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_held

IRs:
RETURN _held"];
}
// Function: 39469.sol-E4Token-getIcoInfo()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_status = icoStatus

IRs:
_status(E4Token.IcoStatusValue) := icoStatus(E4Token.IcoStatusValue)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_saleStart = fundingStart

IRs:
_saleStart(uint256) := fundingStart(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_saleEnd = fundingDeadline

IRs:
_saleEnd(uint256) := fundingDeadline(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_usageEnd = usageDeadline

IRs:
_usageEnd(uint256) := usageDeadline(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_vest = vestTime

IRs:
_vest(uint256) := vestTime(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_saleGoal = minIcoTokenGoal

IRs:
_saleGoal(uint256) := minIcoTokenGoal(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_usageGoal = minUsageGoal

IRs:
_usageGoal(uint256) := minUsageGoal(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_sold = getNumTokensPurchased()

IRs:
TMP_253(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
_sold(uint256) := TMP_253(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_used = getNumGames()

IRs:
TMP_254(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
_used(uint256) := TMP_254(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_funds = totalTokenFundsReceived

IRs:
_funds(uint256) := totalTokenFundsReceived(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_credits = partnerCredits

IRs:
_credits(uint256) := partnerCredits(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_remuStage = remunerationStage

IRs:
_remuStage(uint256) := remunerationStage(uint256)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
(_status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest)

IRs:
RETURN _status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest"];
}
// Function: 39469.sol-E4Token-getNumGames()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
e4_partner != address(0)

IRs:
TMP_96 = CONVERT 0 to address
TMP_97(bool) = e4_partner != TMP_96
CONDITION TMP_97"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
pe4 = iE4RowEscrow(e4_partner)

IRs:
TMP_98 = CONVERT e4_partner to iE4RowEscrow
pe4(iE4RowEscrow) := TMP_98(iE4RowEscrow)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_games = uint256(pe4.getNumGamesStarted())

IRs:
TMP_99(int256) = HIGH_LEVEL_CALL, dest:pe4(iE4RowEscrow), function:getNumGamesStarted, arguments:[]  
TMP_100 = CONVERT TMP_99 to uint256
_games(uint256) := TMP_100(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_games

IRs:
RETURN _games"];
}
// Function: 39469.sol-E4Token-getNumTokensPurchased()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_purchased = totalTokensMinted - numDevTokens

IRs:
TMP_95(uint256) = totalTokensMinted - numDevTokens
_purchased(uint256) := TMP_95(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_purchased

IRs:
RETURN _purchased"];
}
// Function: 39469.sol-E4Token-getOpGas()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_rm = rmGas

IRs:
_rm(uint256) := rmGas(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_rf = rfGas

IRs:
_rf(uint256) := rfGas(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_rw = rwGas

IRs:
_rw(uint256) := rwGas(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(_rm,_rf,_rw)

IRs:
RETURN _rm,_rf,_rw"];
}
// Function: 39469.sol-E4Token-getPayIdAndHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_payId = (_tokHeld / (2 ** 48)) & 0xffff

IRs:
TMP_18(uint256) = 2 ** 48
TMP_19(uint256) = _tokHeld / TMP_18
TMP_20(uint256) = TMP_19 & 65535
_payId(uint256) := TMP_20(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_21(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_21(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
(_payId,_held)

IRs:
RETURN _payId,_held"];
}
// Function: 39469.sol-E4Token-getSpecialAddresses()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_fndr = founderOrg

IRs:
_fndr(address) := founderOrg(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_aux = auxPartner

IRs:
_aux(address) := auxPartner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_dev = developers

IRs:
_dev(address) := developers(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_e4 = e4_partner

IRs:
_e4(address) := e4_partner(address)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
(_fndr,_aux,_dev,_e4)

IRs:
RETURN _fndr,_aux,_dev,_e4"];
}
// Function: 39469.sol-E4Token-haraKiri()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
settingsState != SettingStateValue.debug

IRs:
REF_127(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_250(bool) = settingsState != REF_127
CONDITION TMP_250"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
msg.sender != owner

IRs:
TMP_251(bool) = msg.sender != owner
CONDITION TMP_251"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
suicide(address)(developers)

IRs:
TMP_252(None) = SOLIDITY_CALL suicide(address)(developers)"];
}
// Function: 39469.sol-E4Token-holderExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_exist = holderAccounts[_addr].alloced

IRs:
REF_52(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_53(bool) -> REF_52.alloced
_exist(bool) := REF_53(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_exist

IRs:
RETURN _exist"];
}
// Function: 39469.sol-E4Token-icoCheckup()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_208(bool) = msg.sender != owner
TMP_209(bool) = msg.sender != developers
TMP_210(bool) = TMP_208 && TMP_209
CONDITION TMP_210"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
icoStatus == IcoStatusValue.saleClosed

IRs:
REF_115(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
TMP_211(bool) = icoStatus == REF_115
CONDITION TMP_211"];
5->6[label="True"];
5->12[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
(getNumTokensPurchased() >= minIcoTokenGoal) && (remunerationStage == 0)

IRs:
TMP_212(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_213(bool) = TMP_212 >= minIcoTokenGoal
TMP_214(bool) = remunerationStage == 0
TMP_215(bool) = TMP_213 && TMP_214
CONDITION TMP_215"];
6->7[label="True"];
6->11[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_216(uint256) = totalTokenFundsReceived / 100
TMP_217(uint256) = TMP_216 * 9
remunerationBalance(uint256) := TMP_217(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_218(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_218(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nmsgmask |= 1

IRs:
nmsgmask(uint256) = nmsgmask | 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
icoStatus == IcoStatusValue.succeeded

IRs:
REF_116(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_219(bool) = icoStatus == REF_116
CONDITION TMP_219"];
13->14[label="True"];
13->25[label="False"];
14[label="Node Type: IF 14

EXPRESSION:
remunerationStage == 0

IRs:
TMP_220(bool) = remunerationStage == 0
CONDITION TMP_220"];
14->15[label="True"];
14->19[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_221(uint256) = totalTokenFundsReceived / 100
TMP_222(uint256) = TMP_221 * 9
remunerationBalance(uint256) := TMP_222(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_223(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_223(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
nmsgmask |= 4

IRs:
nmsgmask(uint256) = nmsgmask | 4"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
remunerationStage == 1

IRs:
TMP_224(bool) = remunerationStage == 1
CONDITION TMP_224"];
20->21[label="True"];
20->24[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
remunerationStage = 2

IRs:
remunerationStage(uint256) := 2(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived / 10)

IRs:
TMP_225(uint256) = totalTokenFundsReceived / 10
TMP_226(uint256) = totalTokenFundsReceived - TMP_225
remunerationBalance(uint256) = remunerationBalance + TMP_226"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
nmsgmask |= 8

IRs:
nmsgmask(uint256) = nmsgmask | 8"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: NEW VARIABLE 26
"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
remunerationBalance > 0

IRs:
TMP_227(bool) = remunerationBalance > 0
CONDITION TMP_227"];
27->28[label="True"];
27->35[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
ntmp = remunerationBalance

IRs:
ntmp(uint256) := remunerationBalance(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
29->30;
30[label="Node Type: IF 30

EXPRESSION:
! founderOrg.call.gas(rmGas).value(ntmp)()

IRs:
TMP_230(bool) = LOW_LEVEL_CALL, dest:founderOrg, function:call, arguments:[] value:ntmp gas:rmGas
TMP_231 = UnaryType.BANG TMP_230 
CONDITION TMP_231"];
30->31[label="True"];
30->33[label="False"];
31[label="Node Type: EXPRESSION 31

EXPRESSION:
remunerationBalance = ntmp

IRs:
remunerationBalance(uint256) := ntmp(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
nmsgmask |= 32

IRs:
nmsgmask(uint256) = nmsgmask | 32"];
32->34;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nmsgmask |= 64

IRs:
nmsgmask(uint256) = nmsgmask | 64"];
33->34;
34[label="Node Type: END_IF 34
"];
34->44;
35[label="Node Type: IF 35

EXPRESSION:
auxPartnerBalance > 0

IRs:
TMP_232(bool) = auxPartnerBalance > 0
CONDITION TMP_232"];
35->36[label="True"];
35->43[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
ntmp = auxPartnerBalance

IRs:
ntmp(uint256) := auxPartnerBalance(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
37->38;
38[label="Node Type: IF 38

EXPRESSION:
! auxPartner.call.gas(rmGas).value(ntmp)()

IRs:
TMP_235(bool) = LOW_LEVEL_CALL, dest:auxPartner, function:call, arguments:[] value:ntmp gas:rmGas
TMP_236 = UnaryType.BANG TMP_235 
CONDITION TMP_236"];
38->39[label="True"];
38->41[label="False"];
39[label="Node Type: EXPRESSION 39

EXPRESSION:
auxPartnerBalance = ntmp

IRs:
auxPartnerBalance(uint256) := ntmp(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
nmsgmask |= 128

IRs:
nmsgmask(uint256) = nmsgmask | 128"];
40->42;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
nmsgmask |= 256

IRs:
nmsgmask(uint256) = nmsgmask | 256"];
41->42;
42[label="Node Type: END_IF 42
"];
42->43;
43[label="Node Type: END_IF 43
"];
43->44;
44[label="Node Type: END_IF 44
"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
StatEventI(ico-checkup,nmsgmask)

IRs:
Emit StatEventI(ico-checkup,nmsgmask)"];
}
// Function: 39469.sol-E4Token-purchaseToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nvalue = msg.value

IRs:
nvalue(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
npurchaser = msg.sender

IRs:
npurchaser(address) := msg.sender(address)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
nvalue < tokenPrice

IRs:
TMP_64(bool) = nvalue < tokenPrice
CONDITION TMP_64"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: THROW 4
"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
qty = nvalue / tokenPrice

IRs:
TMP_65(uint256) = nvalue / tokenPrice
qty(uint256) := TMP_65(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
icoStatus != IcoStatusValue.saleOpen

IRs:
REF_54(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_67(bool) = icoStatus != REF_54
CONDITION TMP_67"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: THROW 9
"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
totalTokensMinted + qty > maxMintableTokens

IRs:
TMP_68(uint256) = totalTokensMinted + qty
TMP_69(bool) = TMP_68 > maxMintableTokens
CONDITION TMP_69"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: THROW 12
"];
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
! holderAccounts[npurchaser].alloced

IRs:
REF_55(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_56(bool) -> REF_55.alloced
TMP_70 = UnaryType.BANG REF_56 
CONDITION TMP_70"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
addAccount(npurchaser)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(npurchaser)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
newHeld = qty + getHeld(holderAccounts[npurchaser].tokens)

IRs:
REF_57(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_58(uint256) -> REF_57.tokens
TMP_72(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_58)
TMP_73(uint256) = qty + TMP_72
newHeld(uint256) := TMP_73(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_59(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_60(uint256) -> REF_59.tokens
TMP_74(uint256) = 2 ** 48
TMP_75(uint256) = curPayoutId * TMP_74
TMP_76(uint256) = newHeld | TMP_75
REF_60(uint256) (->holderAccounts) := TMP_76(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
totalTokensMinted += qty

IRs:
totalTokensMinted(uint256) = totalTokensMinted + qty"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
totalTokenFundsReceived += nvalue

IRs:
totalTokenFundsReceived(uint256) = totalTokenFundsReceived + nvalue"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
totalTokensMinted == maxMintableTokens

IRs:
TMP_77(bool) = totalTokensMinted == maxMintableTokens
CONDITION TMP_77"];
21->22[label="True"];
21->25[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_61(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_61(E4Token.IcoStatusValue)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
StatEventI(Purchased,Granted,qty)

IRs:
Emit StatEventI(Purchased,Granted,qty)"];
24->26;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
StatEventI(Purchased,qty)

IRs:
Emit StatEventI(Purchased,qty)"];
25->26;
26[label="Node Type: END_IF 26
"];
}
// Function: 39469.sol-E4Token-requestRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nrequester = msg.sender

IRs:
nrequester(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
ntokens = getHeld(holderAccounts[nrequester].tokens)

IRs:
REF_75(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_76(uint256) -> REF_75.tokens
TMP_138(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_76)
ntokens(uint256) := TMP_138(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
icoStatus != IcoStatusValue.failed

IRs:
REF_77(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_139(bool) = icoStatus != REF_77
CONDITION TMP_139"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(No Refund)

IRs:
Emit StatEvent(No Refund)"];
5->25;
6[label="Node Type: IF 6

EXPRESSION:
ntokens == 0

IRs:
TMP_141(bool) = ntokens == 0
CONDITION TMP_141"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
StatEvent(No Tokens)

IRs:
Emit StatEvent(No Tokens)"];
7->24;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
nrefund = ntokens * tokenPrice

IRs:
TMP_143(uint256) = ntokens * tokenPrice
nrefund(uint256) := TMP_143(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_144(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_145(bool) = TMP_144 >= minIcoTokenGoal
CONDITION TMP_145"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nrefund -= (nrefund / 10)

IRs:
TMP_146(uint256) = nrefund / 10
nrefund(uint256) = nrefund - TMP_146"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
holderAccounts[developers].tokens += ntokens

IRs:
REF_78(E4Token.tokenAccount) -> holderAccounts[developers]
REF_79(uint256) -> REF_78.tokens
REF_79(-> holderAccounts) = REF_79 + ntokens"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[nrequester].tokens = 0

IRs:
REF_80(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_81(uint256) -> REF_80.tokens
REF_81(uint256) (->holderAccounts) := 0(uint256)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
holderAccounts[nrequester].balance > 0

IRs:
REF_82(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_83(uint256) -> REF_82.balance
TMP_147(bool) = REF_83 > 0
CONDITION TMP_147"];
14->15[label="True"];
14->20[label="False"];
15[label="Node Type: IF 15

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_84(E4Token.tokenAccount) -> holderAccounts[developers]
REF_85(bool) -> REF_84.alloced
TMP_148 = UnaryType.BANG REF_85 
CONDITION TMP_148"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[developers].balance += holderAccounts[nrequester].balance

IRs:
REF_86(E4Token.tokenAccount) -> holderAccounts[developers]
REF_87(uint256) -> REF_86.balance
REF_88(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_89(uint256) -> REF_88.balance
REF_87(-> holderAccounts) = REF_87 + REF_89"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
holderAccounts[nrequester].balance = 0

IRs:
REF_90(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_91(uint256) -> REF_90.balance
REF_91(uint256) (->holderAccounts) := 0(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
! nrequester.call.gas(rfGas).value(nrefund)()

IRs:
TMP_152(bool) = LOW_LEVEL_CALL, dest:nrequester, function:call, arguments:[] value:nrefund gas:rfGas
TMP_153 = UnaryType.BANG TMP_152 
CONDITION TMP_153"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: THROW 22
"];
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39469.sol-E4Token-setE4RowPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_89(bool) = msg.sender == owner
CONDITION TMP_89"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
(e4_partner == address(0)) || (settingsState == SettingStateValue.debug)

IRs:
TMP_90 = CONVERT 0 to address
TMP_91(bool) = e4_partner == TMP_90
REF_62(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_92(bool) = settingsState == REF_62
TMP_93(bool) = TMP_91 || TMP_92
CONDITION TMP_93"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
e4_partner = _addr

IRs:
e4_partner(address) := _addr(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
partnerCredits = 0

IRs:
partnerCredits(uint256) := 0(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(Already Set)

IRs:
Emit StatEvent(Already Set)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 39469.sol-E4Token-setOpGas(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_205(bool) = msg.sender != owner
TMP_206(bool) = msg.sender != developers
TMP_207(bool) = TMP_205 && TMP_206
CONDITION TMP_207"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
rmGas = _rm

IRs:
rmGas(uint256) := _rm(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rfGas = _rf

IRs:
rfGas(uint256) := _rf(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
rwGas = _rw

IRs:
rwGas(uint256) := _rw(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 39469.sol-E4Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen || icoStatus == IcoStatusValue.anouncement

IRs:
REF_18(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_26(bool) = icoStatus == REF_18
REF_19(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_27(bool) = icoStatus == REF_19
TMP_28(bool) = TMP_26 || TMP_27
CONDITION TMP_28"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supply = maxMintableTokens

IRs:
supply(uint256) := maxMintableTokens(uint256)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
supply = totalTokensMinted

IRs:
supply(uint256) := totalTokensMinted(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 39469.sol-E4Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_29(bool) = msg.sender == developers
TMP_30(bool) = now < vestTime
TMP_31(bool) = TMP_29 && TMP_30
CONDITION TMP_31"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens)

IRs:
REF_20(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_21(uint256) -> REF_20.tokens
TUPLE_0(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_21)
pidFrom(uint256)= UNPACK TUPLE_0 index: 0 
heldFrom(uint256)= UNPACK TUPLE_0 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && _value > 0

IRs:
TMP_32(bool) = heldFrom >= _value
TMP_33(bool) = _value > 0
TMP_34(bool) = TMP_32 && TMP_33
CONDITION TMP_34"];
7->8[label="True"];
7->16[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].tokens -= _value

IRs:
REF_22(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_23(uint256) -> REF_22.tokens
REF_23(-> holderAccounts) = REF_23 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_24(E4Token.tokenAccount) -> holderAccounts[_to]
REF_25(bool) -> REF_24.alloced
TMP_35 = UnaryType.BANG REF_25 
CONDITION TMP_35"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_26(E4Token.tokenAccount) -> holderAccounts[_to]
REF_27(uint256) -> REF_26.tokens
TMP_37(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_27)
TMP_38(uint256) = _value + TMP_37
newHeld(uint256) := TMP_38(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_28(E4Token.tokenAccount) -> holderAccounts[_to]
REF_29(uint256) -> REF_28.tokens
TMP_39(uint256) = 2 ** 48
TMP_40(uint256) = pidFrom * TMP_39
TMP_41(uint256) = newHeld | TMP_40
REF_29(uint256) (->holderAccounts) := TMP_41(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
true

IRs:
RETURN True"];
16[label="Node Type: RETURN 16

EXPRESSION:
false

IRs:
RETURN False"];
18[label="Node Type: RETURN 18

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39469.sol-E4Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(_from == developers) && (now < vestTime)

IRs:
TMP_43(bool) = _from == developers
TMP_44(bool) = now < vestTime
TMP_45(bool) = TMP_43 && TMP_44
CONDITION TMP_45"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens)

IRs:
REF_30(E4Token.tokenAccount) -> holderAccounts[_from]
REF_31(uint256) -> REF_30.tokens
TUPLE_1(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_31)
pidFrom(uint256)= UNPACK TUPLE_1 index: 0 
heldFrom(uint256)= UNPACK TUPLE_1 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
TMP_46(bool) = heldFrom >= _value
REF_32(mapping(address => uint256)) -> allowed[_from]
REF_33(uint256) -> REF_32[msg.sender]
TMP_47(bool) = REF_33 >= _value
TMP_48(bool) = TMP_46 && TMP_47
TMP_49(bool) = _value > 0
TMP_50(bool) = TMP_48 && TMP_49
CONDITION TMP_50"];
7->8[label="True"];
7->17[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[_from].tokens -= _value

IRs:
REF_34(E4Token.tokenAccount) -> holderAccounts[_from]
REF_35(uint256) -> REF_34.tokens
REF_35(-> holderAccounts) = REF_35 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_36(E4Token.tokenAccount) -> holderAccounts[_to]
REF_37(bool) -> REF_36.alloced
TMP_51 = UnaryType.BANG REF_37 
CONDITION TMP_51"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_38(E4Token.tokenAccount) -> holderAccounts[_to]
REF_39(uint256) -> REF_38.tokens
TMP_53(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_39)
TMP_54(uint256) = _value + TMP_53
newHeld(uint256) := TMP_54(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_40(E4Token.tokenAccount) -> holderAccounts[_to]
REF_41(uint256) -> REF_40.tokens
TMP_55(uint256) = 2 ** 48
TMP_56(uint256) = pidFrom * TMP_55
TMP_57(uint256) = newHeld | TMP_56
REF_41(uint256) (->holderAccounts) := TMP_57(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_42(mapping(address => uint256)) -> allowed[_from]
REF_43(uint256) -> REF_42[msg.sender]
REF_43(-> allowed) = REF_43 - _value"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True"];
17[label="Node Type: RETURN 17

EXPRESSION:
false

IRs:
RETURN False"];
19[label="Node Type: RETURN 19

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39469.sol-E4Token-updateIcoStatus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.succeeded || icoStatus == IcoStatusValue.failed

IRs:
REF_64(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_101(bool) = icoStatus == REF_64
REF_65(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_102(bool) = icoStatus == REF_65
TMP_103(bool) = TMP_101 || TMP_102
CONDITION TMP_103"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: IF 3

EXPRESSION:
icoStatus == IcoStatusValue.anouncement

IRs:
REF_66(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_104(bool) = icoStatus == REF_66
CONDITION TMP_104"];
3->4[label="True"];
3->10[label="False"];
4[label="Node Type: IF 4

EXPRESSION:
now > fundingStart && now <= fundingDeadline

IRs:
TMP_105(bool) = now > fundingStart
TMP_106(bool) = now <= fundingDeadline
TMP_107(bool) = TMP_105 && TMP_106
CONDITION TMP_107"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
icoStatus = IcoStatusValue.saleOpen

IRs:
REF_67(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
icoStatus(E4Token.IcoStatusValue) := REF_67(E4Token.IcoStatusValue)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
now > fundingDeadline

IRs:
TMP_108(bool) = now > fundingDeadline
CONDITION TMP_108"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_68(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_68(E4Token.IcoStatusValue)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
9->21;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
numP = getNumTokensPurchased()

IRs:
TMP_109(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
numP(uint256) := TMP_109(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
numG = getNumGames()

IRs:
TMP_110(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
numG(uint256) := TMP_110(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
(now > fundingDeadline && numP < minIcoTokenGoal) || (now > usageDeadline && numG < minUsageGoal)

IRs:
TMP_111(bool) = now > fundingDeadline
TMP_112(bool) = numP < minIcoTokenGoal
TMP_113(bool) = TMP_111 && TMP_112
TMP_114(bool) = now > usageDeadline
TMP_115(bool) = numG < minUsageGoal
TMP_116(bool) = TMP_114 && TMP_115
TMP_117(bool) = TMP_113 || TMP_116
CONDITION TMP_117"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
icoStatus = IcoStatusValue.failed

IRs:
REF_69(E4Token.IcoStatusValue) -> IcoStatusValue.failed
icoStatus(E4Token.IcoStatusValue) := REF_69(E4Token.IcoStatusValue)"];
13->17;
14[label="Node Type: IF 14

EXPRESSION:
(now > fundingDeadline) && (numP >= minIcoTokenGoal) && (numG >= minUsageGoal)

IRs:
TMP_118(bool) = now > fundingDeadline
TMP_119(bool) = numP >= minIcoTokenGoal
TMP_120(bool) = TMP_118 && TMP_119
TMP_121(bool) = numG >= minUsageGoal
TMP_122(bool) = TMP_120 && TMP_121
CONDITION TMP_122"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
icoStatus = IcoStatusValue.succeeded

IRs:
REF_70(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
icoStatus(E4Token.IcoStatusValue) := REF_70(E4Token.IcoStatusValue)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen && ((numP >= maxMintableTokens) || (now > fundingDeadline))

IRs:
REF_71(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_123(bool) = icoStatus == REF_71
TMP_124(bool) = numP >= maxMintableTokens
TMP_125(bool) = now > fundingDeadline
TMP_126(bool) = TMP_124 || TMP_125
TMP_127(bool) = TMP_123 && TMP_126
CONDITION TMP_127"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_72(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_72(E4Token.IcoStatusValue)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
! developersGranted && icoStatus != IcoStatusValue.saleOpen && icoStatus != IcoStatusValue.anouncement && getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_128 = UnaryType.BANG developersGranted 
REF_73(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_129(bool) = icoStatus != REF_73
TMP_130(bool) = TMP_128 && TMP_129
REF_74(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_131(bool) = icoStatus != REF_74
TMP_132(bool) = TMP_130 && TMP_131
TMP_133(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_134(bool) = TMP_133 >= minIcoTokenGoal
TMP_135(bool) = TMP_132 && TMP_134
CONDITION TMP_135"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39469.sol-E4Token-withdrawDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[msg.sender].balance == 0

IRs:
REF_102(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_103(uint256) -> REF_102.balance
TMP_196(bool) = REF_103 == 0
CONDITION TMP_196"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(0 Balance)

IRs:
Emit StatEvent(0 Balance)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: IF 4

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_198(bool) = msg.sender == developers
TMP_199(bool) = now < vestTime
TMP_200(bool) = TMP_198 && TMP_199
CONDITION TMP_200"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_amount = holderAccounts[msg.sender].balance

IRs:
REF_104(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_105(uint256) -> REF_104.balance
_amount(uint256) := REF_105(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].balance = 0

IRs:
REF_106(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_107(uint256) -> REF_106.balance
REF_107(uint256) (->holderAccounts) := 0(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! msg.sender.call.gas(rwGas).value(_amount)()

IRs:
TMP_203(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_amount gas:rwGas
TMP_204 = UnaryType.BANG TMP_203 
CONDITION TMP_204"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: THROW 10
"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39469.sol-Token-allowance(address,address)
digraph{
}
// Function: 39469.sol-Token-approve(address,uint256)
digraph{
}
// Function: 39469.sol-Token-balanceOf(address)
digraph{
}
// Function: 39469.sol-Token-totalSupply()
digraph{
}
// Function: 39469.sol-Token-transfer(address,uint256)
digraph{
}
// Function: 39469.sol-Token-transferFrom(address,address,uint256)
digraph{
}
// Function: 39469.sol-iE4RowEscrow-getNumGamesStarted()
digraph{
}
}
