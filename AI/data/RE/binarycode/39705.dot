digraph G {
// Function: 39705.sol-FDC-FDC(address,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->25;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
foundationWallet = _masterAuth

IRs:
foundationWallet(address) := _masterAuth(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
masterAuth = _masterAuth

IRs:
masterAuth(address) := _masterAuth(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
exchangeRateAuth = _masterAuth

IRs:
exchangeRateAuth(address) := _masterAuth(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
registrarAuth = _masterAuth

IRs:
registrarAuth(address) := _masterAuth(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
stateOfPhase[0] = state.earlyContrib

IRs:
REF_60(FDC.state) -> stateOfPhase[0]
REF_61(FDC.state) -> state.earlyContrib
REF_60(FDC.state) (->stateOfPhase) := REF_61(FDC.state)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
addPhase(round0StartTime)

IRs:
INTERNAL_CALL, Phased.addPhase(uint256)(round0StartTime)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
stateOfPhase[1] = state.round0

IRs:
REF_62(FDC.state) -> stateOfPhase[1]
REF_63(FDC.state) -> state.round0
REF_62(FDC.state) (->stateOfPhase) := REF_63(FDC.state)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
addPhase(round0EndTime)

IRs:
INTERNAL_CALL, Phased.addPhase(uint256)(round0EndTime)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
stateOfPhase[2] = state.offChainReg

IRs:
REF_64(FDC.state) -> stateOfPhase[2]
REF_65(FDC.state) -> state.offChainReg
REF_64(FDC.state) (->stateOfPhase) := REF_65(FDC.state)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
addPhase(round1StartTime)

IRs:
INTERNAL_CALL, Phased.addPhase(uint256)(round1StartTime)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
stateOfPhase[3] = state.round1

IRs:
REF_66(FDC.state) -> stateOfPhase[3]
REF_67(FDC.state) -> state.round1
REF_66(FDC.state) (->stateOfPhase) := REF_67(FDC.state)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
addPhase(round1EndTime)

IRs:
INTERNAL_CALL, Phased.addPhase(uint256)(round1EndTime)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
stateOfPhase[4] = state.offChainReg

IRs:
REF_68(FDC.state) -> stateOfPhase[4]
REF_69(FDC.state) -> state.offChainReg
REF_68(FDC.state) (->stateOfPhase) := REF_69(FDC.state)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
addPhase(finalizeStartTime)

IRs:
INTERNAL_CALL, Phased.addPhase(uint256)(finalizeStartTime)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
stateOfPhase[5] = state.finalization

IRs:
REF_70(FDC.state) -> stateOfPhase[5]
REF_71(FDC.state) -> state.finalization
REF_70(FDC.state) (->stateOfPhase) := REF_71(FDC.state)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
addPhase(finalizeEndTime)

IRs:
INTERNAL_CALL, Phased.addPhase(uint256)(finalizeEndTime)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
stateOfPhase[6] = state.done

IRs:
REF_72(FDC.state) -> stateOfPhase[6]
REF_73(FDC.state) -> state.done
REF_72(FDC.state) (->stateOfPhase) := REF_73(FDC.state)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
phaseOfRound0 = 1

IRs:
phaseOfRound0(uint256) := 1(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
phaseOfRound1 = 3

IRs:
phaseOfRound1(uint256) := 3(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
setMaxDelay(phaseOfRound0 - 1,maxRoundDelay)

IRs:
TMP_160(uint256) = phaseOfRound0 - 1
INTERNAL_CALL, Phased.setMaxDelay(uint256,uint256)(TMP_160,maxRoundDelay)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
setMaxDelay(phaseOfRound1 - 1,maxRoundDelay)

IRs:
TMP_162(uint256) = phaseOfRound1 - 1
INTERNAL_CALL, Phased.setMaxDelay(uint256,uint256)(TMP_162,maxRoundDelay)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
setTarget(phaseOfRound0,round0Target)

IRs:
INTERNAL_CALL, Targets.setTarget(uint256,uint256)(phaseOfRound0,round0Target)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
setTarget(phaseOfRound1,round1Target)

IRs:
INTERNAL_CALL, Targets.setTarget(uint256,uint256)(phaseOfRound1,round1Target)"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
TokenTracker(earlyContribShare)

IRs:
INTERNAL_CALL, TokenTracker.TokenTracker(uint256)(earlyContribShare)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
StepFunction(round1EndTime - round1StartTime,round1InitialBonus,round1BonusSteps)

IRs:
TMP_167(uint256) = round1EndTime - round1StartTime
INTERNAL_CALL, StepFunction.StepFunction(uint256,uint256,uint256)(TMP_167,round1InitialBonus,round1BonusSteps)"];
26->1;
}
// Function: 39705.sol-FDC-StepFunction(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_nSteps > _phaseLength

IRs:
TMP_86(bool) = _nSteps > _phaseLength
CONDITION TMP_86"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
step = _initialValue / _nSteps

IRs:
TMP_87(uint256) = _initialValue / _nSteps
step(uint256) := TMP_87(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
step * _nSteps != _initialValue

IRs:
TMP_88(uint256) = step * _nSteps
TMP_89(bool) = TMP_88 != _initialValue
CONDITION TMP_89"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
phaseLength = _phaseLength

IRs:
phaseLength(uint256) := _phaseLength(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
nSteps = _nSteps

IRs:
nSteps(uint256) := _nSteps(uint256)"];
}
// Function: 39705.sol-FDC-TokenTracker(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_restrictedShare >= 100

IRs:
TMP_134(bool) = _restrictedShare >= 100
CONDITION TMP_134"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
restrictedShare = _restrictedShare

IRs:
restrictedShare(uint256) := _restrictedShare(uint256)"];
}
// Function: 39705.sol-FDC-addPhase(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
N > 0 && time <= phaseEndTime[N - 1]

IRs:
TMP_113(bool) = N > 0
TMP_114(uint256) = N - 1
REF_42(uint256) -> phaseEndTime[TMP_114]
TMP_115(bool) = time <= REF_42
TMP_116(bool) = TMP_113 && TMP_115
CONDITION TMP_116"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
time <= now

IRs:
TMP_117(bool) = time <= now
CONDITION TMP_117"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
phaseEndTime.push(time)

IRs:
REF_44 -> LENGTH phaseEndTime
TMP_119(uint256) := REF_44(uint256)
TMP_120(uint256) = TMP_119 + 1
REF_44(uint256) (->phaseEndTime) := TMP_120(uint256)
REF_45(uint256) -> phaseEndTime[TMP_119]
REF_45(uint256) (->phaseEndTime) := time(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
N ++

IRs:
TMP_121(uint256) := N(uint256)
N(uint256) = N + 1"];
}
// Function: 39705.sol-FDC-addTowardsTarget(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
firstReached = (counter[id] < target[id]) && (counter[id] + amount >= target[id])

IRs:
REF_33(uint256) -> counter[id]
REF_34(uint256) -> target[id]
TMP_82(bool) = REF_33 < REF_34
REF_35(uint256) -> counter[id]
TMP_83(uint256) = REF_35 + amount
REF_36(uint256) -> target[id]
TMP_84(bool) = TMP_83 >= REF_36
TMP_85(bool) = TMP_82 && TMP_84
firstReached(bool) := TMP_85(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
counter[id] += amount

IRs:
REF_37(uint256) -> counter[id]
REF_37(-> counter) = REF_37 + amount"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
firstReached

IRs:
RETURN firstReached"];
}
// Function: 39705.sol-FDC-assign(address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
assignmentsClosed

IRs:
CONDITION assignmentsClosed"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokens[addr] += tokenAmount

IRs:
REF_55(uint256) -> tokens[addr]
REF_55(-> tokens) = REF_55 + tokenAmount"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
restricted

IRs:
CONDITION restricted"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalRestrictedTokens += tokenAmount

IRs:
totalRestrictedTokens(uint256) = totalRestrictedTokens + tokenAmount"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
totalRestrictedAssignments += 1

IRs:
totalRestrictedAssignments(uint256) = totalRestrictedAssignments + 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
restrictions[addr] += tokenAmount

IRs:
REF_56(uint256) -> restrictions[addr]
REF_56(-> restrictions) = REF_56 + tokenAmount"];
8->11;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalUnrestrictedTokens += tokenAmount

IRs:
totalUnrestrictedTokens(uint256) = totalUnrestrictedTokens + tokenAmount"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
totalUnrestrictedAssignments += 1

IRs:
totalUnrestrictedAssignments(uint256) = totalUnrestrictedAssignments + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
}
// Function: 39705.sol-FDC-bookDonation(address,uint256,uint256,string,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
phase = getPhaseAtTime(timestamp)

IRs:
TMP_260(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(timestamp)
phase(uint256) := TMP_260(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
targetReached = addTowardsTarget(phase,chfCents)

IRs:
TMP_261(bool) = INTERNAL_CALL, Targets.addTowardsTarget(uint256,uint256)(phase,chfCents)
targetReached(bool) := TMP_261(bool)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
targetReached && phase == getPhaseAtTime(now)

IRs:
TMP_262(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(now)
TMP_263(bool) = phase == TMP_262
TMP_264(bool) = targetReached && TMP_263
CONDITION TMP_264"];
3->4[label="True"];
3->10[label="False"];
4[label="Node Type: IF 4

EXPRESSION:
phase == phaseOfRound0

IRs:
TMP_265(bool) = phase == phaseOfRound0
CONDITION TMP_265"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
endCurrentPhaseIn(gracePeriodAfterRound0Target)

IRs:
INTERNAL_CALL, Phased.endCurrentPhaseIn(uint256)(gracePeriodAfterRound0Target)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
phase == phaseOfRound1

IRs:
TMP_267(bool) = phase == phaseOfRound1
CONDITION TMP_267"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endCurrentPhaseIn(gracePeriodAfterRound1Target)

IRs:
INTERNAL_CALL, Phased.endCurrentPhaseIn(uint256)(gracePeriodAfterRound1Target)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
bonusMultiplier = getMultiplierAtTime(timestamp)

IRs:
TMP_269(uint256) = INTERNAL_CALL, FDC.getMultiplierAtTime(uint256)(timestamp)
bonusMultiplier(uint256) := TMP_269(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
chfCents = (chfCents * bonusMultiplier) / 100

IRs:
TMP_270(uint256) = chfCents * bonusMultiplier
TMP_271(uint256) = TMP_270 / 100
chfCents(uint256) := TMP_271(uint256)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
tokenAmount = (chfCents * tokensPerCHF) / 100

IRs:
TMP_272(uint256) = chfCents * tokensPerCHF
TMP_273(uint256) = TMP_272 / 100
tokenAmount(uint256) := TMP_273(uint256)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
! isRegistered(addr,false)

IRs:
TMP_274(bool) = INTERNAL_CALL, TokenTracker.isRegistered(address,bool)(addr,False)
TMP_275 = UnaryType.BANG TMP_274 
CONDITION TMP_275"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
donorList.push(addr)

IRs:
REF_110 -> LENGTH donorList
TMP_277(uint256) := REF_110(uint256)
TMP_278(uint256) = TMP_277 + 1
REF_110(uint256) (->donorList) := TMP_278(uint256)
REF_111(address) -> donorList[TMP_277]
REF_111(address) (->donorList) := addr(address)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
assign(addr,tokenAmount,false)

IRs:
INTERNAL_CALL, TokenTracker.assign(address,uint256,bool)(addr,tokenAmount,False)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
DonationReceipt(addr,currency,bonusMultiplier,timestamp,tokenAmount,memo)

IRs:
Emit DonationReceipt(addr,currency,bonusMultiplier,timestamp,tokenAmount,memo)"];
}
// Function: 39705.sol-FDC-closeAssignmentsIfOpen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
assignmentsClosed

IRs:
CONDITION assignmentsClosed"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assignmentsClosed = true

IRs:
assignmentsClosed(bool) := True(bool)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
totalTokensTarget = (totalUnrestrictedTokens * 100) / (100 - restrictedShare)

IRs:
TMP_144(uint256) = totalUnrestrictedTokens * 100
TMP_145(uint256) = 100 - restrictedShare
TMP_146(uint256) = TMP_144 / TMP_145
totalTokensTarget(uint256) := TMP_146(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
totalTokensExisting = totalRestrictedTokens + totalUnrestrictedTokens

IRs:
TMP_147(uint256) = totalRestrictedTokens + totalUnrestrictedTokens
totalTokensExisting(uint256) := TMP_147(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
totalBurn = 0

IRs:
totalBurn(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
totalTokensExisting > totalTokensTarget

IRs:
TMP_148(bool) = totalTokensExisting > totalTokensTarget
CONDITION TMP_148"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalBurn = totalTokensExisting - totalTokensTarget

IRs:
TMP_149(uint256) = totalTokensExisting - totalTokensTarget
totalBurn(uint256) := TMP_149(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
burnMultNom = totalBurn

IRs:
burnMultNom(uint256) := totalBurn(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
burnMultDen = totalRestrictedTokens

IRs:
burnMultDen(uint256) := totalRestrictedTokens(uint256)"];
}
// Function: 39705.sol-FDC-delayDonPhase(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != registrarAuth

IRs:
TMP_236(bool) = msg.sender != registrarAuth
CONDITION TMP_236"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
donPhase == 0

IRs:
TMP_237(bool) = donPhase == 0
CONDITION TMP_237"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
delayPhaseEndBy(phaseOfRound0 - 1,timedelta)

IRs:
TMP_238(uint256) = phaseOfRound0 - 1
INTERNAL_CALL, Phased.delayPhaseEndBy(uint256,uint256)(TMP_238,timedelta)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
donPhase == 1

IRs:
TMP_240(bool) = donPhase == 1
CONDITION TMP_240"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
delayPhaseEndBy(phaseOfRound1 - 1,timedelta)

IRs:
TMP_241(uint256) = phaseOfRound1 - 1
INTERNAL_CALL, Phased.delayPhaseEndBy(uint256,uint256)(TMP_241,timedelta)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 39705.sol-FDC-delayPhaseEndBy(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
n >= N

IRs:
TMP_123(bool) = n >= N
CONDITION TMP_123"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
now >= phaseEndTime[n]

IRs:
REF_47(uint256) -> phaseEndTime[n]
TMP_124(bool) = now >= REF_47
CONDITION TMP_124"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
timeDelta > maxDelay[n]

IRs:
REF_48(uint256) -> maxDelay[n]
TMP_125(bool) = timeDelta > REF_48
CONDITION TMP_125"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: THROW 8
"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
maxDelay[n] -= timeDelta

IRs:
REF_49(uint256) -> maxDelay[n]
REF_49(-> maxDelay) = REF_49 - timeDelta"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = n

IRs:
i(uint256) := n(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < N

IRs:
TMP_126(bool) = i < N
CONDITION TMP_126"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
phaseEndTime[i] += timeDelta

IRs:
REF_50(uint256) -> phaseEndTime[i]
REF_50(-> phaseEndTime) = REF_50 + timeDelta"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_127(uint256) := i(uint256)
i(uint256) = i + 1"];
16->14;
}
// Function: 39705.sol-FDC-donateAs(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
st = getState()

IRs:
TMP_249(FDC.state) = INTERNAL_CALL, FDC.getState()()
st(FDC.state) := TMP_249(FDC.state)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
st != state.round0 && st != state.round1

IRs:
REF_103(FDC.state) -> state.round0
TMP_250(bool) = st != REF_103
REF_104(FDC.state) -> state.round1
TMP_251(bool) = st != REF_104
TMP_252(bool) = TMP_250 && TMP_251
CONDITION TMP_252"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
msg.value < minDonation

IRs:
TMP_253(bool) = msg.value < minDonation
CONDITION TMP_253"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
weiPerCHF == 0

IRs:
TMP_254(bool) = weiPerCHF == 0
CONDITION TMP_254"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: THROW 9
"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
totalWeiDonated += msg.value

IRs:
totalWeiDonated(uint256) = totalWeiDonated + msg.value"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
weiDonated[addr] += msg.value

IRs:
REF_105(uint256) -> weiDonated[addr]
REF_105(-> weiDonated) = REF_105 + msg.value"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
chfCents = (msg.value * 100) / weiPerCHF

IRs:
TMP_255(uint256) = msg.value * 100
TMP_256(uint256) = TMP_255 / weiPerCHF
chfCents(uint256) := TMP_256(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
bookDonation(addr,now,chfCents,ETH,)

IRs:
INTERNAL_CALL, FDC.bookDonation(address,uint256,uint256,string,bytes32)(addr,now,chfCents,ETH,)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
foundationWallet.call.value(this.balance)()

IRs:
REF_108(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_259(bool) = LOW_LEVEL_CALL, dest:foundationWallet, function:call, arguments:[] value:REF_108 
RETURN TMP_259"];
}
// Function: 39705.sol-FDC-donateAsWithChecksum(address,bytes4)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = sha256()(addr)

IRs:
TMP_178(bytes32) = SOLIDITY_CALL sha256()(addr)
hash(bytes32) := TMP_178(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
bytes4(hash) != checksum

IRs:
TMP_179 = CONVERT hash to bytes4
TMP_180(bool) = TMP_179 != checksum
CONDITION TMP_180"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
donateAs(addr)

IRs:
TMP_181(bool) = INTERNAL_CALL, FDC.donateAs(address)(addr)
RETURN TMP_181"];
}
// Function: 39705.sol-FDC-empty()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
foundationWallet.call.value(this.balance)()

IRs:
REF_82(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_190(bool) = LOW_LEVEL_CALL, dest:foundationWallet, function:call, arguments:[] value:REF_82 
RETURN TMP_190"];
}
// Function: 39705.sol-FDC-endCurrentPhaseIn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
n = getPhaseAtTime(now)

IRs:
TMP_128(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(now)
n(uint256) := TMP_128(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
n >= N

IRs:
TMP_129(bool) = n >= N
CONDITION TMP_129"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
timeDelta == 0

IRs:
TMP_130(bool) = timeDelta == 0
CONDITION TMP_130"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
timeDelta = 1

IRs:
timeDelta(uint256) := 1(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
now + timeDelta < phaseEndTime[n]

IRs:
TMP_131(uint256) = now + timeDelta
REF_51(uint256) -> phaseEndTime[n]
TMP_132(bool) = TMP_131 < REF_51
CONDITION TMP_132"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
phaseEndTime[n] = now + timeDelta

IRs:
REF_52(uint256) -> phaseEndTime[n]
TMP_133(uint256) = now + timeDelta
REF_52(uint256) (->phaseEndTime) := TMP_133(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 39705.sol-FDC-finalize(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
getState() != state.finalization

IRs:
TMP_182(FDC.state) = INTERNAL_CALL, FDC.getState()()
REF_79(FDC.state) -> state.finalization
TMP_183(bool) = TMP_182 != REF_79
CONDITION TMP_183"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
closeAssignmentsIfOpen()

IRs:
INTERNAL_CALL, TokenTracker.closeAssignmentsIfOpen()()"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
tokensBurned = unrestrict(addr)

IRs:
TMP_185(uint256) = INTERNAL_CALL, TokenTracker.unrestrict(address)(addr)
tokensBurned(uint256) := TMP_185(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
BurnReceipt(addr,tokensBurned)

IRs:
Emit BurnReceipt(addr,tokensBurned)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
isUnrestricted()

IRs:
TMP_187(bool) = INTERNAL_CALL, TokenTracker.isUnrestricted()()
CONDITION TMP_187"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
endCurrentPhaseIn(0)

IRs:
INTERNAL_CALL, Phased.endCurrentPhaseIn(uint256)(0)"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 39705.sol-FDC-getMultiplierAtTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
n = getPhaseAtTime(time)

IRs:
TMP_170(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(time)
n(uint256) := TMP_170(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
stateOfPhase[n] == state.round0

IRs:
REF_75(FDC.state) -> stateOfPhase[n]
REF_76(FDC.state) -> state.round0
TMP_171(bool) = REF_75 == REF_76
CONDITION TMP_171"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
100 + round0Bonus

IRs:
TMP_172(uint256) = 100 + round0Bonus
RETURN TMP_172"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
stateOfPhase[n] == state.round1

IRs:
REF_77(FDC.state) -> stateOfPhase[n]
REF_78(FDC.state) -> state.round1
TMP_173(bool) = REF_77 == REF_78
CONDITION TMP_173"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
100 + getStepFunction(time - getPhaseStartTime(n))

IRs:
TMP_174(uint256) = INTERNAL_CALL, Phased.getPhaseStartTime(uint256)(n)
TMP_175(uint256) = time - TMP_174
TMP_176(uint256) = INTERNAL_CALL, StepFunction.getStepFunction(uint256)(TMP_175)
TMP_177(uint256) = 100 + TMP_176
RETURN TMP_177"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: THROW 8
"];
}
// Function: 39705.sol-FDC-getPhaseAtTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
time > now

IRs:
TMP_97(bool) = time > now
CONDITION TMP_97"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: BEGIN_LOOP 4
"];
4->5;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
n < N && phaseEndTime[n] <= time

IRs:
TMP_98(bool) = n < N
REF_38(uint256) -> phaseEndTime[n]
TMP_99(bool) = REF_38 <= time
TMP_100(bool) = TMP_98 && TMP_99
CONDITION TMP_100"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
n ++

IRs:
TMP_101(uint256) := n(uint256)
n(uint256) = n + 1"];
6->5;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
n

IRs:
RETURN n"];
}
// Function: 39705.sol-FDC-getPhaseStartTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
n == 0

IRs:
TMP_111(bool) = n == 0
CONDITION TMP_111"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
phaseEndTime[n - 1]

IRs:
TMP_112(uint256) = n - 1
REF_41(uint256) -> phaseEndTime[TMP_112]
RETURN REF_41"];
}
// Function: 39705.sol-FDC-getState()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
stateOfPhase[getPhaseAtTime(now)]

IRs:
TMP_169(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(now)
REF_74(FDC.state) -> stateOfPhase[TMP_169]
RETURN REF_74"];
}
// Function: 39705.sol-FDC-getStatus(uint256,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
currentState = getState()

IRs:
TMP_191(FDC.state) = INTERNAL_CALL, FDC.getState()()
currentState(FDC.state) := TMP_191(FDC.state)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
currentState == state.round0 || currentState == state.round1

IRs:
REF_83(FDC.state) -> state.round0
TMP_192(bool) = currentState == REF_83
REF_84(FDC.state) -> state.round1
TMP_193(bool) = currentState == REF_84
TMP_194(bool) = TMP_192 || TMP_193
CONDITION TMP_194"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
currentMultiplier = getMultiplierAtTime(now)

IRs:
TMP_195(uint256) = INTERNAL_CALL, FDC.getMultiplierAtTime(uint256)(now)
currentMultiplier(uint256) := TMP_195(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
fxRate = weiPerCHF

IRs:
fxRate(uint256) := weiPerCHF(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
donationCount = totalUnrestrictedAssignments

IRs:
donationCount(uint256) := totalUnrestrictedAssignments(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
totalTokenAmount = totalUnrestrictedTokens

IRs:
totalTokenAmount(uint256) := totalUnrestrictedTokens(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
donationRound == 0

IRs:
TMP_196(bool) = donationRound == 0
CONDITION TMP_196"];
8->9[label="True"];
8->13[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
startTime = getPhaseStartTime(phaseOfRound0)

IRs:
TMP_197(uint256) = INTERNAL_CALL, Phased.getPhaseStartTime(uint256)(phaseOfRound0)
startTime(uint256) := TMP_197(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
endTime = getPhaseStartTime(phaseOfRound0 + 1)

IRs:
TMP_198(uint256) = phaseOfRound0 + 1
TMP_199(uint256) = INTERNAL_CALL, Phased.getPhaseStartTime(uint256)(TMP_198)
endTime(uint256) := TMP_199(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isTargetReached = targetReached(phaseOfRound0)

IRs:
TMP_200(bool) = INTERNAL_CALL, Targets.targetReached(uint256)(phaseOfRound0)
isTargetReached(bool) := TMP_200(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
chfCentsDonated = counter[phaseOfRound0]

IRs:
REF_85(uint256) -> counter[phaseOfRound0]
chfCentsDonated(uint256) := REF_85(uint256)"];
12->17;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
startTime = getPhaseStartTime(phaseOfRound1)

IRs:
TMP_201(uint256) = INTERNAL_CALL, Phased.getPhaseStartTime(uint256)(phaseOfRound1)
startTime(uint256) := TMP_201(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
endTime = getPhaseStartTime(phaseOfRound1 + 1)

IRs:
TMP_202(uint256) = phaseOfRound1 + 1
TMP_203(uint256) = INTERNAL_CALL, Phased.getPhaseStartTime(uint256)(TMP_202)
endTime(uint256) := TMP_203(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
isTargetReached = targetReached(phaseOfRound1)

IRs:
TMP_204(bool) = INTERNAL_CALL, Targets.targetReached(uint256)(phaseOfRound1)
isTargetReached(bool) := TMP_204(bool)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
chfCentsDonated = counter[phaseOfRound1]

IRs:
REF_86(uint256) -> counter[phaseOfRound1]
chfCentsDonated(uint256) := REF_86(uint256)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
tokenAmount = tokens[dfnAddr]

IRs:
REF_87(uint256) -> tokens[dfnAddr]
tokenAmount(uint256) := REF_87(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
donated = weiDonated[dfnAddr]

IRs:
REF_88(uint256) -> weiDonated[dfnAddr]
donated(uint256) := REF_88(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
fwdBalance = fwdAddr.balance

IRs:
TMP_205(uint256) = SOLIDITY_CALL balance(address)(fwdAddr)
fwdBalance(uint256) := TMP_205(uint256)"];
20->21;
21[label="Node Type: RETURN 21

EXPRESSION:
(currentState,fxRate,currentMultiplier,donationCount,totalTokenAmount,startTime,endTime,isTargetReached,chfCentsDonated,tokenAmount,fwdBalance,donated)

IRs:
RETURN currentState,fxRate,currentMultiplier,donationCount,totalTokenAmount,startTime,endTime,isTargetReached,chfCentsDonated,tokenAmount,fwdBalance,donated"];
}
// Function: 39705.sol-FDC-getStepFunction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
elapsedTime >= phaseLength

IRs:
TMP_90(bool) = elapsedTime >= phaseLength
CONDITION TMP_90"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
timeLeft = phaseLength - elapsedTime - 1

IRs:
TMP_91(uint256) = phaseLength - elapsedTime
TMP_92(uint256) = TMP_91 - 1
timeLeft(uint256) := TMP_92(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
stepsLeft = ((nSteps + 1) * timeLeft) / phaseLength

IRs:
TMP_93(uint256) = nSteps + 1
TMP_94(uint256) = TMP_93 * timeLeft
TMP_95(uint256) = TMP_94 / phaseLength
stepsLeft(uint256) := TMP_95(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
stepsLeft * step

IRs:
TMP_96(uint256) = stepsLeft * step
RETURN TMP_96"];
}
// Function: 39705.sol-FDC-isPhase(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
time > now

IRs:
TMP_102(bool) = time > now
CONDITION TMP_102"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
n >= N

IRs:
TMP_103(bool) = n >= N
CONDITION TMP_103"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
n > 0 && phaseEndTime[n - 1] > time

IRs:
TMP_104(bool) = n > 0
TMP_105(uint256) = n - 1
REF_39(uint256) -> phaseEndTime[TMP_105]
TMP_106(bool) = REF_39 > time
TMP_107(bool) = TMP_104 && TMP_106
CONDITION TMP_107"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
n < N && time >= phaseEndTime[n]

IRs:
TMP_108(bool) = n < N
REF_40(uint256) -> phaseEndTime[n]
TMP_109(bool) = time >= REF_40
TMP_110(bool) = TMP_108 && TMP_109
CONDITION TMP_110"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
false

IRs:
RETURN False"];
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 39705.sol-FDC-isRegistered(address,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
restricted

IRs:
CONDITION restricted"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
(restrictions[addr] > 0)

IRs:
REF_53(uint256) -> restrictions[addr]
TMP_142(bool) = REF_53 > 0
RETURN TMP_142"];
3[label="Node Type: RETURN 3

EXPRESSION:
(tokens[addr] > 0)

IRs:
REF_54(uint256) -> tokens[addr]
TMP_143(bool) = REF_54 > 0
RETURN TMP_143"];
}
// Function: 39705.sol-FDC-isUnrestricted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(assignmentsClosed && totalRestrictedTokens == 0)

IRs:
TMP_135(bool) = totalRestrictedTokens == 0
TMP_136(bool) = assignmentsClosed && TMP_135
RETURN TMP_136"];
}
// Function: 39705.sol-FDC-multFracCeiling(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_137(bool) = a == 0
CONDITION TMP_137"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(x * a + (b - 1)) / b

IRs:
TMP_138(uint256) = x * a
TMP_139(uint256) = b - 1
TMP_140(uint256) = TMP_138 + TMP_139
TMP_141(uint256) = TMP_140 / b
RETURN TMP_141"];
}
// Function: 39705.sol-FDC-registerEarlyContrib(address,uint256,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != registrarAuth

IRs:
TMP_207(bool) = msg.sender != registrarAuth
CONDITION TMP_207"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
getState() != state.earlyContrib

IRs:
TMP_208(FDC.state) = INTERNAL_CALL, FDC.getState()()
REF_89(FDC.state) -> state.earlyContrib
TMP_209(bool) = TMP_208 != REF_89
CONDITION TMP_209"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
! isRegistered(addr,true)

IRs:
TMP_210(bool) = INTERNAL_CALL, TokenTracker.isRegistered(address,bool)(addr,True)
TMP_211 = UnaryType.BANG TMP_210 
CONDITION TMP_211"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
earlyContribList.push(addr)

IRs:
REF_91 -> LENGTH earlyContribList
TMP_213(uint256) := REF_91(uint256)
TMP_214(uint256) = TMP_213 + 1
REF_91(uint256) (->earlyContribList) := TMP_214(uint256)
REF_92(address) -> earlyContribList[TMP_213]
REF_92(address) (->earlyContribList) := addr(address)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
assign(addr,tokenAmount,true)

IRs:
INTERNAL_CALL, TokenTracker.assign(address,uint256,bool)(addr,tokenAmount,True)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
EarlyContribReceipt(addr,tokenAmount,memo)

IRs:
Emit EarlyContribReceipt(addr,tokenAmount,memo)"];
}
// Function: 39705.sol-FDC-registerOffChainDonation(address,uint256,uint256,string,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != registrarAuth

IRs:
TMP_217(bool) = msg.sender != registrarAuth
CONDITION TMP_217"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
currentPhase = getPhaseAtTime(now)

IRs:
TMP_218(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(now)
currentPhase(uint256) := TMP_218(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
currentState = stateOfPhase[currentPhase]

IRs:
REF_93(FDC.state) -> stateOfPhase[currentPhase]
currentState(FDC.state) := REF_93(FDC.state)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
currentState != state.round0 && currentState != state.round1 && currentState != state.offChainReg

IRs:
REF_94(FDC.state) -> state.round0
TMP_219(bool) = currentState != REF_94
REF_95(FDC.state) -> state.round1
TMP_220(bool) = currentState != REF_95
TMP_221(bool) = TMP_219 && TMP_220
REF_96(FDC.state) -> state.offChainReg
TMP_222(bool) = currentState != REF_96
TMP_223(bool) = TMP_221 && TMP_222
CONDITION TMP_223"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: THROW 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
timestamp > now

IRs:
TMP_224(bool) = timestamp > now
CONDITION TMP_224"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: THROW 10
"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
timestampPhase = getPhaseAtTime(timestamp)

IRs:
TMP_225(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(timestamp)
timestampPhase(uint256) := TMP_225(uint256)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
timestampState = stateOfPhase[timestampPhase]

IRs:
REF_97(FDC.state) -> stateOfPhase[timestampPhase]
timestampState(FDC.state) := REF_97(FDC.state)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
(currentState == state.round0 || currentState == state.round1) && (timestampState != currentState)

IRs:
REF_98(FDC.state) -> state.round0
TMP_226(bool) = currentState == REF_98
REF_99(FDC.state) -> state.round1
TMP_227(bool) = currentState == REF_99
TMP_228(bool) = TMP_226 || TMP_227
TMP_229(bool) = timestampState != currentState
TMP_230(bool) = TMP_228 && TMP_229
CONDITION TMP_230"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: THROW 15
"];
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
currentState == state.offChainReg && timestampPhase != currentPhase - 1

IRs:
REF_100(FDC.state) -> state.offChainReg
TMP_231(bool) = currentState == REF_100
TMP_232(uint256) = currentPhase - 1
TMP_233(bool) = timestampPhase != TMP_232
TMP_234(bool) = TMP_231 && TMP_233
CONDITION TMP_234"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: THROW 18
"];
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
memoUsed[memo]

IRs:
REF_101(bool) -> memoUsed[memo]
CONDITION REF_101"];
20->21[label="True"];
20->22[label="False"];
21[label="Node Type: THROW 21
"];
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
memoUsed[memo] = true

IRs:
REF_102(bool) -> memoUsed[memo]
REF_102(bool) (->memoUsed) := True(bool)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
bookDonation(addr,timestamp,chfCents,currency,memo)

IRs:
INTERNAL_CALL, FDC.bookDonation(address,uint256,uint256,string,bytes32)(addr,timestamp,chfCents,currency,memo)"];
}
// Function: 39705.sol-FDC-setExchangeRateAuth(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != masterAuth

IRs:
TMP_246(bool) = msg.sender != masterAuth
CONDITION TMP_246"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
exchangeRateAuth = newAuth

IRs:
exchangeRateAuth(address) := newAuth(address)"];
}
// Function: 39705.sol-FDC-setFoundationWallet(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != masterAuth

IRs:
TMP_243(bool) = msg.sender != masterAuth
CONDITION TMP_243"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
getPhaseAtTime(now) >= phaseOfRound0

IRs:
TMP_244(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(now)
TMP_245(bool) = TMP_244 >= phaseOfRound0
CONDITION TMP_245"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
foundationWallet = newAddr

IRs:
foundationWallet(address) := newAddr(address)"];
}
// Function: 39705.sol-FDC-setMasterAuth(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != masterAuth

IRs:
TMP_248(bool) = msg.sender != masterAuth
CONDITION TMP_248"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
masterAuth = newAuth

IRs:
masterAuth(address) := newAuth(address)"];
}
// Function: 39705.sol-FDC-setMaxDelay(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
i >= N

IRs:
TMP_122(bool) = i >= N
CONDITION TMP_122"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
maxDelay[i] = timeDelta

IRs:
REF_46(uint256) -> maxDelay[i]
REF_46(uint256) (->maxDelay) := timeDelta(uint256)"];
}
// Function: 39705.sol-FDC-setRegistrarAuth(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != masterAuth

IRs:
TMP_247(bool) = msg.sender != masterAuth
CONDITION TMP_247"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
registrarAuth = newAuth

IRs:
registrarAuth(address) := newAuth(address)"];
}
// Function: 39705.sol-FDC-setTarget(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
target[id] = _target

IRs:
REF_32(uint256) -> target[id]
REF_32(uint256) (->target) := _target(uint256)"];
}
// Function: 39705.sol-FDC-setWeiPerCHF(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != exchangeRateAuth

IRs:
TMP_206(bool) = msg.sender != exchangeRateAuth
CONDITION TMP_206"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
weiPerCHF = weis

IRs:
weiPerCHF(uint256) := weis(uint256)"];
}
// Function: 39705.sol-FDC-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
assignmentsClosed = false

IRs:
assignmentsClosed(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
round0StartTime = 1484676000

IRs:
round0StartTime(uint256) := 1484676000(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
round1StartTime = 1495040400

IRs:
round1StartTime(uint256) := 1495040400(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
round0EndTime = round0StartTime + 3628800

IRs:
TMP_281(uint256) = round0StartTime + 3628800
round0EndTime(uint256) := TMP_281(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
round1EndTime = round1StartTime + 3628800

IRs:
TMP_282(uint256) = round1StartTime + 3628800
round1EndTime(uint256) := TMP_282(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
finalizeStartTime = round1EndTime + 604800

IRs:
TMP_283(uint256) = round1EndTime + 604800
finalizeStartTime(uint256) := TMP_283(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
finalizeEndTime = finalizeStartTime + 220752000000

IRs:
TMP_284(uint256) = finalizeStartTime + 220752000000
finalizeEndTime(uint256) := TMP_284(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
maxRoundDelay = 23328000

IRs:
maxRoundDelay(uint256) := 23328000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
gracePeriodAfterRound0Target = 86400

IRs:
gracePeriodAfterRound0Target(uint256) := 86400(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
gracePeriodAfterRound1Target = 0

IRs:
gracePeriodAfterRound1Target(uint256) := 0(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
tokensPerCHF = 10

IRs:
tokensPerCHF(uint256) := 10(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
minDonation = 1000000000000000000

IRs:
minDonation(uint256) := 1000000000000000000(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
round0Bonus = 200

IRs:
round0Bonus(uint256) := 200(uint256)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
round1InitialBonus = 25

IRs:
round1InitialBonus(uint256) := 25(uint256)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
round1BonusSteps = 5

IRs:
round1BonusSteps(uint256) := 5(uint256)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
millionInCents = 10 ** 6 * 100

IRs:
TMP_285(uint256) = 10 ** 6
TMP_286(uint256) = TMP_285 * 100
millionInCents(uint256) := TMP_286(uint256)"];
15->16;
16[label="Node Type: OTHER_ENTRYPOINT 16

EXPRESSION:
round0Target = 1 * millionInCents

IRs:
TMP_287(uint256) = 1 * millionInCents
round0Target(uint256) := TMP_287(uint256)"];
16->17;
17[label="Node Type: OTHER_ENTRYPOINT 17

EXPRESSION:
round1Target = 20 * millionInCents

IRs:
TMP_288(uint256) = 20 * millionInCents
round1Target(uint256) := TMP_288(uint256)"];
17->18;
18[label="Node Type: OTHER_ENTRYPOINT 18

EXPRESSION:
earlyContribShare = 22

IRs:
earlyContribShare(uint256) := 22(uint256)"];
}
// Function: 39705.sol-FDC-targetReached(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(counter[id] >= target[id])

IRs:
REF_30(uint256) -> counter[id]
REF_31(uint256) -> target[id]
TMP_81(bool) = REF_30 >= REF_31
RETURN TMP_81"];
}
// Function: 39705.sol-FDC-unrestrict(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assignmentsClosed

IRs:
TMP_150 = UnaryType.BANG assignmentsClosed 
CONDITION TMP_150"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
restrictionsForAddr = restrictions[addr]

IRs:
REF_57(uint256) -> restrictions[addr]
restrictionsForAddr(uint256) := REF_57(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
restrictionsForAddr == 0

IRs:
TMP_151(bool) = restrictionsForAddr == 0
CONDITION TMP_151"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
burn = multFracCeiling(restrictionsForAddr,burnMultNom,burnMultDen)

IRs:
TMP_152(uint256) = INTERNAL_CALL, TokenTracker.multFracCeiling(uint256,uint256,uint256)(restrictionsForAddr,burnMultNom,burnMultDen)
burn(uint256) := TMP_152(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
tokens[addr] -= burn

IRs:
REF_58(uint256) -> tokens[addr]
REF_58(-> tokens) = REF_58 - burn"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
delete restrictions[addr]

IRs:
REF_59(uint256) -> restrictions[addr]
restrictions = delete REF_59 "];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
totalRestrictedTokens -= restrictionsForAddr

IRs:
totalRestrictedTokens(uint256) = totalRestrictedTokens - restrictionsForAddr"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
totalUnrestrictedTokens += restrictionsForAddr - burn

IRs:
TMP_153(uint256) = restrictionsForAddr - burn
totalUnrestrictedTokens(uint256) = totalUnrestrictedTokens + TMP_153"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
burn

IRs:
RETURN burn"];
}
// Function: 39705.sol-Parameters-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
round0StartTime = 1484676000

IRs:
round0StartTime(uint256) := 1484676000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
round1StartTime = 1495040400

IRs:
round1StartTime(uint256) := 1495040400(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
round0EndTime = round0StartTime + 3628800

IRs:
TMP_73(uint256) = round0StartTime + 3628800
round0EndTime(uint256) := TMP_73(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
round1EndTime = round1StartTime + 3628800

IRs:
TMP_74(uint256) = round1StartTime + 3628800
round1EndTime(uint256) := TMP_74(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
finalizeStartTime = round1EndTime + 604800

IRs:
TMP_75(uint256) = round1EndTime + 604800
finalizeStartTime(uint256) := TMP_75(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
finalizeEndTime = finalizeStartTime + 220752000000

IRs:
TMP_76(uint256) = finalizeStartTime + 220752000000
finalizeEndTime(uint256) := TMP_76(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
maxRoundDelay = 23328000

IRs:
maxRoundDelay(uint256) := 23328000(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
gracePeriodAfterRound0Target = 86400

IRs:
gracePeriodAfterRound0Target(uint256) := 86400(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
gracePeriodAfterRound1Target = 0

IRs:
gracePeriodAfterRound1Target(uint256) := 0(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
tokensPerCHF = 10

IRs:
tokensPerCHF(uint256) := 10(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
minDonation = 1000000000000000000

IRs:
minDonation(uint256) := 1000000000000000000(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
round0Bonus = 200

IRs:
round0Bonus(uint256) := 200(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
round1InitialBonus = 25

IRs:
round1InitialBonus(uint256) := 25(uint256)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
round1BonusSteps = 5

IRs:
round1BonusSteps(uint256) := 5(uint256)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
millionInCents = 10 ** 6 * 100

IRs:
TMP_77(uint256) = 10 ** 6
TMP_78(uint256) = TMP_77 * 100
millionInCents(uint256) := TMP_78(uint256)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
round0Target = 1 * millionInCents

IRs:
TMP_79(uint256) = 1 * millionInCents
round0Target(uint256) := TMP_79(uint256)"];
15->16;
16[label="Node Type: OTHER_ENTRYPOINT 16

EXPRESSION:
round1Target = 20 * millionInCents

IRs:
TMP_80(uint256) = 20 * millionInCents
round1Target(uint256) := TMP_80(uint256)"];
16->17;
17[label="Node Type: OTHER_ENTRYPOINT 17

EXPRESSION:
earlyContribShare = 22

IRs:
earlyContribShare(uint256) := 22(uint256)"];
}
// Function: 39705.sol-Phased-addPhase(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
N > 0 && time <= phaseEndTime[N - 1]

IRs:
TMP_36(bool) = N > 0
TMP_37(uint256) = N - 1
REF_11(uint256) -> phaseEndTime[TMP_37]
TMP_38(bool) = time <= REF_11
TMP_39(bool) = TMP_36 && TMP_38
CONDITION TMP_39"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
time <= now

IRs:
TMP_40(bool) = time <= now
CONDITION TMP_40"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
phaseEndTime.push(time)

IRs:
REF_13 -> LENGTH phaseEndTime
TMP_42(uint256) := REF_13(uint256)
TMP_43(uint256) = TMP_42 + 1
REF_13(uint256) (->phaseEndTime) := TMP_43(uint256)
REF_14(uint256) -> phaseEndTime[TMP_42]
REF_14(uint256) (->phaseEndTime) := time(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
N ++

IRs:
TMP_44(uint256) := N(uint256)
N(uint256) = N + 1"];
}
// Function: 39705.sol-Phased-delayPhaseEndBy(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
n >= N

IRs:
TMP_46(bool) = n >= N
CONDITION TMP_46"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
now >= phaseEndTime[n]

IRs:
REF_16(uint256) -> phaseEndTime[n]
TMP_47(bool) = now >= REF_16
CONDITION TMP_47"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
timeDelta > maxDelay[n]

IRs:
REF_17(uint256) -> maxDelay[n]
TMP_48(bool) = timeDelta > REF_17
CONDITION TMP_48"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: THROW 8
"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
maxDelay[n] -= timeDelta

IRs:
REF_18(uint256) -> maxDelay[n]
REF_18(-> maxDelay) = REF_18 - timeDelta"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = n

IRs:
i(uint256) := n(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < N

IRs:
TMP_49(bool) = i < N
CONDITION TMP_49"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
phaseEndTime[i] += timeDelta

IRs:
REF_19(uint256) -> phaseEndTime[i]
REF_19(-> phaseEndTime) = REF_19 + timeDelta"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_50(uint256) := i(uint256)
i(uint256) = i + 1"];
16->14;
}
// Function: 39705.sol-Phased-endCurrentPhaseIn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
n = getPhaseAtTime(now)

IRs:
TMP_51(uint256) = INTERNAL_CALL, Phased.getPhaseAtTime(uint256)(now)
n(uint256) := TMP_51(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
n >= N

IRs:
TMP_52(bool) = n >= N
CONDITION TMP_52"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: THROW 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
timeDelta == 0

IRs:
TMP_53(bool) = timeDelta == 0
CONDITION TMP_53"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
timeDelta = 1

IRs:
timeDelta(uint256) := 1(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
now + timeDelta < phaseEndTime[n]

IRs:
TMP_54(uint256) = now + timeDelta
REF_20(uint256) -> phaseEndTime[n]
TMP_55(bool) = TMP_54 < REF_20
CONDITION TMP_55"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
phaseEndTime[n] = now + timeDelta

IRs:
REF_21(uint256) -> phaseEndTime[n]
TMP_56(uint256) = now + timeDelta
REF_21(uint256) (->phaseEndTime) := TMP_56(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 39705.sol-Phased-getPhaseAtTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
time > now

IRs:
TMP_20(bool) = time > now
CONDITION TMP_20"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: BEGIN_LOOP 4
"];
4->5;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
n < N && phaseEndTime[n] <= time

IRs:
TMP_21(bool) = n < N
REF_7(uint256) -> phaseEndTime[n]
TMP_22(bool) = REF_7 <= time
TMP_23(bool) = TMP_21 && TMP_22
CONDITION TMP_23"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
n ++

IRs:
TMP_24(uint256) := n(uint256)
n(uint256) = n + 1"];
6->5;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
n

IRs:
RETURN n"];
}
// Function: 39705.sol-Phased-getPhaseStartTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
n == 0

IRs:
TMP_34(bool) = n == 0
CONDITION TMP_34"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
phaseEndTime[n - 1]

IRs:
TMP_35(uint256) = n - 1
REF_10(uint256) -> phaseEndTime[TMP_35]
RETURN REF_10"];
}
// Function: 39705.sol-Phased-isPhase(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
time > now

IRs:
TMP_25(bool) = time > now
CONDITION TMP_25"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
n >= N

IRs:
TMP_26(bool) = n >= N
CONDITION TMP_26"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
n > 0 && phaseEndTime[n - 1] > time

IRs:
TMP_27(bool) = n > 0
TMP_28(uint256) = n - 1
REF_8(uint256) -> phaseEndTime[TMP_28]
TMP_29(bool) = REF_8 > time
TMP_30(bool) = TMP_27 && TMP_29
CONDITION TMP_30"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
n < N && time >= phaseEndTime[n]

IRs:
TMP_31(bool) = n < N
REF_9(uint256) -> phaseEndTime[n]
TMP_32(bool) = time >= REF_9
TMP_33(bool) = TMP_31 && TMP_32
CONDITION TMP_33"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
false

IRs:
RETURN False"];
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 39705.sol-Phased-setMaxDelay(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
i >= N

IRs:
TMP_45(bool) = i >= N
CONDITION TMP_45"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
maxDelay[i] = timeDelta

IRs:
REF_15(uint256) -> maxDelay[i]
REF_15(uint256) (->maxDelay) := timeDelta(uint256)"];
}
// Function: 39705.sol-StepFunction-StepFunction(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_nSteps > _phaseLength

IRs:
TMP_57(bool) = _nSteps > _phaseLength
CONDITION TMP_57"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
step = _initialValue / _nSteps

IRs:
TMP_58(uint256) = _initialValue / _nSteps
step(uint256) := TMP_58(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
step * _nSteps != _initialValue

IRs:
TMP_59(uint256) = step * _nSteps
TMP_60(bool) = TMP_59 != _initialValue
CONDITION TMP_60"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
phaseLength = _phaseLength

IRs:
phaseLength(uint256) := _phaseLength(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
nSteps = _nSteps

IRs:
nSteps(uint256) := _nSteps(uint256)"];
}
// Function: 39705.sol-StepFunction-getStepFunction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
elapsedTime >= phaseLength

IRs:
TMP_61(bool) = elapsedTime >= phaseLength
CONDITION TMP_61"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
timeLeft = phaseLength - elapsedTime - 1

IRs:
TMP_62(uint256) = phaseLength - elapsedTime
TMP_63(uint256) = TMP_62 - 1
timeLeft(uint256) := TMP_63(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
stepsLeft = ((nSteps + 1) * timeLeft) / phaseLength

IRs:
TMP_64(uint256) = nSteps + 1
TMP_65(uint256) = TMP_64 * timeLeft
TMP_66(uint256) = TMP_65 / phaseLength
stepsLeft(uint256) := TMP_66(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
stepsLeft * step

IRs:
TMP_67(uint256) = stepsLeft * step
RETURN TMP_67"];
}
// Function: 39705.sol-Targets-addTowardsTarget(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
firstReached = (counter[id] < target[id]) && (counter[id] + amount >= target[id])

IRs:
REF_25(uint256) -> counter[id]
REF_26(uint256) -> target[id]
TMP_69(bool) = REF_25 < REF_26
REF_27(uint256) -> counter[id]
TMP_70(uint256) = REF_27 + amount
REF_28(uint256) -> target[id]
TMP_71(bool) = TMP_70 >= REF_28
TMP_72(bool) = TMP_69 && TMP_71
firstReached(bool) := TMP_72(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
counter[id] += amount

IRs:
REF_29(uint256) -> counter[id]
REF_29(-> counter) = REF_29 + amount"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
firstReached

IRs:
RETURN firstReached"];
}
// Function: 39705.sol-Targets-setTarget(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
target[id] = _target

IRs:
REF_24(uint256) -> target[id]
REF_24(uint256) (->target) := _target(uint256)"];
}
// Function: 39705.sol-Targets-targetReached(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(counter[id] >= target[id])

IRs:
REF_22(uint256) -> counter[id]
REF_23(uint256) -> target[id]
TMP_68(bool) = REF_22 >= REF_23
RETURN TMP_68"];
}
// Function: 39705.sol-TokenTracker-TokenTracker(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_restrictedShare >= 100

IRs:
TMP_0(bool) = _restrictedShare >= 100
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
restrictedShare = _restrictedShare

IRs:
restrictedShare(uint256) := _restrictedShare(uint256)"];
}
// Function: 39705.sol-TokenTracker-assign(address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
assignmentsClosed

IRs:
CONDITION assignmentsClosed"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokens[addr] += tokenAmount

IRs:
REF_2(uint256) -> tokens[addr]
REF_2(-> tokens) = REF_2 + tokenAmount"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
restricted

IRs:
CONDITION restricted"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalRestrictedTokens += tokenAmount

IRs:
totalRestrictedTokens(uint256) = totalRestrictedTokens + tokenAmount"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
totalRestrictedAssignments += 1

IRs:
totalRestrictedAssignments(uint256) = totalRestrictedAssignments + 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
restrictions[addr] += tokenAmount

IRs:
REF_3(uint256) -> restrictions[addr]
REF_3(-> restrictions) = REF_3 + tokenAmount"];
8->11;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalUnrestrictedTokens += tokenAmount

IRs:
totalUnrestrictedTokens(uint256) = totalUnrestrictedTokens + tokenAmount"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
totalUnrestrictedAssignments += 1

IRs:
totalUnrestrictedAssignments(uint256) = totalUnrestrictedAssignments + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
}
// Function: 39705.sol-TokenTracker-closeAssignmentsIfOpen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
assignmentsClosed

IRs:
CONDITION assignmentsClosed"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assignmentsClosed = true

IRs:
assignmentsClosed(bool) := True(bool)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
totalTokensTarget = (totalUnrestrictedTokens * 100) / (100 - restrictedShare)

IRs:
TMP_10(uint256) = totalUnrestrictedTokens * 100
TMP_11(uint256) = 100 - restrictedShare
TMP_12(uint256) = TMP_10 / TMP_11
totalTokensTarget(uint256) := TMP_12(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
totalTokensExisting = totalRestrictedTokens + totalUnrestrictedTokens

IRs:
TMP_13(uint256) = totalRestrictedTokens + totalUnrestrictedTokens
totalTokensExisting(uint256) := TMP_13(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
totalBurn = 0

IRs:
totalBurn(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
totalTokensExisting > totalTokensTarget

IRs:
TMP_14(bool) = totalTokensExisting > totalTokensTarget
CONDITION TMP_14"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalBurn = totalTokensExisting - totalTokensTarget

IRs:
TMP_15(uint256) = totalTokensExisting - totalTokensTarget
totalBurn(uint256) := TMP_15(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
burnMultNom = totalBurn

IRs:
burnMultNom(uint256) := totalBurn(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
burnMultDen = totalRestrictedTokens

IRs:
burnMultDen(uint256) := totalRestrictedTokens(uint256)"];
}
// Function: 39705.sol-TokenTracker-isRegistered(address,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
restricted

IRs:
CONDITION restricted"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
(restrictions[addr] > 0)

IRs:
REF_0(uint256) -> restrictions[addr]
TMP_8(bool) = REF_0 > 0
RETURN TMP_8"];
3[label="Node Type: RETURN 3

EXPRESSION:
(tokens[addr] > 0)

IRs:
REF_1(uint256) -> tokens[addr]
TMP_9(bool) = REF_1 > 0
RETURN TMP_9"];
}
// Function: 39705.sol-TokenTracker-isUnrestricted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(assignmentsClosed && totalRestrictedTokens == 0)

IRs:
TMP_1(bool) = totalRestrictedTokens == 0
TMP_2(bool) = assignmentsClosed && TMP_1
RETURN TMP_2"];
}
// Function: 39705.sol-TokenTracker-multFracCeiling(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_3(bool) = a == 0
CONDITION TMP_3"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(x * a + (b - 1)) / b

IRs:
TMP_4(uint256) = x * a
TMP_5(uint256) = b - 1
TMP_6(uint256) = TMP_4 + TMP_5
TMP_7(uint256) = TMP_6 / b
RETURN TMP_7"];
}
// Function: 39705.sol-TokenTracker-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
assignmentsClosed = false

IRs:
assignmentsClosed(bool) := False(bool)"];
}
// Function: 39705.sol-TokenTracker-unrestrict(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assignmentsClosed

IRs:
TMP_16 = UnaryType.BANG assignmentsClosed 
CONDITION TMP_16"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
restrictionsForAddr = restrictions[addr]

IRs:
REF_4(uint256) -> restrictions[addr]
restrictionsForAddr(uint256) := REF_4(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
restrictionsForAddr == 0

IRs:
TMP_17(bool) = restrictionsForAddr == 0
CONDITION TMP_17"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
burn = multFracCeiling(restrictionsForAddr,burnMultNom,burnMultDen)

IRs:
TMP_18(uint256) = INTERNAL_CALL, TokenTracker.multFracCeiling(uint256,uint256,uint256)(restrictionsForAddr,burnMultNom,burnMultDen)
burn(uint256) := TMP_18(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
tokens[addr] -= burn

IRs:
REF_5(uint256) -> tokens[addr]
REF_5(-> tokens) = REF_5 - burn"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
delete restrictions[addr]

IRs:
REF_6(uint256) -> restrictions[addr]
restrictions = delete REF_6 "];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
totalRestrictedTokens -= restrictionsForAddr

IRs:
totalRestrictedTokens(uint256) = totalRestrictedTokens - restrictionsForAddr"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
totalUnrestrictedTokens += restrictionsForAddr - burn

IRs:
TMP_19(uint256) = restrictionsForAddr - burn
totalUnrestrictedTokens(uint256) = totalUnrestrictedTokens + TMP_19"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
burn

IRs:
RETURN burn"];
}
}
