digraph G {
// Function: 39994.sol-Base-Base()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 39994.sol-Base-canEnter()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-Base-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ChangedOwner(msg.sender,owner)

IRs:
Emit ChangedOwner(msg.sender,owner)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Base.onlyOwner()()"];
4->1;
}
// Function: 39994.sol-Base-contractBalance()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
RETURN REF_0"];
}
// Function: 39994.sol-Base-noReentry()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-Base-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_6(bool) = msg.sender != owner
CONDITION TMP_6"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-Base-preventReentry()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
mutex = true

IRs:
mutex(bool) := True(bool)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: _ 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
delete mutex

IRs:
mutex = delete mutex "];
6->7;
7[label="Node Type: RETURN 7
"];
}
// Function: 39994.sol-Base-safeSend(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
! _recipient.call.value(_ether)()

IRs:
TMP_3(bool) = LOW_LEVEL_CALL, dest:_recipient, function:call, arguments:[] value:_ether 
TMP_4 = UnaryType.BANG TMP_3 
CONDITION TMP_4"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
success_ = true

IRs:
success_(bool) := True(bool)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
preventReentry()

IRs:
MODIFIER_CALL, Base.preventReentry()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success_

IRs:
RETURN success_"];
}
// Function: 39994.sol-Base-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = Base 0.1.1 


IRs:
VERSION(string) := Base 0.1.1 
(string)"];
}
// Function: 39994.sol-Base-version()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
VERSION

IRs:
RETURN VERSION"];
}
// Function: 39994.sol-ERC20Interface-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1


IRs:
VERSION(string) := ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1
(string)"];
}
// Function: 39994.sol-ERC20Token-Base()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 39994.sol-ERC20Token-ERC20Token(uint256,uint8,string,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = _supply

IRs:
totalSupply(uint256) := _supply(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
decimalPlaces = _decimalPlaces

IRs:
decimalPlaces(uint8) := _decimalPlaces(uint8)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balance[msg.sender] = totalSupply

IRs:
REF_6(uint256) -> balance[msg.sender]
REF_6(uint256) (->balance) := totalSupply(uint256)"];
}
// Function: 39994.sol-ERC20Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
balance[msg.sender] == 0

IRs:
REF_20(uint256) -> balance[msg.sender]
TMP_72(bool) = REF_20 == 0
CONDITION TMP_72"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowance[msg.sender][_spender] = _value

IRs:
REF_21(mapping(address => uint256)) -> allowance[msg.sender]
REF_22(uint256) -> REF_21[_spender]
REF_22(uint256) (->allowance) := _value(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canEnter()

IRs:
MODIFIER_CALL, Base.canEnter()()"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39994.sol-ERC20Token-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_32 = UnaryType.BANG assertion 
CONDITION TMP_32"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39994.sol-ERC20Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance[_addr]

IRs:
REF_7(uint256) -> balance[_addr]
RETURN REF_7"];
}
// Function: 39994.sol-ERC20Token-canEnter()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ERC20Token-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ChangedOwner(msg.sender,owner)

IRs:
Emit ChangedOwner(msg.sender,owner)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Base.onlyOwner()()"];
4->1;
}
// Function: 39994.sol-ERC20Token-cmp(uint256,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(a != b) && ((a < b) != _sym)

IRs:
TMP_33(bool) = a != b
TMP_34(bool) = a < b
TMP_35(bool) = TMP_34 != _sym
TMP_36(bool) = TMP_33 && TMP_35
RETURN TMP_36"];
}
// Function: 39994.sol-ERC20Token-cmpEq(uint256,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(a == b) || ((a < b) != _sym)

IRs:
TMP_37(bool) = a == b
TMP_38(bool) = a < b
TMP_39(bool) = TMP_38 != _sym
TMP_40(bool) = TMP_37 || TMP_39
RETURN TMP_40"];
}
// Function: 39994.sol-ERC20Token-contractBalance()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
this.balance

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
RETURN REF_3"];
}
// Function: 39994.sol-ERC20Token-isAllowed(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount > allowance[_from][msg.sender] || _amount > balance[_from]

IRs:
REF_24(mapping(address => uint256)) -> allowance[_from]
REF_25(uint256) -> REF_24[msg.sender]
TMP_79(bool) = _amount > REF_25
REF_26(uint256) -> balance[_from]
TMP_80(bool) = _amount > REF_26
TMP_81(bool) = TMP_79 || TMP_80
CONDITION TMP_81"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ERC20Token-isAvailable(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount > balance[msg.sender]

IRs:
REF_23(uint256) -> balance[msg.sender]
TMP_78(bool) = _amount > REF_23
CONDITION TMP_78"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ERC20Token-noReentry()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ERC20Token-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_77(bool) = msg.sender != owner
CONDITION TMP_77"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ERC20Token-preventReentry()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
mutex = true

IRs:
mutex(bool) := True(bool)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: _ 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
delete mutex

IRs:
mutex = delete mutex "];
6->7;
7[label="Node Type: RETURN 7
"];
}
// Function: 39994.sol-ERC20Token-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_50(uint256) = a + b
c(uint256) := TMP_50(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_51(bool) = c >= a
TMP_52(bool) = c >= b
TMP_53(bool) = TMP_51 && TMP_52
INTERNAL_CALL, Math.assert(bool)(TMP_53)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39994.sol-ERC20Token-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_41(uint256) = a * b
c(uint256) := TMP_41(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_42(bool) = a == 0
TMP_43(uint256) = c / a
TMP_44(bool) = TMP_43 == b
TMP_45(bool) = TMP_42 || TMP_44
INTERNAL_CALL, Math.assert(bool)(TMP_45)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39994.sol-ERC20Token-safeSend(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
! _recipient.call.value(_ether)()

IRs:
TMP_58(bool) = LOW_LEVEL_CALL, dest:_recipient, function:call, arguments:[] value:_ether 
TMP_59 = UnaryType.BANG TMP_58 
CONDITION TMP_59"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
success_ = true

IRs:
success_(bool) := True(bool)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
preventReentry()

IRs:
MODIFIER_CALL, Base.preventReentry()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success_

IRs:
RETURN success_"];
}
// Function: 39994.sol-ERC20Token-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_47(bool) = b <= a
INTERNAL_CALL, Math.assert(bool)(TMP_47)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_49(uint256) = a - b
RETURN TMP_49"];
}
// Function: 39994.sol-ERC20Token-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1


IRs:
VERSION(string) := ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1
(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
NULL = 0

IRs:
NULL(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
LT = false

IRs:
LT(bool) := False(bool)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
GT = true

IRs:
GT(bool) := True(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
iTRUE = 1

IRs:
iTRUE(uint256) := 1(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
iFALSE = 0

IRs:
iFALSE(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
iPOS = 1

IRs:
iPOS(uint256) := 1(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
iZERO = 0

IRs:
iZERO(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
iNEG = uint256(- 1)

IRs:
TMP_75(uint256) = 0 - 1
TMP_76 = CONVERT TMP_75 to uint256
iNEG(uint256) := TMP_76(uint256)"];
}
// Function: 39994.sol-ERC20Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balance[msg.sender] = safeSub(balance[msg.sender],_value)

IRs:
REF_8(uint256) -> balance[msg.sender]
REF_9(uint256) -> balance[msg.sender]
TMP_61(uint256) = INTERNAL_CALL, Math.safeSub(uint256,uint256)(REF_9,_value)
REF_8(uint256) (->balance) := TMP_61(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance[_to] = safeAdd(balance[_to],_value)

IRs:
REF_10(uint256) -> balance[_to]
REF_11(uint256) -> balance[_to]
TMP_62(uint256) = INTERNAL_CALL, Math.safeAdd(uint256,uint256)(REF_11,_value)
REF_10(uint256) (->balance) := TMP_62(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canEnter()

IRs:
MODIFIER_CALL, Base.canEnter()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
isAvailable(_value)

IRs:
MODIFIER_CALL, ERC20Token.isAvailable(uint256)(_value)"];
6->1;
}
// Function: 39994.sol-ERC20Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balance[_from] = safeSub(balance[_from],_value)

IRs:
REF_12(uint256) -> balance[_from]
REF_13(uint256) -> balance[_from]
TMP_66(uint256) = INTERNAL_CALL, Math.safeSub(uint256,uint256)(REF_13,_value)
REF_12(uint256) (->balance) := TMP_66(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance[_to] = safeAdd(balance[_to],_value)

IRs:
REF_14(uint256) -> balance[_to]
REF_15(uint256) -> balance[_to]
TMP_67(uint256) = INTERNAL_CALL, Math.safeAdd(uint256,uint256)(REF_15,_value)
REF_14(uint256) (->balance) := TMP_67(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value)

IRs:
REF_16(mapping(address => uint256)) -> allowance[_from]
REF_17(uint256) -> REF_16[msg.sender]
REF_18(mapping(address => uint256)) -> allowance[_from]
REF_19(uint256) -> REF_18[msg.sender]
TMP_68(uint256) = INTERNAL_CALL, Math.safeSub(uint256,uint256)(REF_19,_value)
REF_17(uint256) (->allowance) := TMP_68(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
canEnter()

IRs:
MODIFIER_CALL, Base.canEnter()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isAllowed(_from,_value)

IRs:
MODIFIER_CALL, ERC20Token.isAllowed(address,uint256)(_from,_value)"];
7->1;
}
// Function: 39994.sol-ERC20Token-version()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
VERSION

IRs:
RETURN VERSION"];
}
// Function: 39994.sol-ITT-Base()
digraph{
}
// Function: 39994.sol-ITT-ERC20Token(uint256,uint8,string,string)
digraph{
}
// Function: 39994.sol-ITT-ITT(uint256,uint8,string,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
priceBook.cll[HEAD][PREV] = MINPRICE

IRs:
REF_40(mapping(uint256 => mapping(bool => uint256))) -> priceBook.cll
REF_41(mapping(bool => uint256)) -> REF_40[HEAD]
REF_42(uint256) -> REF_41[PREV]
REF_42(uint256) (->priceBook) := MINPRICE(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
priceBook.cll[MINPRICE][PREV] = MAXNUM

IRs:
REF_43(mapping(uint256 => mapping(bool => uint256))) -> priceBook.cll
REF_44(mapping(bool => uint256)) -> REF_43[MINPRICE]
REF_45(uint256) -> REF_44[PREV]
REF_45(uint256) (->priceBook) := MAXNUM(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
priceBook.cll[HEAD][NEXT] = MAXNUM

IRs:
REF_46(mapping(uint256 => mapping(bool => uint256))) -> priceBook.cll
REF_47(mapping(bool => uint256)) -> REF_46[HEAD]
REF_48(uint256) -> REF_47[NEXT]
REF_48(uint256) (->priceBook) := MAXNUM(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
priceBook.cll[MAXNUM][NEXT] = MINPRICE

IRs:
REF_49(mapping(uint256 => mapping(bool => uint256))) -> priceBook.cll
REF_50(mapping(bool => uint256)) -> REF_49[MAXNUM]
REF_51(uint256) -> REF_50[NEXT]
REF_51(uint256) (->priceBook) := MINPRICE(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
trading = true

IRs:
trading(bool) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balance[owner] = totalSupply

IRs:
REF_52(uint256) -> balance[owner]
REF_52(uint256) (->balance) := totalSupply(uint256)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ERC20Token(_totalSupply,_decimalPlaces,_symbol,_name)

IRs:
INTERNAL_CALL, ERC20Token.ERC20Token(uint256,uint8,string,string)(_totalSupply,_decimalPlaces,_symbol,_name)"];
7->1;
}
// Function: 39994.sol-ITT-approve(address,uint256)
digraph{
}
// Function: 39994.sol-ITT-assert(bool)
digraph{
}
// Function: 39994.sol-ITT-balanceOf(address)
digraph{
}
// Function: 39994.sol-ITT-buy(uint256,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
trade(_bidPrice,_amount,BID,_make)

IRs:
INTERNAL_CALL, ITT.trade(uint256,uint256,bool,bool)(_bidPrice,_amount,BID,_make)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
canEnter()

IRs:
MODIFIER_CALL, Base.canEnter()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isTrading()

IRs:
MODIFIER_CALL, ITT.isTrading()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isValidBuy(_bidPrice,_amount)

IRs:
MODIFIER_CALL, ITT.isValidBuy(uint256,uint256)(_bidPrice,_amount)"];
5->1;
}
// Function: 39994.sol-ITT-canEnter()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-cancel(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tmsg.price = _price

IRs:
REF_85(uint256) -> tmsg.price
REF_85(uint256) (->tmsg) := _price(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tmsg.balance = balance[msg.sender]

IRs:
REF_86(uint256) -> tmsg.balance
REF_87(uint256) -> balance[msg.sender]
REF_86(uint256) (->tmsg) := REF_87(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tmsg.etherBalance = etherBalance[msg.sender]

IRs:
REF_88(uint256) -> tmsg.etherBalance
REF_89(uint256) -> etherBalance[msg.sender]
REF_88(uint256) (->tmsg) := REF_89(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5
"];
5->6;
6[label="Node Type: EXPRESSION 6
"];
6->7;
7[label="Node Type: EXPRESSION 7
"];
7->8;
8[label="Node Type: RETURN 8
"];
9[label="Node Type: EXPRESSION 9
"];
9->1;
}
// Function: 39994.sol-ITT-cancelIntl(ITTInterface.TradeMessage)
digraph{
}
// Function: 39994.sol-ITT-changeOwner(address)
digraph{
}
// Function: 39994.sol-ITT-closeOrder(uint256,address)
digraph{
}
// Function: 39994.sol-ITT-cmp(uint256,uint256,bool)
digraph{
}
// Function: 39994.sol-ITT-cmpEq(uint256,uint256,bool)
digraph{
}
// Function: 39994.sol-ITT-contractBalance()
digraph{
}
// Function: 39994.sol-ITT-etherBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
etherBalance[_addr]

IRs:
REF_53(uint256) -> etherBalance[_addr]
RETURN REF_53"];
}
// Function: 39994.sol-ITT-getAmount(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
amounts[sha3()(_price,_trader)]

IRs:
TMP_95(bytes32) = SOLIDITY_CALL sha3()(_price,_trader)
REF_55(uint256) -> amounts[TMP_95]
RETURN REF_55"];
}
// Function: 39994.sol-ITT-getBook()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
p = priceBook.step(MINNUM,NEXT)

IRs:
TMP_104(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.step(LibCLLu.CLL,uint256,bool), arguments:['priceBook', 'MINNUM', 'NEXT'] 
p(uint256) := TMP_104(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
volumes = new uint256[](priceBook.sizeOf() * 2 - 2)

IRs:
TMP_106(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.sizeOf(LibCLLu.CLL), arguments:['priceBook'] 
TMP_107(uint256) = TMP_106 * 2
TMP_108(uint256) = TMP_107 - 2
TMP_109(uint256[])  = new uint256[](TMP_108)
volumes(uint256[]) = ['TMP_109(uint256[])']"];
3->4;
4[label="Node Type: BEGIN_LOOP 4
"];
4->5;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
p < MAXNUM

IRs:
TMP_110(bool) = p < MAXNUM
CONDITION TMP_110"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
volumes[i ++] = p

IRs:
TMP_111(uint256) := i(uint256)
i(uint256) = i + 1
REF_66(uint256) -> volumes[TMP_111]
REF_66(uint256) (->volumes) := p(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
volumes[i ++] = getPriceVolume(p)

IRs:
TMP_112(uint256) := i(uint256)
i(uint256) = i + 1
REF_67(uint256) -> volumes[TMP_112]
TMP_113(uint256) = INTERNAL_CALL, ITT.getPriceVolume(uint256)(p)
REF_67(uint256) (->volumes) := TMP_113(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
p = priceBook.step(p,NEXT)

IRs:
TMP_114(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.step(LibCLLu.CLL,uint256,bool), arguments:['priceBook', 'p', 'NEXT'] 
p(uint256) := TMP_114(uint256)"];
8->5;
9[label="Node Type: END_LOOP 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
volumes

IRs:
RETURN volumes"];
}
// Function: 39994.sol-ITT-getNode(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(orderFIFOs[_list].cll[_node][PREV],orderFIFOs[_list].cll[_node][NEXT])

IRs:
REF_76(LibCLLu.CLL) -> orderFIFOs[_list]
REF_77(mapping(uint256 => mapping(bool => uint256))) -> REF_76.cll
REF_78(mapping(bool => uint256)) -> REF_77[_node]
REF_79(uint256) -> REF_78[PREV]
REF_80(LibCLLu.CLL) -> orderFIFOs[_list]
REF_81(mapping(uint256 => mapping(bool => uint256))) -> REF_80.cll
REF_82(mapping(bool => uint256)) -> REF_81[_node]
REF_83(uint256) -> REF_82[NEXT]
RETURN REF_79,REF_83"];
}
// Function: 39994.sol-ITT-getOpenOrdersOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = MINNUM

IRs:
p(uint256) := MINNUM(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
open = new uint256[](numOrdersOf(_addr) * 2)

IRs:
TMP_121(uint256) = INTERNAL_CALL, ITT.numOrdersOf(address)(_addr)
TMP_122(uint256) = TMP_121 * 2
TMP_123(uint256[])  = new uint256[](TMP_122)
open(uint256[]) = ['TMP_123(uint256[])']"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
p = MINNUM

IRs:
p(uint256) := MINNUM(uint256)"];
5->6;
6[label="Node Type: BEGIN_LOOP 6
"];
6->7;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
p < MAXNUM

IRs:
TMP_124(bool) = p < MAXNUM
CONDITION TMP_124"];
7->8[label="True"];
7->13[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
amounts[sha3()(p,_addr)] > 0

IRs:
TMP_125(bytes32) = SOLIDITY_CALL sha3()(p,_addr)
REF_71(uint256) -> amounts[TMP_125]
TMP_126(bool) = REF_71 > 0
CONDITION TMP_126"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
open[i ++] = p

IRs:
TMP_127(uint256) := i(uint256)
i(uint256) = i + 1
REF_72(uint256) -> open[TMP_127]
REF_72(uint256) (->open) := p(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
open[i ++] = amounts[sha3()(p,_addr)]

IRs:
TMP_128(uint256) := i(uint256)
i(uint256) = i + 1
REF_73(uint256) -> open[TMP_128]
TMP_129(bytes32) = SOLIDITY_CALL sha3()(p,_addr)
REF_74(uint256) -> amounts[TMP_129]
REF_73(uint256) (->open) := REF_74(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
p = priceBook.step(p,NEXT)

IRs:
TMP_130(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.step(LibCLLu.CLL,uint256,bool), arguments:['priceBook', 'p', 'NEXT'] 
p(uint256) := TMP_130(uint256)"];
12->7;
13[label="Node Type: END_LOOP 13
"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
open

IRs:
RETURN open"];
}
// Function: 39994.sol-ITT-getPriceVolume(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
n = orderFIFOs[_price].step(HEAD,NEXT)

IRs:
REF_59(LibCLLu.CLL) -> orderFIFOs[_price]
TMP_99(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.step(LibCLLu.CLL,uint256,bool), arguments:['REF_59', 'HEAD', 'NEXT'] 
n(uint256) := TMP_99(uint256)"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3

EXPRESSION:
n != HEAD

IRs:
TMP_100(bool) = n != HEAD
CONDITION TMP_100"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
v_ += amounts[sha3()(_price,address(n))]

IRs:
TMP_101 = CONVERT n to address
TMP_102(bytes32) = SOLIDITY_CALL sha3()(_price,TMP_101)
REF_61(uint256) -> amounts[TMP_102]
v_(uint256) = v_ + REF_61"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
n = orderFIFOs[_price].step(n,NEXT)

IRs:
REF_62(LibCLLu.CLL) -> orderFIFOs[_price]
TMP_103(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.step(LibCLLu.CLL,uint256,bool), arguments:['REF_62', 'n', 'NEXT'] 
n(uint256) := TMP_103(uint256)"];
5->3;
6[label="Node Type: END_LOOP 6
"];
6->7;
7[label="Node Type: RETURN 7
"];
8[label="Node Type: RETURN 8

EXPRESSION:
v_

IRs:
RETURN v_"];
}
// Function: 39994.sol-ITT-hasBalance(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balance[_member] < _amount

IRs:
REF_98(uint256) -> balance[_member]
TMP_174(bool) = REF_98 < _amount
CONDITION TMP_174"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-hasEther(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
etherBalance[_member] < _ether

IRs:
REF_97(uint256) -> etherBalance[_member]
TMP_173(bool) = REF_97 < _ether
CONDITION TMP_173"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-isAllowed(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount > allowance[_from][msg.sender] || _amount > balance[_from]

IRs:
REF_92(mapping(address => uint256)) -> allowance[_from]
REF_93(uint256) -> REF_92[msg.sender]
TMP_150(bool) = _amount > REF_93
REF_94(uint256) -> balance[_from]
TMP_151(bool) = _amount > REF_94
TMP_152(bool) = TMP_150 || TMP_151
CONDITION TMP_152"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-isAvailable(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount > balance[msg.sender]

IRs:
REF_91(uint256) -> balance[msg.sender]
TMP_149(bool) = _amount > REF_91
CONDITION TMP_149"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-isTrading()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! trading

IRs:
TMP_154 = UnaryType.BANG trading 
CONDITION TMP_154"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-isValidBuy(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(etherBalance[msg.sender] + msg.value) < (_amount * _bidPrice) || _amount == 0 || _amount > totalSupply || _bidPrice <= MINPRICE || _bidPrice >= MAXNUM

IRs:
REF_95(uint256) -> etherBalance[msg.sender]
TMP_155(uint256) = REF_95 + msg.value
TMP_156(uint256) = _amount * _bidPrice
TMP_157(bool) = TMP_155 < TMP_156
TMP_158(bool) = _amount == 0
TMP_159(bool) = TMP_157 || TMP_158
TMP_160(bool) = _amount > totalSupply
TMP_161(bool) = TMP_159 || TMP_160
TMP_162(bool) = _bidPrice <= MINPRICE
TMP_163(bool) = TMP_161 || TMP_162
TMP_164(bool) = _bidPrice >= MAXNUM
TMP_165(bool) = TMP_163 || TMP_164
CONDITION TMP_165"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-isValidSell(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_amount > balance[msg.sender] || _amount == 0 || _askPrice < MINPRICE || _askPrice > MAXNUM

IRs:
REF_96(uint256) -> balance[msg.sender]
TMP_166(bool) = _amount > REF_96
TMP_167(bool) = _amount == 0
TMP_168(bool) = TMP_166 || TMP_167
TMP_169(bool) = _askPrice < MINPRICE
TMP_170(bool) = TMP_168 || TMP_169
TMP_171(bool) = _askPrice > MAXNUM
TMP_172(bool) = TMP_170 || TMP_171
CONDITION TMP_172"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-make(ITTInterface.TradeMessage)
digraph{
}
// Function: 39994.sol-ITT-noReentry()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-numOrdersOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
p = MINNUM

IRs:
p(uint256) := MINNUM(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < MAXNUM

IRs:
TMP_115(bool) = p < MAXNUM
CONDITION TMP_115"];
4->5[label="True"];
4->9[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
amounts[sha3()(p,_addr)] > 0

IRs:
TMP_116(bytes32) = SOLIDITY_CALL sha3()(p,_addr)
REF_69(uint256) -> amounts[TMP_116]
TMP_117(bool) = REF_69 > 0
CONDITION TMP_117"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
c ++

IRs:
TMP_118(uint256) := c(uint256)
c(uint256) = c + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
p = priceBook.step(p,NEXT)

IRs:
TMP_119(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.step(LibCLLu.CLL,uint256,bool), arguments:['priceBook', 'p', 'NEXT'] 
p(uint256) := TMP_119(uint256)"];
8->4;
9[label="Node Type: END_LOOP 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39994.sol-ITT-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_153(bool) = msg.sender != owner
CONDITION TMP_153"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 39994.sol-ITT-preventReentry()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
mutex

IRs:
CONDITION mutex"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
mutex = true

IRs:
mutex(bool) := True(bool)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: _ 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
delete mutex

IRs:
mutex = delete mutex "];
6->7;
7[label="Node Type: RETURN 7
"];
}
// Function: 39994.sol-ITT-safeAdd(uint256,uint256)
digraph{
}
// Function: 39994.sol-ITT-safeMul(uint256,uint256)
digraph{
}
// Function: 39994.sol-ITT-safeSend(address,uint256)
digraph{
}
// Function: 39994.sol-ITT-safeSub(uint256,uint256)
digraph{
}
// Function: 39994.sol-ITT-sell(uint256,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
trade(_askPrice,_amount,ASK,_make)

IRs:
INTERNAL_CALL, ITT.trade(uint256,uint256,bool,bool)(_askPrice,_amount,ASK,_make)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
canEnter()

IRs:
MODIFIER_CALL, Base.canEnter()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isTrading()

IRs:
MODIFIER_CALL, ITT.isTrading()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isValidSell(_askPrice,_amount)

IRs:
MODIFIER_CALL, ITT.isValidSell(uint256,uint256)(_askPrice,_amount)"];
5->1;
}
// Function: 39994.sol-ITT-setTrading(bool)
digraph{
}
// Function: 39994.sol-ITT-sizeOf(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
l == 0

IRs:
TMP_96(bool) = l == 0
CONDITION TMP_96"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
priceBook.sizeOf()

IRs:
TMP_97(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.sizeOf(LibCLLu.CLL), arguments:['priceBook'] 
RETURN TMP_97"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
orderFIFOs[l].sizeOf()

IRs:
REF_57(LibCLLu.CLL) -> orderFIFOs[l]
TMP_98(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.sizeOf(LibCLLu.CLL), arguments:['REF_57'] 
RETURN TMP_98"];
5[label="Node Type: RETURN 5

EXPRESSION:
s

IRs:
RETURN s"];
}
// Function: 39994.sol-ITT-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = ITT 0.3.6
ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1


IRs:
VERSION(string) := ITT 0.3.6
ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1
(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
NULL = 0

IRs:
NULL(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
LT = false

IRs:
LT(bool) := False(bool)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
GT = true

IRs:
GT(bool) := True(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
iTRUE = 1

IRs:
iTRUE(uint256) := 1(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
iFALSE = 0

IRs:
iFALSE(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
iPOS = 1

IRs:
iPOS(uint256) := 1(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
iZERO = 0

IRs:
iZERO(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
iNEG = uint256(- 1)

IRs:
TMP_142(uint256) = 0 - 1
TMP_143 = CONVERT TMP_142 to uint256
iNEG(uint256) := TMP_143(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
HEAD = 0

IRs:
HEAD(uint256) := 0(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
MINNUM = uint256(1)

IRs:
TMP_144 = CONVERT 1 to uint256
MINNUM(uint256) := TMP_144(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
MAXNUM = 2 ** 128

IRs:
TMP_145(uint256) = 2 ** 128
MAXNUM(uint256) := TMP_145(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
MINPRICE = uint256(1)

IRs:
TMP_146 = CONVERT 1 to uint256
MINPRICE(uint256) := TMP_146(uint256)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
NEG = uint256(- 1)

IRs:
TMP_147(uint256) = 0 - 1
TMP_148 = CONVERT TMP_147 to uint256
NEG(uint256) := TMP_148(uint256)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
PREV = false

IRs:
PREV(bool) := False(bool)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
NEXT = true

IRs:
NEXT(bool) := True(bool)"];
15->16;
16[label="Node Type: OTHER_ENTRYPOINT 16

EXPRESSION:
BID = false

IRs:
BID(bool) := False(bool)"];
16->17;
17[label="Node Type: OTHER_ENTRYPOINT 17

EXPRESSION:
ASK = true

IRs:
ASK(bool) := True(bool)"];
17->18;
18[label="Node Type: OTHER_ENTRYPOINT 18

EXPRESSION:
MINGAS = 100000

IRs:
MINGAS(uint256) := 100000(uint256)"];
18->19;
19[label="Node Type: OTHER_ENTRYPOINT 19

EXPRESSION:
priceBook = orderFIFOs[0]

IRs:
REF_90(LibCLLu.CLL) -> orderFIFOs[0]
priceBook(LibCLLu.CLL) := REF_90(LibCLLu.CLL)"];
}
// Function: 39994.sol-ITT-spread(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
priceBook.step(HEAD,_side)

IRs:
TMP_94(uint256) = LIBRARY_CALL, dest:LibCLLu, function:LibCLLu.step(LibCLLu.CLL,uint256,bool), arguments:['priceBook', 'HEAD', '_side'] 
RETURN TMP_94"];
}
// Function: 39994.sol-ITT-take(ITTInterface.TradeMessage)
digraph{
}
// Function: 39994.sol-ITT-trade(uint256,uint256,bool,bool)
digraph{
}
// Function: 39994.sol-ITT-transfer(address,uint256)
digraph{
}
// Function: 39994.sol-ITT-transferFrom(address,address,uint256)
digraph{
}
// Function: 39994.sol-ITT-version()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
VERSION

IRs:
RETURN VERSION"];
}
// Function: 39994.sol-ITT-withdraw(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
etherBalance[msg.sender] -= _ether

IRs:
REF_84(uint256) -> etherBalance[msg.sender]
REF_84(-> etherBalance) = REF_84 - _ether"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
safeSend(msg.sender,_ether)

IRs:
TMP_139(bool) = INTERNAL_CALL, Base.safeSend(address,uint256)(msg.sender,_ether)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
success_ = true

IRs:
success_(bool) := True(bool)"];
3->6;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canEnter()

IRs:
MODIFIER_CALL, Base.canEnter()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
hasEther(msg.sender,_ether)

IRs:
MODIFIER_CALL, ITT.hasEther(address,uint256)(msg.sender,_ether)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success_

IRs:
RETURN success_"];
}
// Function: 39994.sol-ITTInterface-buy(uint256,uint256,bool)
digraph{
}
// Function: 39994.sol-ITTInterface-cancel(uint256)
digraph{
}
// Function: 39994.sol-ITTInterface-getAmount(uint256,address)
digraph{
}
// Function: 39994.sol-ITTInterface-getBook()
digraph{
}
// Function: 39994.sol-ITTInterface-getPriceVolume(uint256)
digraph{
}
// Function: 39994.sol-ITTInterface-sell(uint256,uint256,bool)
digraph{
}
// Function: 39994.sol-ITTInterface-setTrading(bool)
digraph{
}
// Function: 39994.sol-ITTInterface-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = ITT 0.3.6
ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1


IRs:
VERSION(string) := ITT 0.3.6
ERC20 0.2.3-o0ragman0o
Math 0.0.1
Base 0.1.1
(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
HEAD = 0

IRs:
HEAD(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
MINNUM = uint256(1)

IRs:
TMP_88 = CONVERT 1 to uint256
MINNUM(uint256) := TMP_88(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
MAXNUM = 2 ** 128

IRs:
TMP_89(uint256) = 2 ** 128
MAXNUM(uint256) := TMP_89(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
MINPRICE = uint256(1)

IRs:
TMP_90 = CONVERT 1 to uint256
MINPRICE(uint256) := TMP_90(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
NEG = uint256(- 1)

IRs:
TMP_91(uint256) = 0 - 1
TMP_92 = CONVERT TMP_91 to uint256
NEG(uint256) := TMP_92(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
PREV = false

IRs:
PREV(bool) := False(bool)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
NEXT = true

IRs:
NEXT(bool) := True(bool)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
BID = false

IRs:
BID(bool) := False(bool)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
ASK = true

IRs:
ASK(bool) := True(bool)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
MINGAS = 100000

IRs:
MINGAS(uint256) := 100000(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
priceBook = orderFIFOs[0]

IRs:
REF_39(LibCLLu.CLL) -> orderFIFOs[0]
priceBook(LibCLLu.CLL) := REF_39(LibCLLu.CLL)"];
}
// Function: 39994.sol-ITTInterface-spread(bool)
digraph{
}
// Function: 39994.sol-ITTInterface-withdraw(uint256)
digraph{
}
// Function: 39994.sol-LibCLLi-exists(LibCLLi.CLL,int256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
self.cll[HEAD][PREV] != HEAD || self.cll[HEAD][NEXT] != HEAD

IRs:
REF_33(mapping(int256 => mapping(bool => int256))) -> self.cll
REF_34(mapping(bool => int256)) -> REF_33[HEAD]
REF_35(int256) -> REF_34[PREV]
TMP_85(bool) = REF_35 != HEAD
REF_36(mapping(int256 => mapping(bool => int256))) -> self.cll
REF_37(mapping(bool => int256)) -> REF_36[HEAD]
REF_38(int256) -> REF_37[NEXT]
TMP_86(bool) = REF_38 != HEAD
TMP_87(bool) = TMP_85 || TMP_86
CONDITION TMP_87"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39994.sol-LibCLLi-getNode(LibCLLi.CLL,int256)
digraph{
}
// Function: 39994.sol-LibCLLi-insert(LibCLLi.CLL,int256,int256,bool)
digraph{
}
// Function: 39994.sol-LibCLLi-pop(LibCLLi.CLL,bool)
digraph{
}
// Function: 39994.sol-LibCLLi-push(LibCLLi.CLL,int256,bool)
digraph{
}
// Function: 39994.sol-LibCLLi-remove(LibCLLi.CLL,int256)
digraph{
}
// Function: 39994.sol-LibCLLi-seek(LibCLLi.CLL,int256,int256,bool)
digraph{
}
// Function: 39994.sol-LibCLLi-sizeOf(LibCLLi.CLL)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3
"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4
"];
4->5;
5[label="Node Type: EXPRESSION 5
"];
5->3;
6[label="Node Type: END_LOOP 6
"];
6->7;
7[label="Node Type: RETURN 7
"];
}
// Function: 39994.sol-LibCLLi-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = LibCLLi 0.3.1

IRs:
VERSION(string) := LibCLLi 0.3.1(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
NULL = 0

IRs:
NULL(int256) := 0(int256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
HEAD = NULL

IRs:
HEAD(int256) := NULL(int256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
PREV = false

IRs:
PREV(bool) := False(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
NEXT = true

IRs:
NEXT(bool) := True(bool)"];
}
// Function: 39994.sol-LibCLLi-step(LibCLLi.CLL,int256,bool)
digraph{
}
// Function: 39994.sol-LibCLLi-stitch(LibCLLi.CLL,int256,int256,bool)
digraph{
}
// Function: 39994.sol-LibCLLi-version()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
VERSION

IRs:
RETURN VERSION"];
}
// Function: 39994.sol-LibCLLu-exists(LibCLLu.CLL)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
self.cll[HEAD][PREV] != HEAD || self.cll[HEAD][NEXT] != HEAD

IRs:
REF_27(mapping(uint256 => mapping(bool => uint256))) -> self.cll
REF_28(mapping(bool => uint256)) -> REF_27[HEAD]
REF_29(uint256) -> REF_28[PREV]
TMP_82(bool) = REF_29 != HEAD
REF_30(mapping(uint256 => mapping(bool => uint256))) -> self.cll
REF_31(mapping(bool => uint256)) -> REF_30[HEAD]
REF_32(uint256) -> REF_31[NEXT]
TMP_83(bool) = REF_32 != HEAD
TMP_84(bool) = TMP_82 || TMP_83
CONDITION TMP_84"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39994.sol-LibCLLu-getNode(LibCLLu.CLL,uint256)
digraph{
}
// Function: 39994.sol-LibCLLu-insert(LibCLLu.CLL,uint256,uint256,bool)
digraph{
}
// Function: 39994.sol-LibCLLu-pop(LibCLLu.CLL,bool)
digraph{
}
// Function: 39994.sol-LibCLLu-push(LibCLLu.CLL,uint256,bool)
digraph{
}
// Function: 39994.sol-LibCLLu-remove(LibCLLu.CLL,uint256)
digraph{
}
// Function: 39994.sol-LibCLLu-seek(LibCLLu.CLL,uint256,uint256,bool)
digraph{
}
// Function: 39994.sol-LibCLLu-sizeOf(LibCLLu.CLL)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3
"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4
"];
4->5;
5[label="Node Type: EXPRESSION 5
"];
5->3;
6[label="Node Type: END_LOOP 6
"];
6->7;
7[label="Node Type: RETURN 7
"];
}
// Function: 39994.sol-LibCLLu-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = LibCLLu 0.3.1

IRs:
VERSION(string) := LibCLLu 0.3.1(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
NULL = 0

IRs:
NULL(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
HEAD = NULL

IRs:
HEAD(uint256) := NULL(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
PREV = false

IRs:
PREV(bool) := False(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
NEXT = true

IRs:
NEXT(bool) := True(bool)"];
}
// Function: 39994.sol-LibCLLu-step(LibCLLu.CLL,uint256,bool)
digraph{
}
// Function: 39994.sol-LibCLLu-stitch(LibCLLu.CLL,uint256,uint256,bool)
digraph{
}
// Function: 39994.sol-LibCLLu-version()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
VERSION

IRs:
RETURN VERSION"];
}
// Function: 39994.sol-Math-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_7 = UnaryType.BANG assertion 
CONDITION TMP_7"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39994.sol-Math-cmp(uint256,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(a != b) && ((a < b) != _sym)

IRs:
TMP_8(bool) = a != b
TMP_9(bool) = a < b
TMP_10(bool) = TMP_9 != _sym
TMP_11(bool) = TMP_8 && TMP_10
RETURN TMP_11"];
}
// Function: 39994.sol-Math-cmpEq(uint256,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(a == b) || ((a < b) != _sym)

IRs:
TMP_12(bool) = a == b
TMP_13(bool) = a < b
TMP_14(bool) = TMP_13 != _sym
TMP_15(bool) = TMP_12 || TMP_14
RETURN TMP_15"];
}
// Function: 39994.sol-Math-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_25(uint256) = a + b
c(uint256) := TMP_25(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_26(bool) = c >= a
TMP_27(bool) = c >= b
TMP_28(bool) = TMP_26 && TMP_27
INTERNAL_CALL, Math.assert(bool)(TMP_28)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39994.sol-Math-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_16(uint256) = a * b
c(uint256) := TMP_16(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_17(bool) = a == 0
TMP_18(uint256) = c / a
TMP_19(bool) = TMP_18 == b
TMP_20(bool) = TMP_17 || TMP_19
INTERNAL_CALL, Math.assert(bool)(TMP_20)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39994.sol-Math-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_22(bool) = b <= a
INTERNAL_CALL, Math.assert(bool)(TMP_22)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_24(uint256) = a - b
RETURN TMP_24"];
}
// Function: 39994.sol-Math-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = Math 0.0.1 


IRs:
VERSION(string) := Math 0.0.1 
(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
NULL = 0

IRs:
NULL(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
LT = false

IRs:
LT(bool) := False(bool)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
GT = true

IRs:
GT(bool) := True(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
iTRUE = 1

IRs:
iTRUE(uint256) := 1(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
iFALSE = 0

IRs:
iFALSE(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
iPOS = 1

IRs:
iPOS(uint256) := 1(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
iZERO = 0

IRs:
iZERO(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
iNEG = uint256(- 1)

IRs:
TMP_30(uint256) = 0 - 1
TMP_31 = CONVERT TMP_30 to uint256
iNEG(uint256) := TMP_31(uint256)"];
}
// Function: 39994.sol-Math-version()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
VERSION

IRs:
RETURN VERSION"];
}
}
