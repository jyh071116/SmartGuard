digraph G {
// Function: 1122.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 1122.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 1122.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 1122.sol-ERC20-totalSupply()
digraph{
}
// Function: 1122.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 1122.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 1122.sol-ERC223ReceivingContract-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 1122.sol-Math-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x + y) >= x)

IRs:
TMP_0(uint256) = x + y
z(uint256) := TMP_0(uint256)
TMP_1(bool) = z >= x
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-cast(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = uint128(x)) == x)

IRs:
TMP_83 = CONVERT x to uint128
z(uint128) := TMP_83(uint128)
TMP_84(bool) = z == x
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
y > 0

IRs:
TMP_24(bool) = y > 0
CONDITION TMP_24"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
z = x / y

IRs:
TMP_25(uint256) = x / y
z(uint256) := TMP_25(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
z = 0

IRs:
z(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-hadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x + y) >= x)

IRs:
TMP_28(uint128) = x + y
z(uint128) := TMP_28(uint128)
TMP_29(bool) = z >= x
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-hdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(y > 0)

IRs:
TMP_37(bool) = y > 0
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
z = x / y

IRs:
TMP_39(uint128) = x / y
z(uint128) := TMP_39(uint128)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-hmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_41(bool) = x >= y
CONDITION TMP_41"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-hmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_40(bool) = x <= y
CONDITION TMP_40"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-hmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x * y) >= x)

IRs:
TMP_34(uint128) = x * y
z(uint128) := TMP_34(uint128)
TMP_35(bool) = z >= x
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-hsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x - y) <= x)

IRs:
TMP_31(uint128) = x - y
z(uint128) := TMP_31(uint128)
TMP_32(bool) = z <= x
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-imax(int256,int256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_43(bool) = x >= y
CONDITION TMP_43"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-imin(int256,int256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_42(bool) = x <= y
CONDITION TMP_42"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_27(bool) = x >= y
CONDITION TMP_27"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_26(bool) = x <= y
CONDITION TMP_26"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = x * y

IRs:
TMP_6(uint256) = x * y
z(uint256) := TMP_6(uint256)"];
1->3;
3[label="Node Type: IF 3

EXPRESSION:
x > y

IRs:
TMP_7(bool) = x > y
CONDITION TMP_7"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)((z == 0 && (x == 0 || y == 0)) || z >= x)

IRs:
TMP_8(bool) = z == 0
TMP_9(bool) = x == 0
TMP_10(bool) = y == 0
TMP_11(bool) = TMP_9 || TMP_10
TMP_12(bool) = TMP_8 && TMP_11
TMP_13(bool) = z >= x
TMP_14(bool) = TMP_12 || TMP_13
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)((z == 0 && (x == 0 || y == 0)) || z >= y)

IRs:
TMP_16(bool) = z == 0
TMP_17(bool) = x == 0
TMP_18(bool) = y == 0
TMP_19(bool) = TMP_17 || TMP_18
TMP_20(bool) = TMP_16 && TMP_19
TMP_21(bool) = z >= y
TMP_22(bool) = TMP_20 || TMP_21
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-radd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hadd(x,y)

IRs:
TMP_60(uint128) = INTERNAL_CALL, Math.hadd(uint128,uint128)(x,y)
RETURN TMP_60"];
}
// Function: 1122.sol-Math-rdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * RAY + y / 2) / y)

IRs:
TMP_68 = CONVERT x to uint256
TMP_69(uint256) = TMP_68 * RAY
TMP_70(uint128) = y / 2
TMP_71(uint256) = TMP_69 + TMP_70
TMP_72(uint256) = TMP_71 / y
TMP_73(uint128) = INTERNAL_CALL, Math.cast(uint256)(TMP_72)
z(uint128) := TMP_73(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-rmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmax(x,y)

IRs:
TMP_82(uint128) = INTERNAL_CALL, Math.hmax(uint128,uint128)(x,y)
RETURN TMP_82"];
}
// Function: 1122.sol-Math-rmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmin(x,y)

IRs:
TMP_81(uint128) = INTERNAL_CALL, Math.hmin(uint128,uint128)(x,y)
RETURN TMP_81"];
}
// Function: 1122.sol-Math-rmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * y + RAY / 2) / RAY)

IRs:
TMP_62 = CONVERT x to uint256
TMP_63(uint256) = TMP_62 * y
TMP_64(uint128) = RAY / 2
TMP_65(uint256) = TMP_63 + TMP_64
TMP_66(uint256) = TMP_65 / RAY
TMP_67(uint128) = INTERNAL_CALL, Math.cast(uint256)(TMP_66)
z(uint128) := TMP_67(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-rpow(uint128,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->15;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
n /= 2

IRs:
n(uint64) = n / 2"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
n != 0

IRs:
TMP_74(bool) = n != 0
CONDITION TMP_74"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
x = rmul(x,x)

IRs:
TMP_75(uint128) = INTERNAL_CALL, Math.rmul(uint128,uint128)(x,x)
x(uint128) := TMP_75(uint128)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
n % 2 != 0

IRs:
TMP_76(uint64) = n % 2
TMP_77(bool) = TMP_76 != 0
CONDITION TMP_77"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
z = rmul(z,x)

IRs:
TMP_78(uint128) = INTERNAL_CALL, Math.rmul(uint128,uint128)(z,x)
z(uint128) := TMP_78(uint128)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
n /= 2

IRs:
n(uint64) = n / 2"];
10->5;
11[label="Node Type: IF 11

EXPRESSION:
n % 2 != 0

IRs:
TMP_79(uint64) = n % 2
TMP_80(bool) = TMP_79 != 0
CONDITION TMP_80"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
z = x

IRs:
z(uint128) := x(uint128)"];
12->14;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
z = RAY

IRs:
z(uint128) := RAY(uint128)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->4;
15[label="Node Type: RETURN 15

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-rsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hsub(x,y)

IRs:
TMP_61(uint128) = INTERNAL_CALL, Math.hsub(uint128,uint128)(x,y)
RETURN TMP_61"];
}
// Function: 1122.sol-Math-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
WAD = 10 ** 18

IRs:
TMP_86(uint256) = 10 ** 18
WAD(uint128) := TMP_86(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
RAY = 10 ** 27

IRs:
TMP_87(uint256) = 10 ** 27
RAY(uint128) := TMP_87(uint256)"];
}
// Function: 1122.sol-Math-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x - y) <= x)

IRs:
TMP_3(uint256) = x - y
z(uint256) := TMP_3(uint256)
TMP_4(bool) = z <= x
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-wadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hadd(x,y)

IRs:
TMP_44(uint128) = INTERNAL_CALL, Math.hadd(uint128,uint128)(x,y)
RETURN TMP_44"];
}
// Function: 1122.sol-Math-wdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * WAD + y / 2) / y)

IRs:
TMP_52 = CONVERT x to uint256
TMP_53(uint256) = TMP_52 * WAD
TMP_54(uint128) = y / 2
TMP_55(uint256) = TMP_53 + TMP_54
TMP_56(uint256) = TMP_55 / y
TMP_57(uint128) = INTERNAL_CALL, Math.cast(uint256)(TMP_56)
z(uint128) := TMP_57(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-wmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmax(x,y)

IRs:
TMP_59(uint128) = INTERNAL_CALL, Math.hmax(uint128,uint128)(x,y)
RETURN TMP_59"];
}
// Function: 1122.sol-Math-wmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmin(x,y)

IRs:
TMP_58(uint128) = INTERNAL_CALL, Math.hmin(uint128,uint128)(x,y)
RETURN TMP_58"];
}
// Function: 1122.sol-Math-wmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * y + WAD / 2) / WAD)

IRs:
TMP_46 = CONVERT x to uint256
TMP_47(uint256) = TMP_46 * y
TMP_48(uint128) = WAD / 2
TMP_49(uint256) = TMP_47 + TMP_48
TMP_50(uint256) = TMP_49 / WAD
TMP_51(uint128) = INTERNAL_CALL, Math.cast(uint256)(TMP_50)
z(uint128) := TMP_51(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 1122.sol-Math-wsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hsub(x,y)

IRs:
TMP_45(uint128) = INTERNAL_CALL, Math.hsub(uint128,uint128)(x,y)
RETURN TMP_45"];
}
// Function: 1122.sol-Owned-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1122.sol-Owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_90(bool) = msg.sender == owner
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Owned-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-Roles-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1122.sol-Roles-Roles()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SecuredWithRoles(RolesRepository,this)

IRs:
INTERNAL_CALL, SecuredWithRoles.SecuredWithRoles(string,address)(RolesRepository,this)"];
}
// Function: 1122.sol-Roles-SecuredWithRoles(string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractHash = keccak256()(contractName_)

IRs:
TMP_119(bytes32) = SOLIDITY_CALL keccak256()(contractName_)
contractHash(bytes32) := TMP_119(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_120 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_120(RolesI)"];
}
// Function: 1122.sol-Roles-addContractRole(bytes32,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! knownRoleNames[ctrct][keccak256()(roleName)])

IRs:
REF_4(mapping(bytes32 => bool)) -> knownRoleNames[ctrct]
TMP_137(bytes32) = SOLIDITY_CALL keccak256()(roleName)
REF_5(bool) -> REF_4[TMP_137]
TMP_138 = UnaryType.BANG REF_5 
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
knownRoleNames[ctrct][keccak256()(roleName)] = true

IRs:
REF_6(mapping(bytes32 => bool)) -> knownRoleNames[ctrct]
TMP_140(bytes32) = SOLIDITY_CALL keccak256()(roleName)
REF_7(bool) -> REF_6[TMP_140]
REF_7(bool) (->knownRoleNames) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
LogRoleAdded(ctrct,roleName)

IRs:
Emit LogRoleAdded(ctrct,roleName)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roleOrOwner(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(admin)"];
4->1;
}
// Function: 1122.sol-Roles-grantUserRole(bytes32,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(knownRoleNames[ctrct][keccak256()(roleName)])

IRs:
REF_12(mapping(bytes32 => bool)) -> knownRoleNames[ctrct]
TMP_148(bytes32) = SOLIDITY_CALL keccak256()(roleName)
REF_13(bool) -> REF_12[TMP_148]
TMP_149(None) = SOLIDITY_CALL require(bool)(REF_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleList[ctrct][keccak256()(roleName)][user] = true

IRs:
REF_14(mapping(bytes32 => mapping(address => bool))) -> roleList[ctrct]
TMP_150(bytes32) = SOLIDITY_CALL keccak256()(roleName)
REF_15(mapping(address => bool)) -> REF_14[TMP_150]
REF_16(bool) -> REF_15[user]
REF_16(bool) (->roleList) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
LogRoleGranted(ctrct,roleName,user)

IRs:
Emit LogRoleGranted(ctrct,roleName,user)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roleOrOwner(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(admin)"];
4->1;
}
// Function: 1122.sol-Roles-hasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
roles.knownRoleNames(contractHash,keccak256()(roleName))

IRs:
TMP_121(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_122(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:knownRoleNames, arguments:['contractHash', 'TMP_121']  
RETURN TMP_122"];
}
// Function: 1122.sol-Roles-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_164(bool) = msg.sender == owner
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Roles-onlyRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(senderHasRole(role))

IRs:
TMP_158(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Roles-removeContractRole(bytes32,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(knownRoleNames[ctrct][keccak256()(roleName)])

IRs:
REF_8(mapping(bytes32 => bool)) -> knownRoleNames[ctrct]
TMP_143(bytes32) = SOLIDITY_CALL keccak256()(roleName)
REF_9(bool) -> REF_8[TMP_143]
TMP_144(None) = SOLIDITY_CALL require(bool)(REF_9)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
delete knownRoleNames[ctrct][keccak256()(roleName)]

IRs:
REF_10(mapping(bytes32 => bool)) -> knownRoleNames[ctrct]
TMP_145(bytes32) = SOLIDITY_CALL keccak256()(roleName)
REF_11(bool) -> REF_10[TMP_145]
REF_10 = delete REF_11 "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
LogRoleRemoved(ctrct,roleName)

IRs:
Emit LogRoleRemoved(ctrct,roleName)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
roleOrOwner(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(admin)"];
4->1;
}
// Function: 1122.sol-Roles-restart()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(restarter)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(restarter)"];
2->1;
}
// Function: 1122.sol-Roles-revokeUserRole(bytes32,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
delete roleList[ctrct][keccak256()(roleName)][user]

IRs:
REF_17(mapping(bytes32 => mapping(address => bool))) -> roleList[ctrct]
TMP_153(bytes32) = SOLIDITY_CALL keccak256()(roleName)
REF_18(mapping(address => bool)) -> REF_17[TMP_153]
REF_19(bool) -> REF_18[user]
REF_18 = delete REF_19 "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogRoleRevoked(ctrct,roleName,user)

IRs:
Emit LogRoleRevoked(ctrct,roleName,user)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
roleOrOwner(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(admin)"];
3->1;
}
// Function: 1122.sol-Roles-roleOrOwner(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || senderHasRole(role))

IRs:
TMP_160(bool) = msg.sender == owner
TMP_161(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_162(bool) = TMP_160 || TMP_161
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Roles-senderHasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hasRole(roleName) && roles.roleList(contractHash,keccak256()(roleName),msg.sender)

IRs:
TMP_123(bool) = INTERNAL_CALL, SecuredWithRoles.hasRole(string)(roleName)
TMP_124(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_125(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:roleList, arguments:['contractHash', 'TMP_124', 'msg.sender']  
TMP_126(bool) = TMP_123 && TMP_125
RETURN TMP_126"];
}
// Function: 1122.sol-Roles-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-Roles-setRolesContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this != address(roles))

IRs:
TMP_129 = CONVERT roles to address
TMP_130(bool) = this != TMP_129
TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_132 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_132(RolesI)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-Roles-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
}
// Function: 1122.sol-Roles-stop()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = true

IRs:
stopped(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(stopper)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(stopper)"];
2->1;
}
// Function: 1122.sol-Roles-stoppable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! stopped)

IRs:
TMP_156 = UnaryType.BANG stopped 
TMP_157(None) = SOLIDITY_CALL require(bool)(TMP_156)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-RolesI-addContractRole(bytes32,string)
digraph{
}
// Function: 1122.sol-RolesI-grantUserRole(bytes32,string,address)
digraph{
}
// Function: 1122.sol-RolesI-knownRoleNames(bytes32,bytes32)
digraph{
}
// Function: 1122.sol-RolesI-removeContractRole(bytes32,string)
digraph{
}
// Function: 1122.sol-RolesI-revokeUserRole(bytes32,string,address)
digraph{
}
// Function: 1122.sol-RolesI-roleList(bytes32,bytes32,address)
digraph{
}
// Function: 1122.sol-SecuredWithRoles-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1122.sol-SecuredWithRoles-SecuredWithRoles(string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractHash = keccak256()(contractName_)

IRs:
TMP_94(bytes32) = SOLIDITY_CALL keccak256()(contractName_)
contractHash(bytes32) := TMP_94(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_95 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_95(RolesI)"];
}
// Function: 1122.sol-SecuredWithRoles-hasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
roles.knownRoleNames(contractHash,keccak256()(roleName))

IRs:
TMP_96(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_97(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:knownRoleNames, arguments:['contractHash', 'TMP_96']  
RETURN TMP_97"];
}
// Function: 1122.sol-SecuredWithRoles-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_109(bool) = msg.sender == owner
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SecuredWithRoles-onlyRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(senderHasRole(role))

IRs:
TMP_113(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_114(None) = SOLIDITY_CALL require(bool)(TMP_113)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SecuredWithRoles-restart()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(restarter)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(restarter)"];
2->1;
}
// Function: 1122.sol-SecuredWithRoles-roleOrOwner(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || senderHasRole(role))

IRs:
TMP_115(bool) = msg.sender == owner
TMP_116(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_117(bool) = TMP_115 || TMP_116
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SecuredWithRoles-senderHasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hasRole(roleName) && roles.roleList(contractHash,keccak256()(roleName),msg.sender)

IRs:
TMP_98(bool) = INTERNAL_CALL, SecuredWithRoles.hasRole(string)(roleName)
TMP_99(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_100(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:roleList, arguments:['contractHash', 'TMP_99', 'msg.sender']  
TMP_101(bool) = TMP_98 && TMP_100
RETURN TMP_101"];
}
// Function: 1122.sol-SecuredWithRoles-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-SecuredWithRoles-setRolesContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this != address(roles))

IRs:
TMP_104 = CONVERT roles to address
TMP_105(bool) = this != TMP_104
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_107 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_107(RolesI)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-SecuredWithRoles-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
}
// Function: 1122.sol-SecuredWithRoles-stop()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = true

IRs:
stopped(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(stopper)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(stopper)"];
2->1;
}
// Function: 1122.sol-SecuredWithRoles-stoppable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! stopped)

IRs:
TMP_111 = UnaryType.BANG stopped 
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SecuredWithRolesI-contractHash()
digraph{
}
// Function: 1122.sol-SecuredWithRolesI-hasRole(string)
digraph{
}
// Function: 1122.sol-SecuredWithRolesI-senderHasRole(string)
digraph{
}
// Function: 1122.sol-SweetTokenLogic-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1122.sol-SweetTokenLogic-SecuredWithRoles(string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractHash = keccak256()(contractName_)

IRs:
TMP_466(bytes32) = SOLIDITY_CALL keccak256()(contractName_)
contractHash(bytes32) := TMP_466(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_467 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_467(RolesI)"];
}
// Function: 1122.sol-SweetTokenLogic-SweetTokenLogic(address,address,address,address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: IF 1

EXPRESSION:
tokenData_ == address(0x0)

IRs:
TMP_483 = CONVERT 0 to address
TMP_484(bool) = tokenData_ == TMP_483
CONDITION TMP_484"];
1->2[label="True"];
1->13[label="False"];
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(initialBalances.length == initialWallets.length)

IRs:
REF_154 -> LENGTH initialBalances
REF_155 -> LENGTH initialWallets
TMP_485(bool) = REF_154 == REF_155
TMP_486(None) = SOLIDITY_CALL require(bool)(TMP_485)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->12;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < initialWallets.length

IRs:
REF_156 -> LENGTH initialWallets
TMP_487(bool) = i < REF_156
CONDITION TMP_487"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
data.setBalances(initialWallets[i],initialBalances[i])

IRs:
REF_158(address) -> initialWallets[i]
REF_159(uint256) -> initialBalances[i]
HIGH_LEVEL_CALL, dest:data(TokenData), function:setBalances, arguments:['REF_158', 'REF_159']  "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
token.triggerTransfer(address(0x0),initialWallets[i],initialBalances[i])

IRs:
TMP_489 = CONVERT 0 to address
REF_161(address) -> initialWallets[i]
REF_162(uint256) -> initialBalances[i]
HIGH_LEVEL_CALL, dest:token(Token), function:triggerTransfer, arguments:['TMP_489', 'REF_161', 'REF_162']  "];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
totalSupply = Math.add(totalSupply,initialBalances[i])

IRs:
REF_164(uint256) -> initialBalances[i]
TMP_491(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['totalSupply', 'REF_164'] 
totalSupply(uint256) := TMP_491(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_492(uint256) := i(uint256)
i(uint256) = i + 1"];
11->7;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
data.setSupply(totalSupply)

IRs:
HIGH_LEVEL_CALL, dest:data(TokenData), function:setSupply, arguments:['totalSupply']  "];
12->13;
13[label="Node Type: END_IF 13
"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
TokenLogic(token_,tokenData_,rolesContract)

IRs:
INTERNAL_CALL, TokenLogic.TokenLogic(address,address,address)(token_,tokenData_,rolesContract)"];
14->1;
}
// Function: 1122.sol-SweetTokenLogic-TokenLogic(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token_ != address(0x0))

IRs:
TMP_376 = CONVERT 0 to address
TMP_377(bool) = token_ != TMP_376
TMP_378(None) = SOLIDITY_CALL require(bool)(TMP_377)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(rolesContract != address(0x0))

IRs:
TMP_379 = CONVERT 0 to address
TMP_380(bool) = rolesContract != TMP_379
TMP_381(None) = SOLIDITY_CALL require(bool)(TMP_380)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token = Token(token_)

IRs:
TMP_382 = CONVERT token_ to Token
token(Token) := TMP_382(Token)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
tokenData_ == address(0x0)

IRs:
TMP_383 = CONVERT 0 to address
TMP_384(bool) = tokenData_ == TMP_383
CONDITION TMP_384"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
data = new TokenData(this,msg.sender)

IRs:
TMP_386(TokenData) = new TokenData(this,msg.sender) 
data(TokenData) := TMP_386(TokenData)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
data = TokenData(tokenData_)

IRs:
TMP_387 = CONVERT tokenData_ to TokenData
data(TokenData) := TMP_387(TokenData)"];
6->7;
7[label="Node Type: END_IF 7
"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
SecuredWithRoles(TokenLogic,rolesContract)

IRs:
INTERNAL_CALL, SecuredWithRoles.SecuredWithRoles(string,address)(TokenLogic,rolesContract)"];
8->1;
}
// Function: 1122.sol-SweetTokenLogic-addToWhiteList(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(listExists(listName))

IRs:
TMP_417(bool) = INTERNAL_CALL, TokenLogic.listExists(bytes32)(listName)
TMP_418(None) = SOLIDITY_CALL require(bool)(TMP_417)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whiteLists[guy][listName] = true

IRs:
REF_117(mapping(bytes32 => bool)) -> whiteLists[guy]
REF_118(bool) -> REF_117[listName]
REF_118(bool) (->whiteLists) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
AdditionToWhiteList(listName,guy)

IRs:
Emit AdditionToWhiteList(listName,guy)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyRole(userManager)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(userManager)"];
4->1;
}
// Function: 1122.sol-SweetTokenLogic-addWhiteList(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! listExists(listName))

IRs:
TMP_400(bool) = INTERNAL_CALL, TokenLogic.listExists(bytes32)(listName)
TMP_401 = UnaryType.BANG TMP_400 
TMP_402(None) = SOLIDITY_CALL require(bool)(TMP_401)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(listNames.length < 256)

IRs:
REF_106 -> LENGTH listNames
TMP_403(bool) = REF_106 < 256
TMP_404(None) = SOLIDITY_CALL require(bool)(TMP_403)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
listNames.push(listName)

IRs:
REF_108 -> LENGTH listNames
TMP_406(uint256) := REF_108(uint256)
TMP_407(uint256) = TMP_406 + 1
REF_108(uint256) (->listNames) := TMP_407(uint256)
REF_109(bytes32) -> listNames[TMP_406]
REF_109(bytes32) (->listNames) := listName(bytes32)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
WhiteListAddition(listName)

IRs:
Emit WhiteListAddition(listName)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyRole(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(admin)"];
5->1;
}
// Function: 1122.sol-SweetTokenLogic-allowance(address,address)
digraph{
}
// Function: 1122.sol-SweetTokenLogic-approve(address,address,uint256)
digraph{
}
// Function: 1122.sol-SweetTokenLogic-balanceOf(address)
digraph{
}
// Function: 1122.sol-SweetTokenLogic-burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(false)

IRs:
TMP_497(None) = SOLIDITY_CALL assert(bool)(False)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tokenOnly()

IRs:
MODIFIER_CALL, TokenLogic.tokenOnly()()"];
2->1;
}
// Function: 1122.sol-SweetTokenLogic-canTransfer(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(freeTransfer || src == owner || dst == owner || sameWhiteList(src,dst))

IRs:
TMP_502(bool) = src == owner
TMP_503(bool) = freeTransfer || TMP_502
TMP_504(bool) = dst == owner
TMP_505(bool) = TMP_503 || TMP_504
TMP_506(bool) = INTERNAL_CALL, TokenLogic.sameWhiteList(address,address)(src,dst)
TMP_507(bool) = TMP_505 || TMP_506
TMP_508(None) = SOLIDITY_CALL require(bool)(TMP_507)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SweetTokenLogic-hasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
roles.knownRoleNames(contractHash,keccak256()(roleName))

IRs:
TMP_468(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_469(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:knownRoleNames, arguments:['contractHash', 'TMP_468']  
RETURN TMP_469"];
}
// Function: 1122.sol-SweetTokenLogic-indexOf(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < listNames.length

IRs:
REF_102 -> LENGTH listNames
TMP_392(bool) = i < REF_102
CONDITION TMP_392"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
listNames[i] == listName

IRs:
REF_103(bytes32) -> listNames[i]
TMP_393(bool) = REF_103 == listName
CONDITION TMP_393"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
(i,true)

IRs:
RETURN i,True"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_394(uint8) := i(uint8)
i(uint8) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
(0,false)

IRs:
RETURN 0,False"];
}
// Function: 1122.sol-SweetTokenLogic-listExists(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
(None,ok) = indexOf(listName)

IRs:
TUPLE_2(uint8,bool) = INTERNAL_CALL, TokenLogic.indexOf(bytes32)(listName)
ok(bool)= UNPACK TUPLE_2 index: 1 "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 1122.sol-SweetTokenLogic-listNamesLen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
listNames.length

IRs:
REF_101 -> LENGTH listNames
RETURN REF_101"];
}
// Function: 1122.sol-SweetTokenLogic-mintFor(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(false)

IRs:
TMP_495(None) = SOLIDITY_CALL assert(bool)(False)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tokenOnly()

IRs:
MODIFIER_CALL, TokenLogic.tokenOnly()()"];
2->1;
}
// Function: 1122.sol-SweetTokenLogic-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_517(bool) = msg.sender == owner
TMP_518(None) = SOLIDITY_CALL require(bool)(TMP_517)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SweetTokenLogic-onlyRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(senderHasRole(role))

IRs:
TMP_511(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_512(None) = SOLIDITY_CALL require(bool)(TMP_511)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SweetTokenLogic-removeFromWhiteList(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(listExists(listName))

IRs:
TMP_421(bool) = INTERNAL_CALL, TokenLogic.listExists(bytes32)(listName)
TMP_422(None) = SOLIDITY_CALL require(bool)(TMP_421)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whiteLists[guy][listName] = false

IRs:
REF_119(mapping(bytes32 => bool)) -> whiteLists[guy]
REF_120(bool) -> REF_119[listName]
REF_120(bool) (->whiteLists) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RemovalFromWhiteList(listName,guy)

IRs:
Emit RemovalFromWhiteList(listName,guy)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyRole(userManager)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(userManager)"];
4->1;
}
// Function: 1122.sol-SweetTokenLogic-removeWhiteList(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(i,ok) = indexOf(listName)

IRs:
TUPLE_3(uint8,bool) = INTERNAL_CALL, TokenLogic.indexOf(bytes32)(listName)
i(uint8)= UNPACK TUPLE_3 index: 0 
ok(bool)= UNPACK TUPLE_3 index: 1 "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(ok)

IRs:
TMP_410(None) = SOLIDITY_CALL require(bool)(ok)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
i < listNames.length - 1

IRs:
REF_110 -> LENGTH listNames
TMP_411(uint256) = REF_110 - 1
TMP_412(bool) = i < TMP_411
CONDITION TMP_412"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
listNames[i] = listNames[listNames.length - 1]

IRs:
REF_111(bytes32) -> listNames[i]
REF_112 -> LENGTH listNames
TMP_413(uint256) = REF_112 - 1
REF_113(bytes32) -> listNames[TMP_413]
REF_111(bytes32) (->listNames) := REF_113(bytes32)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
delete listNames[listNames.length - 1]

IRs:
REF_114 -> LENGTH listNames
TMP_414(uint256) = REF_114 - 1
REF_115(bytes32) -> listNames[TMP_414]
listNames = delete REF_115 "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
-- listNames.length

IRs:
REF_116 -> LENGTH listNames
REF_116(-> listNames) = REF_116 - 1"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
WhiteListRemoval(listName)

IRs:
Emit WhiteListRemoval(listName)"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
onlyRole(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(admin)"];
11->1;
}
// Function: 1122.sol-SweetTokenLogic-replaceLogic(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.setLogic(TokenLogicI(newLogic))

IRs:
TMP_395 = CONVERT newLogic to TokenLogicI
HIGH_LEVEL_CALL, dest:token(Token), function:setLogic, arguments:['TMP_395']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
data.setTokenLogic(newLogic)

IRs:
HIGH_LEVEL_CALL, dest:data(TokenData), function:setTokenLogic, arguments:['newLogic']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_398(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
4->1;
}
// Function: 1122.sol-SweetTokenLogic-restart()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(restarter)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(restarter)"];
2->1;
}
// Function: 1122.sol-SweetTokenLogic-roleOrOwner(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || senderHasRole(role))

IRs:
TMP_513(bool) = msg.sender == owner
TMP_514(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_515(bool) = TMP_513 || TMP_514
TMP_516(None) = SOLIDITY_CALL require(bool)(TMP_515)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SweetTokenLogic-sameWhiteList(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < listNames.length

IRs:
REF_95 -> LENGTH listNames
TMP_389(bool) = i < REF_95
CONDITION TMP_389"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
listName = listNames[i]

IRs:
REF_96(bytes32) -> listNames[i]
listName(bytes32) := REF_96(bytes32)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
whiteLists[src][listName] && whiteLists[dst][listName]

IRs:
REF_97(mapping(bytes32 => bool)) -> whiteLists[src]
REF_98(bool) -> REF_97[listName]
REF_99(mapping(bytes32 => bool)) -> whiteLists[dst]
REF_100(bool) -> REF_99[listName]
TMP_390(bool) = REF_98 && REF_100
CONDITION TMP_390"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_391(uint8) := i(uint8)
i(uint8) = i + 1"];
9->4;
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 1122.sol-SweetTokenLogic-senderHasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hasRole(roleName) && roles.roleList(contractHash,keccak256()(roleName),msg.sender)

IRs:
TMP_470(bool) = INTERNAL_CALL, SecuredWithRoles.hasRole(string)(roleName)
TMP_471(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_472(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:roleList, arguments:['contractHash', 'TMP_471', 'msg.sender']  
TMP_473(bool) = TMP_470 && TMP_472
RETURN TMP_473"];
}
// Function: 1122.sol-SweetTokenLogic-setFreeTransfer(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
freeTransfer = isFree

IRs:
freeTransfer(bool) := isFree(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 1122.sol-SweetTokenLogic-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-SweetTokenLogic-setRolesContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this != address(roles))

IRs:
TMP_476 = CONVERT roles to address
TMP_477(bool) = this != TMP_476
TMP_478(None) = SOLIDITY_CALL require(bool)(TMP_477)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_479 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_479(RolesI)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-SweetTokenLogic-setToken(address)
digraph{
}
// Function: 1122.sol-SweetTokenLogic-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
freeTransfer = true

IRs:
freeTransfer(bool) := True(bool)"];
}
// Function: 1122.sol-SweetTokenLogic-stop()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = true

IRs:
stopped(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(stopper)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(stopper)"];
2->1;
}
// Function: 1122.sol-SweetTokenLogic-stoppable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! stopped)

IRs:
TMP_509 = UnaryType.BANG stopped 
TMP_510(None) = SOLIDITY_CALL require(bool)(TMP_509)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SweetTokenLogic-tokenOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == address(token))

IRs:
TMP_499 = CONVERT token to address
TMP_500(bool) = msg.sender == TMP_499
TMP_501(None) = SOLIDITY_CALL assert(bool)(TMP_500)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-SweetTokenLogic-totalSupply()
digraph{
}
// Function: 1122.sol-SweetTokenLogic-transfer(address,address,uint256)
digraph{
}
// Function: 1122.sol-SweetTokenLogic-transferFrom(address,address,uint256)
digraph{
}
// Function: 1122.sol-Token-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1122.sol-Token-SecuredWithRoles(string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractHash = keccak256()(contractName_)

IRs:
TMP_303(bytes32) = SOLIDITY_CALL keccak256()(contractName_)
contractHash(bytes32) := TMP_303(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_304 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_304(RolesI)"];
}
// Function: 1122.sol-Token-Token(string,string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = name_

IRs:
name(string) := name_(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = symbol_

IRs:
symbol(string) := symbol_(string)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
SecuredWithRoles(name_,rolesContract)

IRs:
INTERNAL_CALL, SecuredWithRoles.SecuredWithRoles(string,address)(name_,rolesContract)"];
3->1;
}
// Function: 1122.sol-Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
logic.allowance(owner,spender)

IRs:
TMP_323(uint256) = HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:allowance, arguments:['owner', 'spender']  
RETURN TMP_323"];
2[label="Node Type: RETURN 2

EXPRESSION:
_allowance

IRs:
RETURN _allowance"];
}
// Function: 1122.sol-Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
ok = logic.approve(msg.sender,guy,wad)

IRs:
TMP_344(bool) = HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:approve, arguments:['msg.sender', 'guy', 'wad']  
ok(bool) := TMP_344(bool)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
ok

IRs:
CONDITION ok"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,guy,wad)

IRs:
Emit Approval(msg.sender,guy,wad)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
ok

IRs:
RETURN ok"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
stoppable()

IRs:
MODIFIER_CALL, SecuredWithRoles.stoppable()()"];
6->1;
}
// Function: 1122.sol-Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
logic.balanceOf(who)

IRs:
TMP_322(uint256) = HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:balanceOf, arguments:['who']  
RETURN TMP_322"];
2[label="Node Type: RETURN 2

EXPRESSION:
value

IRs:
RETURN value"];
}
// Function: 1122.sol-Token-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
logic.burn(msg.sender,wad)

IRs:
HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:burn, arguments:['msg.sender', 'wad']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogBurn(msg.sender,wad)

IRs:
Emit LogBurn(msg.sender,wad)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
stoppable()

IRs:
MODIFIER_CALL, SecuredWithRoles.stoppable()()"];
3->1;
}
// Function: 1122.sol-Token-hasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
roles.knownRoleNames(contractHash,keccak256()(roleName))

IRs:
TMP_305(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_306(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:knownRoleNames, arguments:['contractHash', 'TMP_305']  
RETURN TMP_306"];
}
// Function: 1122.sol-Token-logicOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(logic) == address(0x0) || address(logic) == msg.sender)

IRs:
TMP_369 = CONVERT logic to address
TMP_370 = CONVERT 0 to address
TMP_371(bool) = TMP_369 == TMP_370
TMP_372 = CONVERT logic to address
TMP_373(bool) = TMP_372 == msg.sender
TMP_374(bool) = TMP_371 || TMP_373
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Token-mintFor(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
logic.mintFor(recipient,wad)

IRs:
HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:mintFor, arguments:['recipient', 'wad']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogMint(recipient,wad)

IRs:
Emit LogMint(recipient,wad)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0x0),recipient,wad)

IRs:
TMP_351 = CONVERT 0 to address
Emit Transfer(TMP_351,recipient,wad)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
stoppable()

IRs:
MODIFIER_CALL, SecuredWithRoles.stoppable()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyRole(minter)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(minter)"];
5->1;
}
// Function: 1122.sol-Token-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_367(bool) = msg.sender == owner
TMP_368(None) = SOLIDITY_CALL require(bool)(TMP_367)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Token-onlyRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(senderHasRole(role))

IRs:
TMP_361(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_362(None) = SOLIDITY_CALL require(bool)(TMP_361)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Token-pull(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
transferFrom(src,msg.sender,wad)

IRs:
TMP_347(bool) = INTERNAL_CALL, Token.transferFrom(address,address,uint256)(src,msg.sender,wad)
RETURN TMP_347"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stoppable()

IRs:
MODIFIER_CALL, SecuredWithRoles.stoppable()()"];
2->1;
}
// Function: 1122.sol-Token-restart()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(restarter)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(restarter)"];
2->1;
}
// Function: 1122.sol-Token-roleOrOwner(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || senderHasRole(role))

IRs:
TMP_363(bool) = msg.sender == owner
TMP_364(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_365(bool) = TMP_363 || TMP_364
TMP_366(None) = SOLIDITY_CALL require(bool)(TMP_365)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Token-senderHasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hasRole(roleName) && roles.roleList(contractHash,keccak256()(roleName),msg.sender)

IRs:
TMP_307(bool) = INTERNAL_CALL, SecuredWithRoles.hasRole(string)(roleName)
TMP_308(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_309(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:roleList, arguments:['contractHash', 'TMP_308', 'msg.sender']  
TMP_310(bool) = TMP_307 && TMP_309
RETURN TMP_310"];
}
// Function: 1122.sol-Token-setLogic(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(logic_ != address(0))

IRs:
TMP_326 = CONVERT 0 to address
TMP_327(bool) = logic_ != TMP_326
TMP_328(None) = SOLIDITY_CALL assert(bool)(TMP_327)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
logic = TokenLogicI(logic_)

IRs:
TMP_329 = CONVERT logic_ to TokenLogicI
logic(TokenLogicI) := TMP_329(TokenLogicI)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
LogLogicReplaced(logic)

IRs:
Emit LogLogicReplaced(logic)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
logicOnly()

IRs:
MODIFIER_CALL, Token.logicOnly()()"];
4->1;
}
// Function: 1122.sol-Token-setName(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = name_

IRs:
name(string) := name_(string)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(admin)"];
2->1;
}
// Function: 1122.sol-Token-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-Token-setRolesContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this != address(roles))

IRs:
TMP_313 = CONVERT roles to address
TMP_314(bool) = this != TMP_313
TMP_315(None) = SOLIDITY_CALL require(bool)(TMP_314)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_316 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_316(RolesI)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-Token-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
}
// Function: 1122.sol-Token-stop()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = true

IRs:
stopped(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(stopper)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(stopper)"];
2->1;
}
// Function: 1122.sol-Token-stoppable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! stopped)

IRs:
TMP_359 = UnaryType.BANG stopped 
TMP_360(None) = SOLIDITY_CALL require(bool)(TMP_359)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
logic.totalSupply()

IRs:
TMP_321(uint256) = HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:totalSupply, arguments:[]  
RETURN TMP_321"];
}
// Function: 1122.sol-Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
retVal = logic.transfer(msg.sender,dst,wad)

IRs:
TMP_332(bool) = HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:transfer, arguments:['msg.sender', 'dst', 'wad']  
retVal(bool) := TMP_332(bool)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
retVal

IRs:
CONDITION retVal"];
2->3[label="True"];
2->12[label="False"];
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: INLINE ASM 4
"];
4->5;
5[label="Node Type: END INLINE ASM 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
codeLength > 0

IRs:
TMP_333(bool) = codeLength > 0
CONDITION TMP_333"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
receiver = ERC223ReceivingContract(dst)

IRs:
TMP_334 = CONVERT dst to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_334(ERC223ReceivingContract)"];
7->8;
8[label="Node Type: NEW VARIABLE 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
receiver.tokenFallback(msg.sender,wad,empty)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', 'wad', 'empty']  "];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Transfer(msg.sender,dst,wad)

IRs:
Emit Transfer(msg.sender,dst,wad)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
retVal

IRs:
RETURN retVal"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
stoppable()

IRs:
MODIFIER_CALL, SecuredWithRoles.stoppable()()"];
14->1;
}
// Function: 1122.sol-Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
retVal = logic.transferFrom(src,dst,wad)

IRs:
TMP_338(bool) = HIGH_LEVEL_CALL, dest:logic(TokenLogicI), function:transferFrom, arguments:['src', 'dst', 'wad']  
retVal(bool) := TMP_338(bool)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
retVal

IRs:
CONDITION retVal"];
2->3[label="True"];
2->12[label="False"];
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: INLINE ASM 4
"];
4->5;
5[label="Node Type: END INLINE ASM 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
codeLength > 0

IRs:
TMP_339(bool) = codeLength > 0
CONDITION TMP_339"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
receiver = ERC223ReceivingContract(dst)

IRs:
TMP_340 = CONVERT dst to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_340(ERC223ReceivingContract)"];
7->8;
8[label="Node Type: NEW VARIABLE 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
receiver.tokenFallback(src,wad,empty)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['src', 'wad', 'empty']  "];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Transfer(src,dst,wad)

IRs:
Emit Transfer(src,dst,wad)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
retVal

IRs:
RETURN retVal"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
stoppable()

IRs:
MODIFIER_CALL, SecuredWithRoles.stoppable()()"];
14->1;
}
// Function: 1122.sol-Token-triggerTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Transfer(src,dst,wad)

IRs:
Emit Transfer(src,dst,wad)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
logicOnly()

IRs:
MODIFIER_CALL, Token.logicOnly()()"];
2->1;
}
// Function: 1122.sol-TokenData-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1122.sol-TokenData-TokenData(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
logic = logic_

IRs:
logic(address) := logic_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] = supply

IRs:
REF_20(uint256) -> balances[owner]
REF_20(uint256) (->balances) := supply(uint256)"];
}
// Function: 1122.sol-TokenData-onlyLogic()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == logic)

IRs:
TMP_174(bool) = msg.sender == logic
TMP_175(None) = SOLIDITY_CALL assert(bool)(TMP_174)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenData-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_172(bool) = msg.sender == owner
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenData-setApprovals(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
approvals[src][guy] = wad

IRs:
REF_22(mapping(address => uint256)) -> approvals[src]
REF_23(uint256) -> REF_22[guy]
REF_23(uint256) (->approvals) := wad(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyLogic()

IRs:
MODIFIER_CALL, TokenData.onlyLogic()()"];
2->1;
}
// Function: 1122.sol-TokenData-setBalances(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[guy] = balance

IRs:
REF_21(uint256) -> balances[guy]
REF_21(uint256) (->balances) := balance(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyLogic()

IRs:
MODIFIER_CALL, TokenData.onlyLogic()()"];
2->1;
}
// Function: 1122.sol-TokenData-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-TokenData-setSupply(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
supply = supply_

IRs:
supply(uint256) := supply_(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyLogic()

IRs:
MODIFIER_CALL, TokenData.onlyLogic()()"];
2->1;
}
// Function: 1122.sol-TokenData-setTokenLogic(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
logic = logic_

IRs:
logic(address) := logic_(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyLogic()

IRs:
MODIFIER_CALL, TokenData.onlyLogic()()"];
2->1;
}
// Function: 1122.sol-TokenI-allowance(address,address)
digraph{
}
// Function: 1122.sol-TokenI-approve(address,uint256)
digraph{
}
// Function: 1122.sol-TokenI-balanceOf(address)
digraph{
}
// Function: 1122.sol-TokenI-mintFor(address,uint256)
digraph{
}
// Function: 1122.sol-TokenI-totalSupply()
digraph{
}
// Function: 1122.sol-TokenI-transfer(address,uint256)
digraph{
}
// Function: 1122.sol-TokenI-transferFrom(address,address,uint256)
digraph{
}
// Function: 1122.sol-TokenI-triggerTransfer(address,address,uint256)
digraph{
}
// Function: 1122.sol-TokenLogic-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1122.sol-TokenLogic-SecuredWithRoles(string,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
contractHash = keccak256()(contractName_)

IRs:
TMP_176(bytes32) = SOLIDITY_CALL keccak256()(contractName_)
contractHash(bytes32) := TMP_176(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_177 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_177(RolesI)"];
}
// Function: 1122.sol-TokenLogic-TokenLogic(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token_ != address(0x0))

IRs:
TMP_193 = CONVERT 0 to address
TMP_194(bool) = token_ != TMP_193
TMP_195(None) = SOLIDITY_CALL require(bool)(TMP_194)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(rolesContract != address(0x0))

IRs:
TMP_196 = CONVERT 0 to address
TMP_197(bool) = rolesContract != TMP_196
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token = Token(token_)

IRs:
TMP_199 = CONVERT token_ to Token
token(Token) := TMP_199(Token)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
tokenData_ == address(0x0)

IRs:
TMP_200 = CONVERT 0 to address
TMP_201(bool) = tokenData_ == TMP_200
CONDITION TMP_201"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
data = new TokenData(this,msg.sender)

IRs:
TMP_203(TokenData) = new TokenData(this,msg.sender) 
data(TokenData) := TMP_203(TokenData)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
data = TokenData(tokenData_)

IRs:
TMP_204 = CONVERT tokenData_ to TokenData
data(TokenData) := TMP_204(TokenData)"];
6->7;
7[label="Node Type: END_IF 7
"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
SecuredWithRoles(TokenLogic,rolesContract)

IRs:
INTERNAL_CALL, SecuredWithRoles.SecuredWithRoles(string,address)(TokenLogic,rolesContract)"];
8->1;
}
// Function: 1122.sol-TokenLogic-addToWhiteList(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(listExists(listName))

IRs:
TMP_234(bool) = INTERNAL_CALL, TokenLogic.listExists(bytes32)(listName)
TMP_235(None) = SOLIDITY_CALL require(bool)(TMP_234)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whiteLists[guy][listName] = true

IRs:
REF_48(mapping(bytes32 => bool)) -> whiteLists[guy]
REF_49(bool) -> REF_48[listName]
REF_49(bool) (->whiteLists) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
AdditionToWhiteList(listName,guy)

IRs:
Emit AdditionToWhiteList(listName,guy)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyRole(userManager)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(userManager)"];
4->1;
}
// Function: 1122.sol-TokenLogic-addWhiteList(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! listExists(listName))

IRs:
TMP_217(bool) = INTERNAL_CALL, TokenLogic.listExists(bytes32)(listName)
TMP_218 = UnaryType.BANG TMP_217 
TMP_219(None) = SOLIDITY_CALL require(bool)(TMP_218)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(listNames.length < 256)

IRs:
REF_37 -> LENGTH listNames
TMP_220(bool) = REF_37 < 256
TMP_221(None) = SOLIDITY_CALL require(bool)(TMP_220)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
listNames.push(listName)

IRs:
REF_39 -> LENGTH listNames
TMP_223(uint256) := REF_39(uint256)
TMP_224(uint256) = TMP_223 + 1
REF_39(uint256) (->listNames) := TMP_224(uint256)
REF_40(bytes32) -> listNames[TMP_223]
REF_40(bytes32) (->listNames) := listName(bytes32)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
WhiteListAddition(listName)

IRs:
Emit WhiteListAddition(listName)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyRole(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(admin)"];
5->1;
}
// Function: 1122.sol-TokenLogic-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
data.approvals(src,spender)

IRs:
TMP_247(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:approvals, arguments:['src', 'spender']  
RETURN TMP_247"];
}
// Function: 1122.sol-TokenLogic-approve(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
data.setApprovals(src,dst,wad)

IRs:
HIGH_LEVEL_CALL, dest:data(TokenData), function:setApprovals, arguments:['src', 'dst', 'wad']  "];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenOnly()

IRs:
MODIFIER_CALL, TokenLogic.tokenOnly()()"];
3->1;
}
// Function: 1122.sol-TokenLogic-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
data.balances(src)

IRs:
TMP_246(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:balances, arguments:['src']  
RETURN TMP_246"];
}
// Function: 1122.sol-TokenLogic-burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
data.setBalances(src,Math.sub(data.balances(src),wad))

IRs:
TMP_276(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:balances, arguments:['src']  
TMP_277(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['TMP_276', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setBalances, arguments:['src', 'TMP_277']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
data.setSupply(Math.sub(data.supply(),wad))

IRs:
TMP_279(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:supply, arguments:[]  
TMP_280(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['TMP_279', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setSupply, arguments:['TMP_280']  "];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenOnly()

IRs:
MODIFIER_CALL, TokenLogic.tokenOnly()()"];
3->1;
}
// Function: 1122.sol-TokenLogic-canTransfer(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(freeTransfer || src == owner || dst == owner || sameWhiteList(src,dst))

IRs:
TMP_296(bool) = src == owner
TMP_297(bool) = freeTransfer || TMP_296
TMP_298(bool) = dst == owner
TMP_299(bool) = TMP_297 || TMP_298
TMP_300(bool) = INTERNAL_CALL, TokenLogic.sameWhiteList(address,address)(src,dst)
TMP_301(bool) = TMP_299 || TMP_300
TMP_302(None) = SOLIDITY_CALL require(bool)(TMP_301)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenLogic-hasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
roles.knownRoleNames(contractHash,keccak256()(roleName))

IRs:
TMP_178(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_179(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:knownRoleNames, arguments:['contractHash', 'TMP_178']  
RETURN TMP_179"];
}
// Function: 1122.sol-TokenLogic-indexOf(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < listNames.length

IRs:
REF_33 -> LENGTH listNames
TMP_209(bool) = i < REF_33
CONDITION TMP_209"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
listNames[i] == listName

IRs:
REF_34(bytes32) -> listNames[i]
TMP_210(bool) = REF_34 == listName
CONDITION TMP_210"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
(i,true)

IRs:
RETURN i,True"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_211(uint8) := i(uint8)
i(uint8) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
(0,false)

IRs:
RETURN 0,False"];
}
// Function: 1122.sol-TokenLogic-listExists(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
(None,ok) = indexOf(listName)

IRs:
TUPLE_0(uint8,bool) = INTERNAL_CALL, TokenLogic.indexOf(bytes32)(listName)
ok(bool)= UNPACK TUPLE_0 index: 1 "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 1122.sol-TokenLogic-listNamesLen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
listNames.length

IRs:
REF_32 -> LENGTH listNames
RETURN REF_32"];
}
// Function: 1122.sol-TokenLogic-mintFor(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
data.setBalances(dst,Math.add(data.balances(dst),wad))

IRs:
TMP_269(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:balances, arguments:['dst']  
TMP_270(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_269', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setBalances, arguments:['dst', 'TMP_270']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
data.setSupply(Math.add(data.supply(),wad))

IRs:
TMP_272(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:supply, arguments:[]  
TMP_273(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_272', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setSupply, arguments:['TMP_273']  "];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenOnly()

IRs:
MODIFIER_CALL, TokenLogic.tokenOnly()()"];
3->1;
}
// Function: 1122.sol-TokenLogic-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_291(bool) = msg.sender == owner
TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenLogic-onlyRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(senderHasRole(role))

IRs:
TMP_285(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenLogic-removeFromWhiteList(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(listExists(listName))

IRs:
TMP_238(bool) = INTERNAL_CALL, TokenLogic.listExists(bytes32)(listName)
TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whiteLists[guy][listName] = false

IRs:
REF_50(mapping(bytes32 => bool)) -> whiteLists[guy]
REF_51(bool) -> REF_50[listName]
REF_51(bool) (->whiteLists) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RemovalFromWhiteList(listName,guy)

IRs:
Emit RemovalFromWhiteList(listName,guy)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyRole(userManager)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(userManager)"];
4->1;
}
// Function: 1122.sol-TokenLogic-removeWhiteList(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(i,ok) = indexOf(listName)

IRs:
TUPLE_1(uint8,bool) = INTERNAL_CALL, TokenLogic.indexOf(bytes32)(listName)
i(uint8)= UNPACK TUPLE_1 index: 0 
ok(bool)= UNPACK TUPLE_1 index: 1 "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(ok)

IRs:
TMP_227(None) = SOLIDITY_CALL require(bool)(ok)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
i < listNames.length - 1

IRs:
REF_41 -> LENGTH listNames
TMP_228(uint256) = REF_41 - 1
TMP_229(bool) = i < TMP_228
CONDITION TMP_229"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
listNames[i] = listNames[listNames.length - 1]

IRs:
REF_42(bytes32) -> listNames[i]
REF_43 -> LENGTH listNames
TMP_230(uint256) = REF_43 - 1
REF_44(bytes32) -> listNames[TMP_230]
REF_42(bytes32) (->listNames) := REF_44(bytes32)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
delete listNames[listNames.length - 1]

IRs:
REF_45 -> LENGTH listNames
TMP_231(uint256) = REF_45 - 1
REF_46(bytes32) -> listNames[TMP_231]
listNames = delete REF_46 "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
-- listNames.length

IRs:
REF_47 -> LENGTH listNames
REF_47(-> listNames) = REF_47 - 1"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
WhiteListRemoval(listName)

IRs:
Emit WhiteListRemoval(listName)"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
onlyRole(admin)

IRs:
MODIFIER_CALL, SecuredWithRoles.onlyRole(string)(admin)"];
11->1;
}
// Function: 1122.sol-TokenLogic-replaceLogic(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.setLogic(TokenLogicI(newLogic))

IRs:
TMP_212 = CONVERT newLogic to TokenLogicI
HIGH_LEVEL_CALL, dest:token(Token), function:setLogic, arguments:['TMP_212']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
data.setTokenLogic(newLogic)

IRs:
HIGH_LEVEL_CALL, dest:data(TokenData), function:setTokenLogic, arguments:['newLogic']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_215(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
4->1;
}
// Function: 1122.sol-TokenLogic-restart()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(restarter)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(restarter)"];
2->1;
}
// Function: 1122.sol-TokenLogic-roleOrOwner(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || senderHasRole(role))

IRs:
TMP_287(bool) = msg.sender == owner
TMP_288(bool) = INTERNAL_CALL, SecuredWithRoles.senderHasRole(string)(role)
TMP_289(bool) = TMP_287 || TMP_288
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenLogic-sameWhiteList(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < listNames.length

IRs:
REF_26 -> LENGTH listNames
TMP_206(bool) = i < REF_26
CONDITION TMP_206"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
listName = listNames[i]

IRs:
REF_27(bytes32) -> listNames[i]
listName(bytes32) := REF_27(bytes32)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
whiteLists[src][listName] && whiteLists[dst][listName]

IRs:
REF_28(mapping(bytes32 => bool)) -> whiteLists[src]
REF_29(bool) -> REF_28[listName]
REF_30(mapping(bytes32 => bool)) -> whiteLists[dst]
REF_31(bool) -> REF_30[listName]
TMP_207(bool) = REF_29 && REF_31
CONDITION TMP_207"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_208(uint8) := i(uint8)
i(uint8) = i + 1"];
9->4;
10[label="Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 1122.sol-TokenLogic-senderHasRole(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hasRole(roleName) && roles.roleList(contractHash,keccak256()(roleName),msg.sender)

IRs:
TMP_180(bool) = INTERNAL_CALL, SecuredWithRoles.hasRole(string)(roleName)
TMP_181(bytes32) = SOLIDITY_CALL keccak256()(roleName)
TMP_182(bool) = HIGH_LEVEL_CALL, dest:roles(RolesI), function:roleList, arguments:['contractHash', 'TMP_181', 'msg.sender']  
TMP_183(bool) = TMP_180 && TMP_182
RETURN TMP_183"];
}
// Function: 1122.sol-TokenLogic-setFreeTransfer(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
freeTransfer = isFree

IRs:
freeTransfer(bool) := isFree(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 1122.sol-TokenLogic-setOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-TokenLogic-setRolesContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this != address(roles))

IRs:
TMP_186 = CONVERT roles to address
TMP_187(bool) = this != TMP_186
TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roles = RolesI(roles_)

IRs:
TMP_189 = CONVERT roles_ to RolesI
roles(RolesI) := TMP_189(RolesI)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 1122.sol-TokenLogic-setToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token = Token(token_)

IRs:
TMP_243 = CONVERT token_ to Token
token(Token) := TMP_243(Token)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 1122.sol-TokenLogic-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
freeTransfer = true

IRs:
freeTransfer(bool) := True(bool)"];
}
// Function: 1122.sol-TokenLogic-stop()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stopped = true

IRs:
stopped(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roleOrOwner(stopper)

IRs:
MODIFIER_CALL, SecuredWithRoles.roleOrOwner(string)(stopper)"];
2->1;
}
// Function: 1122.sol-TokenLogic-stoppable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! stopped)

IRs:
TMP_283 = UnaryType.BANG stopped 
TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenLogic-tokenOnly()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == address(token))

IRs:
TMP_293 = CONVERT token to address
TMP_294(bool) = msg.sender == TMP_293
TMP_295(None) = SOLIDITY_CALL assert(bool)(TMP_294)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1122.sol-TokenLogic-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
data.supply()

IRs:
TMP_245(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:supply, arguments:[]  
RETURN TMP_245"];
}
// Function: 1122.sol-TokenLogic-transfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
data.setBalances(src,Math.sub(data.balances(src),wad))

IRs:
TMP_248(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:balances, arguments:['src']  
TMP_249(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['TMP_248', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setBalances, arguments:['src', 'TMP_249']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
data.setBalances(dst,Math.add(data.balances(dst),wad))

IRs:
TMP_251(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:balances, arguments:['dst']  
TMP_252(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_251', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setBalances, arguments:['dst', 'TMP_252']  "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokenOnly()

IRs:
MODIFIER_CALL, TokenLogic.tokenOnly()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canTransfer(src,dst)

IRs:
MODIFIER_CALL, TokenLogic.canTransfer(address,address)(src,dst)"];
5->1;
}
// Function: 1122.sol-TokenLogic-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
data.setApprovals(src,dst,Math.sub(data.approvals(src,dst),wad))

IRs:
TMP_256(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:approvals, arguments:['src', 'dst']  
TMP_257(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['TMP_256', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setApprovals, arguments:['src', 'dst', 'TMP_257']  "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
data.setBalances(src,Math.sub(data.balances(src),wad))

IRs:
TMP_259(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:balances, arguments:['src']  
TMP_260(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['TMP_259', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setBalances, arguments:['src', 'TMP_260']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
data.setBalances(dst,Math.add(data.balances(dst),wad))

IRs:
TMP_262(uint256) = HIGH_LEVEL_CALL, dest:data(TokenData), function:balances, arguments:['dst']  
TMP_263(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_262', 'wad'] 
HIGH_LEVEL_CALL, dest:data(TokenData), function:setBalances, arguments:['dst', 'TMP_263']  "];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokenOnly()

IRs:
MODIFIER_CALL, TokenLogic.tokenOnly()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
canTransfer(src,dst)

IRs:
MODIFIER_CALL, TokenLogic.canTransfer(address,address)(src,dst)"];
6->1;
}
// Function: 1122.sol-TokenLogicI-allowance(address,address)
digraph{
}
// Function: 1122.sol-TokenLogicI-approve(address,address,uint256)
digraph{
}
// Function: 1122.sol-TokenLogicI-balanceOf(address)
digraph{
}
// Function: 1122.sol-TokenLogicI-burn(address,uint256)
digraph{
}
// Function: 1122.sol-TokenLogicI-mintFor(address,uint256)
digraph{
}
// Function: 1122.sol-TokenLogicI-setToken(address)
digraph{
}
// Function: 1122.sol-TokenLogicI-totalSupply()
digraph{
}
// Function: 1122.sol-TokenLogicI-transfer(address,address,uint256)
digraph{
}
// Function: 1122.sol-TokenLogicI-transferFrom(address,address,uint256)
digraph{
}
}
