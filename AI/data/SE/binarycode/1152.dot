digraph G {
// Function: 1152.sol-ERC223Receiving-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 1152.sol-Fortis-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[_customerAddress][spender] = tokens

IRs:
REF_48(mapping(address => uint256)) -> allowed[_customerAddress]
REF_49(uint256) -> REF_48[spender]
REF_49(uint256) (->allowed) := tokens(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(_customerAddress,spender,tokens)

IRs:
Emit Approval(_customerAddress,spender,tokens)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1152.sol-Fortis-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
getFrontEndTokenBalanceOf(_owner)

IRs:
TMP_143(uint256) = INTERNAL_CALL, Fortis.getFrontEndTokenBalanceOf(address)(_owner)
RETURN TMP_143"];
}
// Function: 1152.sol-Fortis-buy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_15(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(userSelectedRate[_customerAddress])

IRs:
REF_16(bool) -> userSelectedRate[_customerAddress]
TMP_16(None) = SOLIDITY_CALL require(bool)(REF_16)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
purchaseTokens(msg.value,_referredBy)

IRs:
TMP_17(uint256) = INTERNAL_CALL, Fortis.purchaseTokens(uint256,address)(msg.value,_referredBy)"];
}
// Function: 1152.sol-Fortis-buyAndSetDivPercentage(address,uint8,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(icoPhase || regularPhase)

IRs:
TMP_1(bool) = icoPhase || regularPhase
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
icoPhase

IRs:
CONDITION icoPhase"];
2->3[label="True"];
2->7[label="False"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
hashedProvidedPass = keccak256()(providedUnhashedPass)

IRs:
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(providedUnhashedPass)
hashedProvidedPass(bytes32) := TMP_3(bytes32)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(hashedProvidedPass == icoHashedPass || msg.sender == bankrollAddress)

IRs:
TMP_4(bool) = hashedProvidedPass == icoHashedPass
TMP_5(bool) = msg.sender == bankrollAddress
TMP_6(bool) = TMP_4 || TMP_5
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
gasPrice = tx.gasprice

IRs:
gasPrice(uint256) := tx.gasprice(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap)

IRs:
TMP_8(bool) = gasPrice <= icoMaxGasPrice
TMP_9(bool) = ethInvestedDuringICO <= icoHardCap
TMP_10(bool) = TMP_8 && TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(validDividendRates_[_divChoice])

IRs:
REF_13(bool) -> validDividendRates_[_divChoice]
TMP_12(None) = SOLIDITY_CALL require(bool)(REF_13)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
userSelectedRate[msg.sender] = true

IRs:
REF_14(bool) -> userSelectedRate[msg.sender]
REF_14(bool) (->userSelectedRate) := True(bool)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
userDividendRate[msg.sender] = _divChoice

IRs:
REF_15(uint8) -> userDividendRate[msg.sender]
REF_15(uint8) (->userDividendRate) := _divChoice(uint8)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
UserDividendRate(msg.sender,_divChoice)

IRs:
Emit UserDividendRate(msg.sender,_divChoice)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
purchaseTokens(msg.value,_referredBy)

IRs:
TMP_14(uint256) = INTERNAL_CALL, Fortis.purchaseTokens(uint256,address)(msg.value,_referredBy)"];
}
// Function: 1152.sol-Fortis-buyAndTransfer(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
buyAndTransfer(_referredBy,target,empty,20)

IRs:
INTERNAL_CALL, Fortis.buyAndTransfer(address,address,bytes,uint8)(_referredBy,target,empty,20)"];
}
// Function: 1152.sol-Fortis-buyAndTransfer(address,address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyAndTransfer(_referredBy,target,_data,20)

IRs:
INTERNAL_CALL, Fortis.buyAndTransfer(address,address,bytes,uint8)(_referredBy,target,_data,20)"];
}
// Function: 1152.sol-Fortis-buyAndTransfer(address,address,bytes,uint8)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_20(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
frontendBalance = frontTokenBalanceLedger_[msg.sender]

IRs:
REF_17(uint256) -> frontTokenBalanceLedger_[msg.sender]
frontendBalance(uint256) := REF_17(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
userSelectedRate[_customerAddress] && divChoice == 0

IRs:
REF_18(bool) -> userSelectedRate[_customerAddress]
TMP_21(bool) = divChoice == 0
TMP_22(bool) = REF_18 && TMP_21
CONDITION TMP_22"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
purchaseTokens(msg.value,_referredBy)

IRs:
TMP_23(uint256) = INTERNAL_CALL, Fortis.purchaseTokens(uint256,address)(msg.value,_referredBy)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
buyAndSetDivPercentage(_referredBy,divChoice,0x0)

IRs:
TMP_24(uint256) = INTERNAL_CALL, Fortis.buyAndSetDivPercentage(address,uint8,string)(_referredBy,divChoice,0x0)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender],frontendBalance)

IRs:
REF_20(uint256) -> frontTokenBalanceLedger_[msg.sender]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', 'frontendBalance'] 
difference(uint256) := TMP_25(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transferTo(msg.sender,target,difference,_data)

IRs:
INTERNAL_CALL, Fortis.transferTo(address,address,uint256,bytes)(msg.sender,target,difference,_data)"];
}
// Function: 1152.sol-Fortis-buyPrice(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
icoPhase || currentEthInvested < ethInvestedDuringICO

IRs:
TMP_159(bool) = currentEthInvested < ethInvestedDuringICO
TMP_160(bool) = icoPhase || TMP_159
CONDITION TMP_160"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
price = tokenPriceInitial_

IRs:
price(uint256) := tokenPriceInitial_(uint256)"];
3->6;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokensReceivedForEth = ethereumToTokens_(1000000000000000)

IRs:
TMP_161(uint256) = INTERNAL_CALL, Fortis.ethereumToTokens_(uint256)(1000000000000000)
tokensReceivedForEth(uint256) := TMP_161(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
price = (1e18 * 1000000000000000) / tokensReceivedForEth

IRs:
TMP_162(uint256) = 1000000000000000000 * 1000000000000000
TMP_163(uint256) = TMP_162 / tokensReceivedForEth
price(uint256) := TMP_163(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
theBuyPrice = (price.mul(dividendRate).div(100)).add(price)

IRs:
TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['price', 'dividendRate'] 
TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_164', '100'] 
TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_165', 'price'] 
theBuyPrice(uint256) := TMP_166(uint256)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
theBuyPrice

IRs:
RETURN theBuyPrice"];
}
// Function: 1152.sol-Fortis-calculateEthereumReceived(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_tokensToSell <= tokenSupply)

IRs:
TMP_171(bool) = _tokensToSell <= tokenSupply
TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_ethereum = tokensToEthereum_(_tokensToSell)

IRs:
TMP_173(uint256) = INTERNAL_CALL, Fortis.tokensToEthereum_(uint256)(_tokensToSell)
_ethereum(uint256) := TMP_173(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
userAverageDividendRate = getUserAverageDividendRate(msg.sender)

IRs:
TMP_174(uint256) = INTERNAL_CALL, Fortis.getUserAverageDividendRate(address)(msg.sender)
userAverageDividendRate(uint256) := TMP_174(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_dividends = (_ethereum.mul(userAverageDividendRate).div(100)).div(magnitude)

IRs:
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_ethereum', 'userAverageDividendRate'] 
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_175', '100'] 
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_176', 'magnitude'] 
_dividends(uint256) := TMP_177(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_taxedEthereum = _ethereum.sub(_dividends)

IRs:
TMP_178(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereum', '_dividends'] 
_taxedEthereum(uint256) := TMP_178(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
_taxedEthereum

IRs:
RETURN _taxedEthereum"];
}
// Function: 1152.sol-Fortis-calculateTokensReceived(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_dividends = (_ethereumToSpend.mul(userDividendRate[msg.sender])).div(100)

IRs:
REF_74(uint8) -> userDividendRate[msg.sender]
TMP_167(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_ethereumToSpend', 'REF_74'] 
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_167', '100'] 
_dividends(uint256) := TMP_168(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_taxedEthereum = _ethereumToSpend.sub(_dividends)

IRs:
TMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereumToSpend', '_dividends'] 
_taxedEthereum(uint256) := TMP_169(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_amountOfTokens = ethereumToTokens_(_taxedEthereum)

IRs:
TMP_170(uint256) = INTERNAL_CALL, Fortis.ethereumToTokens_(uint256)(_taxedEthereum)
_amountOfTokens(uint256) := TMP_170(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
_amountOfTokens

IRs:
RETURN _amountOfTokens"];
}
// Function: 1152.sol-Fortis-cbrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = (x + 1) / 3

IRs:
TMP_369(uint256) = x + 1
TMP_370(uint256) = TMP_369 / 3
z(uint256) := TMP_370(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
y = x

IRs:
y(uint256) := x(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
z < y

IRs:
TMP_371(bool) = z < y
CONDITION TMP_371"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
y = z

IRs:
y(uint256) := z(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
z = (x / (z * z) + 2 * z) / 3

IRs:
TMP_372(uint256) = z * z
TMP_373(uint256) = x / TMP_372
TMP_374(uint256) = 2 * z
TMP_375(uint256) = TMP_373 + TMP_374
TMP_376(uint256) = TMP_375 / 3
z(uint256) := TMP_376(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
y

IRs:
RETURN y"];
}
// Function: 1152.sol-Fortis-changeBankroll(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bankrollAddress = _newBankrollAddress

IRs:
bankrollAddress(address) := _newBankrollAddress(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
2->1;
}
// Function: 1152.sol-Fortis-constructor(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bankrollAddress = _bankrollAddress

IRs:
bankrollAddress(address) := _bankrollAddress(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
divCardContract = ZethrDividendCards(_divCardAddress)

IRs:
TMP_0 = CONVERT _divCardAddress to ZethrDividendCards
divCardContract(ZethrDividendCards) := TMP_0(ZethrDividendCards)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
administrators[0x9b3bb44b1a9243db229e5ccc6d20cada9efce5f8] = true

IRs:
REF_0(bool) -> administrators[886225019212373048451147932148992591411334145528]
REF_0(bool) (->administrators) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
administrators[0x487a03097b4d7320d5a0e7451f6a0e1224c37f09] = true

IRs:
REF_1(bool) -> administrators[413768290976833464755412109730741708939128438537]
REF_1(bool) (->administrators) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
administrators[0x24d6e2d15a85c27b0282bbc2afbc06cfbd9c15a0] = true

IRs:
REF_2(bool) -> administrators[210315785838104080152694499522223778427303630240]
REF_2(bool) (->administrators) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
administrators[msg.sender] = true

IRs:
REF_3(bool) -> administrators[msg.sender]
REF_3(bool) (->administrators) := True(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
validDividendRates_[2] = true

IRs:
REF_4(bool) -> validDividendRates_[2]
REF_4(bool) (->validDividendRates_) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
validDividendRates_[5] = true

IRs:
REF_5(bool) -> validDividendRates_[5]
REF_5(bool) (->validDividendRates_) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
validDividendRates_[10] = true

IRs:
REF_6(bool) -> validDividendRates_[10]
REF_6(bool) (->validDividendRates_) := True(bool)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
validDividendRates_[15] = true

IRs:
REF_7(bool) -> validDividendRates_[15]
REF_7(bool) (->validDividendRates_) := True(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
validDividendRates_[20] = true

IRs:
REF_8(bool) -> validDividendRates_[20]
REF_8(bool) (->validDividendRates_) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
validDividendRates_[25] = true

IRs:
REF_9(bool) -> validDividendRates_[25]
REF_9(bool) (->validDividendRates_) := True(bool)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
validDividendRates_[33] = true

IRs:
REF_10(bool) -> validDividendRates_[33]
REF_10(bool) (->validDividendRates_) := True(bool)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
userSelectedRate[bankrollAddress] = true

IRs:
REF_11(bool) -> userSelectedRate[bankrollAddress]
REF_11(bool) (->userSelectedRate) := True(bool)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
userDividendRate[bankrollAddress] = 33

IRs:
REF_12(uint8) -> userDividendRate[bankrollAddress]
REF_12(uint8) (->userDividendRate) := 33(uint256)"];
}
// Function: 1152.sol-Fortis-dividendHolder()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(myDividends(true) > 0)

IRs:
TMP_382(uint256) = INTERNAL_CALL, Fortis.myDividends(bool)(True)
TMP_383(bool) = TMP_382 > 0
TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1152.sol-Fortis-dividendsOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_64(uint256) -> dividendTokenBalanceLedger_[_customerAddress]
TMP_144(uint256) = profitPerDivToken * REF_64
TMP_145 = CONVERT TMP_144 to int256
REF_65(int256) -> payoutsTo_[_customerAddress]
TMP_146(int256) = TMP_145 - REF_65
TMP_147 = CONVERT TMP_146 to uint256
TMP_148(uint256) = TMP_147 / magnitude
RETURN TMP_148"];
}
// Function: 1152.sol-Fortis-endICOPhase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
icoPhase = false

IRs:
icoPhase(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
2->1;
}
// Function: 1152.sol-Fortis-ethereumToTokens_(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_ethereumAmount > MIN_ETH_BUYIN,Tried to buy tokens with too little eth.)

IRs:
TMP_250(bool) = _ethereumAmount > MIN_ETH_BUYIN
TMP_251(None) = SOLIDITY_CALL require(bool,string)(TMP_250,Tried to buy tokens with too little eth.)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
icoPhase

IRs:
CONDITION icoPhase"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
_ethereumAmount.div(tokenPriceInitial_) * 1e18

IRs:
TMP_252(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_ethereumAmount', 'tokenPriceInitial_'] 
TMP_253(uint256) = TMP_252 * 1000000000000000000
RETURN TMP_253"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
ethTowardsICOPriceTokens = 0

IRs:
ethTowardsICOPriceTokens(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
ethTowardsVariablePriceTokens = 0

IRs:
ethTowardsVariablePriceTokens(uint256) := 0(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
currentEthInvested >= ethInvestedDuringICO

IRs:
TMP_254(bool) = currentEthInvested >= ethInvestedDuringICO
CONDITION TMP_254"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ethTowardsVariablePriceTokens = _ethereumAmount

IRs:
ethTowardsVariablePriceTokens(uint256) := _ethereumAmount(uint256)"];
8->17;
9[label="Node Type: IF 9

EXPRESSION:
currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount <= ethInvestedDuringICO

IRs:
TMP_255(bool) = currentEthInvested < ethInvestedDuringICO
TMP_256(uint256) = currentEthInvested + _ethereumAmount
TMP_257(bool) = TMP_256 <= ethInvestedDuringICO
TMP_258(bool) = TMP_255 && TMP_257
CONDITION TMP_258"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
ethTowardsICOPriceTokens = _ethereumAmount

IRs:
ethTowardsICOPriceTokens(uint256) := _ethereumAmount(uint256)"];
10->16;
11[label="Node Type: IF 11

EXPRESSION:
currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount > ethInvestedDuringICO

IRs:
TMP_259(bool) = currentEthInvested < ethInvestedDuringICO
TMP_260(uint256) = currentEthInvested + _ethereumAmount
TMP_261(bool) = TMP_260 > ethInvestedDuringICO
TMP_262(bool) = TMP_259 && TMP_261
CONDITION TMP_262"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
ethTowardsICOPriceTokens = ethInvestedDuringICO.sub(currentEthInvested)

IRs:
TMP_263(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethInvestedDuringICO', 'currentEthInvested'] 
ethTowardsICOPriceTokens(uint256) := TMP_263(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
ethTowardsVariablePriceTokens = _ethereumAmount.sub(ethTowardsICOPriceTokens)

IRs:
TMP_264(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereumAmount', 'ethTowardsICOPriceTokens'] 
ethTowardsVariablePriceTokens(uint256) := TMP_264(uint256)"];
13->15;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
revert()()

IRs:
TMP_265(None) = SOLIDITY_CALL revert()()"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
assert(bool)(ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens == _ethereumAmount)

IRs:
TMP_266(uint256) = ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens
TMP_267(bool) = TMP_266 == _ethereumAmount
TMP_268(None) = SOLIDITY_CALL assert(bool)(TMP_267)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
icoPriceTokens = 0

IRs:
icoPriceTokens(uint256) := 0(uint256)"];
19->20;
20[label="Node Type: NEW VARIABLE 20

EXPRESSION:
varPriceTokens = 0

IRs:
varPriceTokens(uint256) := 0(uint256)"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
ethTowardsICOPriceTokens != 0

IRs:
TMP_269(bool) = ethTowardsICOPriceTokens != 0
CONDITION TMP_269"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
icoPriceTokens = ethTowardsICOPriceTokens.mul(1e18).div(tokenPriceInitial_)

IRs:
TMP_270(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['ethTowardsICOPriceTokens', '1000000000000000000'] 
TMP_271(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_270', 'tokenPriceInitial_'] 
icoPriceTokens(uint256) := TMP_271(uint256)"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: IF 24

EXPRESSION:
ethTowardsVariablePriceTokens != 0

IRs:
TMP_272(bool) = ethTowardsVariablePriceTokens != 0
CONDITION TMP_272"];
24->25[label="True"];
24->30[label="False"];
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
simulatedEthBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3) + ethTowardsICOPriceTokens

IRs:
TMP_273(uint256) = MULTIPLIER * 1000000
TMP_274(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['tokenSupply', 'TMP_273'] 
TMP_275(uint256) = INTERNAL_CALL, Fortis.toPowerOfThreeHalves(uint256)(TMP_274)
TMP_276(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_275', '2'] 
TMP_277(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_276', '3'] 
TMP_278(uint256) = TMP_277 + ethTowardsICOPriceTokens
simulatedEthBeforeInvested(uint256) := TMP_278(uint256)"];
25->26;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
simulatedEthAfterInvested = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens

IRs:
TMP_279(uint256) = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens
simulatedEthAfterInvested(uint256) := TMP_279(uint256)"];
26->27;
27[label="Node Type: NEW VARIABLE 27

EXPRESSION:
tokensBefore = toPowerOfTwoThirds(simulatedEthBeforeInvested.mul(3).div(2)).mul(MULTIPLIER)

IRs:
TMP_280(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['simulatedEthBeforeInvested', '3'] 
TMP_281(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_280', '2'] 
TMP_282(uint256) = INTERNAL_CALL, Fortis.toPowerOfTwoThirds(uint256)(TMP_281)
TMP_283(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_282', 'MULTIPLIER'] 
tokensBefore(uint256) := TMP_283(uint256)"];
27->28;
28[label="Node Type: NEW VARIABLE 28

EXPRESSION:
tokensAfter = toPowerOfTwoThirds(simulatedEthAfterInvested.mul(3).div(2)).mul(MULTIPLIER)

IRs:
TMP_284(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['simulatedEthAfterInvested', '3'] 
TMP_285(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_284', '2'] 
TMP_286(uint256) = INTERNAL_CALL, Fortis.toPowerOfTwoThirds(uint256)(TMP_285)
TMP_287(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_286', 'MULTIPLIER'] 
tokensAfter(uint256) := TMP_287(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore)

IRs:
TMP_288(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensAfter', 'tokensBefore'] 
TMP_289(uint256) = 1000000 * TMP_288
varPriceTokens(uint256) := TMP_289(uint256)"];
29->30;
30[label="Node Type: END_IF 30
"];
30->31;
31[label="Node Type: NEW VARIABLE 31

EXPRESSION:
totalTokensReceived = icoPriceTokens + varPriceTokens

IRs:
TMP_290(uint256) = icoPriceTokens + varPriceTokens
totalTokensReceived(uint256) := TMP_290(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
assert(bool)(totalTokensReceived > 0)

IRs:
TMP_291(bool) = totalTokensReceived > 0
TMP_292(None) = SOLIDITY_CALL assert(bool)(TMP_291)"];
32->33;
33[label="Node Type: RETURN 33

EXPRESSION:
totalTokensReceived

IRs:
RETURN totalTokensReceived"];
}
// Function: 1152.sol-Fortis-exit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_37(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_tokens = frontTokenBalanceLedger_[_customerAddress]

IRs:
REF_25(uint256) -> frontTokenBalanceLedger_[_customerAddress]
_tokens(uint256) := REF_25(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_tokens > 0

IRs:
TMP_38(bool) = _tokens > 0
CONDITION TMP_38"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
sell(_tokens)

IRs:
INTERNAL_CALL, Fortis.sell(uint256)(_tokens)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
withdraw(_customerAddress)

IRs:
INTERNAL_CALL, Fortis.withdraw(address)(_customerAddress)"];
}
// Function: 1152.sol-Fortis-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_27(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
userSelectedRate[_customerAddress]

IRs:
REF_21(bool) -> userSelectedRate[_customerAddress]
CONDITION REF_21"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
purchaseTokens(msg.value,0x0)

IRs:
TMP_28(uint256) = INTERNAL_CALL, Fortis.purchaseTokens(uint256,address)(msg.value,0)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
buyAndSetDivPercentage(0x0,20,0x0)

IRs:
TMP_29(uint256) = INTERNAL_CALL, Fortis.buyAndSetDivPercentage(address,uint8,string)(0,20,0x0)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 1152.sol-Fortis-getDividendTokenBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
dividendTokenBalanceLedger_[_customerAddress]

IRs:
REF_63(uint256) -> dividendTokenBalanceLedger_[_customerAddress]
RETURN REF_63"];
}
// Function: 1152.sol-Fortis-getDividendTokenSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
divTokenSupply

IRs:
RETURN divTokenSupply"];
}
// Function: 1152.sol-Fortis-getFrontEndTokenBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
frontTokenBalanceLedger_[_customerAddress]

IRs:
REF_62(uint256) -> frontTokenBalanceLedger_[_customerAddress]
RETURN REF_62"];
}
// Function: 1152.sol-Fortis-getFrontEndTokenSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
tokenSupply

IRs:
RETURN tokenSupply"];
}
// Function: 1152.sol-Fortis-getMyAverageDividendRate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
getUserAverageDividendRate(msg.sender)

IRs:
TMP_181(uint256) = INTERNAL_CALL, Fortis.getUserAverageDividendRate(address)(msg.sender)
RETURN TMP_181"];
}
// Function: 1152.sol-Fortis-getMyDividendRate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(userSelectedRate[_customerAddress])

IRs:
REF_58(bool) -> userSelectedRate[_customerAddress]
TMP_131(None) = SOLIDITY_CALL require(bool)(REF_58)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
userDividendRate[_customerAddress]

IRs:
REF_59(uint8) -> userDividendRate[_customerAddress]
RETURN REF_59"];
}
// Function: 1152.sol-Fortis-getUserAverageDividendRate(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user])

IRs:
REF_81(uint256) -> dividendTokenBalanceLedger_[user]
TMP_179(uint256) = magnitude * REF_81
REF_83(uint256) -> frontTokenBalanceLedger_[user]
TMP_180(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_179', 'REF_83'] 
RETURN TMP_180"];
}
// Function: 1152.sol-Fortis-injectEther()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
}
// Function: 1152.sol-Fortis-myDividendTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
getDividendTokenBalanceOf(_customerAddress)

IRs:
TMP_133(uint256) = INTERNAL_CALL, Fortis.getDividendTokenBalanceOf(address)(_customerAddress)
RETURN TMP_133"];
}
// Function: 1152.sol-Fortis-myDividends(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->3;
3[label="Node Type: IF 3

EXPRESSION:
_includeReferralBonus

IRs:
CONDITION _includeReferralBonus"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
dividendsOf(_customerAddress) + referralBalance_[_customerAddress]

IRs:
TMP_137(uint256) = INTERNAL_CALL, Fortis.dividendsOf(address)(_customerAddress)
REF_60(uint256) -> referralBalance_[_customerAddress]
TMP_138(uint256) = TMP_137 + REF_60
RETURN TMP_138"];
5[label="Node Type: RETURN 5

EXPRESSION:
dividendsOf(_customerAddress)

IRs:
TMP_139(uint256) = INTERNAL_CALL, Fortis.dividendsOf(address)(_customerAddress)
RETURN TMP_139"];
}
// Function: 1152.sol-Fortis-myFrontEndTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
getFrontEndTokenBalanceOf(_customerAddress)

IRs:
TMP_132(uint256) = INTERNAL_CALL, Fortis.getFrontEndTokenBalanceOf(address)(_customerAddress)
RETURN TMP_132"];
}
// Function: 1152.sol-Fortis-myReferralDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
myDividends(true) - myDividends(false)

IRs:
TMP_134(uint256) = INTERNAL_CALL, Fortis.myDividends(bool)(True)
TMP_135(uint256) = INTERNAL_CALL, Fortis.myDividends(bool)(False)
TMP_136(uint256) = TMP_134 - TMP_135
RETURN TMP_136"];
}
// Function: 1152.sol-Fortis-onlyAdministrator()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(administrators[_customerAddress])

IRs:
REF_167(bool) -> administrators[_customerAddress]
TMP_385(None) = SOLIDITY_CALL require(bool)(REF_167)"];
2->3;
3[label="Node Type: _ 3
"];
}
// Function: 1152.sol-Fortis-onlyHolders()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(myFrontEndTokens() > 0)

IRs:
TMP_379(uint256) = INTERNAL_CALL, Fortis.myFrontEndTokens()()
TMP_380(bool) = TMP_379 > 0
TMP_381(None) = SOLIDITY_CALL require(bool)(TMP_380)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1152.sol-Fortis-publicStartRegularPhase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > (icoOpenTime + 1209600) && icoOpenTime != 0)

IRs:
TMP_112(uint256) = icoOpenTime + 1209600
TMP_113(bool) = now > TMP_112
TMP_114(bool) = icoOpenTime != 0
TMP_115(bool) = TMP_113 && TMP_114
TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
icoPhase = false

IRs:
icoPhase(bool) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
regularPhase = true

IRs:
regularPhase(bool) := True(bool)"];
}
// Function: 1152.sol-Fortis-purchaseTokens(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_incomingEthereum >= MIN_ETH_BUYIN || msg.sender == bankrollAddress,Tried to buy below the min eth buyin threshold.)

IRs:
TMP_182(bool) = _incomingEthereum >= MIN_ETH_BUYIN
TMP_183(bool) = msg.sender == bankrollAddress
TMP_184(bool) = TMP_182 || TMP_183
TMP_185(None) = SOLIDITY_CALL require(bool,string)(TMP_184,Tried to buy below the min eth buyin threshold.)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6
"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
remainingEth = _incomingEthereum

IRs:
remainingEth(uint256) := _incomingEthereum(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
regularPhase

IRs:
CONDITION regularPhase"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
toDivCardHolders = _incomingEthereum.div(100)

IRs:
TMP_186(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_incomingEthereum', '100'] 
toDivCardHolders(uint256) := TMP_186(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
remainingEth = remainingEth.sub(toDivCardHolders)

IRs:
TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['remainingEth', 'toDivCardHolders'] 
remainingEth(uint256) := TMP_187(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
dividendRate = userDividendRate[msg.sender]

IRs:
REF_86(uint8) -> userDividendRate[msg.sender]
dividendRate(uint256) := REF_86(uint8)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
dividendAmount = (remainingEth.mul(dividendRate)).div(100)

IRs:
TMP_188(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['remainingEth', 'dividendRate'] 
TMP_189(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_188', '100'] 
dividendAmount(uint256) := TMP_189(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
remainingEth = remainingEth.sub(dividendAmount)

IRs:
TMP_190(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['remainingEth', 'dividendAmount'] 
remainingEth(uint256) := TMP_190(uint256)"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
icoPhase && msg.sender == bankrollAddress

IRs:
TMP_191(bool) = msg.sender == bankrollAddress
TMP_192(bool) = icoPhase && TMP_191
CONDITION TMP_192"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
remainingEth = remainingEth + dividendAmount

IRs:
TMP_193(uint256) = remainingEth + dividendAmount
remainingEth(uint256) := TMP_193(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
tokensBought = ethereumToTokens_(remainingEth)

IRs:
TMP_194(uint256) = INTERNAL_CALL, Fortis.ethereumToTokens_(uint256)(remainingEth)
tokensBought(uint256) := TMP_194(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
dividendTokensBought = tokensBought.mul(dividendRate)

IRs:
TMP_195(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensBought', 'dividendRate'] 
dividendTokensBought(uint256) := TMP_195(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
tokenSupply = tokenSupply.add(tokensBought)

IRs:
TMP_196(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenSupply', 'tokensBought'] 
tokenSupply(uint256) := TMP_196(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
divTokenSupply = divTokenSupply.add(dividendTokensBought)

IRs:
TMP_197(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['divTokenSupply', 'dividendTokensBought'] 
divTokenSupply(uint256) := TMP_197(uint256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
currentEthInvested = currentEthInvested + remainingEth

IRs:
TMP_198(uint256) = currentEthInvested + remainingEth
currentEthInvested(uint256) := TMP_198(uint256)"];
25->26;
26[label="Node Type: IF 26

EXPRESSION:
icoPhase

IRs:
CONDITION icoPhase"];
26->27[label="True"];
26->42[label="False"];
27[label="Node Type: EXPRESSION 27

EXPRESSION:
toBankRoll = dividendAmount

IRs:
toBankRoll(uint256) := dividendAmount(uint256)"];
27->28;
28[label="Node Type: IF 28

EXPRESSION:
msg.sender == bankrollAddress

IRs:
TMP_199(bool) = msg.sender == bankrollAddress
CONDITION TMP_199"];
28->29[label="True"];
28->30[label="False"];
29[label="Node Type: EXPRESSION 29

EXPRESSION:
toBankRoll = 0

IRs:
toBankRoll(uint256) := 0(uint256)"];
29->30;
30[label="Node Type: END_IF 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
toReferrer = 0

IRs:
toReferrer(uint256) := 0(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
toTokenHolders = 0

IRs:
toTokenHolders(uint256) := 0(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
ethInvestedDuringICO = ethInvestedDuringICO + remainingEth

IRs:
TMP_200(uint256) = ethInvestedDuringICO + remainingEth
ethInvestedDuringICO(uint256) := TMP_200(uint256)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
tokensMintedDuringICO = tokensMintedDuringICO + tokensBought

IRs:
TMP_201(uint256) = tokensMintedDuringICO + tokensBought
tokensMintedDuringICO(uint256) := TMP_201(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
require(bool)(ethInvestedDuringICO <= icoHardCap)

IRs:
TMP_202(bool) = ethInvestedDuringICO <= icoHardCap
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(tx.origin == msg.sender || msg.sender == bankrollAddress)

IRs:
TMP_204(bool) = tx.origin == msg.sender
TMP_205(bool) = msg.sender == bankrollAddress
TMP_206(bool) = TMP_204 || TMP_205
TMP_207(None) = SOLIDITY_CALL require(bool)(TMP_206)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
ICOBuyIn[msg.sender] += remainingEth

IRs:
REF_93(uint256) -> ICOBuyIn[msg.sender]
REF_93(-> ICOBuyIn) = REF_93 + remainingEth"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
require(bool)(ICOBuyIn[msg.sender] <= addressICOLimit || msg.sender == bankrollAddress)

IRs:
REF_94(uint256) -> ICOBuyIn[msg.sender]
TMP_208(bool) = REF_94 <= addressICOLimit
TMP_209(bool) = msg.sender == bankrollAddress
TMP_210(bool) = TMP_208 || TMP_209
TMP_211(None) = SOLIDITY_CALL require(bool)(TMP_210)"];
38->39;
39[label="Node Type: IF 39

EXPRESSION:
ethInvestedDuringICO == icoHardCap

IRs:
TMP_212(bool) = ethInvestedDuringICO == icoHardCap
CONDITION TMP_212"];
39->40[label="True"];
39->41[label="False"];
40[label="Node Type: EXPRESSION 40

EXPRESSION:
icoPhase = false

IRs:
icoPhase(bool) := False(bool)"];
40->41;
41[label="Node Type: END_IF 41
"];
41->52;
42[label="Node Type: IF 42

EXPRESSION:
_referredBy != 0x0000000000000000000000000000000000000000 && _referredBy != msg.sender && frontTokenBalanceLedger_[_referredBy] >= stakingRequirement

IRs:
TMP_213(bool) = _referredBy != 0
TMP_214(bool) = _referredBy != msg.sender
TMP_215(bool) = TMP_213 && TMP_214
REF_95(uint256) -> frontTokenBalanceLedger_[_referredBy]
TMP_216(bool) = REF_95 >= stakingRequirement
TMP_217(bool) = TMP_215 && TMP_216
CONDITION TMP_217"];
42->43[label="True"];
42->46[label="False"];
43[label="Node Type: EXPRESSION 43

EXPRESSION:
toReferrer = (dividendAmount.mul(referrer_percentage)).div(100)

IRs:
TMP_218(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['dividendAmount', 'referrer_percentage'] 
TMP_219(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_218', '100'] 
toReferrer(uint256) := TMP_219(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
referralBalance_[_referredBy] += toReferrer

IRs:
REF_98(uint256) -> referralBalance_[_referredBy]
REF_98(-> referralBalance_) = REF_98 + toReferrer"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
Referral(_referredBy,toReferrer)

IRs:
Emit Referral(_referredBy,toReferrer)"];
45->46;
46[label="Node Type: END_IF 46
"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
toTokenHolders = dividendAmount.sub(toReferrer)

IRs:
TMP_221(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dividendAmount', 'toReferrer'] 
toTokenHolders(uint256) := TMP_221(uint256)"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
fee = toTokenHolders * magnitude

IRs:
TMP_222(uint256) = toTokenHolders * magnitude
fee(uint256) := TMP_222(uint256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
fee = fee - (fee - (dividendTokensBought * (toTokenHolders * magnitude / (divTokenSupply))))

IRs:
TMP_223(uint256) = toTokenHolders * magnitude
TMP_224(uint256) = TMP_223 / divTokenSupply
TMP_225(uint256) = dividendTokensBought * TMP_224
TMP_226(uint256) = fee - TMP_225
TMP_227(uint256) = fee - TMP_226
fee(uint256) := TMP_227(uint256)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
profitPerDivToken = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply))

IRs:
TMP_228(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['toTokenHolders', 'magnitude'] 
TMP_229(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_228', 'divTokenSupply'] 
TMP_230(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['profitPerDivToken', 'TMP_229'] 
profitPerDivToken(uint256) := TMP_230(uint256)"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
payoutsTo_[msg.sender] += int256((profitPerDivToken * dividendTokensBought) - fee)

IRs:
REF_103(int256) -> payoutsTo_[msg.sender]
TMP_231(uint256) = profitPerDivToken * dividendTokensBought
TMP_232(uint256) = TMP_231 - fee
TMP_233 = CONVERT TMP_232 to int256
REF_103(-> payoutsTo_) = REF_103 + TMP_233"];
51->52;
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought)

IRs:
REF_104(uint256) -> frontTokenBalanceLedger_[msg.sender]
REF_105(uint256) -> frontTokenBalanceLedger_[msg.sender]
TMP_234(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_105', 'tokensBought'] 
REF_104(uint256) (->frontTokenBalanceLedger_) := TMP_234(uint256)"];
53->54;
54[label="Node Type: EXPRESSION 54

EXPRESSION:
dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(dividendTokensBought)

IRs:
REF_107(uint256) -> dividendTokenBalanceLedger_[msg.sender]
REF_108(uint256) -> dividendTokenBalanceLedger_[msg.sender]
TMP_235(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_108', 'dividendTokensBought'] 
REF_107(uint256) (->dividendTokenBalanceLedger_) := TMP_235(uint256)"];
54->55;
55[label="Node Type: IF 55

EXPRESSION:
toBankRoll != 0

IRs:
TMP_236(bool) = toBankRoll != 0
CONDITION TMP_236"];
55->56[label="True"];
55->57[label="False"];
56[label="Node Type: EXPRESSION 56

EXPRESSION:
ZethrBankroll(bankrollAddress).receiveDividends.value(toBankRoll)()

IRs:
TMP_237 = CONVERT bankrollAddress to ZethrBankroll
HIGH_LEVEL_CALL, dest:TMP_237(ZethrBankroll), function:receiveDividends, arguments:[] value:toBankRoll "];
56->57;
57[label="Node Type: END_IF 57
"];
57->58;
58[label="Node Type: IF 58

EXPRESSION:
regularPhase

IRs:
CONDITION regularPhase"];
58->59[label="True"];
58->60[label="False"];
59[label="Node Type: EXPRESSION 59

EXPRESSION:
divCardContract.receiveDividends.value(toDivCardHolders)(dividendRate)

IRs:
HIGH_LEVEL_CALL, dest:divCardContract(ZethrDividendCards), function:receiveDividends, arguments:['dividendRate'] value:toDivCardHolders "];
59->60;
60[label="Node Type: END_IF 60
"];
60->61;
61[label="Node Type: EXPRESSION 61

EXPRESSION:
Allocation(toBankRoll,toReferrer,toTokenHolders,toDivCardHolders,remainingEth)

IRs:
Emit Allocation(toBankRoll,toReferrer,toTokenHolders,toDivCardHolders,remainingEth)"];
61->62;
62[label="Node Type: NEW VARIABLE 62

EXPRESSION:
sum = toBankRoll + toReferrer + toTokenHolders + toDivCardHolders + remainingEth - _incomingEthereum

IRs:
TMP_243(uint256) = toBankRoll + toReferrer
TMP_244(uint256) = TMP_243 + toTokenHolders
TMP_245(uint256) = TMP_244 + toDivCardHolders
TMP_246(uint256) = TMP_245 + remainingEth
TMP_247(uint256) = TMP_246 - _incomingEthereum
sum(uint256) := TMP_247(uint256)"];
62->63;
63[label="Node Type: EXPRESSION 63

EXPRESSION:
assert(bool)(sum == 0)

IRs:
TMP_248(bool) = sum == 0
TMP_249(None) = SOLIDITY_CALL assert(bool)(TMP_248)"];
}
// Function: 1152.sol-Fortis-reinvest()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_30(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_dividends = myDividends(false)

IRs:
TMP_31(uint256) = INTERNAL_CALL, Fortis.myDividends(bool)(False)
_dividends(uint256) := TMP_31(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payoutsTo_[_customerAddress] += int256(_dividends * magnitude)

IRs:
REF_22(int256) -> payoutsTo_[_customerAddress]
TMP_32(uint256) = _dividends * magnitude
TMP_33 = CONVERT TMP_32 to int256
REF_22(-> payoutsTo_) = REF_22 + TMP_33"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_dividends += referralBalance_[_customerAddress]

IRs:
REF_23(uint256) -> referralBalance_[_customerAddress]
_dividends(uint256) = _dividends + REF_23"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
referralBalance_[_customerAddress] = 0

IRs:
REF_24(uint256) -> referralBalance_[_customerAddress]
REF_24(uint256) (->referralBalance_) := 0(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
_tokens = purchaseTokens(_dividends,0x0)

IRs:
TMP_34(uint256) = INTERNAL_CALL, Fortis.purchaseTokens(uint256,address)(_dividends,0)
_tokens(uint256) := TMP_34(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onReinvestment(_customerAddress,_dividends,_tokens)

IRs:
Emit onReinvestment(_customerAddress,_dividends,_tokens)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
dividendHolder()

IRs:
MODIFIER_CALL, Fortis.dividendHolder()()"];
9->1;
}
// Function: 1152.sol-Fortis-sell(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->25;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! icoPhase)

IRs:
TMP_50 = UnaryType.BANG icoPhase 
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_52(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender])

IRs:
REF_30(uint256) -> frontTokenBalanceLedger_[msg.sender]
TMP_53(bool) = _amountOfTokens <= REF_30
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_frontEndTokensToBurn = _amountOfTokens

IRs:
_frontEndTokensToBurn(uint256) := _amountOfTokens(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
userDivRate = getUserAverageDividendRate(msg.sender)

IRs:
TMP_55(uint256) = INTERNAL_CALL, Fortis.getUserAverageDividendRate(address)(msg.sender)
userDivRate(uint256) := TMP_55(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)((2 * magnitude) <= userDivRate && (50 * magnitude) >= userDivRate)

IRs:
TMP_56(uint256) = 2 * magnitude
TMP_57(bool) = TMP_56 <= userDivRate
TMP_58(uint256) = 50 * magnitude
TMP_59(bool) = TMP_58 >= userDivRate
TMP_60(bool) = TMP_57 && TMP_59
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
_divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude)

IRs:
TMP_62(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_frontEndTokensToBurn', 'userDivRate'] 
TMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_62', 'magnitude'] 
_divTokensToBurn(uint256) := TMP_63(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
_ethereum = tokensToEthereum_(_frontEndTokensToBurn)

IRs:
TMP_64(uint256) = INTERNAL_CALL, Fortis.tokensToEthereum_(uint256)(_frontEndTokensToBurn)
_ethereum(uint256) := TMP_64(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
_ethereum > currentEthInvested

IRs:
TMP_65(bool) = _ethereum > currentEthInvested
CONDITION TMP_65"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
currentEthInvested = 0

IRs:
currentEthInvested(uint256) := 0(uint256)"];
10->12;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
currentEthInvested = currentEthInvested - _ethereum

IRs:
TMP_66(uint256) = currentEthInvested - _ethereum
currentEthInvested(uint256) := TMP_66(uint256)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
_dividends = (_ethereum.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude)

IRs:
TMP_67(uint256) = INTERNAL_CALL, Fortis.getUserAverageDividendRate(address)(msg.sender)
TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_ethereum', 'TMP_67'] 
TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_68', '100'] 
TMP_70(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_69', 'magnitude'] 
_dividends(uint256) := TMP_70(uint256)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
_taxedEthereum = _ethereum.sub(_dividends)

IRs:
TMP_71(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereum', '_dividends'] 
_taxedEthereum(uint256) := TMP_71(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
tokenSupply = tokenSupply.sub(_frontEndTokensToBurn)

IRs:
TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokenSupply', '_frontEndTokensToBurn'] 
tokenSupply(uint256) := TMP_72(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
divTokenSupply = divTokenSupply.sub(_divTokensToBurn)

IRs:
TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['divTokenSupply', '_divTokensToBurn'] 
divTokenSupply(uint256) := TMP_73(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn)

IRs:
REF_39(uint256) -> frontTokenBalanceLedger_[msg.sender]
REF_40(uint256) -> frontTokenBalanceLedger_[msg.sender]
TMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_40', '_frontEndTokensToBurn'] 
REF_39(uint256) (->frontTokenBalanceLedger_) := TMP_74(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn)

IRs:
REF_42(uint256) -> dividendTokenBalanceLedger_[msg.sender]
REF_43(uint256) -> dividendTokenBalanceLedger_[msg.sender]
TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_43', '_divTokensToBurn'] 
REF_42(uint256) (->dividendTokenBalanceLedger_) := TMP_75(uint256)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
_updatedPayouts = int256(profitPerDivToken * _divTokensToBurn + (_taxedEthereum * magnitude))

IRs:
TMP_76(uint256) = profitPerDivToken * _divTokensToBurn
TMP_77(uint256) = _taxedEthereum * magnitude
TMP_78(uint256) = TMP_76 + TMP_77
TMP_79 = CONVERT TMP_78 to int256
_updatedPayouts(int256) := TMP_79(int256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
payoutsTo_[msg.sender] -= _updatedPayouts

IRs:
REF_45(int256) -> payoutsTo_[msg.sender]
REF_45(-> payoutsTo_) = REF_45 - _updatedPayouts"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
divTokenSupply > 0

IRs:
TMP_80(bool) = divTokenSupply > 0
CONDITION TMP_80"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply)

IRs:
TMP_81(uint256) = _dividends * magnitude
TMP_82(uint256) = TMP_81 / divTokenSupply
TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['profitPerDivToken', 'TMP_82'] 
profitPerDivToken(uint256) := TMP_83(uint256)"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
onTokenSell(msg.sender,_frontEndTokensToBurn,_taxedEthereum)

IRs:
Emit onTokenSell(msg.sender,_frontEndTokensToBurn,_taxedEthereum)"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
onlyHolders()

IRs:
MODIFIER_CALL, Fortis.onlyHolders()()"];
25->1;
}
// Function: 1152.sol-Fortis-sellPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
icoPhase || currentEthInvested < ethInvestedDuringICO

IRs:
TMP_149(bool) = currentEthInvested < ethInvestedDuringICO
TMP_150(bool) = icoPhase || TMP_149
CONDITION TMP_150"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
price = tokenPriceInitial_

IRs:
price(uint256) := tokenPriceInitial_(uint256)"];
3->6;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokensReceivedForEth = ethereumToTokens_(1000000000000000)

IRs:
TMP_151(uint256) = INTERNAL_CALL, Fortis.ethereumToTokens_(uint256)(1000000000000000)
tokensReceivedForEth(uint256) := TMP_151(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
price = (1e18 * 1000000000000000) / tokensReceivedForEth

IRs:
TMP_152(uint256) = 1000000000000000000 * 1000000000000000
TMP_153(uint256) = TMP_152 / tokensReceivedForEth
price(uint256) := TMP_153(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude))

IRs:
TMP_154(uint256) = INTERNAL_CALL, Fortis.getUserAverageDividendRate(address)(msg.sender)
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['price', 'TMP_154'] 
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_155', '100'] 
TMP_157(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_156', 'magnitude'] 
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['price', 'TMP_157'] 
theSellPrice(uint256) := TMP_158(uint256)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
theSellPrice

IRs:
RETURN theSellPrice"];
}
// Function: 1152.sol-Fortis-setAdministrator(address,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
administrators[_newAdmin] = _status

IRs:
REF_57(bool) -> administrators[_newAdmin]
REF_57(bool) (->administrators) := _status(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
2->1;
}
// Function: 1152.sol-Fortis-setName(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
2->1;
}
// Function: 1152.sol-Fortis-setStakingRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amountOfTokens >= 100e18)

IRs:
TMP_123(bool) = _amountOfTokens >= 100000000000000000000
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stakingRequirement = _amountOfTokens

IRs:
stakingRequirement(uint256) := _amountOfTokens(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
3->1;
}
// Function: 1152.sol-Fortis-setSymbol(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
2->1;
}
// Function: 1152.sol-Fortis-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
tokenPriceInitial_ = 653000000000000

IRs:
tokenPriceInitial_(uint256) := 653000000000000(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
magnitude = 2 ** 64

IRs:
TMP_377(uint256) = 2 ** 64
magnitude(uint256) := TMP_377(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
icoHardCap = 250000000000000000000

IRs:
icoHardCap(uint256) := 250000000000000000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
addressICOLimit = 1000000000000000000

IRs:
addressICOLimit(uint256) := 1000000000000000000(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
icoMinBuyIn = 100000000000000

IRs:
icoMinBuyIn(uint256) := 100000000000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
icoMaxGasPrice = 50000000000

IRs:
icoMaxGasPrice(uint256) := 50000000000(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
MULTIPLIER = 9615

IRs:
MULTIPLIER(uint256) := 9615(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
MIN_ETH_BUYIN = 100000000000000

IRs:
MIN_ETH_BUYIN(uint256) := 100000000000000(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
MIN_TOKEN_SELL_AMOUNT = 100000000000000

IRs:
MIN_TOKEN_SELL_AMOUNT(uint256) := 100000000000000(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
MIN_TOKEN_TRANSFER = 1e10

IRs:
MIN_TOKEN_TRANSFER(uint256) := 10000000000(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
referrer_percentage = 25

IRs:
referrer_percentage(uint256) := 25(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
icoHashedPass = bytes32(0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262)

IRs:
TMP_378 = CONVERT 42455334854654954735899034370503135178714718087616476583501828057901202580066 to bytes32
icoHashedPass(bytes32) := TMP_378(bytes32)"];
}
// Function: 1152.sol-Fortis-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
stakingRequirement = 100e18

IRs:
stakingRequirement(uint256) := 100000000000000000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
name = Fortis

IRs:
name(string) := Fortis(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
symbol = IRON

IRs:
symbol(string) := IRON(string)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
tokenSupply = 0

IRs:
tokenSupply(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
divTokenSupply = 0

IRs:
divTokenSupply(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
icoPhase = false

IRs:
icoPhase(bool) := False(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
regularPhase = false

IRs:
regularPhase(bool) := False(bool)"];
}
// Function: 1152.sol-Fortis-sqrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = (x + 1) / 2

IRs:
TMP_363(uint256) = x + 1
TMP_364(uint256) = TMP_363 / 2
z(uint256) := TMP_364(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
y = x

IRs:
y(uint256) := x(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
z < y

IRs:
TMP_365(bool) = z < y
CONDITION TMP_365"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
y = z

IRs:
y(uint256) := z(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
z = (x / z + z) / 2

IRs:
TMP_366(uint256) = x / z
TMP_367(uint256) = TMP_366 + z
TMP_368(uint256) = TMP_367 / 2
z(uint256) := TMP_368(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
y

IRs:
RETURN y"];
}
// Function: 1152.sol-Fortis-startICOPhase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(icoOpenTime == 0)

IRs:
TMP_117(bool) = icoOpenTime == 0
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
icoPhase = true

IRs:
icoPhase(bool) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
icoOpenTime = now

IRs:
icoOpenTime(uint256) := now(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
4->1;
}
// Function: 1152.sol-Fortis-startRegularPhase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
icoPhase = false

IRs:
icoPhase(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
regularPhase = true

IRs:
regularPhase(bool) := True(bool)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, Fortis.onlyAdministrator()()"];
3->1;
}
// Function: 1152.sol-Fortis-theDividendsOf(bool,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
_includeReferralBonus

IRs:
CONDITION _includeReferralBonus"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
dividendsOf(_customerAddress) + referralBalance_[_customerAddress]

IRs:
TMP_140(uint256) = INTERNAL_CALL, Fortis.dividendsOf(address)(_customerAddress)
REF_61(uint256) -> referralBalance_[_customerAddress]
TMP_141(uint256) = TMP_140 + REF_61
RETURN TMP_141"];
4[label="Node Type: RETURN 4

EXPRESSION:
dividendsOf(_customerAddress)

IRs:
TMP_142(uint256) = INTERNAL_CALL, Fortis.dividendsOf(address)(_customerAddress)
RETURN TMP_142"];
}
// Function: 1152.sol-Fortis-toPowerOfThreeHalves(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
sqrt(x ** 3)

IRs:
TMP_359(uint256) = x ** 3
TMP_360(uint256) = INTERNAL_CALL, Fortis.sqrt(uint256)(TMP_359)
RETURN TMP_360"];
}
// Function: 1152.sol-Fortis-toPowerOfTwoThirds(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
cbrt(x ** 2)

IRs:
TMP_361(uint256) = x ** 2
TMP_362(uint256) = INTERNAL_CALL, Fortis.cbrt(uint256)(TMP_361)
RETURN TMP_362"];
}
// Function: 1152.sol-Fortis-tokensToEthereum_(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_tokens >= MIN_TOKEN_SELL_AMOUNT,Tried to sell too few tokens.)

IRs:
TMP_293(bool) = _tokens >= MIN_TOKEN_SELL_AMOUNT
TMP_294(None) = SOLIDITY_CALL require(bool,string)(TMP_293,Tried to sell too few tokens.)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tokensToSellAtICOPrice = 0

IRs:
tokensToSellAtICOPrice(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokensToSellAtVariablePrice = 0

IRs:
tokensToSellAtVariablePrice(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
tokenSupply <= tokensMintedDuringICO

IRs:
TMP_295(bool) = tokenSupply <= tokensMintedDuringICO
CONDITION TMP_295"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokensToSellAtICOPrice = _tokens

IRs:
tokensToSellAtICOPrice(uint256) := _tokens(uint256)"];
5->14;
6[label="Node Type: IF 6

EXPRESSION:
tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO

IRs:
TMP_296(bool) = tokenSupply > tokensMintedDuringICO
TMP_297(uint256) = tokenSupply - _tokens
TMP_298(bool) = TMP_297 >= tokensMintedDuringICO
TMP_299(bool) = TMP_296 && TMP_298
CONDITION TMP_299"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokensToSellAtVariablePrice = _tokens

IRs:
tokensToSellAtVariablePrice(uint256) := _tokens(uint256)"];
7->13;
8[label="Node Type: IF 8

EXPRESSION:
tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO

IRs:
TMP_300(bool) = tokenSupply > tokensMintedDuringICO
TMP_301(uint256) = tokenSupply - _tokens
TMP_302(bool) = TMP_301 < tokensMintedDuringICO
TMP_303(bool) = TMP_300 && TMP_302
CONDITION TMP_303"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO)

IRs:
TMP_304(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokenSupply', 'tokensMintedDuringICO'] 
tokensToSellAtVariablePrice(uint256) := TMP_304(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
tokensToSellAtICOPrice = _tokens.sub(tokensToSellAtVariablePrice)

IRs:
TMP_305(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_tokens', 'tokensToSellAtVariablePrice'] 
tokensToSellAtICOPrice(uint256) := TMP_305(uint256)"];
10->12;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
revert()()

IRs:
TMP_306(None) = SOLIDITY_CALL revert()()"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
assert(bool)(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens)

IRs:
TMP_307(uint256) = tokensToSellAtVariablePrice + tokensToSellAtICOPrice
TMP_308(bool) = TMP_307 == _tokens
TMP_309(None) = SOLIDITY_CALL assert(bool)(TMP_308)"];
15->16;
16[label="Node Type: NEW VARIABLE 16
"];
16->17;
17[label="Node Type: NEW VARIABLE 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
tokensToSellAtICOPrice != 0

IRs:
TMP_310(bool) = tokensToSellAtICOPrice != 0
CONDITION TMP_310"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18)

IRs:
TMP_311(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensToSellAtICOPrice', 'tokenPriceInitial_'] 
TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_311', '1000000000000000000'] 
ethFromICOPriceTokens(uint256) := TMP_312(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
tokensToSellAtVariablePrice != 0

IRs:
TMP_313(bool) = tokensToSellAtVariablePrice != 0
CONDITION TMP_313"];
21->22[label="True"];
21->25[label="False"];
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3)

IRs:
TMP_314(uint256) = MULTIPLIER * 1000000
TMP_315(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['tokenSupply', 'TMP_314'] 
TMP_316(uint256) = INTERNAL_CALL, Fortis.toPowerOfThreeHalves(uint256)(TMP_315)
TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_316', '2'] 
TMP_318(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_317', '3'] 
investmentBefore(uint256) := TMP_318(uint256)"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
investmentAfter = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3)

IRs:
TMP_319(uint256) = tokenSupply - tokensToSellAtVariablePrice
TMP_320(uint256) = MULTIPLIER * 1000000
TMP_321(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_319', 'TMP_320'] 
TMP_322(uint256) = INTERNAL_CALL, Fortis.toPowerOfThreeHalves(uint256)(TMP_321)
TMP_323(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_322', '2'] 
TMP_324(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_323', '3'] 
investmentAfter(uint256) := TMP_324(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
ethFromVarPriceTokens = investmentBefore.sub(investmentAfter)

IRs:
TMP_325(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['investmentBefore', 'investmentAfter'] 
ethFromVarPriceTokens(uint256) := TMP_325(uint256)"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens

IRs:
TMP_326(uint256) = ethFromVarPriceTokens + ethFromICOPriceTokens
totalEthReceived(uint256) := TMP_326(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
assert(bool)(totalEthReceived > 0)

IRs:
TMP_327(bool) = totalEthReceived > 0
TMP_328(None) = SOLIDITY_CALL assert(bool)(TMP_327)"];
27->28;
28[label="Node Type: RETURN 28

EXPRESSION:
totalEthReceived

IRs:
RETURN totalEthReceived"];
}
// Function: 1152.sol-Fortis-totalEthereumBalance()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
address(this).balance

IRs:
TMP_129 = CONVERT this to address
TMP_130(uint256) = SOLIDITY_CALL balance(address)(TMP_129)
RETURN TMP_130"];
}
// Function: 1152.sol-Fortis-totalEthereumICOReceived()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
ethInvestedDuringICO

IRs:
RETURN ethInvestedDuringICO"];
}
// Function: 1152.sol-Fortis-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
tokenSupply

IRs:
RETURN tokenSupply"];
}
// Function: 1152.sol-Fortis-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= frontTokenBalanceLedger_[msg.sender])

IRs:
TMP_86(bool) = _amountOfTokens >= MIN_TOKEN_TRANSFER
REF_47(uint256) -> frontTokenBalanceLedger_[msg.sender]
TMP_87(bool) = _amountOfTokens <= REF_47
TMP_88(bool) = TMP_86 && TMP_87
TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transferFromInternal(msg.sender,_toAddress,_amountOfTokens,empty)

IRs:
INTERNAL_CALL, Fortis.transferFromInternal(address,address,uint256,bytes)(msg.sender,_toAddress,_amountOfTokens,empty)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyHolders()

IRs:
MODIFIER_CALL, Fortis.onlyHolders()()"];
5->1;
}
// Function: 1152.sol-Fortis-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = _from

IRs:
_customerAddress(address) := _from(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress] && _amountOfTokens <= allowed[_customerAddress][msg.sender])

IRs:
TMP_93(bool) = _amountOfTokens >= MIN_TOKEN_TRANSFER
REF_50(uint256) -> frontTokenBalanceLedger_[_customerAddress]
TMP_94(bool) = _amountOfTokens <= REF_50
TMP_95(bool) = TMP_93 && TMP_94
REF_51(mapping(address => uint256)) -> allowed[_customerAddress]
REF_52(uint256) -> REF_51[msg.sender]
TMP_96(bool) = _amountOfTokens <= REF_52
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
transferFromInternal(_from,_toAddress,_amountOfTokens,empty)

IRs:
INTERNAL_CALL, Fortis.transferFromInternal(address,address,uint256,bytes)(_from,_toAddress,_amountOfTokens,empty)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1152.sol-Fortis-transferFromInternal(address,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_329(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_toAddress != address(0x0))

IRs:
TMP_330 = CONVERT 0 to address
TMP_331(bool) = _toAddress != TMP_330
TMP_332(None) = SOLIDITY_CALL require(bool)(TMP_331)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_customerAddress = _from

IRs:
_customerAddress(address) := _from(address)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_amountOfFrontEndTokens = _amountOfTokens

IRs:
_amountOfFrontEndTokens(uint256) := _amountOfTokens(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
theDividendsOf(true,_customerAddress) > 0

IRs:
TMP_333(uint256) = INTERNAL_CALL, Fortis.theDividendsOf(bool,address)(True,_customerAddress)
TMP_334(bool) = TMP_333 > 0
CONDITION TMP_334"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
withdrawFrom(_customerAddress)

IRs:
INTERNAL_CALL, Fortis.withdrawFrom(address)(_customerAddress)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
_amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude)

IRs:
TMP_336(uint256) = INTERNAL_CALL, Fortis.getUserAverageDividendRate(address)(_customerAddress)
TMP_337(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_amountOfFrontEndTokens', 'TMP_336'] 
TMP_338(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_337', 'magnitude'] 
_amountOfDivTokens(uint256) := TMP_338(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
_customerAddress != msg.sender

IRs:
TMP_339(bool) = _customerAddress != msg.sender
CONDITION TMP_339"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
allowed[_customerAddress][msg.sender] -= _amountOfTokens

IRs:
REF_142(mapping(address => uint256)) -> allowed[_customerAddress]
REF_143(uint256) -> REF_142[msg.sender]
REF_143(-> allowed) = REF_143 - _amountOfTokens"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
frontTokenBalanceLedger_[_customerAddress] = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens)

IRs:
REF_144(uint256) -> frontTokenBalanceLedger_[_customerAddress]
REF_145(uint256) -> frontTokenBalanceLedger_[_customerAddress]
TMP_340(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_145', '_amountOfFrontEndTokens'] 
REF_144(uint256) (->frontTokenBalanceLedger_) := TMP_340(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
frontTokenBalanceLedger_[_toAddress] = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens)

IRs:
REF_147(uint256) -> frontTokenBalanceLedger_[_toAddress]
REF_148(uint256) -> frontTokenBalanceLedger_[_toAddress]
TMP_341(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_148', '_amountOfFrontEndTokens'] 
REF_147(uint256) (->frontTokenBalanceLedger_) := TMP_341(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens)

IRs:
REF_150(uint256) -> dividendTokenBalanceLedger_[_customerAddress]
REF_151(uint256) -> dividendTokenBalanceLedger_[_customerAddress]
TMP_342(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_151', '_amountOfDivTokens'] 
REF_150(uint256) (->dividendTokenBalanceLedger_) := TMP_342(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
dividendTokenBalanceLedger_[_toAddress] = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens)

IRs:
REF_153(uint256) -> dividendTokenBalanceLedger_[_toAddress]
REF_154(uint256) -> dividendTokenBalanceLedger_[_toAddress]
TMP_343(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_154', '_amountOfDivTokens'] 
REF_153(uint256) (->dividendTokenBalanceLedger_) := TMP_343(uint256)"];
15->16;
16[label="Node Type: IF 16

EXPRESSION:
! userSelectedRate[_toAddress]

IRs:
REF_156(bool) -> userSelectedRate[_toAddress]
TMP_344 = UnaryType.BANG REF_156 
CONDITION TMP_344"];
16->17[label="True"];
16->19[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
userSelectedRate[_toAddress] = true

IRs:
REF_157(bool) -> userSelectedRate[_toAddress]
REF_157(bool) (->userSelectedRate) := True(bool)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
userDividendRate[_toAddress] = userDividendRate[_customerAddress]

IRs:
REF_158(uint8) -> userDividendRate[_toAddress]
REF_159(uint8) -> userDividendRate[_customerAddress]
REF_158(uint8) (->userDividendRate) := REF_159(uint8)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
payoutsTo_[_customerAddress] -= int256(profitPerDivToken * _amountOfDivTokens)

IRs:
REF_160(int256) -> payoutsTo_[_customerAddress]
TMP_345(uint256) = profitPerDivToken * _amountOfDivTokens
TMP_346 = CONVERT TMP_345 to int256
REF_160(-> payoutsTo_) = REF_160 - TMP_346"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
payoutsTo_[_toAddress] += int256(profitPerDivToken * _amountOfDivTokens)

IRs:
REF_161(int256) -> payoutsTo_[_toAddress]
TMP_347(uint256) = profitPerDivToken * _amountOfDivTokens
TMP_348 = CONVERT TMP_347 to int256
REF_161(-> payoutsTo_) = REF_161 + TMP_348"];
21->22;
22[label="Node Type: NEW VARIABLE 22
"];
22->23;
23[label="Node Type: INLINE ASM 23
"];
23->24;
24[label="Node Type: END INLINE ASM 24
"];
24->25;
25[label="Node Type: IF 25

EXPRESSION:
length > 0

IRs:
TMP_349(bool) = length > 0
CONDITION TMP_349"];
25->26[label="True"];
25->28[label="False"];
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
receiver = ERC223Receiving(_toAddress)

IRs:
TMP_350 = CONVERT _toAddress to ERC223Receiving
receiver(ERC223Receiving) := TMP_350(ERC223Receiving)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
receiver.tokenFallback(_from,_amountOfTokens,_data)

IRs:
TMP_351(bool) = HIGH_LEVEL_CALL, dest:receiver(ERC223Receiving), function:tokenFallback, arguments:['_from', '_amountOfTokens', '_data']  "];
27->28;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
Transfer(_customerAddress,_toAddress,_amountOfFrontEndTokens)

IRs:
Emit Transfer(_customerAddress,_toAddress,_amountOfFrontEndTokens)"];
}
// Function: 1152.sol-Fortis-transferTo(address,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_from != msg.sender

IRs:
TMP_100(bool) = _from != msg.sender
CONDITION TMP_100"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= frontTokenBalanceLedger_[_from] && _amountOfTokens <= allowed[_from][msg.sender])

IRs:
TMP_101(bool) = _amountOfTokens >= MIN_TOKEN_TRANSFER
REF_53(uint256) -> frontTokenBalanceLedger_[_from]
TMP_102(bool) = _amountOfTokens <= REF_53
TMP_103(bool) = TMP_101 && TMP_102
REF_54(mapping(address => uint256)) -> allowed[_from]
REF_55(uint256) -> REF_54[msg.sender]
TMP_104(bool) = _amountOfTokens <= REF_55
TMP_105(bool) = TMP_103 && TMP_104
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= frontTokenBalanceLedger_[_from])

IRs:
TMP_107(bool) = _amountOfTokens >= MIN_TOKEN_TRANSFER
REF_56(uint256) -> frontTokenBalanceLedger_[_from]
TMP_108(bool) = _amountOfTokens <= REF_56
TMP_109(bool) = TMP_107 && TMP_108
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transferFromInternal(_from,_to,_amountOfTokens,_data)

IRs:
INTERNAL_CALL, Fortis.transferFromInternal(address,address,uint256,bytes)(_from,_to,_amountOfTokens,_data)"];
}
// Function: 1152.sol-Fortis-withdraw(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(regularPhase)

IRs:
TMP_41(None) = SOLIDITY_CALL require(bool)(regularPhase)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_dividends = myDividends(false)

IRs:
TMP_42(uint256) = INTERNAL_CALL, Fortis.myDividends(bool)(False)
_dividends(uint256) := TMP_42(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payoutsTo_[_customerAddress] += int256(_dividends * magnitude)

IRs:
REF_26(int256) -> payoutsTo_[_customerAddress]
TMP_43(uint256) = _dividends * magnitude
TMP_44 = CONVERT TMP_43 to int256
REF_26(-> payoutsTo_) = REF_26 + TMP_44"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_dividends += referralBalance_[_customerAddress]

IRs:
REF_27(uint256) -> referralBalance_[_customerAddress]
_dividends(uint256) = _dividends + REF_27"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
referralBalance_[_customerAddress] = 0

IRs:
REF_28(uint256) -> referralBalance_[_customerAddress]
REF_28(uint256) (->referralBalance_) := 0(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_recipient == address(0x0)

IRs:
TMP_45 = CONVERT 0 to address
TMP_46(bool) = _recipient == TMP_45
CONDITION TMP_46"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_recipient = msg.sender

IRs:
_recipient(address) := msg.sender(address)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_recipient.transfer(_dividends)

IRs:
Transfer dest:_recipient value:_dividends"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
onWithdraw(_recipient,_dividends)

IRs:
Emit onWithdraw(_recipient,_dividends)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
dividendHolder()

IRs:
MODIFIER_CALL, Fortis.dividendHolder()()"];
12->1;
}
// Function: 1152.sol-Fortis-withdrawFrom(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_dividends = theDividendsOf(false,_customerAddress)

IRs:
TMP_353(uint256) = INTERNAL_CALL, Fortis.theDividendsOf(bool,address)(False,_customerAddress)
_dividends(uint256) := TMP_353(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
payoutsTo_[_customerAddress] += int256(_dividends * magnitude)

IRs:
REF_163(int256) -> payoutsTo_[_customerAddress]
TMP_354(uint256) = _dividends * magnitude
TMP_355 = CONVERT TMP_354 to int256
REF_163(-> payoutsTo_) = REF_163 + TMP_355"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_dividends += referralBalance_[_customerAddress]

IRs:
REF_164(uint256) -> referralBalance_[_customerAddress]
_dividends(uint256) = _dividends + REF_164"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
referralBalance_[_customerAddress] = 0

IRs:
REF_165(uint256) -> referralBalance_[_customerAddress]
REF_165(uint256) (->referralBalance_) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_customerAddress.transfer(_dividends)

IRs:
Transfer dest:_customerAddress value:_dividends"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onWithdraw(_customerAddress,_dividends)

IRs:
Emit onWithdraw(_customerAddress,_dividends)"];
}
// Function: 1152.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_395(uint256) = a + b
c(uint256) := TMP_395(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_396(bool) = c >= a
TMP_397(None) = SOLIDITY_CALL assert(bool)(TMP_396)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1152.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_391(uint256) = a / b
c(uint256) := TMP_391(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1152.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_386(bool) = a == 0
CONDITION TMP_386"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_387(uint256) = a * b
c(uint256) := TMP_387(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_388(uint256) = c / a
TMP_389(bool) = TMP_388 == b
TMP_390(None) = SOLIDITY_CALL assert(bool)(TMP_389)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1152.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_392(bool) = b <= a
TMP_393(None) = SOLIDITY_CALL assert(bool)(TMP_392)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_394(uint256) = a - b
RETURN TMP_394"];
}
// Function: 1152.sol-ZethrBankroll-receiveDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1152.sol-ZethrDividendCards-ownerOf(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1152.sol-ZethrDividendCards-receiveDividends(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
}
