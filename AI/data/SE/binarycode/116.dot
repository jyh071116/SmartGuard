digraph G {
// Function: 116.sol-AdvisorsAddress-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_130(None) = SOLIDITY_CALL revert()()"];
}
// Function: 116.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
}
// Function: 116.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 116.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = _to != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_15(bool) = _value <= REF_0
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_17(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_18(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-BountyAddress-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_131(None) = SOLIDITY_CALL revert()()"];
}
// Function: 116.sol-BurnableToken-_burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_who])

IRs:
REF_16(uint256) -> balances[_who]
TMP_29(bool) = _value <= REF_16
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_who] = balances[_who].sub(_value)

IRs:
REF_17(uint256) -> balances[_who]
REF_18(uint256) -> balances[_who]
TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_18', '_value'] 
REF_17(uint256) (->balances) := TMP_31(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_32(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(_who,_value)

IRs:
Emit Burn(_who,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_who,address(0),_value)

IRs:
TMP_34 = CONVERT 0 to address
Emit Transfer(_who,TMP_34,_value)"];
}
// Function: 116.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 116.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_burn(msg.sender,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(msg.sender,_value)"];
}
// Function: 116.sol-BurnableToken-totalSupply()
digraph{
}
// Function: 116.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 116.sol-Crowdsale-_saleTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(uint64(now) > crowdSaleStartTime,Sale stage is not yet, Contract is init, do not accept ether.)

IRs:
TMP_339 = CONVERT now to uint64
TMP_340(bool) = TMP_339 > crowdSaleStartTime
TMP_341(None) = SOLIDITY_CALL require(bool,string)(TMP_340,Sale stage is not yet, Contract is init, do not accept ether.)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
currentState == State.Init

IRs:
REF_181(Crowdsale.State) -> State.Init
TMP_342(bool) = currentState == REF_181
CONDITION TMP_342"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(neironixProfitAddress != address(0),At least one of profit addresses must be entered)

IRs:
TMP_343 = CONVERT 0 to address
TMP_344(bool) = neironixProfitAddress != TMP_343
TMP_345(None) = SOLIDITY_CALL require(bool,string)(TMP_344,At least one of profit addresses must be entered)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
setState(State.CrowdSale)

IRs:
REF_182(Crowdsale.State) -> State.CrowdSale
INTERNAL_CALL, Crowdsale.setState(Crowdsale.State)(REF_182)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
uint64(now) > crowdSaleEndTime

IRs:
TMP_347 = CONVERT now to uint64
TMP_348(bool) = TMP_347 > crowdSaleEndTime
CONDITION TMP_348"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(false,CrowdSale stage is passed - contract do not accept ether)

IRs:
TMP_349(None) = SOLIDITY_CALL require(bool,string)(False,CrowdSale stage is passed - contract do not accept ether)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
tokens = tokenRate.mul(msg.value)

IRs:
TMP_350(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenRate', 'msg.value'] 
tokens(uint256) := TMP_350(uint256)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
currentState == State.CrowdSale

IRs:
REF_184(Crowdsale.State) -> State.CrowdSale
TMP_351(bool) = currentState == REF_184
CONDITION TMP_351"];
10->11[label="True"];
10->13[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(msg.value <= 250000000000000000000,Maximum 250 ether for transaction all CrowdSale period)

IRs:
TMP_352(bool) = msg.value <= 250000000000000000000
TMP_353(None) = SOLIDITY_CALL require(bool,string)(TMP_352,Maximum 250 ether for transaction all CrowdSale period)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool,string)(msg.value >= 100000000000000000,Minimum 0,1 ether for transaction all CrowdSale period)

IRs:
TMP_354(bool) = msg.value >= 100000000000000000
TMP_355(None) = SOLIDITY_CALL require(bool,string)(TMP_354,Minimum 0,1 ether for transaction all CrowdSale period)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
tokens = tokens.add(tokens.mul(setBonus()).div(100))

IRs:
TMP_356(uint256) = INTERNAL_CALL, Crowdsale.setBonus()()
TMP_357(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'TMP_356'] 
TMP_358(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_357', '100'] 
TMP_359(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'TMP_358'] 
tokens(uint256) := TMP_359(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
token.transfer(msg.sender,tokens)

IRs:
TMP_360(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:transfer, arguments:['msg.sender', 'tokens']  "];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-Crowdsale-_transferTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newInvestor != address(0))

IRs:
TMP_236 = CONVERT 0 to address
TMP_237(bool) = _newInvestor != TMP_236
TMP_238(None) = SOLIDITY_CALL require(bool)(TMP_237)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value >= 1)

IRs:
TMP_239(bool) = _value >= 1
TMP_240(None) = SOLIDITY_CALL require(bool)(TMP_239)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
value = _value

IRs:
value(uint256) := _value(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
value = value.mul(1000000000000000000)

IRs:
TMP_241(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '1000000000000000000'] 
value(uint256) := TMP_241(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token.transfer(_newInvestor,value)

IRs:
TMP_242(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:transfer, arguments:['_newInvestor', 'value']  "];
}
// Function: 116.sol-Crowdsale-_withdrawProfit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
marketingProfit = myAddress.balance.mul(30).div(100)

IRs:
TMP_296(uint256) = SOLIDITY_CALL balance(address)(myAddress)
TMP_297(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_296', '30'] 
TMP_298(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_297', '100'] 
marketingProfit(uint256) := TMP_298(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
lawSupportProfit = myAddress.balance.div(20)

IRs:
TMP_299(uint256) = SOLIDITY_CALL balance(address)(myAddress)
TMP_300(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_299', '20'] 
lawSupportProfit(uint256) := TMP_300(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
hostingProfit = myAddress.balance.div(20)

IRs:
TMP_301(uint256) = SOLIDITY_CALL balance(address)(myAddress)
TMP_302(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_301', '20'] 
hostingProfit(uint256) := TMP_302(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
teamProfit = myAddress.balance.div(10)

IRs:
TMP_303(uint256) = SOLIDITY_CALL balance(address)(myAddress)
TMP_304(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_303', '10'] 
teamProfit(uint256) := TMP_304(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
contractorsProfit = myAddress.balance.div(20)

IRs:
TMP_305(uint256) = SOLIDITY_CALL balance(address)(myAddress)
TMP_306(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_305', '20'] 
contractorsProfit(uint256) := TMP_306(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
saasApiProfit = myAddress.balance.div(20)

IRs:
TMP_307(uint256) = SOLIDITY_CALL balance(address)(myAddress)
TMP_308(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_307', '20'] 
saasApiProfit(uint256) := TMP_308(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
marketingProfitAddress != address(0)

IRs:
TMP_309 = CONVERT 0 to address
TMP_310(bool) = marketingProfitAddress != TMP_309
CONDITION TMP_310"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
marketingProfitAddress.transfer(marketingProfit)

IRs:
Transfer dest:marketingProfitAddress value:marketingProfit"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Withdraw(msg.sender,marketingProfitAddress,marketingProfit)

IRs:
Emit Withdraw(msg.sender,marketingProfitAddress,marketingProfit)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
lawSupportProfitAddress != address(0)

IRs:
TMP_313 = CONVERT 0 to address
TMP_314(bool) = lawSupportProfitAddress != TMP_313
CONDITION TMP_314"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
lawSupportProfitAddress.transfer(lawSupportProfit)

IRs:
Transfer dest:lawSupportProfitAddress value:lawSupportProfit"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
Withdraw(msg.sender,lawSupportProfitAddress,lawSupportProfit)

IRs:
Emit Withdraw(msg.sender,lawSupportProfitAddress,lawSupportProfit)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
hostingProfitAddress != address(0)

IRs:
TMP_317 = CONVERT 0 to address
TMP_318(bool) = hostingProfitAddress != TMP_317
CONDITION TMP_318"];
15->16[label="True"];
15->18[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
hostingProfitAddress.transfer(hostingProfit)

IRs:
Transfer dest:hostingProfitAddress value:hostingProfit"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
Withdraw(msg.sender,hostingProfitAddress,hostingProfit)

IRs:
Emit Withdraw(msg.sender,hostingProfitAddress,hostingProfit)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: IF 19

EXPRESSION:
teamProfitAddress != address(0)

IRs:
TMP_321 = CONVERT 0 to address
TMP_322(bool) = teamProfitAddress != TMP_321
CONDITION TMP_322"];
19->20[label="True"];
19->22[label="False"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
teamProfitAddress.transfer(teamProfit)

IRs:
Transfer dest:teamProfitAddress value:teamProfit"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
Withdraw(msg.sender,teamProfitAddress,teamProfit)

IRs:
Emit Withdraw(msg.sender,teamProfitAddress,teamProfit)"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
contractorsProfitAddress != address(0)

IRs:
TMP_325 = CONVERT 0 to address
TMP_326(bool) = contractorsProfitAddress != TMP_325
CONDITION TMP_326"];
23->24[label="True"];
23->26[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
contractorsProfitAddress.transfer(contractorsProfit)

IRs:
Transfer dest:contractorsProfitAddress value:contractorsProfit"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
Withdraw(msg.sender,contractorsProfitAddress,contractorsProfit)

IRs:
Emit Withdraw(msg.sender,contractorsProfitAddress,contractorsProfit)"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
saasApiProfitAddress != address(0)

IRs:
TMP_329 = CONVERT 0 to address
TMP_330(bool) = saasApiProfitAddress != TMP_329
CONDITION TMP_330"];
27->28[label="True"];
27->30[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
saasApiProfitAddress.transfer(saasApiProfit)

IRs:
Transfer dest:saasApiProfitAddress value:saasApiProfit"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
Withdraw(msg.sender,saasApiProfitAddress,saasApiProfit)

IRs:
Emit Withdraw(msg.sender,saasApiProfitAddress,saasApiProfit)"];
29->30;
30[label="Node Type: END_IF 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
require(bool)(neironixProfitAddress != address(0))

IRs:
TMP_333 = CONVERT 0 to address
TMP_334(bool) = neironixProfitAddress != TMP_333
TMP_335(None) = SOLIDITY_CALL require(bool)(TMP_334)"];
31->32;
32[label="Node Type: NEW VARIABLE 32

EXPRESSION:
myBalance = myAddress.balance

IRs:
TMP_336(uint256) = SOLIDITY_CALL balance(address)(myAddress)
myBalance(uint256) := TMP_336(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
neironixProfitAddress.transfer(myBalance)

IRs:
Transfer dest:neironixProfitAddress value:myBalance"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
Withdraw(msg.sender,neironixProfitAddress,myBalance)

IRs:
Emit Withdraw(msg.sender,neironixProfitAddress,myBalance)"];
}
// Function: 116.sol-Crowdsale-acceptTokensFromUsers(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.acceptTokens(_investor,_value)

IRs:
TMP_195(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:acceptTokens, arguments:['_investor', '_value']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 116.sol-Crowdsale-blockExternalTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.lockTransfers() == false)

IRs:
TMP_264(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:lockTransfers, arguments:[]  
TMP_265(bool) = TMP_264 == False
TMP_266(None) = SOLIDITY_CALL require(bool)(TMP_265)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.lockTransfer(true)

IRs:
HIGH_LEVEL_CALL, dest:token(NRXtoken), function:lockTransfer, arguments:['True']  "];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.WorkTime)

IRs:
REF_163(Crowdsale.State) -> State.WorkTime
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_163)"];
4->1;
}
// Function: 116.sol-Crowdsale-confirmOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(candidate == msg.sender)

IRs:
TMP_136(bool) = candidate == msg.sender
TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = candidate

IRs:
owner(address) := candidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete candidate

IRs:
candidate = delete candidate "];
}
// Function: 116.sol-Crowdsale-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
TotalTokens = token.INITIAL_SUPPLY().div(1000000000000000000)

IRs:
TMP_138(uint256) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:INITIAL_SUPPLY, arguments:[]  
TMP_139(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_138', '1000000000000000000'] 
TotalTokens(uint256) := TMP_139(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_transferTokens(address(holdAddress1),TotalTokens.mul(7).div(100))

IRs:
TMP_140 = CONVERT holdAddress1 to address
TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TotalTokens', '7'] 
TMP_142(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_141', '100'] 
INTERNAL_CALL, Crowdsale._transferTokens(address,uint256)(TMP_140,TMP_142)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_transferTokens(address(holdAddress2),TotalTokens.div(10))

IRs:
TMP_144 = CONVERT holdAddress2 to address
TMP_145(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TotalTokens', '10'] 
INTERNAL_CALL, Crowdsale._transferTokens(address,uint256)(TMP_144,TMP_145)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_transferTokens(address(holdAddress3),TotalTokens.div(10))

IRs:
TMP_147 = CONVERT holdAddress3 to address
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TotalTokens', '10'] 
INTERNAL_CALL, Crowdsale._transferTokens(address,uint256)(TMP_147,TMP_148)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_transferTokens(address(holdAddress4),TotalTokens.mul(35).div(1000))

IRs:
TMP_150 = CONVERT holdAddress4 to address
TMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TotalTokens', '35'] 
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_151', '1000'] 
INTERNAL_CALL, Crowdsale._transferTokens(address,uint256)(TMP_150,TMP_152)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_transferTokens(address(holdAddress5),TotalTokens.mul(3).div(100))

IRs:
TMP_154 = CONVERT holdAddress5 to address
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TotalTokens', '3'] 
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_155', '100'] 
INTERNAL_CALL, Crowdsale._transferTokens(address,uint256)(TMP_154,TMP_156)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
crowdSaleStartTime = 1535760000

IRs:
crowdSaleStartTime(uint64) := 1535760000(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
crowdSaleEndTime = crowdSaleStartTime + 7862400

IRs:
TMP_158(uint64) = crowdSaleStartTime + 7862400
crowdSaleEndTime(uint64) := TMP_158(uint64)"];
}
// Function: 116.sol-Crowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_saleTokens()

IRs:
TMP_361(bool) = INTERNAL_CALL, Crowdsale._saleTokens()()
CONDITION TMP_361"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_withdrawProfit()

IRs:
INTERNAL_CALL, Crowdsale._withdrawProfit()()"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 116.sol-Crowdsale-finishCrowdSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(now > crowdSaleEndTime,CrowdSale stage is not over)

IRs:
TMP_256(bool) = now > crowdSaleEndTime
TMP_257(None) = SOLIDITY_CALL require(bool,string)(TMP_256,CrowdSale stage is not over)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
setState(State.WorkTime)

IRs:
REF_156(Crowdsale.State) -> State.WorkTime
INTERNAL_CALL, Crowdsale.setState(Crowdsale.State)(REF_156)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token.lockTransfer(false)

IRs:
HIGH_LEVEL_CALL, dest:token(NRXtoken), function:lockTransfer, arguments:['False']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
token.burn(token.balanceOf(myAddress))

IRs:
TMP_260(uint256) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:balanceOf, arguments:['myAddress']  
HIGH_LEVEL_CALL, dest:token(NRXtoken), function:burn, arguments:['TMP_260']  "];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyInState(State.CrowdSale)

IRs:
REF_160(Crowdsale.State) -> State.CrowdSale
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_160)"];
6->1;
}
// Function: 116.sol-Crowdsale-onlyInState(Crowdsale.State)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == currentState)

IRs:
TMP_377(bool) = state == currentState
TMP_378(None) = SOLIDITY_CALL require(bool)(TMP_377)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 116.sol-Crowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_375(bool) = msg.sender == owner
TMP_376(None) = SOLIDITY_CALL require(bool)(TMP_375)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 116.sol-Crowdsale-setBonus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
actualBonus = 0

IRs:
actualBonus(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
(uint64(now) >= crowdSaleStartTime) && (uint64(now) < crowdSaleStartTime + 2592000)

IRs:
TMP_276 = CONVERT now to uint64
TMP_277(bool) = TMP_276 >= crowdSaleStartTime
TMP_278 = CONVERT now to uint64
TMP_279(uint64) = crowdSaleStartTime + 2592000
TMP_280(bool) = TMP_278 < TMP_279
TMP_281(bool) = TMP_277 && TMP_280
CONDITION TMP_281"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
actualBonus = 35

IRs:
actualBonus(uint256) := 35(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
(uint64(now) >= crowdSaleStartTime + 2592000) && (uint64(now) < crowdSaleStartTime + 5270400)

IRs:
TMP_282 = CONVERT now to uint64
TMP_283(uint64) = crowdSaleStartTime + 2592000
TMP_284(bool) = TMP_282 >= TMP_283
TMP_285 = CONVERT now to uint64
TMP_286(uint64) = crowdSaleStartTime + 5270400
TMP_287(bool) = TMP_285 < TMP_286
TMP_288(bool) = TMP_284 && TMP_287
CONDITION TMP_288"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
actualBonus = 15

IRs:
actualBonus(uint256) := 15(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
(uint64(now) >= crowdSaleStartTime + 5270400) && (uint64(now) < crowdSaleStartTime + 7862400)

IRs:
TMP_289 = CONVERT now to uint64
TMP_290(uint64) = crowdSaleStartTime + 5270400
TMP_291(bool) = TMP_289 >= TMP_290
TMP_292 = CONVERT now to uint64
TMP_293(uint64) = crowdSaleStartTime + 7862400
TMP_294(bool) = TMP_292 < TMP_293
TMP_295(bool) = TMP_291 && TMP_294
CONDITION TMP_295"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
actualBonus = 5

IRs:
actualBonus(uint256) := 5(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
actualBonus

IRs:
RETURN actualBonus"];
}
// Function: 116.sol-Crowdsale-setContractorsProfitAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != address(0))

IRs:
TMP_185 = CONVERT 0 to address
TMP_186(bool) = _addr != TMP_185
TMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
contractorsProfitAddress = _addr

IRs:
contractorsProfitAddress(address) := _addr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_138(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_138)"];
4->1;
}
// Function: 116.sol-Crowdsale-setHostingProfitAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != address(0))

IRs:
TMP_175 = CONVERT 0 to address
TMP_176(bool) = _addr != TMP_175
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
hostingProfitAddress = _addr

IRs:
hostingProfitAddress(address) := _addr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_136(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_136)"];
4->1;
}
// Function: 116.sol-Crowdsale-setLawSupportProfitAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != address(0))

IRs:
TMP_170 = CONVERT 0 to address
TMP_171(bool) = _addr != TMP_170
TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
lawSupportProfitAddress = _addr

IRs:
lawSupportProfitAddress(address) := _addr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_135(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_135)"];
4->1;
}
// Function: 116.sol-Crowdsale-setMarketingProfitAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != address(0))

IRs:
TMP_160 = CONVERT 0 to address
TMP_161(bool) = _addr != TMP_160
TMP_162(None) = SOLIDITY_CALL require(bool)(TMP_161)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
marketingProfitAddress = _addr

IRs:
marketingProfitAddress(address) := _addr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_133(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_133)"];
4->1;
}
// Function: 116.sol-Crowdsale-setNeironixProfitAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != address(0))

IRs:
TMP_165 = CONVERT 0 to address
TMP_166(bool) = _addr != TMP_165
TMP_167(None) = SOLIDITY_CALL require(bool)(TMP_166)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
neironixProfitAddress = _addr

IRs:
neironixProfitAddress(address) := _addr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_134(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_134)"];
4->1;
}
// Function: 116.sol-Crowdsale-setRate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenRate = _newRate

IRs:
tokenRate(uint256) := _newRate(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 116.sol-Crowdsale-setSaasApiProfitAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != address(0))

IRs:
TMP_190 = CONVERT 0 to address
TMP_191(bool) = _addr != TMP_190
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
saasApiProfitAddress = _addr

IRs:
saasApiProfitAddress(address) := _addr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_139(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_139)"];
4->1;
}
// Function: 116.sol-Crowdsale-setState(Crowdsale.State)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
currentState = _state

IRs:
currentState(Crowdsale.State) := _state(Crowdsale.State)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
LogStateSwitch(_state)

IRs:
Emit LogStateSwitch(_state)"];
}
// Function: 116.sol-Crowdsale-setTeamProfitAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != address(0))

IRs:
TMP_180 = CONVERT 0 to address
TMP_181(bool) = _addr != TMP_180
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
teamProfitAddress = _addr

IRs:
teamProfitAddress(address) := _addr(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_137(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_137)"];
4->1;
}
// Function: 116.sol-Crowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
crowdSaleStartTime = 0

IRs:
crowdSaleStartTime(uint64) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
crowdSaleEndTime = 0

IRs:
crowdSaleEndTime(uint64) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
tokenRate = 942

IRs:
tokenRate(uint256) := 942(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
marketingProfitAddress = 0x0

IRs:
marketingProfitAddress(address) := 0(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
neironixProfitAddress = 0x0

IRs:
neironixProfitAddress(address) := 0(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
lawSupportProfitAddress = 0x0

IRs:
lawSupportProfitAddress(address) := 0(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
hostingProfitAddress = 0x0

IRs:
hostingProfitAddress(address) := 0(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
teamProfitAddress = 0x0

IRs:
teamProfitAddress(address) := 0(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
contractorsProfitAddress = 0x0

IRs:
contractorsProfitAddress(address) := 0(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
saasApiProfitAddress = 0x0

IRs:
saasApiProfitAddress(address) := 0(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
token = new NRXtoken(myAddress)

IRs:
TMP_364(NRXtoken) = new NRXtoken(myAddress) 
token(NRXtoken) := TMP_364(NRXtoken)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
holdAddress1 = new ProjectFundAddress()

IRs:
TMP_366(ProjectFundAddress) = new ProjectFundAddress() 
holdAddress1(ProjectFundAddress) := TMP_366(ProjectFundAddress)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
holdAddress2 = new TeamAddress()

IRs:
TMP_368(TeamAddress) = new TeamAddress() 
holdAddress2(TeamAddress) := TMP_368(TeamAddress)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
holdAddress3 = new PartnersAddress()

IRs:
TMP_370(PartnersAddress) = new PartnersAddress() 
holdAddress3(PartnersAddress) := TMP_370(PartnersAddress)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
holdAddress4 = new AdvisorsAddress()

IRs:
TMP_372(AdvisorsAddress) = new AdvisorsAddress() 
holdAddress4(AdvisorsAddress) := TMP_372(AdvisorsAddress)"];
15->16;
16[label="Node Type: OTHER_ENTRYPOINT 16

EXPRESSION:
holdAddress5 = new BountyAddress()

IRs:
TMP_374(BountyAddress) = new BountyAddress() 
holdAddress5(BountyAddress) := TMP_374(BountyAddress)"];
16->17;
17[label="Node Type: OTHER_ENTRYPOINT 17

EXPRESSION:
currentState = State.Init

IRs:
REF_189(Crowdsale.State) -> State.Init
currentState(Crowdsale.State) := REF_189(Crowdsale.State)"];
}
// Function: 116.sol-Crowdsale-startSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(uint64(now) > crowdSaleStartTime,Sale time is not coming.)

IRs:
TMP_246 = CONVERT now to uint64
TMP_247(bool) = TMP_246 > crowdSaleStartTime
TMP_248(None) = SOLIDITY_CALL require(bool,string)(TMP_247,Sale time is not coming.)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(neironixProfitAddress != address(0))

IRs:
TMP_249 = CONVERT 0 to address
TMP_250(bool) = neironixProfitAddress != TMP_249
TMP_251(None) = SOLIDITY_CALL require(bool)(TMP_250)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
setState(State.CrowdSale)

IRs:
REF_153(Crowdsale.State) -> State.CrowdSale
INTERNAL_CALL, Crowdsale.setState(Crowdsale.State)(REF_153)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
token.lockTransfer(true)

IRs:
HIGH_LEVEL_CALL, dest:token(NRXtoken), function:lockTransfer, arguments:['True']  "];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyInState(State.Init)

IRs:
REF_155(Crowdsale.State) -> State.Init
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_155)"];
6->1;
}
// Function: 116.sol-Crowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_132 = CONVERT 0 to address
TMP_133(bool) = newOwner != TMP_132
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
candidate = newOwner

IRs:
candidate(address) := newOwner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 116.sol-Crowdsale-transferTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferTokens(_newInvestor,_value)

IRs:
INTERNAL_CALL, Crowdsale._transferTokens(address,uint256)(_newInvestor,_value)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 116.sol-Crowdsale-transferTokensFromAdvisorsAddress(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = _value

IRs:
value(uint256) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value >= 1)

IRs:
TMP_221(bool) = value >= 1
TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
value = value.mul(1000000000000000000)

IRs:
TMP_223(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '1000000000000000000'] 
value(uint256) := TMP_223(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(now >= crowdSaleEndTime + 7862400,only after 91 days)

IRs:
TMP_224(uint64) = crowdSaleEndTime + 7862400
TMP_225(bool) = now >= TMP_224
TMP_226(None) = SOLIDITY_CALL require(bool,string)(TMP_225,only after 91 days)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token.transferTokensFromSpecialAddress(address(holdAddress4),_investor,value)

IRs:
TMP_227 = CONVERT holdAddress4 to address
TMP_228(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:transferTokensFromSpecialAddress, arguments:['TMP_227', '_investor', 'value']  "];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 116.sol-Crowdsale-transferTokensFromBountyAddress(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = _value

IRs:
value(uint256) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value >= 1)

IRs:
TMP_230(bool) = value >= 1
TMP_231(None) = SOLIDITY_CALL require(bool)(TMP_230)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
value = value.mul(1000000000000000000)

IRs:
TMP_232(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '1000000000000000000'] 
value(uint256) := TMP_232(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
token.transferTokensFromSpecialAddress(address(holdAddress5),_investor,value)

IRs:
TMP_233 = CONVERT holdAddress5 to address
TMP_234(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:transferTokensFromSpecialAddress, arguments:['TMP_233', '_investor', 'value']  "];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 116.sol-Crowdsale-transferTokensFromPartnersAddress(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = _value

IRs:
value(uint256) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value >= 1)

IRs:
TMP_212(bool) = value >= 1
TMP_213(None) = SOLIDITY_CALL require(bool)(TMP_212)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
value = value.mul(1000000000000000000)

IRs:
TMP_214(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '1000000000000000000'] 
value(uint256) := TMP_214(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(now >= crowdSaleEndTime + 7862400,only after 91 days)

IRs:
TMP_215(uint64) = crowdSaleEndTime + 7862400
TMP_216(bool) = now >= TMP_215
TMP_217(None) = SOLIDITY_CALL require(bool,string)(TMP_216,only after 91 days)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token.transferTokensFromSpecialAddress(address(holdAddress3),_investor,value)

IRs:
TMP_218 = CONVERT holdAddress3 to address
TMP_219(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:transferTokensFromSpecialAddress, arguments:['TMP_218', '_investor', 'value']  "];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 116.sol-Crowdsale-transferTokensFromProjectFundAddress(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = _value

IRs:
value(uint256) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value >= 1)

IRs:
TMP_197(bool) = value >= 1
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
value = value.mul(1000000000000000000)

IRs:
TMP_199(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '1000000000000000000'] 
value(uint256) := TMP_199(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
token.transferTokensFromSpecialAddress(address(holdAddress1),_investor,value)

IRs:
TMP_200 = CONVERT holdAddress1 to address
TMP_201(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:transferTokensFromSpecialAddress, arguments:['TMP_200', '_investor', 'value']  "];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 116.sol-Crowdsale-transferTokensFromTeamAddress(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = _value

IRs:
value(uint256) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value >= 1)

IRs:
TMP_203(bool) = value >= 1
TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
value = value.mul(1000000000000000000)

IRs:
TMP_205(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '1000000000000000000'] 
value(uint256) := TMP_205(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(now >= crowdSaleEndTime + 15724800,only after 182 days)

IRs:
TMP_206(uint64) = crowdSaleEndTime + 15724800
TMP_207(bool) = now >= TMP_206
TMP_208(None) = SOLIDITY_CALL require(bool,string)(TMP_207,only after 182 days)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token.transferTokensFromSpecialAddress(address(holdAddress2),_investor,value)

IRs:
TMP_209 = CONVERT holdAddress2 to address
TMP_210(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:transferTokensFromSpecialAddress, arguments:['TMP_209', '_investor', 'value']  "];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 116.sol-Crowdsale-unBlockExternalTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.lockTransfers() == true)

IRs:
TMP_270(bool) = HIGH_LEVEL_CALL, dest:token(NRXtoken), function:lockTransfers, arguments:[]  
TMP_271(bool) = TMP_270 == True
TMP_272(None) = SOLIDITY_CALL require(bool)(TMP_271)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.lockTransfer(false)

IRs:
HIGH_LEVEL_CALL, dest:token(NRXtoken), function:lockTransfer, arguments:['False']  "];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyInState(State.WorkTime)

IRs:
REF_166(Crowdsale.State) -> State.WorkTime
MODIFIER_CALL, Crowdsale.onlyInState(Crowdsale.State)(REF_166)"];
4->1;
}
// Function: 116.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 116.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 116.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 116.sol-ERC20-totalSupply()
digraph{
}
// Function: 116.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 116.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 116.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 116.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 116.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 116.sol-NRXtoken-_burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_who])

IRs:
REF_63(uint256) -> balances[_who]
TMP_62(bool) = _value <= REF_63
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_who] = balances[_who].sub(_value)

IRs:
REF_64(uint256) -> balances[_who]
REF_65(uint256) -> balances[_who]
TMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_65', '_value'] 
REF_64(uint256) (->balances) := TMP_64(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_65(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_65(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(_who,_value)

IRs:
Emit Burn(_who,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_who,address(0),_value)

IRs:
TMP_67 = CONVERT 0 to address
Emit Transfer(_who,TMP_67,_value)"];
}
// Function: 116.sol-NRXtoken-acceptTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_111(uint256) -> balances[_from]
TMP_102(bool) = REF_111 >= _value
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_112(uint256) -> balances[_from]
REF_113(uint256) -> balances[_from]
TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_113', '_value'] 
REF_112(uint256) (->balances) := TMP_104(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_105(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
AcceptToken(_from,_value)

IRs:
Emit AcceptToken(_from,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, NRXtoken.onlyOwner()()"];
6->1;
}
// Function: 116.sol-NRXtoken-allowance(address,address)
digraph{
}
// Function: 116.sol-NRXtoken-approve(address,uint256)
digraph{
}
// Function: 116.sol-NRXtoken-balanceOf(address)
digraph{
}
// Function: 116.sol-NRXtoken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_burn(msg.sender,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(msg.sender,_value)"];
}
// Function: 116.sol-NRXtoken-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
CrowdsaleAddress = _CrowdsaleAddress

IRs:
CrowdsaleAddress(address) := _CrowdsaleAddress(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
totalSupply_ = INITIAL_SUPPLY

IRs:
totalSupply_(uint256) := INITIAL_SUPPLY(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = INITIAL_SUPPLY

IRs:
REF_110(uint256) -> balances[msg.sender]
REF_110(uint256) (->balances) := INITIAL_SUPPLY(uint256)"];
}
// Function: 116.sol-NRXtoken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_101(mapping(address => uint256)) -> allowed[msg.sender]
REF_102(uint256) -> REF_101[_spender]
oldValue(uint256) := REF_102(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_91(bool) = _subtractedValue > oldValue
CONDITION TMP_91"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_103(mapping(address => uint256)) -> allowed[msg.sender]
REF_104(uint256) -> REF_103[_spender]
REF_104(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_105(mapping(address => uint256)) -> allowed[msg.sender]
REF_106(uint256) -> REF_105[_spender]
TMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_106(uint256) (->allowed) := TMP_92(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_108(mapping(address => uint256)) -> allowed[msg.sender]
REF_109(uint256) -> REF_108[_spender]
Emit Approval(msg.sender,_spender,REF_109)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-NRXtoken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert(string)(The token contract don`t receive ether)

IRs:
TMP_115(None) = SOLIDITY_CALL revert(string)(The token contract don`t receive ether)"];
}
// Function: 116.sol-NRXtoken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_94(mapping(address => uint256)) -> allowed[msg.sender]
REF_95(uint256) -> REF_94[_spender]
REF_96(mapping(address => uint256)) -> allowed[msg.sender]
REF_97(uint256) -> REF_96[_spender]
TMP_89(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_97', '_addedValue'] 
REF_95(uint256) (->allowed) := TMP_89(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_99(mapping(address => uint256)) -> allowed[msg.sender]
REF_100(uint256) -> REF_99[_spender]
Emit Approval(msg.sender,_spender,REF_100)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-NRXtoken-lockTransfer(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
lockTransfers = _lock

IRs:
lockTransfers(bool) := _lock(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, NRXtoken.onlyOwner()()"];
2->1;
}
// Function: 116.sol-NRXtoken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == CrowdsaleAddress)

IRs:
TMP_117(bool) = msg.sender == CrowdsaleAddress
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 116.sol-NRXtoken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Neironix

IRs:
name(string) := Neironix(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = NRX

IRs:
symbol(string) := NRX(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint32) := 18(uint256)"];
}
// Function: 116.sol-NRXtoken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
INITIAL_SUPPLY = 140000000 * 1000000000000000000

IRs:
TMP_116(uint256) = 140000000 * 1000000000000000000
INITIAL_SUPPLY(uint256) := TMP_116(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
lockTransfers = false

IRs:
lockTransfers(bool) := False(bool)"];
}
// Function: 116.sol-NRXtoken-totalSupply()
digraph{
}
// Function: 116.sol-NRXtoken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != CrowdsaleAddress

IRs:
TMP_94(bool) = msg.sender != CrowdsaleAddress
CONDITION TMP_94"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(! lockTransfers,Transfers are prohibited in Crowdsale period)

IRs:
TMP_95 = UnaryType.BANG lockTransfers 
TMP_96(None) = SOLIDITY_CALL require(bool,string)(TMP_95,Transfers are prohibited in Crowdsale period)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_97(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)
RETURN TMP_97"];
}
// Function: 116.sol-NRXtoken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != CrowdsaleAddress

IRs:
TMP_98(bool) = msg.sender != CrowdsaleAddress
CONDITION TMP_98"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(! lockTransfers,Transfers are prohibited in Crowdsale period)

IRs:
TMP_99 = UnaryType.BANG lockTransfers 
TMP_100(None) = SOLIDITY_CALL require(bool,string)(TMP_99,Transfers are prohibited in Crowdsale period)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_101(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_101"];
}
// Function: 116.sol-NRXtoken-transferTokensFromSpecialAddress(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_116(uint256) -> balances[_from]
TMP_108(bool) = REF_116 >= _value
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_117(uint256) -> balances[_from]
REF_118(uint256) -> balances[_from]
TMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_118', '_value'] 
REF_117(uint256) (->balances) := TMP_110(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_120(uint256) -> balances[_to]
REF_121(uint256) -> balances[_to]
TMP_111(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_121', '_value'] 
REF_120(uint256) (->balances) := TMP_111(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, NRXtoken.onlyOwner()()"];
6->1;
}
// Function: 116.sol-Ownable-confirmOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(candidate == msg.sender)

IRs:
TMP_123(bool) = candidate == msg.sender
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = candidate

IRs:
owner(address) := candidate(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete candidate

IRs:
candidate = delete candidate "];
}
// Function: 116.sol-Ownable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 116.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_125(bool) = msg.sender == owner
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 116.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_119 = CONVERT 0 to address
TMP_120(bool) = newOwner != TMP_119
TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
candidate = newOwner

IRs:
candidate(address) := newOwner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 116.sol-PartnersAddress-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_129(None) = SOLIDITY_CALL revert()()"];
}
// Function: 116.sol-ProjectFundAddress-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_127(None) = SOLIDITY_CALL revert()()"];
}
// Function: 116.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 116.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a / b

IRs:
TMP_5(uint256) = a / b
RETURN TMP_5"];
}
// Function: 116.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 116.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 116.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_45(mapping(address => uint256)) -> allowed[_owner]
REF_46(uint256) -> REF_45[_spender]
RETURN REF_46"];
}
// Function: 116.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 116.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_54(mapping(address => uint256)) -> allowed[msg.sender]
REF_55(uint256) -> REF_54[_spender]
oldValue(uint256) := REF_55(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_58(bool) = _subtractedValue > oldValue
CONDITION TMP_58"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_56(mapping(address => uint256)) -> allowed[msg.sender]
REF_57(uint256) -> REF_56[_spender]
REF_57(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_58(mapping(address => uint256)) -> allowed[msg.sender]
REF_59(uint256) -> REF_58[_spender]
TMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_59(uint256) (->allowed) := TMP_59(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_61(mapping(address => uint256)) -> allowed[msg.sender]
REF_62(uint256) -> REF_61[_spender]
Emit Approval(msg.sender,_spender,REF_62)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_47(mapping(address => uint256)) -> allowed[msg.sender]
REF_48(uint256) -> REF_47[_spender]
REF_49(mapping(address => uint256)) -> allowed[msg.sender]
REF_50(uint256) -> REF_49[_spender]
TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_50', '_addedValue'] 
REF_48(uint256) (->allowed) := TMP_56(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_52(mapping(address => uint256)) -> allowed[msg.sender]
REF_53(uint256) -> REF_52[_spender]
Emit Approval(msg.sender,_spender,REF_53)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-StandardToken-totalSupply()
digraph{
}
// Function: 116.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 116.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_44 = CONVERT 0 to address
TMP_45(bool) = _to != TMP_44
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_29(uint256) -> balances[_from]
TMP_47(bool) = _value <= REF_29
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_30(mapping(address => uint256)) -> allowed[_from]
REF_31(uint256) -> REF_30[msg.sender]
TMP_49(bool) = _value <= REF_31
TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_32(uint256) -> balances[_from]
REF_33(uint256) -> balances[_from]
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_33', '_value'] 
REF_32(uint256) (->balances) := TMP_51(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_35(uint256) -> balances[_to]
REF_36(uint256) -> balances[_to]
TMP_52(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_36', '_value'] 
REF_35(uint256) (->balances) := TMP_52(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_38(mapping(address => uint256)) -> allowed[_from]
REF_39(uint256) -> REF_38[msg.sender]
REF_40(mapping(address => uint256)) -> allowed[_from]
REF_41(uint256) -> REF_40[msg.sender]
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_41', '_value'] 
REF_39(uint256) (->allowed) := TMP_53(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 116.sol-TeamAddress-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_128(None) = SOLIDITY_CALL revert()()"];
}
}
