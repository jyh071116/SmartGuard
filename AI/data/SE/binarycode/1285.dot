digraph G {
// Function: 1285.sol-NameFilter-nameFilter(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_temp = bytes(_input)

IRs:
TMP_128 = CONVERT _input to bytes
_temp(bytes) := TMP_128(bytes)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_length = _temp.length

IRs:
REF_92 -> LENGTH _temp
_length(uint256) := REF_92(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(_length <= 32 && _length > 0,string must be between 1 and 32 characters)

IRs:
TMP_129(bool) = _length <= 32
TMP_130(bool) = _length > 0
TMP_131(bool) = TMP_129 && TMP_130
TMP_132(None) = SOLIDITY_CALL require(bool,string)(TMP_131,string must be between 1 and 32 characters)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(_temp[0] != 0x20 && _temp[_length - 1] != 0x20,string cannot start or end with space)

IRs:
REF_93(None) -> _temp[0]
TMP_133(bool) = REF_93 != 32
TMP_134(uint256) = _length - 1
REF_94(None) -> _temp[TMP_134]
TMP_135(bool) = REF_94 != 32
TMP_136(bool) = TMP_133 && TMP_135
TMP_137(None) = SOLIDITY_CALL require(bool,string)(TMP_136,string cannot start or end with space)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
_temp[0] == 0x30

IRs:
REF_95(None) -> _temp[0]
TMP_138(bool) = REF_95 == 48
CONDITION TMP_138"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool,string)(_temp[1] != 0x78,string cannot start with 0x)

IRs:
REF_96(None) -> _temp[1]
TMP_139(bool) = REF_96 != 120
TMP_140(None) = SOLIDITY_CALL require(bool,string)(TMP_139,string cannot start with 0x)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(_temp[1] != 0x58,string cannot start with 0X)

IRs:
REF_97(None) -> _temp[1]
TMP_141(bool) = REF_97 != 88
TMP_142(None) = SOLIDITY_CALL require(bool,string)(TMP_141,string cannot start with 0X)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9
"];
9->12;
10[label="Node Type: BEGIN_LOOP 10
"];
10->13;
11[label="Node Type: END_LOOP 11
"];
11->28;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
12->10;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
i < _length

IRs:
TMP_143(bool) = i < _length
CONDITION TMP_143"];
13->14[label="True"];
13->11[label="False"];
14[label="Node Type: IF 14

EXPRESSION:
_temp[i] > 0x40 && _temp[i] < 0x5b

IRs:
REF_98(None) -> _temp[i]
TMP_144(bool) = REF_98 > 64
REF_99(None) -> _temp[i]
TMP_145(bool) = REF_99 < 91
TMP_146(bool) = TMP_144 && TMP_145
CONDITION TMP_146"];
14->15[label="True"];
14->19[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_temp[i] = bytes1(uint256(_temp[i]) + 32)

IRs:
REF_100(bytes1) -> _temp[i]
REF_101(None) -> _temp[i]
TMP_147 = CONVERT REF_101 to uint256
TMP_148(uint256) = TMP_147 + 32
TMP_149 = CONVERT TMP_148 to bytes1
REF_100(bytes1) (->_temp) := TMP_149(bytes1)"];
15->16;
16[label="Node Type: IF 16

EXPRESSION:
_hasNonNumber == false

IRs:
TMP_150(bool) = _hasNonNumber == False
CONDITION TMP_150"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
_hasNonNumber = true

IRs:
_hasNonNumber(bool) := True(bool)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->26;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
require(bool,string)(_temp[i] == 0x20 || (_temp[i] > 0x60 && _temp[i] < 0x7b) || (_temp[i] > 0x2f && _temp[i] < 0x3a),string contains invalid characters)

IRs:
REF_102(None) -> _temp[i]
TMP_151(bool) = REF_102 == 32
REF_103(None) -> _temp[i]
TMP_152(bool) = REF_103 > 96
REF_104(None) -> _temp[i]
TMP_153(bool) = REF_104 < 123
TMP_154(bool) = TMP_152 && TMP_153
TMP_155(bool) = TMP_151 || TMP_154
REF_105(None) -> _temp[i]
TMP_156(bool) = REF_105 > 47
REF_106(None) -> _temp[i]
TMP_157(bool) = REF_106 < 58
TMP_158(bool) = TMP_156 && TMP_157
TMP_159(bool) = TMP_155 || TMP_158
TMP_160(None) = SOLIDITY_CALL require(bool,string)(TMP_159,string contains invalid characters)"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
_temp[i] == 0x20

IRs:
REF_107(None) -> _temp[i]
TMP_161(bool) = REF_107 == 32
CONDITION TMP_161"];
20->21[label="True"];
20->22[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
require(bool,string)(_temp[i + 1] != 0x20,string cannot contain consecutive spaces)

IRs:
TMP_162(uint256) = i + 1
REF_108(None) -> _temp[TMP_162]
TMP_163(bool) = REF_108 != 32
TMP_164(None) = SOLIDITY_CALL require(bool,string)(TMP_163,string cannot contain consecutive spaces)"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)

IRs:
TMP_165(bool) = _hasNonNumber == False
REF_109(None) -> _temp[i]
TMP_166(bool) = REF_109 < 48
REF_110(None) -> _temp[i]
TMP_167(bool) = REF_110 > 57
TMP_168(bool) = TMP_166 || TMP_167
TMP_169(bool) = TMP_165 && TMP_168
CONDITION TMP_169"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
_hasNonNumber = true

IRs:
_hasNonNumber(bool) := True(bool)"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
i ++

IRs:
TMP_170(uint256) := i(uint256)
i(uint256) = i + 1"];
27->13;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
require(bool,string)(_hasNonNumber == true,string cannot be only numbers)

IRs:
TMP_171(bool) = _hasNonNumber == True
TMP_172(None) = SOLIDITY_CALL require(bool,string)(TMP_171,string cannot be only numbers)"];
28->29;
29[label="Node Type: NEW VARIABLE 29
"];
29->30;
30[label="Node Type: INLINE ASM 30
"];
30->31;
31[label="Node Type: END INLINE ASM 31
"];
31->32;
32[label="Node Type: RETURN 32

EXPRESSION:
(_ret)

IRs:
RETURN _ret"];
}
// Function: 1285.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_181(uint256) = a + b
c(uint256) := TMP_181(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(c >= a,SafeMath add failed)

IRs:
TMP_182(bool) = c >= a
TMP_183(None) = SOLIDITY_CALL require(bool,string)(TMP_182,SafeMath add failed)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1285.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_173(bool) = a == 0
CONDITION TMP_173"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_174(uint256) = a * b
c(uint256) := TMP_174(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(c / a == b,SafeMath mul failed)

IRs:
TMP_175(uint256) = c / a
TMP_176(bool) = TMP_175 == b
TMP_177(None) = SOLIDITY_CALL require(bool,string)(TMP_176,SafeMath mul failed)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1285.sol-SafeMath-pwr(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
x == 0

IRs:
TMP_191(bool) = x == 0
CONDITION TMP_191"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
(0)

IRs:
RETURN 0"];
3[label="Node Type: IF 3

EXPRESSION:
y == 0

IRs:
TMP_192(bool) = y == 0
CONDITION TMP_192"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
(1)

IRs:
RETURN 1"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
z = x

IRs:
z(uint256) := x(uint256)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
7->12;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i < y

IRs:
TMP_193(bool) = i < y
CONDITION TMP_193"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
z = mul(z,x)

IRs:
TMP_194(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(z,x)
z(uint256) := TMP_194(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_195(uint256) := i(uint256)
i(uint256) = i + 1"];
11->9;
12[label="Node Type: RETURN 12

EXPRESSION:
(z)

IRs:
RETURN z"];
}
// Function: 1285.sol-SafeMath-sq(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(mul(x,x))

IRs:
TMP_190(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(x,x)
RETURN TMP_190"];
}
// Function: 1285.sol-SafeMath-sqrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = ((add(x,1)) / 2)

IRs:
TMP_184(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(x,1)
TMP_185(uint256) = TMP_184 / 2
z(uint256) := TMP_185(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
y = x

IRs:
y(uint256) := x(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
z < y

IRs:
TMP_186(bool) = z < y
CONDITION TMP_186"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
y = z

IRs:
y(uint256) := z(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
z = ((add((x / z),z)) / 2)

IRs:
TMP_187(uint256) = x / z
TMP_188(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(TMP_187,z)
TMP_189(uint256) = TMP_188 / 2
z(uint256) := TMP_189(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
y

IRs:
RETURN y"];
}
// Function: 1285.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(b <= a,SafeMath sub failed)

IRs:
TMP_178(bool) = b <= a
TMP_179(None) = SOLIDITY_CALL require(bool,string)(TMP_178,SafeMath sub failed)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_180(uint256) = a - b
RETURN TMP_180"];
}
// Function: 1285.sol-Winner-activate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(activated_ == false,contract is activated)

IRs:
TMP_31(bool) = activated_ == False
TMP_32(None) = SOLIDITY_CALL require(bool,string)(TMP_31,contract is activated)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
activated_ = true

IRs:
activated_(bool) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
roundID_ = 1

IRs:
roundID_(uint256) := 1(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
4->1;
}
// Function: 1285.sol-Winner-addPlayerOrder(address,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
pID = address2PID_[addr]

IRs:
REF_56(uint256) -> address2PID_[addr]
pID(uint256) := REF_56(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(pID != 0,cannot find the player)

IRs:
TMP_78(bool) = pID != 0
TMP_79(None) = SOLIDITY_CALL require(bool,string)(TMP_78,cannot find the player)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(roundID == roundID_,not current round)

IRs:
TMP_80(bool) = roundID == roundID_
TMP_81(None) = SOLIDITY_CALL require(bool,string)(TMP_80,not current round)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(keys >= 0,keys invalid)

IRs:
TMP_82(bool) = keys >= 0
TMP_83(None) = SOLIDITY_CALL require(bool,string)(TMP_82,keys invalid)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(eth >= 0,eth invalid)

IRs:
TMP_84(bool) = eth >= 0
TMP_85(None) = SOLIDITY_CALL require(bool,string)(TMP_84,eth invalid)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool,string)(otype >= 0,type invalid)

IRs:
TMP_86(bool) = otype >= 0
TMP_87(None) = SOLIDITY_CALL require(bool,string)(TMP_86,type invalid)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(keysAvailable >= 0,keysAvailable invalid)

IRs:
TMP_88(bool) = keysAvailable >= 0
TMP_89(None) = SOLIDITY_CALL require(bool,string)(TMP_88,keysAvailable invalid)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
pID2Round_[pID][roundID_].eth = keysEth

IRs:
REF_57(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_58(WinnerDatasets.PlayerRound) -> REF_57[roundID_]
REF_59(uint256) -> REF_58.eth
REF_59(uint256) (->pID2Round_) := keysEth(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
pID2Round_[pID][roundID_].keys = keysAvailable

IRs:
REF_60(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_61(WinnerDatasets.PlayerRound) -> REF_60[roundID_]
REF_62(uint256) -> REF_61.keys
REF_62(uint256) (->pID2Round_) := keysAvailable(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
playerOrder = WinnerDatasets.PlayerOrder(keys,eth,otype)

IRs:
TMP_90(WinnerDatasets.PlayerOrder) = new PlayerOrder(keys,eth,otype)
playerOrder(WinnerDatasets.PlayerOrder) := TMP_90(WinnerDatasets.PlayerOrder)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
pID2Order_[pID][roundID_].push(playerOrder)

IRs:
REF_64(mapping(uint256 => WinnerDatasets.PlayerOrder[])) -> pID2Order_[pID]
REF_65(WinnerDatasets.PlayerOrder[]) -> REF_64[roundID_]
REF_67 -> LENGTH REF_65
TMP_92(uint256) := REF_67(uint256)
TMP_93(uint256) = TMP_92 + 1
REF_67(uint256) (->pID2Order_) := TMP_93(uint256)
REF_68(WinnerDatasets.PlayerOrder) -> REF_65[TMP_92]
REF_68(WinnerDatasets.PlayerOrder) (->pID2Order_) := playerOrder(WinnerDatasets.PlayerOrder)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
WinnerEvents.onAddPlayerOrder(addr,keys,eth,otype)

IRs:
Emit onAddPlayerOrder(addr,keys,eth,otype)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
14->1;
}
// Function: 1285.sol-Winner-buyCore(address,uint256,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
pID = address2PID_[addr]

IRs:
REF_15(uint256) -> address2PID_[addr]
pID(uint256) := REF_15(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
pID == 0

IRs:
TMP_26(bool) = pID == 0
CONDITION TMP_26"];
2->3[label="True"];
2->10[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
pIDCount_ ++

IRs:
TMP_27(uint256) := pIDCount_(uint256)
pIDCount_(uint256) = pIDCount_ + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
pID = pIDCount_

IRs:
pID(uint256) := pIDCount_(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
player = WinnerDatasets.Player(pID,addr,0,0,0,0,0)

IRs:
TMP_28(WinnerDatasets.Player) = new Player(pID,addr,0,0,0,0,0)
player(WinnerDatasets.Player) := TMP_28(WinnerDatasets.Player)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
playerRound = WinnerDatasets.PlayerRound(0,0,0,0,0)

IRs:
TMP_29(WinnerDatasets.PlayerRound) = new PlayerRound(0,0,0,0,0)
playerRound(WinnerDatasets.PlayerRound) := TMP_29(WinnerDatasets.PlayerRound)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
pID2Player_[pID] = player

IRs:
REF_18(WinnerDatasets.Player) -> pID2Player_[pID]
REF_18(WinnerDatasets.Player) (->pID2Player_) := player(WinnerDatasets.Player)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
pID2Round_[pID][roundID_] = playerRound

IRs:
REF_19(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_20(WinnerDatasets.PlayerRound) -> REF_19[roundID_]
REF_20(WinnerDatasets.PlayerRound) (->pID2Round_) := playerRound(WinnerDatasets.PlayerRound)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
address2PID_[addr] = pID

IRs:
REF_21(uint256) -> address2PID_[addr]
REF_21(uint256) (->address2PID_) := pID(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
WinnerEvents.onBuy(addr,eth,reff,now)

IRs:
Emit onBuy(addr,eth,reff,now)"];
}
// Function: 1285.sol-Winner-buyKey()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyCore(msg.sender,msg.value,)

IRs:
INTERNAL_CALL, Winner.buyCore(address,uint256,string)(msg.sender,msg.value,)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, Winner.isHuman()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isWithinLimits(msg.value)

IRs:
MODIFIER_CALL, Winner.isWithinLimits(uint256)(msg.value)"];
4->1;
}
// Function: 1285.sol-Winner-buyKeyUseBalance(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
pID = address2PID_[msg.sender]

IRs:
REF_0(uint256) -> address2PID_[msg.sender]
pID(uint256) := REF_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(pID > 0,cannot find player)

IRs:
TMP_12(bool) = pID > 0
TMP_13(None) = SOLIDITY_CALL require(bool,string)(TMP_12,cannot find player)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
WinnerEvents.onBuyUseBalance(msg.sender,keys,now)

IRs:
Emit onBuyUseBalance(msg.sender,keys,now)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, Winner.isHuman()()"];
5->1;
}
// Function: 1285.sol-Winner-buyKeyWithReff(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyCore(msg.sender,msg.value,reff)

IRs:
INTERNAL_CALL, Winner.buyCore(address,uint256,string)(msg.sender,msg.value,reff)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, Winner.isHuman()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isWithinLimits(msg.value)

IRs:
MODIFIER_CALL, Winner.isWithinLimits(uint256)(msg.value)"];
4->1;
}
// Function: 1285.sol-Winner-buyName(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
pID = address2PID_[msg.sender]

IRs:
REF_2(uint256) -> address2PID_[msg.sender]
pID(uint256) := REF_2(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
pID == 0

IRs:
TMP_17(bool) = pID == 0
CONDITION TMP_17"];
2->3[label="True"];
2->10[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
pIDCount_ ++

IRs:
TMP_18(uint256) := pIDCount_(uint256)
pIDCount_(uint256) = pIDCount_ + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
pID = pIDCount_

IRs:
pID(uint256) := pIDCount_(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
player = WinnerDatasets.Player(pID,msg.sender,0,0,0,0,0)

IRs:
TMP_19(WinnerDatasets.Player) = new Player(pID,msg.sender,0,0,0,0,0)
player(WinnerDatasets.Player) := TMP_19(WinnerDatasets.Player)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
playerRound = WinnerDatasets.PlayerRound(0,0,0,0,0)

IRs:
TMP_20(WinnerDatasets.PlayerRound) = new PlayerRound(0,0,0,0,0)
playerRound(WinnerDatasets.PlayerRound) := TMP_20(WinnerDatasets.PlayerRound)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
pID2Player_[pID] = player

IRs:
REF_5(WinnerDatasets.Player) -> pID2Player_[pID]
REF_5(WinnerDatasets.Player) (->pID2Player_) := player(WinnerDatasets.Player)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
pID2Round_[pID][roundID_] = playerRound

IRs:
REF_6(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_7(WinnerDatasets.PlayerRound) -> REF_6[roundID_]
REF_7(WinnerDatasets.PlayerRound) (->pID2Round_) := playerRound(WinnerDatasets.PlayerRound)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
address2PID_[msg.sender] = pID

IRs:
REF_8(uint256) -> address2PID_[msg.sender]
REF_8(uint256) (->address2PID_) := pID(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
pID2Player_[pID].pname = pname.nameFilter()

IRs:
REF_9(WinnerDatasets.Player) -> pID2Player_[pID]
REF_10(bytes32) -> REF_9.pname
TMP_21(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['pname'] 
REF_10(bytes32) (->pID2Player_) := TMP_21(bytes32)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
WinnerEvents.onBuyName(msg.sender,pID2Player_[pID].pname,msg.value,now)

IRs:
REF_13(WinnerDatasets.Player) -> pID2Player_[pID]
REF_14(bytes32) -> REF_13.pname
Emit onBuyName(msg.sender,REF_14,msg.value,now)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, Winner.isHuman()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
isWithinLimits(msg.value)

IRs:
MODIFIER_CALL, Winner.isWithinLimits(uint256)(msg.value)"];
15->1;
}
// Function: 1285.sol-Winner-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pIDCount_ = 0

IRs:
pIDCount_(uint256) := 0(uint256)"];
}
// Function: 1285.sol-Winner-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyCore(msg.sender,msg.value,)

IRs:
INTERNAL_CALL, Winner.buyCore(address,uint256,string)(msg.sender,msg.value,)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, Winner.isHuman()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isWithinLimits(msg.value)

IRs:
MODIFIER_CALL, Winner.isWithinLimits(uint256)(msg.value)"];
4->1;
}
// Function: 1285.sol-Winner-inactivate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
activated_ = false

IRs:
activated_(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
3->1;
}
// Function: 1285.sol-Winner-isActivated()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(activated_ == true,the contract is not ready yet)

IRs:
TMP_118(bool) = activated_ == True
TMP_119(None) = SOLIDITY_CALL require(bool,string)(TMP_118,the contract is not ready yet)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1285.sol-Winner-isAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.sender == 0x74B25afBbd16Ef94d6a32c311d5c184a736850D3,sorry admins only)

IRs:
TMP_122(bool) = msg.sender == 666220387828854972330317819882575665264599781587
TMP_123(None) = SOLIDITY_CALL require(bool,string)(TMP_122,sorry admins only)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1285.sol-Winner-isHuman()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_addr = msg.sender

IRs:
_addr(address) := msg.sender(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: INLINE ASM 3
"];
3->4;
4[label="Node Type: END INLINE ASM 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(_codeLength == 0,sorry humans only)

IRs:
TMP_120(bool) = _codeLength == 0
TMP_121(None) = SOLIDITY_CALL require(bool,string)(TMP_120,sorry humans only)"];
5->6;
6[label="Node Type: _ 6
"];
}
// Function: 1285.sol-Winner-isWithinLimits(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_eth >= 10000000000,eth too small)

IRs:
TMP_124(bool) = _eth >= 10000000000
TMP_125(None) = SOLIDITY_CALL require(bool,string)(TMP_124,eth too small)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_eth <= 100000000000000000000000,eth too huge)

IRs:
TMP_126(bool) = _eth <= 100000000000000000000000
TMP_127(None) = SOLIDITY_CALL require(bool,string)(TMP_126,eth too huge)"];
2->3;
3[label="Node Type: _ 3
"];
}
// Function: 1285.sol-Winner-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Im Winner Game

IRs:
name(string) := Im Winner Game(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = IMW

IRs:
symbol(string) := IMW(string)"];
}
// Function: 1285.sol-Winner-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
activated_ = false

IRs:
activated_(bool) := False(bool)"];
}
// Function: 1285.sol-Winner-upPlayer(address,bytes32,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
pID = address2PID_[addr]

IRs:
REF_27(uint256) -> address2PID_[addr]
pID(uint256) := REF_27(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(pID != 0,cannot find the player)

IRs:
TMP_48(bool) = pID != 0
TMP_49(None) = SOLIDITY_CALL require(bool,string)(TMP_48,cannot find the player)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(balance >= 0,balance invalid)

IRs:
TMP_50(bool) = balance >= 0
TMP_51(None) = SOLIDITY_CALL require(bool,string)(TMP_50,balance invalid)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(interest >= 0,interest invalid)

IRs:
TMP_52(bool) = interest >= 0
TMP_53(None) = SOLIDITY_CALL require(bool,string)(TMP_52,interest invalid)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(win >= 0,win invalid)

IRs:
TMP_54(bool) = win >= 0
TMP_55(None) = SOLIDITY_CALL require(bool,string)(TMP_54,win invalid)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool,string)(reff >= 0,reff invalid)

IRs:
TMP_56(bool) = reff >= 0
TMP_57(None) = SOLIDITY_CALL require(bool,string)(TMP_56,reff invalid)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
pID2Player_[pID].pname = pname

IRs:
REF_28(WinnerDatasets.Player) -> pID2Player_[pID]
REF_29(bytes32) -> REF_28.pname
REF_29(bytes32) (->pID2Player_) := pname(bytes32)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
pID2Player_[pID].balance = balance

IRs:
REF_30(WinnerDatasets.Player) -> pID2Player_[pID]
REF_31(uint256) -> REF_30.balance
REF_31(uint256) (->pID2Player_) := balance(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
pID2Player_[pID].interest = interest

IRs:
REF_32(WinnerDatasets.Player) -> pID2Player_[pID]
REF_33(uint256) -> REF_32.interest
REF_33(uint256) (->pID2Player_) := interest(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
pID2Player_[pID].win = win

IRs:
REF_34(WinnerDatasets.Player) -> pID2Player_[pID]
REF_35(uint256) -> REF_34.win
REF_35(uint256) (->pID2Player_) := win(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
pID2Player_[pID].reff = reff

IRs:
REF_36(WinnerDatasets.Player) -> pID2Player_[pID]
REF_37(uint256) -> REF_36.reff
REF_37(uint256) (->pID2Player_) := reff(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
WinnerEvents.onUpPlayer(addr,pname,balance,interest,win,reff)

IRs:
Emit onUpPlayer(addr,pname,balance,interest,win,reff)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
14->1;
}
// Function: 1285.sol-Winner-upPlayerRound(address,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->15;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
pID = address2PID_[addr]

IRs:
REF_39(uint256) -> address2PID_[addr]
pID(uint256) := REF_39(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(pID != 0,cannot find the player)

IRs:
TMP_61(bool) = pID != 0
TMP_62(None) = SOLIDITY_CALL require(bool,string)(TMP_61,cannot find the player)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(roundID == roundID_,not current round)

IRs:
TMP_63(bool) = roundID == roundID_
TMP_64(None) = SOLIDITY_CALL require(bool,string)(TMP_63,not current round)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(eth >= 0,eth invalid)

IRs:
TMP_65(bool) = eth >= 0
TMP_66(None) = SOLIDITY_CALL require(bool,string)(TMP_65,eth invalid)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(keys >= 0,keys invalid)

IRs:
TMP_67(bool) = keys >= 0
TMP_68(None) = SOLIDITY_CALL require(bool,string)(TMP_67,keys invalid)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool,string)(interest >= 0,interest invalid)

IRs:
TMP_69(bool) = interest >= 0
TMP_70(None) = SOLIDITY_CALL require(bool,string)(TMP_69,interest invalid)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(win >= 0,win invalid)

IRs:
TMP_71(bool) = win >= 0
TMP_72(None) = SOLIDITY_CALL require(bool,string)(TMP_71,win invalid)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool,string)(reff >= 0,reff invalid)

IRs:
TMP_73(bool) = reff >= 0
TMP_74(None) = SOLIDITY_CALL require(bool,string)(TMP_73,reff invalid)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
pID2Round_[pID][roundID_].eth = eth

IRs:
REF_40(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_41(WinnerDatasets.PlayerRound) -> REF_40[roundID_]
REF_42(uint256) -> REF_41.eth
REF_42(uint256) (->pID2Round_) := eth(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
pID2Round_[pID][roundID_].keys = keys

IRs:
REF_43(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_44(WinnerDatasets.PlayerRound) -> REF_43[roundID_]
REF_45(uint256) -> REF_44.keys
REF_45(uint256) (->pID2Round_) := keys(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
pID2Round_[pID][roundID_].interest = interest

IRs:
REF_46(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_47(WinnerDatasets.PlayerRound) -> REF_46[roundID_]
REF_48(uint256) -> REF_47.interest
REF_48(uint256) (->pID2Round_) := interest(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
pID2Round_[pID][roundID_].win = win

IRs:
REF_49(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_50(WinnerDatasets.PlayerRound) -> REF_49[roundID_]
REF_51(uint256) -> REF_50.win
REF_51(uint256) (->pID2Round_) := win(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
pID2Round_[pID][roundID_].reff = reff

IRs:
REF_52(mapping(uint256 => WinnerDatasets.PlayerRound)) -> pID2Round_[pID]
REF_53(WinnerDatasets.PlayerRound) -> REF_52[roundID_]
REF_54(uint256) -> REF_53.reff
REF_54(uint256) (->pID2Round_) := reff(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
WinnerEvents.onUpPlayerRound(addr,roundID,eth,keys,interest,win,reff)

IRs:
Emit onUpPlayerRound(addr,roundID,eth,keys,interest,win,reff)"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
16->1;
}
// Function: 1285.sol-Winner-upRound(uint256,address,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->22;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(roundID == roundID_,not current round)

IRs:
TMP_97(bool) = roundID == roundID_
TMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,not current round)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
pID = address2PID_[leader]

IRs:
REF_70(uint256) -> address2PID_[leader]
pID(uint256) := REF_70(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(pID != 0,cannot find the leader)

IRs:
TMP_99(bool) = pID != 0
TMP_100(None) = SOLIDITY_CALL require(bool,string)(TMP_99,cannot find the leader)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(end >= start,start end invalid)

IRs:
TMP_101(bool) = end >= start
TMP_102(None) = SOLIDITY_CALL require(bool,string)(TMP_101,start end invalid)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(keys >= 0,keys invalid)

IRs:
TMP_103(bool) = keys >= 0
TMP_104(None) = SOLIDITY_CALL require(bool,string)(TMP_103,keys invalid)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool,string)(eth >= 0,eth invalid)

IRs:
TMP_105(bool) = eth >= 0
TMP_106(None) = SOLIDITY_CALL require(bool,string)(TMP_105,eth invalid)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(pool >= 0,pool invalid)

IRs:
TMP_107(bool) = pool >= 0
TMP_108(None) = SOLIDITY_CALL require(bool,string)(TMP_107,pool invalid)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool,string)(interest >= 0,interest invalid)

IRs:
TMP_109(bool) = interest >= 0
TMP_110(None) = SOLIDITY_CALL require(bool,string)(TMP_109,interest invalid)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool,string)(win >= 0,win invalid)

IRs:
TMP_111(bool) = win >= 0
TMP_112(None) = SOLIDITY_CALL require(bool,string)(TMP_111,win invalid)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool,string)(reff >= 0,reff invalid)

IRs:
TMP_113(bool) = reff >= 0
TMP_114(None) = SOLIDITY_CALL require(bool,string)(TMP_113,reff invalid)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
rID2Round_[roundID_].leader = leader

IRs:
REF_71(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_72(address) -> REF_71.leader
REF_72(address) (->rID2Round_) := leader(address)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
rID2Round_[roundID_].start = start

IRs:
REF_73(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_74(uint256) -> REF_73.start
REF_74(uint256) (->rID2Round_) := start(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
rID2Round_[roundID_].end = end

IRs:
REF_75(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_76(uint256) -> REF_75.end
REF_76(uint256) (->rID2Round_) := end(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
rID2Round_[roundID_].ended = ended

IRs:
REF_77(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_78(bool) -> REF_77.ended
REF_78(bool) (->rID2Round_) := ended(bool)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
rID2Round_[roundID_].keys = keys

IRs:
REF_79(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_80(uint256) -> REF_79.keys
REF_80(uint256) (->rID2Round_) := keys(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
rID2Round_[roundID_].eth = eth

IRs:
REF_81(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_82(uint256) -> REF_81.eth
REF_82(uint256) (->rID2Round_) := eth(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
rID2Round_[roundID_].pool = pool

IRs:
REF_83(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_84(uint256) -> REF_83.pool
REF_84(uint256) (->rID2Round_) := pool(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
rID2Round_[roundID_].interest = interest

IRs:
REF_85(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_86(uint256) -> REF_85.interest
REF_86(uint256) (->rID2Round_) := interest(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
rID2Round_[roundID_].win = win

IRs:
REF_87(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_88(uint256) -> REF_87.win
REF_88(uint256) (->rID2Round_) := win(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
rID2Round_[roundID_].reff = reff

IRs:
REF_89(WinnerDatasets.Round) -> rID2Round_[roundID_]
REF_90(uint256) -> REF_89.reff
REF_90(uint256) (->rID2Round_) := reff(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
WinnerEvents.onUpRound(roundID,leader,start,end,ended,keys,eth,pool,interest,win,reff)

IRs:
Emit onUpRound(roundID,leader,start,end,ended,keys,eth,pool,interest,win,reff)"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
23->1;
}
// Function: 1285.sol-Winner-upRoundID(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(roundID_ != roundID,same to the current roundID)

IRs:
TMP_43(bool) = roundID_ != roundID
TMP_44(None) = SOLIDITY_CALL require(bool,string)(TMP_43,same to the current roundID)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
roundID_ = roundID

IRs:
roundID_(uint256) := roundID(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
WinnerEvents.onUpRoundID(roundID)

IRs:
Emit onUpRoundID(roundID)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
5->1;
}
// Function: 1285.sol-Winner-withdraw(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
pID = address2PID_[addr]

IRs:
REF_23(uint256) -> address2PID_[addr]
pID(uint256) := REF_23(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(pID > 0,user not exist)

IRs:
TMP_36(bool) = pID > 0
TMP_37(None) = SOLIDITY_CALL require(bool,string)(TMP_36,user not exist)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
addr.transfer(eth)

IRs:
Transfer dest:addr value:eth"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
WinnerEvents.onWithdraw(msg.sender,eth,now)

IRs:
Emit onWithdraw(msg.sender,eth,now)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Winner.isActivated()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Winner.isAdmin()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isWithinLimits(eth)

IRs:
MODIFIER_CALL, Winner.isWithinLimits(uint256)(eth)"];
7->1;
}
}
