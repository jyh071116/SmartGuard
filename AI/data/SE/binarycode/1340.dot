digraph G {
// Function: 1340.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 1340.sol-BasicToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.data.length == numwords * 32 + 4)

IRs:
REF_8 -> LENGTH msg.data
TMP_27(uint256) = numwords * 32
TMP_28(uint256) = TMP_27 + 4
TMP_29(bool) = REF_8 == TMP_28
TMP_30(None) = SOLIDITY_CALL assert(bool)(TMP_29)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1340.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_17 = CONVERT 0 to address
TMP_18(bool) = _to != TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_20(bool) = _value <= REF_0
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_22(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_23(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_24(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyPayloadSize(2)

IRs:
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(2)"];
8->1;
}
// Function: 1340.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 1340.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 1340.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 1340.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 1340.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 1340.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 1340.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 1340.sol-KYROInv-KYROInv()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = INITIAL_SUPPLY

IRs:
totalSupply(uint256) := INITIAL_SUPPLY(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] = INITIAL_SUPPLY

IRs:
REF_94(uint256) -> balances[owner]
REF_94(uint256) (->balances) := INITIAL_SUPPLY(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokenAllocated = 0

IRs:
tokenAllocated(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transfersEnabled = true

IRs:
transfersEnabled(bool) := True(bool)"];
}
// Function: 1340.sol-KYROInv-allowance(address,address)
digraph{
}
// Function: 1340.sol-KYROInv-approve(address,uint256)
digraph{
}
// Function: 1340.sol-KYROInv-balanceOf(address)
digraph{
}
// Function: 1340.sol-KYROInv-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_investor != address(0))

IRs:
TMP_96 = CONVERT 0 to address
TMP_97(bool) = _investor != TMP_96
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(saleToken == true)

IRs:
TMP_99(bool) = saleToken == True
TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
wallet = owner

IRs:
wallet(address) := owner(address)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
tokens = validPurchaseTokens(weiAmount)

IRs:
TMP_101(uint256) = INTERNAL_CALL, KYROInv.validPurchaseTokens(uint256)(weiAmount)
tokens(uint256) := TMP_101(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
tokens == 0

IRs:
TMP_102(bool) = tokens == 0
CONDITION TMP_102"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
revert()()

IRs:
TMP_103(None) = SOLIDITY_CALL revert()()"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_104(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
tokenAllocated = tokenAllocated.add(tokens)

IRs:
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenAllocated', 'tokens'] 
tokenAllocated(uint256) := TMP_105(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
mint(_investor,tokens,owner)

IRs:
TMP_106(bool) = INTERNAL_CALL, KYROInv.mint(address,uint256,address)(_investor,tokens,owner)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
TokenPurchase(_investor,weiAmount,tokens)

IRs:
Emit TokenPurchase(_investor,weiAmount,tokens)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
wallet.transfer(weiAmount)

IRs:
Transfer dest:wallet value:weiAmount"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
tokens

IRs:
RETURN tokens"];
}
// Function: 1340.sol-KYROInv-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_282 = CONVERT 0 to address
TMP_283(bool) = _newOwner != TMP_282
TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnerChanged(owner,_newOwner)

IRs:
Emit OwnerChanged(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KYROInv.onlyOwner()()"];
5->1;
}
// Function: 1340.sol-KYROInv-claimTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_107(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_107"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
balance = balanceOf(this)

IRs:
TMP_291(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(this)
balance(uint256) := TMP_291(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transfer(owner,balance)

IRs:
TMP_292(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(owner,balance)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,owner,balance)

IRs:
Emit Transfer(this,owner,balance)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KYROInv.onlyOwner()()"];
5->1;
}
// Function: 1340.sol-KYROInv-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
oldValue(uint256) := REF_78(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_82(bool) = _subtractedValue > oldValue
CONDITION TMP_82"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
REF_80(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_81(mapping(address => uint256)) -> allowed[msg.sender]
REF_82(uint256) -> REF_81[_spender]
TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_82(uint256) (->allowed) := TMP_83(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_84(mapping(address => uint256)) -> allowed[msg.sender]
REF_85(uint256) -> REF_84[_spender]
Emit Approval(msg.sender,_spender,REF_85)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1340.sol-KYROInv-enableTransfers(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transfersEnabled = _transfersEnabled

IRs:
transfersEnabled(bool) := _transfersEnabled(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KYROInv.onlyOwner()()"];
2->1;
}
// Function: 1340.sol-KYROInv-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
TMP_95(uint256) = INTERNAL_CALL, KYROInv.buyTokens(address)(msg.sender)"];
}
// Function: 1340.sol-KYROInv-getTotalAmountOfTokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amountOfTokens = 0

IRs:
amountOfTokens(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_weiAmount == 0

IRs:
TMP_112(bool) = _weiAmount == 0
CONDITION TMP_112"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
amountOfTokens = 250 * (10 ** uint256(decimals))

IRs:
TMP_113 = CONVERT decimals to uint256
TMP_114(uint256) = 10 ** TMP_113
TMP_115(uint256) = 250 * TMP_114
amountOfTokens(uint256) := TMP_115(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
_weiAmount == 1000000000000000

IRs:
TMP_116(bool) = _weiAmount == 1000000000000000
CONDITION TMP_116"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
amountOfTokens = 3 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_117(uint256) = 10 ** 3
TMP_118(uint256) = 3 * TMP_117
TMP_119 = CONVERT decimals to uint256
TMP_120(uint256) = 10 ** TMP_119
TMP_121(uint256) = TMP_118 * TMP_120
amountOfTokens(uint256) := TMP_121(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
_weiAmount == 2000000000000000

IRs:
TMP_122(bool) = _weiAmount == 2000000000000000
CONDITION TMP_122"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
amountOfTokens = 6 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_123(uint256) = 10 ** 3
TMP_124(uint256) = 6 * TMP_123
TMP_125 = CONVERT decimals to uint256
TMP_126(uint256) = 10 ** TMP_125
TMP_127(uint256) = TMP_124 * TMP_126
amountOfTokens(uint256) := TMP_127(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
_weiAmount == 3000000000000000

IRs:
TMP_128(bool) = _weiAmount == 3000000000000000
CONDITION TMP_128"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
amountOfTokens = 9 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_129(uint256) = 10 ** 3
TMP_130(uint256) = 9 * TMP_129
TMP_131 = CONVERT decimals to uint256
TMP_132(uint256) = 10 ** TMP_131
TMP_133(uint256) = TMP_130 * TMP_132
amountOfTokens(uint256) := TMP_133(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
_weiAmount == 4000000000000000

IRs:
TMP_134(bool) = _weiAmount == 4000000000000000
CONDITION TMP_134"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
amountOfTokens = 12 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_135(uint256) = 10 ** 3
TMP_136(uint256) = 12 * TMP_135
TMP_137 = CONVERT decimals to uint256
TMP_138(uint256) = 10 ** TMP_137
TMP_139(uint256) = TMP_136 * TMP_138
amountOfTokens(uint256) := TMP_139(uint256)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
_weiAmount == 5000000000000000

IRs:
TMP_140(bool) = _weiAmount == 5000000000000000
CONDITION TMP_140"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
amountOfTokens = 15750 * (10 ** uint256(decimals))

IRs:
TMP_141 = CONVERT decimals to uint256
TMP_142(uint256) = 10 ** TMP_141
TMP_143(uint256) = 15750 * TMP_142
amountOfTokens(uint256) := TMP_143(uint256)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
_weiAmount == 6000000000000000

IRs:
TMP_144(bool) = _weiAmount == 6000000000000000
CONDITION TMP_144"];
20->21[label="True"];
20->22[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
amountOfTokens = 18900 * (10 ** uint256(decimals))

IRs:
TMP_145 = CONVERT decimals to uint256
TMP_146(uint256) = 10 ** TMP_145
TMP_147(uint256) = 18900 * TMP_146
amountOfTokens(uint256) := TMP_147(uint256)"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
_weiAmount == 7000000000000000

IRs:
TMP_148(bool) = _weiAmount == 7000000000000000
CONDITION TMP_148"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
amountOfTokens = 22050 * (10 ** uint256(decimals))

IRs:
TMP_149 = CONVERT decimals to uint256
TMP_150(uint256) = 10 ** TMP_149
TMP_151(uint256) = 22050 * TMP_150
amountOfTokens(uint256) := TMP_151(uint256)"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: IF 26

EXPRESSION:
_weiAmount == 8000000000000000

IRs:
TMP_152(bool) = _weiAmount == 8000000000000000
CONDITION TMP_152"];
26->27[label="True"];
26->28[label="False"];
27[label="Node Type: EXPRESSION 27

EXPRESSION:
amountOfTokens = 25200 * (10 ** uint256(decimals))

IRs:
TMP_153 = CONVERT decimals to uint256
TMP_154(uint256) = 10 ** TMP_153
TMP_155(uint256) = 25200 * TMP_154
amountOfTokens(uint256) := TMP_155(uint256)"];
27->28;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: IF 29

EXPRESSION:
_weiAmount == 9000000000000000

IRs:
TMP_156(bool) = _weiAmount == 9000000000000000
CONDITION TMP_156"];
29->30[label="True"];
29->31[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
amountOfTokens = 28350 * (10 ** uint256(decimals))

IRs:
TMP_157 = CONVERT decimals to uint256
TMP_158(uint256) = 10 ** TMP_157
TMP_159(uint256) = 28350 * TMP_158
amountOfTokens(uint256) := TMP_159(uint256)"];
30->31;
31[label="Node Type: END_IF 31
"];
31->32;
32[label="Node Type: IF 32

EXPRESSION:
_weiAmount == 10000000000000000

IRs:
TMP_160(bool) = _weiAmount == 10000000000000000
CONDITION TMP_160"];
32->33[label="True"];
32->34[label="False"];
33[label="Node Type: EXPRESSION 33

EXPRESSION:
amountOfTokens = 33 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_161(uint256) = 10 ** 3
TMP_162(uint256) = 33 * TMP_161
TMP_163 = CONVERT decimals to uint256
TMP_164(uint256) = 10 ** TMP_163
TMP_165(uint256) = TMP_162 * TMP_164
amountOfTokens(uint256) := TMP_165(uint256)"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: IF 35

EXPRESSION:
_weiAmount == 20000000000000000

IRs:
TMP_166(bool) = _weiAmount == 20000000000000000
CONDITION TMP_166"];
35->36[label="True"];
35->37[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
amountOfTokens = 66 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_167(uint256) = 10 ** 3
TMP_168(uint256) = 66 * TMP_167
TMP_169 = CONVERT decimals to uint256
TMP_170(uint256) = 10 ** TMP_169
TMP_171(uint256) = TMP_168 * TMP_170
amountOfTokens(uint256) := TMP_171(uint256)"];
36->37;
37[label="Node Type: END_IF 37
"];
37->38;
38[label="Node Type: IF 38

EXPRESSION:
_weiAmount == 30000000000000000

IRs:
TMP_172(bool) = _weiAmount == 30000000000000000
CONDITION TMP_172"];
38->39[label="True"];
38->40[label="False"];
39[label="Node Type: EXPRESSION 39

EXPRESSION:
amountOfTokens = 99 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_173(uint256) = 10 ** 3
TMP_174(uint256) = 99 * TMP_173
TMP_175 = CONVERT decimals to uint256
TMP_176(uint256) = 10 ** TMP_175
TMP_177(uint256) = TMP_174 * TMP_176
amountOfTokens(uint256) := TMP_177(uint256)"];
39->40;
40[label="Node Type: END_IF 40
"];
40->41;
41[label="Node Type: IF 41

EXPRESSION:
_weiAmount == 40000000000000000

IRs:
TMP_178(bool) = _weiAmount == 40000000000000000
CONDITION TMP_178"];
41->42[label="True"];
41->43[label="False"];
42[label="Node Type: EXPRESSION 42

EXPRESSION:
amountOfTokens = 132 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_179(uint256) = 10 ** 3
TMP_180(uint256) = 132 * TMP_179
TMP_181 = CONVERT decimals to uint256
TMP_182(uint256) = 10 ** TMP_181
TMP_183(uint256) = TMP_180 * TMP_182
amountOfTokens(uint256) := TMP_183(uint256)"];
42->43;
43[label="Node Type: END_IF 43
"];
43->44;
44[label="Node Type: IF 44

EXPRESSION:
_weiAmount == 50000000000000000

IRs:
TMP_184(bool) = _weiAmount == 50000000000000000
CONDITION TMP_184"];
44->45[label="True"];
44->46[label="False"];
45[label="Node Type: EXPRESSION 45

EXPRESSION:
amountOfTokens = 165 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_185(uint256) = 10 ** 3
TMP_186(uint256) = 165 * TMP_185
TMP_187 = CONVERT decimals to uint256
TMP_188(uint256) = 10 ** TMP_187
TMP_189(uint256) = TMP_186 * TMP_188
amountOfTokens(uint256) := TMP_189(uint256)"];
45->46;
46[label="Node Type: END_IF 46
"];
46->47;
47[label="Node Type: IF 47

EXPRESSION:
_weiAmount == 60000000000000000

IRs:
TMP_190(bool) = _weiAmount == 60000000000000000
CONDITION TMP_190"];
47->48[label="True"];
47->49[label="False"];
48[label="Node Type: EXPRESSION 48

EXPRESSION:
amountOfTokens = 198 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_191(uint256) = 10 ** 3
TMP_192(uint256) = 198 * TMP_191
TMP_193 = CONVERT decimals to uint256
TMP_194(uint256) = 10 ** TMP_193
TMP_195(uint256) = TMP_192 * TMP_194
amountOfTokens(uint256) := TMP_195(uint256)"];
48->49;
49[label="Node Type: END_IF 49
"];
49->50;
50[label="Node Type: IF 50

EXPRESSION:
_weiAmount == 70000000000000000

IRs:
TMP_196(bool) = _weiAmount == 70000000000000000
CONDITION TMP_196"];
50->51[label="True"];
50->52[label="False"];
51[label="Node Type: EXPRESSION 51

EXPRESSION:
amountOfTokens = 231 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_197(uint256) = 10 ** 3
TMP_198(uint256) = 231 * TMP_197
TMP_199 = CONVERT decimals to uint256
TMP_200(uint256) = 10 ** TMP_199
TMP_201(uint256) = TMP_198 * TMP_200
amountOfTokens(uint256) := TMP_201(uint256)"];
51->52;
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: IF 53

EXPRESSION:
_weiAmount == 80000000000000000

IRs:
TMP_202(bool) = _weiAmount == 80000000000000000
CONDITION TMP_202"];
53->54[label="True"];
53->55[label="False"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
amountOfTokens = 264 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_203(uint256) = 10 ** 3
TMP_204(uint256) = 264 * TMP_203
TMP_205 = CONVERT decimals to uint256
TMP_206(uint256) = 10 ** TMP_205
TMP_207(uint256) = TMP_204 * TMP_206
amountOfTokens(uint256) := TMP_207(uint256)"];
54->55;
55[label="Node Type: END_IF 55
"];
55->56;
56[label="Node Type: IF 56

EXPRESSION:
_weiAmount == 90000000000000000

IRs:
TMP_208(bool) = _weiAmount == 90000000000000000
CONDITION TMP_208"];
56->57[label="True"];
56->58[label="False"];
57[label="Node Type: EXPRESSION 57

EXPRESSION:
amountOfTokens = 295 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_209(uint256) = 10 ** 3
TMP_210(uint256) = 295 * TMP_209
TMP_211 = CONVERT decimals to uint256
TMP_212(uint256) = 10 ** TMP_211
TMP_213(uint256) = TMP_210 * TMP_212
amountOfTokens(uint256) := TMP_213(uint256)"];
57->58;
58[label="Node Type: END_IF 58
"];
58->59;
59[label="Node Type: IF 59

EXPRESSION:
_weiAmount == 100000000000000000

IRs:
TMP_214(bool) = _weiAmount == 100000000000000000
CONDITION TMP_214"];
59->60[label="True"];
59->61[label="False"];
60[label="Node Type: EXPRESSION 60

EXPRESSION:
amountOfTokens = 345 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_215(uint256) = 10 ** 3
TMP_216(uint256) = 345 * TMP_215
TMP_217 = CONVERT decimals to uint256
TMP_218(uint256) = 10 ** TMP_217
TMP_219(uint256) = TMP_216 * TMP_218
amountOfTokens(uint256) := TMP_219(uint256)"];
60->61;
61[label="Node Type: END_IF 61
"];
61->62;
62[label="Node Type: IF 62

EXPRESSION:
_weiAmount == 200000000000000000

IRs:
TMP_220(bool) = _weiAmount == 200000000000000000
CONDITION TMP_220"];
62->63[label="True"];
62->64[label="False"];
63[label="Node Type: EXPRESSION 63

EXPRESSION:
amountOfTokens = 690 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_221(uint256) = 10 ** 3
TMP_222(uint256) = 690 * TMP_221
TMP_223 = CONVERT decimals to uint256
TMP_224(uint256) = 10 ** TMP_223
TMP_225(uint256) = TMP_222 * TMP_224
amountOfTokens(uint256) := TMP_225(uint256)"];
63->64;
64[label="Node Type: END_IF 64
"];
64->65;
65[label="Node Type: IF 65

EXPRESSION:
_weiAmount == 300000000000000000

IRs:
TMP_226(bool) = _weiAmount == 300000000000000000
CONDITION TMP_226"];
65->66[label="True"];
65->67[label="False"];
66[label="Node Type: EXPRESSION 66

EXPRESSION:
amountOfTokens = 1035 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_227(uint256) = 10 ** 3
TMP_228(uint256) = 1035 * TMP_227
TMP_229 = CONVERT decimals to uint256
TMP_230(uint256) = 10 ** TMP_229
TMP_231(uint256) = TMP_228 * TMP_230
amountOfTokens(uint256) := TMP_231(uint256)"];
66->67;
67[label="Node Type: END_IF 67
"];
67->68;
68[label="Node Type: IF 68

EXPRESSION:
_weiAmount == 400000000000000000

IRs:
TMP_232(bool) = _weiAmount == 400000000000000000
CONDITION TMP_232"];
68->69[label="True"];
68->70[label="False"];
69[label="Node Type: EXPRESSION 69

EXPRESSION:
amountOfTokens = 1380 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_233(uint256) = 10 ** 3
TMP_234(uint256) = 1380 * TMP_233
TMP_235 = CONVERT decimals to uint256
TMP_236(uint256) = 10 ** TMP_235
TMP_237(uint256) = TMP_234 * TMP_236
amountOfTokens(uint256) := TMP_237(uint256)"];
69->70;
70[label="Node Type: END_IF 70
"];
70->71;
71[label="Node Type: IF 71

EXPRESSION:
_weiAmount == 500000000000000000

IRs:
TMP_238(bool) = _weiAmount == 500000000000000000
CONDITION TMP_238"];
71->72[label="True"];
71->73[label="False"];
72[label="Node Type: EXPRESSION 72

EXPRESSION:
amountOfTokens = 1725 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_239(uint256) = 10 ** 3
TMP_240(uint256) = 1725 * TMP_239
TMP_241 = CONVERT decimals to uint256
TMP_242(uint256) = 10 ** TMP_241
TMP_243(uint256) = TMP_240 * TMP_242
amountOfTokens(uint256) := TMP_243(uint256)"];
72->73;
73[label="Node Type: END_IF 73
"];
73->74;
74[label="Node Type: IF 74

EXPRESSION:
_weiAmount == 600000000000000000

IRs:
TMP_244(bool) = _weiAmount == 600000000000000000
CONDITION TMP_244"];
74->75[label="True"];
74->76[label="False"];
75[label="Node Type: EXPRESSION 75

EXPRESSION:
amountOfTokens = 2070 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_245(uint256) = 10 ** 3
TMP_246(uint256) = 2070 * TMP_245
TMP_247 = CONVERT decimals to uint256
TMP_248(uint256) = 10 ** TMP_247
TMP_249(uint256) = TMP_246 * TMP_248
amountOfTokens(uint256) := TMP_249(uint256)"];
75->76;
76[label="Node Type: END_IF 76
"];
76->77;
77[label="Node Type: IF 77

EXPRESSION:
_weiAmount == 700000000000000000

IRs:
TMP_250(bool) = _weiAmount == 700000000000000000
CONDITION TMP_250"];
77->78[label="True"];
77->79[label="False"];
78[label="Node Type: EXPRESSION 78

EXPRESSION:
amountOfTokens = 2415 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_251(uint256) = 10 ** 3
TMP_252(uint256) = 2415 * TMP_251
TMP_253 = CONVERT decimals to uint256
TMP_254(uint256) = 10 ** TMP_253
TMP_255(uint256) = TMP_252 * TMP_254
amountOfTokens(uint256) := TMP_255(uint256)"];
78->79;
79[label="Node Type: END_IF 79
"];
79->80;
80[label="Node Type: IF 80

EXPRESSION:
_weiAmount == 800000000000000000

IRs:
TMP_256(bool) = _weiAmount == 800000000000000000
CONDITION TMP_256"];
80->81[label="True"];
80->82[label="False"];
81[label="Node Type: EXPRESSION 81

EXPRESSION:
amountOfTokens = 2760 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_257(uint256) = 10 ** 3
TMP_258(uint256) = 2760 * TMP_257
TMP_259 = CONVERT decimals to uint256
TMP_260(uint256) = 10 ** TMP_259
TMP_261(uint256) = TMP_258 * TMP_260
amountOfTokens(uint256) := TMP_261(uint256)"];
81->82;
82[label="Node Type: END_IF 82
"];
82->83;
83[label="Node Type: IF 83

EXPRESSION:
_weiAmount == 900000000000000000

IRs:
TMP_262(bool) = _weiAmount == 900000000000000000
CONDITION TMP_262"];
83->84[label="True"];
83->85[label="False"];
84[label="Node Type: EXPRESSION 84

EXPRESSION:
amountOfTokens = 3450 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_263(uint256) = 10 ** 3
TMP_264(uint256) = 3450 * TMP_263
TMP_265 = CONVERT decimals to uint256
TMP_266(uint256) = 10 ** TMP_265
TMP_267(uint256) = TMP_264 * TMP_266
amountOfTokens(uint256) := TMP_267(uint256)"];
84->85;
85[label="Node Type: END_IF 85
"];
85->86;
86[label="Node Type: IF 86

EXPRESSION:
_weiAmount == 1000000000000000000

IRs:
TMP_268(bool) = _weiAmount == 1000000000000000000
CONDITION TMP_268"];
86->87[label="True"];
86->88[label="False"];
87[label="Node Type: EXPRESSION 87

EXPRESSION:
amountOfTokens = 3600 * 10 ** 3 * (10 ** uint256(decimals))

IRs:
TMP_269(uint256) = 10 ** 3
TMP_270(uint256) = 3600 * TMP_269
TMP_271 = CONVERT decimals to uint256
TMP_272(uint256) = 10 ** TMP_271
TMP_273(uint256) = TMP_270 * TMP_272
amountOfTokens(uint256) := TMP_273(uint256)"];
87->88;
88[label="Node Type: END_IF 88
"];
88->89;
89[label="Node Type: RETURN 89

EXPRESSION:
amountOfTokens

IRs:
RETURN amountOfTokens"];
}
// Function: 1340.sol-KYROInv-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
REF_72(mapping(address => uint256)) -> allowed[msg.sender]
REF_73(uint256) -> REF_72[_spender]
TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_73', '_addedValue'] 
REF_71(uint256) (->allowed) := TMP_80(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
Emit Approval(msg.sender,_spender,REF_76)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1340.sol-KYROInv-mint(address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_274 = CONVERT 0 to address
TMP_275(bool) = _to != TMP_274
TMP_276(None) = SOLIDITY_CALL require(bool)(TMP_275)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= balances[_owner])

IRs:
REF_99(uint256) -> balances[_owner]
TMP_277(bool) = _amount <= REF_99
TMP_278(None) = SOLIDITY_CALL require(bool)(TMP_277)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_100(uint256) -> balances[_to]
REF_101(uint256) -> balances[_to]
TMP_279(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_101', '_amount'] 
REF_100(uint256) (->balances) := TMP_279(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_owner] = balances[_owner].sub(_amount)

IRs:
REF_103(uint256) -> balances[_owner]
REF_104(uint256) -> balances[_owner]
TMP_280(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_104', '_amount'] 
REF_103(uint256) (->balances) := TMP_280(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_owner,_to,_amount)

IRs:
Emit Transfer(_owner,_to,_amount)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1340.sol-KYROInv-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_304(bool) = msg.sender == owner
TMP_305(None) = SOLIDITY_CALL require(bool)(TMP_304)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1340.sol-KYROInv-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.data.length == numwords * 32 + 4)

IRs:
REF_108 -> LENGTH msg.data
TMP_300(uint256) = numwords * 32
TMP_301(uint256) = TMP_300 + 4
TMP_302(bool) = REF_108 == TMP_301
TMP_303(None) = SOLIDITY_CALL assert(bool)(TMP_302)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1340.sol-KYROInv-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = KYRO Inv

IRs:
name(string) := KYRO Inv(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = KR

IRs:
symbol(string) := KR(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
INITIAL_SUPPLY = 3 * 10 ** 9 * (10 ** uint256(decimals))

IRs:
TMP_295(uint256) = 10 ** 9
TMP_296(uint256) = 3 * TMP_295
TMP_297 = CONVERT decimals to uint256
TMP_298(uint256) = 10 ** TMP_297
TMP_299(uint256) = TMP_296 * TMP_298
INITIAL_SUPPLY(uint256) := TMP_299(uint256)"];
}
// Function: 1340.sol-KYROInv-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
saleToken = true

IRs:
saleToken(bool) := True(bool)"];
}
// Function: 1340.sol-KYROInv-startSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
saleToken = true

IRs:
saleToken(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KYROInv.onlyOwner()()"];
2->1;
}
// Function: 1340.sol-KYROInv-stopSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
saleToken = false

IRs:
saleToken(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KYROInv.onlyOwner()()"];
2->1;
}
// Function: 1340.sol-KYROInv-transfer(address,uint256)
digraph{
}
// Function: 1340.sol-KYROInv-transferFrom(address,address,uint256)
digraph{
}
// Function: 1340.sol-KYROInv-validPurchaseTokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
addTokens = getTotalAmountOfTokens(_weiAmount)

IRs:
TMP_109(uint256) = INTERNAL_CALL, KYROInv.getTotalAmountOfTokens(uint256)(_weiAmount)
addTokens(uint256) := TMP_109(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
addTokens > balances[owner]

IRs:
REF_98(uint256) -> balances[owner]
TMP_110(bool) = addTokens > REF_98
CONDITION TMP_110"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
TokenLimitReached(tokenAllocated,addTokens)

IRs:
Emit TokenLimitReached(tokenAllocated,addTokens)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
addTokens

IRs:
RETURN addTokens"];
}
// Function: 1340.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1340.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_6(uint256) = a / b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1340.sol-SafeMath-max256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_15(bool) = a >= b
CONDITION TMP_15"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 1340.sol-SafeMath-max64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a >= b

IRs:
TMP_13(bool) = a >= b
CONDITION TMP_13"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 1340.sol-SafeMath-min256(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_16(bool) = a < b
CONDITION TMP_16"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 1340.sol-SafeMath-min64(uint64,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
a < b

IRs:
TMP_14(bool) = a < b
CONDITION TMP_14"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
a

IRs:
RETURN a"];
4[label="Node Type: RETURN 4

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 1340.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1340.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_7(bool) = b <= a
TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_9(uint256) = a - b
RETURN TMP_9"];
}
// Function: 1340.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_33(mapping(address => uint256)) -> allowed[_owner]
REF_34(uint256) -> REF_33[_spender]
RETURN REF_34"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyPayloadSize(2)

IRs:
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(2)"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 1340.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
REF_32(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1340.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 1340.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_42(mapping(address => uint256)) -> allowed[msg.sender]
REF_43(uint256) -> REF_42[_spender]
oldValue(uint256) := REF_43(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_58(bool) = _subtractedValue > oldValue
CONDITION TMP_58"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_44(mapping(address => uint256)) -> allowed[msg.sender]
REF_45(uint256) -> REF_44[_spender]
REF_45(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_46(mapping(address => uint256)) -> allowed[msg.sender]
REF_47(uint256) -> REF_46[_spender]
TMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_47(uint256) (->allowed) := TMP_59(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_49(mapping(address => uint256)) -> allowed[msg.sender]
REF_50(uint256) -> REF_49[_spender]
Emit Approval(msg.sender,_spender,REF_50)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1340.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_35(mapping(address => uint256)) -> allowed[msg.sender]
REF_36(uint256) -> REF_35[_spender]
REF_37(mapping(address => uint256)) -> allowed[msg.sender]
REF_38(uint256) -> REF_37[_spender]
TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_38', '_addedValue'] 
REF_36(uint256) (->allowed) := TMP_56(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_40(mapping(address => uint256)) -> allowed[msg.sender]
REF_41(uint256) -> REF_40[_spender]
Emit Approval(msg.sender,_spender,REF_41)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 1340.sol-StandardToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.data.length == numwords * 32 + 4)

IRs:
REF_51 -> LENGTH msg.data
TMP_61(uint256) = numwords * 32
TMP_62(uint256) = TMP_61 + 4
TMP_63(bool) = REF_51 == TMP_62
TMP_64(None) = SOLIDITY_CALL assert(bool)(TMP_63)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1340.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 1340.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_41 = CONVERT 0 to address
TMP_42(bool) = _to != TMP_41
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_17(uint256) -> balances[_from]
TMP_44(bool) = _value <= REF_17
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_18(mapping(address => uint256)) -> allowed[_from]
REF_19(uint256) -> REF_18[msg.sender]
TMP_46(bool) = _value <= REF_19
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(transfersEnabled)

IRs:
TMP_48(None) = SOLIDITY_CALL require(bool)(transfersEnabled)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_20(uint256) -> balances[_from]
REF_21(uint256) -> balances[_from]
TMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_21', '_value'] 
REF_20(uint256) (->balances) := TMP_49(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_23(uint256) -> balances[_to]
REF_24(uint256) -> balances[_to]
TMP_50(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_24', '_value'] 
REF_23(uint256) (->balances) := TMP_50(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_26(mapping(address => uint256)) -> allowed[_from]
REF_27(uint256) -> REF_26[msg.sender]
REF_28(mapping(address => uint256)) -> allowed[_from]
REF_29(uint256) -> REF_28[msg.sender]
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', '_value'] 
REF_27(uint256) (->allowed) := TMP_51(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyPayloadSize(3)

IRs:
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(3)"];
10->1;
}
}
