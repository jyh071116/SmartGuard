digraph G {
// Function: 1628.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_10(uint256) -> balances[_owner]
RETURN REF_10"];
}
// Function: 1628.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 1628.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_18 = CONVERT 0 to address
TMP_19(bool) = _to != TMP_18
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_3(uint256) -> balances[msg.sender]
TMP_21(bool) = _value <= REF_3
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_4(uint256) -> balances[msg.sender]
REF_5(uint256) -> balances[msg.sender]
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_23(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_7(uint256) -> balances[_to]
REF_8(uint256) -> balances[_to]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_8', '_value'] 
REF_7(uint256) (->balances) := TMP_24(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-BurnableToken-_burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_who])

IRs:
REF_19(uint256) -> balances[_who]
TMP_35(bool) = _value <= REF_19
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_who] = balances[_who].sub(_value)

IRs:
REF_20(uint256) -> balances[_who]
REF_21(uint256) -> balances[_who]
TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_21', '_value'] 
REF_20(uint256) (->balances) := TMP_37(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_38(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(_who,_value)

IRs:
Emit Burn(_who,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_who,address(0),_value)

IRs:
TMP_40 = CONVERT 0 to address
Emit Transfer(_who,TMP_40,_value)"];
}
// Function: 1628.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 1628.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_burn(msg.sender,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(msg.sender,_value)"];
}
// Function: 1628.sol-BurnableToken-totalSupply()
digraph{
}
// Function: 1628.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 1628.sol-DaonomicCrowdsale-_deliverTokens(address,uint256)
digraph{
}
// Function: 1628.sol-DaonomicCrowdsale-_getBonus(uint256)
digraph{
}
// Function: 1628.sol-DaonomicCrowdsale-_getTokenAmount(uint256)
digraph{
}
// Function: 1628.sol-DaonomicCrowdsale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1628.sol-DaonomicCrowdsale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_167 = CONVERT 0 to address
TMP_168(bool) = _beneficiary != TMP_167
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_weiAmount != 0)

IRs:
TMP_170(bool) = _weiAmount != 0
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)"];
}
// Function: 1628.sol-DaonomicCrowdsale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_deliverTokens(_beneficiary,_tokenAmount)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)"];
}
// Function: 1628.sol-DaonomicCrowdsale-_updatePurchasingState(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1628.sol-DaonomicCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
(tokens,left) = _getTokenAmount(weiAmount)

IRs:
TUPLE_0(uint256,uint256) = INTERNAL_CALL, DaonomicCrowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256)= UNPACK TUPLE_0 index: 0 
left(uint256)= UNPACK TUPLE_0 index: 1 "];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
weiEarned = weiAmount.sub(left)

IRs:
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['weiAmount', 'left'] 
weiEarned(uint256) := TMP_156(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
bonus = _getBonus(tokens)

IRs:
TMP_157(uint256) = INTERNAL_CALL, DaonomicCrowdsale._getBonus(uint256)(tokens)
bonus(uint256) := TMP_157(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
withBonus = tokens.add(bonus)

IRs:
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'bonus'] 
withBonus(uint256) := TMP_158(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
weiRaised = weiRaised.add(weiEarned)

IRs:
TMP_159(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiEarned'] 
weiRaised(uint256) := TMP_159(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_processPurchase(_beneficiary,withBonus)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._processPurchase(address,uint256)(_beneficiary,withBonus)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Purchase(_beneficiary,address(0),weiEarned,tokens,bonus,)

IRs:
TMP_161 = CONVERT 0 to address
Emit Purchase(_beneficiary,TMP_161,weiEarned,tokens,bonus,)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_updatePurchasingState(_beneficiary,weiEarned,withBonus)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._updatePurchasingState(address,uint256,uint256)(_beneficiary,weiEarned,withBonus)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_postValidatePurchase(_beneficiary,weiEarned)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiEarned)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
left > 0

IRs:
TMP_165(bool) = left > 0
CONDITION TMP_165"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_beneficiary.transfer(left)

IRs:
Transfer dest:_beneficiary value:left"];
15->16;
16[label="Node Type: END_IF 16
"];
}
// Function: 1628.sol-DaonomicCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, DaonomicCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 1628.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 1628.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 1628.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 1628.sol-ERC20-totalSupply()
digraph{
}
// Function: 1628.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 1628.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 1628.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 1628.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 1628.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 1628.sol-Ownable-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_148 = CONVERT 0 to address
TMP_149(bool) = _newOwner != TMP_148
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 1628.sol-Ownable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1628.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_152(bool) = msg.sender == owner
TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1628.sol-Ownable-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_144 = CONVERT 0 to address
owner(address) := TMP_144(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 1628.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-_deliverTokens(address,uint256)
digraph{
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-_getBonus(uint256)
digraph{
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-_getTokenAmount(uint256)
digraph{
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_223 = CONVERT 0 to address
TMP_224(bool) = _beneficiary != TMP_223
TMP_225(None) = SOLIDITY_CALL require(bool)(TMP_224)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_weiAmount != 0)

IRs:
TMP_226(bool) = _weiAmount != 0
TMP_227(None) = SOLIDITY_CALL require(bool)(TMP_226)"];
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_deliverTokens(_beneficiary,_tokenAmount)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)"];
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-_updatePurchasingState(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super._updatePurchasingState(_beneficiary,_weiAmount,_tokens)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._updatePurchasingState(address,uint256,uint256)(_beneficiary,_weiAmount,_tokens)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
investments[_beneficiary] = investments[_beneficiary].add(_weiAmount)

IRs:
REF_194(uint256) -> investments[_beneficiary]
REF_195(uint256) -> investments[_beneficiary]
TMP_236(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_195', '_weiAmount'] 
REF_194(uint256) (->investments) := TMP_236(uint256)"];
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
(tokens,left) = _getTokenAmount(weiAmount)

IRs:
TUPLE_2(uint256,uint256) = INTERNAL_CALL, DaonomicCrowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256)= UNPACK TUPLE_2 index: 0 
left(uint256)= UNPACK TUPLE_2 index: 1 "];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
weiEarned = weiAmount.sub(left)

IRs:
TMP_212(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['weiAmount', 'left'] 
weiEarned(uint256) := TMP_212(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
bonus = _getBonus(tokens)

IRs:
TMP_213(uint256) = INTERNAL_CALL, DaonomicCrowdsale._getBonus(uint256)(tokens)
bonus(uint256) := TMP_213(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
withBonus = tokens.add(bonus)

IRs:
TMP_214(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'bonus'] 
withBonus(uint256) := TMP_214(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
weiRaised = weiRaised.add(weiEarned)

IRs:
TMP_215(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiEarned'] 
weiRaised(uint256) := TMP_215(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_processPurchase(_beneficiary,withBonus)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._processPurchase(address,uint256)(_beneficiary,withBonus)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Purchase(_beneficiary,address(0),weiEarned,tokens,bonus,)

IRs:
TMP_217 = CONVERT 0 to address
Emit Purchase(_beneficiary,TMP_217,weiEarned,tokens,bonus,)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_updatePurchasingState(_beneficiary,weiEarned,withBonus)

IRs:
INTERNAL_CALL, RefundableDaonomicCrowdsale._updatePurchasingState(address,uint256,uint256)(_beneficiary,weiEarned,withBonus)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_postValidatePurchase(_beneficiary,weiEarned)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiEarned)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
left > 0

IRs:
TMP_221(bool) = left > 0
CONDITION TMP_221"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_beneficiary.transfer(left)

IRs:
Transfer dest:_beneficiary value:left"];
15->16;
16[label="Node Type: END_IF 16
"];
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-claimRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isRefundable())

IRs:
TMP_229(bool) = INTERNAL_CALL, RefundableDaonomicCrowdsale.isRefundable()()
TMP_230(None) = SOLIDITY_CALL require(bool)(TMP_229)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(investments[msg.sender] > 0)

IRs:
REF_190(uint256) -> investments[msg.sender]
TMP_231(bool) = REF_190 > 0
TMP_232(None) = SOLIDITY_CALL require(bool)(TMP_231)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
investment = investments[msg.sender]

IRs:
REF_191(uint256) -> investments[msg.sender]
investment(uint256) := REF_191(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
investments[msg.sender] = 0

IRs:
REF_192(uint256) -> investments[msg.sender]
REF_192(uint256) (->investments) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(investment)

IRs:
Transfer dest:msg.sender value:investment"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Refund(msg.sender,investment)

IRs:
Emit Refund(msg.sender,investment)"];
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, DaonomicCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 1628.sol-RefundableDaonomicCrowdsale-isRefundable()
digraph{
}
// Function: 1628.sol-SafeERC20-safeApprove(ERC20,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.approve(spender,value))

IRs:
TMP_4(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['spender', 'value']  
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)"];
}
// Function: 1628.sol-SafeERC20-safeTransfer(ERC20Basic,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.transfer(to,value))

IRs:
TMP_0(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['to', 'value']  
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)"];
}
// Function: 1628.sol-SafeERC20-safeTransferFrom(ERC20,address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.transferFrom(from,to,value))

IRs:
TMP_2(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['from', 'to', 'value']  
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)"];
}
// Function: 1628.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_15(uint256) = a + b
c(uint256) := TMP_15(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_16(bool) = c >= a
TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1628.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a / b

IRs:
TMP_11(uint256) = a / b
RETURN TMP_11"];
}
// Function: 1628.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_6(bool) = a == 0
CONDITION TMP_6"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_7(uint256) = a * b
c(uint256) := TMP_7(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_8(uint256) = c / a
TMP_9(bool) = TMP_8 == b
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 1628.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_12(bool) = b <= a
TMP_13(None) = SOLIDITY_CALL assert(bool)(TMP_12)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_14(uint256) = a - b
RETURN TMP_14"];
}
// Function: 1628.sol-StandardBurnableToken-_burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_who])

IRs:
REF_108(uint256) -> balances[_who]
TMP_93(bool) = _value <= REF_108
TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_who] = balances[_who].sub(_value)

IRs:
REF_109(uint256) -> balances[_who]
REF_110(uint256) -> balances[_who]
TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_110', '_value'] 
REF_109(uint256) (->balances) := TMP_95(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_96(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(_who,_value)

IRs:
Emit Burn(_who,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_who,address(0),_value)

IRs:
TMP_98 = CONVERT 0 to address
Emit Transfer(_who,TMP_98,_value)"];
}
// Function: 1628.sol-StandardBurnableToken-allowance(address,address)
digraph{
}
// Function: 1628.sol-StandardBurnableToken-approve(address,uint256)
digraph{
}
// Function: 1628.sol-StandardBurnableToken-balanceOf(address)
digraph{
}
// Function: 1628.sol-StandardBurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_burn(msg.sender,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(msg.sender,_value)"];
}
// Function: 1628.sol-StandardBurnableToken-burnFrom(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_113(mapping(address => uint256)) -> allowed[_from]
REF_114(uint256) -> REF_113[msg.sender]
TMP_100(bool) = _value <= REF_114
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_115(mapping(address => uint256)) -> allowed[_from]
REF_116(uint256) -> REF_115[msg.sender]
REF_117(mapping(address => uint256)) -> allowed[_from]
REF_118(uint256) -> REF_117[msg.sender]
TMP_102(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_118', '_value'] 
REF_116(uint256) (->allowed) := TMP_102(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_burn(_from,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(_from,_value)"];
}
// Function: 1628.sol-StandardBurnableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_91(mapping(address => uint256)) -> allowed[msg.sender]
REF_92(uint256) -> REF_91[_spender]
oldValue(uint256) := REF_92(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_81(bool) = _subtractedValue > oldValue
CONDITION TMP_81"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_93(mapping(address => uint256)) -> allowed[msg.sender]
REF_94(uint256) -> REF_93[_spender]
REF_94(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_95(mapping(address => uint256)) -> allowed[msg.sender]
REF_96(uint256) -> REF_95[_spender]
TMP_82(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_96(uint256) (->allowed) := TMP_82(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_98(mapping(address => uint256)) -> allowed[msg.sender]
REF_99(uint256) -> REF_98[_spender]
Emit Approval(msg.sender,_spender,REF_99)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-StandardBurnableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_84(mapping(address => uint256)) -> allowed[msg.sender]
REF_85(uint256) -> REF_84[_spender]
REF_86(mapping(address => uint256)) -> allowed[msg.sender]
REF_87(uint256) -> REF_86[_spender]
TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_87', '_addedValue'] 
REF_85(uint256) (->allowed) := TMP_79(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_89(mapping(address => uint256)) -> allowed[msg.sender]
REF_90(uint256) -> REF_89[_spender]
Emit Approval(msg.sender,_spender,REF_90)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-StandardBurnableToken-totalSupply()
digraph{
}
// Function: 1628.sol-StandardBurnableToken-transfer(address,uint256)
digraph{
}
// Function: 1628.sol-StandardBurnableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 1628.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_48(mapping(address => uint256)) -> allowed[_owner]
REF_49(uint256) -> REF_48[_spender]
RETURN REF_49"];
}
// Function: 1628.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_46(mapping(address => uint256)) -> allowed[msg.sender]
REF_47(uint256) -> REF_46[_spender]
REF_47(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 1628.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_57(mapping(address => uint256)) -> allowed[msg.sender]
REF_58(uint256) -> REF_57[_spender]
oldValue(uint256) := REF_58(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_64(bool) = _subtractedValue > oldValue
CONDITION TMP_64"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_59(mapping(address => uint256)) -> allowed[msg.sender]
REF_60(uint256) -> REF_59[_spender]
REF_60(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_61(mapping(address => uint256)) -> allowed[msg.sender]
REF_62(uint256) -> REF_61[_spender]
TMP_65(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_62(uint256) (->allowed) := TMP_65(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_64(mapping(address => uint256)) -> allowed[msg.sender]
REF_65(uint256) -> REF_64[_spender]
Emit Approval(msg.sender,_spender,REF_65)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_50(mapping(address => uint256)) -> allowed[msg.sender]
REF_51(uint256) -> REF_50[_spender]
REF_52(mapping(address => uint256)) -> allowed[msg.sender]
REF_53(uint256) -> REF_52[_spender]
TMP_62(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_53', '_addedValue'] 
REF_51(uint256) (->allowed) := TMP_62(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_55(mapping(address => uint256)) -> allowed[msg.sender]
REF_56(uint256) -> REF_55[_spender]
Emit Approval(msg.sender,_spender,REF_56)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-StandardToken-totalSupply()
digraph{
}
// Function: 1628.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 1628.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_50 = CONVERT 0 to address
TMP_51(bool) = _to != TMP_50
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_32(uint256) -> balances[_from]
TMP_53(bool) = _value <= REF_32
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_33(mapping(address => uint256)) -> allowed[_from]
REF_34(uint256) -> REF_33[msg.sender]
TMP_55(bool) = _value <= REF_34
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_35(uint256) -> balances[_from]
REF_36(uint256) -> balances[_from]
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_36', '_value'] 
REF_35(uint256) (->balances) := TMP_57(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_38(uint256) -> balances[_to]
REF_39(uint256) -> balances[_to]
TMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_39', '_value'] 
REF_38(uint256) (->balances) := TMP_58(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_41(mapping(address => uint256)) -> allowed[_from]
REF_42(uint256) -> REF_41[msg.sender]
REF_43(mapping(address => uint256)) -> allowed[_from]
REF_44(uint256) -> REF_43[msg.sender]
TMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_44', '_value'] 
REF_42(uint256) (->allowed) := TMP_59(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-WgdSale-_deliverTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.safeTransfer(_beneficiary,_tokenAmount)

IRs:
LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', '_beneficiary', '_tokenAmount'] "];
}
// Function: 1628.sol-WgdSale-_getBonus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
getRealAmountBonus(FOR_SALE,sold,_tokens)

IRs:
TMP_304(uint256) = INTERNAL_CALL, WgdSale.getRealAmountBonus(uint256,uint256,uint256)(FOR_SALE,sold,_tokens)
RETURN TMP_304"];
}
// Function: 1628.sol-WgdSale-_getTokenAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
getTokenAmount(sold,_weiAmount)

IRs:
TUPLE_6(uint256,uint256) = INTERNAL_CALL, WgdSale.getTokenAmount(uint256,uint256)(sold,_weiAmount)
RETURN TUPLE_6"];
}
// Function: 1628.sol-WgdSale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1628.sol-WgdSale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super._preValidatePurchase(_beneficiary,_weiAmount)

IRs:
INTERNAL_CALL, WhitelistDaonomicCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,_weiAmount)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_weiAmount >= MINIMAL_WEI)

IRs:
TMP_284(bool) = _weiAmount >= MINIMAL_WEI
TMP_285(None) = SOLIDITY_CALL require(bool)(TMP_284)"];
}
// Function: 1628.sol-WgdSale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_deliverTokens(_beneficiary,_tokenAmount)

IRs:
INTERNAL_CALL, WgdSale._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)"];
}
// Function: 1628.sol-WgdSale-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_276 = CONVERT 0 to address
TMP_277(bool) = _newOwner != TMP_276
TMP_278(None) = SOLIDITY_CALL require(bool)(TMP_277)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 1628.sol-WgdSale-_updatePurchasingState(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super._updatePurchasingState(_beneficiary,_weiAmount,_tokens)

IRs:
INTERNAL_CALL, RefundableDaonomicCrowdsale._updatePurchasingState(address,uint256,uint256)(_beneficiary,_weiAmount,_tokens)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
sold = sold.add(_tokens)

IRs:
TMP_327(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sold', '_tokens'] 
sold(uint256) := TMP_327(uint256)"];
}
// Function: 1628.sol-WgdSale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, WgdSale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
(tokens,left) = _getTokenAmount(weiAmount)

IRs:
TUPLE_3(uint256,uint256) = INTERNAL_CALL, WgdSale._getTokenAmount(uint256)(weiAmount)
tokens(uint256)= UNPACK TUPLE_3 index: 0 
left(uint256)= UNPACK TUPLE_3 index: 1 "];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
weiEarned = weiAmount.sub(left)

IRs:
TMP_247(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['weiAmount', 'left'] 
weiEarned(uint256) := TMP_247(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
bonus = _getBonus(tokens)

IRs:
TMP_248(uint256) = INTERNAL_CALL, WgdSale._getBonus(uint256)(tokens)
bonus(uint256) := TMP_248(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
withBonus = tokens.add(bonus)

IRs:
TMP_249(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'bonus'] 
withBonus(uint256) := TMP_249(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
weiRaised = weiRaised.add(weiEarned)

IRs:
TMP_250(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiEarned'] 
weiRaised(uint256) := TMP_250(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_processPurchase(_beneficiary,withBonus)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._processPurchase(address,uint256)(_beneficiary,withBonus)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Purchase(_beneficiary,address(0),weiEarned,tokens,bonus,)

IRs:
TMP_252 = CONVERT 0 to address
Emit Purchase(_beneficiary,TMP_252,weiEarned,tokens,bonus,)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_updatePurchasingState(_beneficiary,weiEarned,withBonus)

IRs:
INTERNAL_CALL, WgdSale._updatePurchasingState(address,uint256,uint256)(_beneficiary,weiEarned,withBonus)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_postValidatePurchase(_beneficiary,weiEarned)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiEarned)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
left > 0

IRs:
TMP_256(bool) = left > 0
CONDITION TMP_256"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_beneficiary.transfer(left)

IRs:
Transfer dest:_beneficiary value:left"];
15->16;
16[label="Node Type: END_IF 16
"];
}
// Function: 1628.sol-WgdSale-buyback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
(stage,None,None) = getStage(sold)

IRs:
TUPLE_5(uint8,uint256,uint256) = INTERNAL_CALL, WgdSale.getStage(uint256)(sold)
stage(uint8)= UNPACK TUPLE_5 index: 0 "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(stage > 0,buyback doesn't work on stage 0)

IRs:
TMP_290(bool) = stage > 0
TMP_291(None) = SOLIDITY_CALL require(bool,string)(TMP_290,buyback doesn't work on stage 0)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
approved = token.allowance(msg.sender,this)

IRs:
TMP_292(uint256) = HIGH_LEVEL_CALL, dest:token(WgdToken), function:allowance, arguments:['msg.sender', 'this']  
approved(uint256) := TMP_292(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
inCirculation = token.totalSupply().sub(token.balanceOf(this))

IRs:
TMP_293(uint256) = HIGH_LEVEL_CALL, dest:token(WgdToken), function:totalSupply, arguments:[]  
TMP_294(uint256) = HIGH_LEVEL_CALL, dest:token(WgdToken), function:balanceOf, arguments:['this']  
TMP_295(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_293', 'TMP_294'] 
inCirculation(uint256) := TMP_295(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
value = approved.mul(address(this).balance).div(inCirculation)

IRs:
TMP_296 = CONVERT this to address
TMP_297(uint256) = SOLIDITY_CALL balance(address)(TMP_296)
TMP_298(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['approved', 'TMP_297'] 
TMP_299(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_298', 'inCirculation'] 
value(uint256) := TMP_299(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.burnFrom(msg.sender,approved)

IRs:
HIGH_LEVEL_CALL, dest:token(WgdToken), function:burnFrom, arguments:['msg.sender', 'approved']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.transfer(value)

IRs:
Transfer dest:msg.sender value:value"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Buyback(msg.sender,approved,value)

IRs:
Emit Buyback(msg.sender,approved,value)"];
}
// Function: 1628.sol-WgdSale-canBuy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < whitelists.length

IRs:
REF_208 -> LENGTH whitelists
TMP_268(bool) = i < REF_208
CONDITION TMP_268"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
whitelists[i].isInWhitelist(_beneficiary)

IRs:
REF_209(Whitelist) -> whitelists[i]
TMP_269(bool) = HIGH_LEVEL_CALL, dest:REF_209(Whitelist), function:isInWhitelist, arguments:['_beneficiary']  
CONDITION TMP_269"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_270(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 1628.sol-WgdSale-claimRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isRefundable())

IRs:
TMP_237(bool) = INTERNAL_CALL, WgdSale.isRefundable()()
TMP_238(None) = SOLIDITY_CALL require(bool)(TMP_237)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(investments[msg.sender] > 0)

IRs:
REF_197(uint256) -> investments[msg.sender]
TMP_239(bool) = REF_197 > 0
TMP_240(None) = SOLIDITY_CALL require(bool)(TMP_239)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
investment = investments[msg.sender]

IRs:
REF_198(uint256) -> investments[msg.sender]
investment(uint256) := REF_198(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
investments[msg.sender] = 0

IRs:
REF_199(uint256) -> investments[msg.sender]
REF_199(uint256) (->investments) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(investment)

IRs:
Transfer dest:msg.sender value:investment"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Refund(msg.sender,investment)

IRs:
Emit Refund(msg.sender,investment)"];
}
// Function: 1628.sol-WgdSale-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1628.sol-WgdSale-constructor(WgdToken,Whitelist[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token = _token

IRs:
token(WgdToken) := _token(WgdToken)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RateAdd(address(0))

IRs:
TMP_280 = CONVERT 0 to address
Emit RateAdd(TMP_280)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
WhitelistDaonomicCrowdsale(_whitelists)

IRs:
INTERNAL_CALL, WhitelistDaonomicCrowdsale.constructor(Whitelist[])(_whitelists)"];
3->1;
}
// Function: 1628.sol-WgdSale-constructor(Whitelist[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelists = _whitelists

IRs:
whitelists(Whitelist[]) := _whitelists(Whitelist[])"];
}
// Function: 1628.sol-WgdSale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, DaonomicCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 1628.sol-WgdSale-getAmountBonus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_tokens < BONUS_STAGE1

IRs:
TMP_335(bool) = _tokens < BONUS_STAGE1
CONDITION TMP_335"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: IF 3

EXPRESSION:
_tokens < BONUS_STAGE2

IRs:
TMP_336(bool) = _tokens < BONUS_STAGE2
CONDITION TMP_336"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
BONUS1

IRs:
RETURN BONUS1"];
5[label="Node Type: IF 5

EXPRESSION:
_tokens < BONUS_STAGE3

IRs:
TMP_337(bool) = _tokens < BONUS_STAGE3
CONDITION TMP_337"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
BONUS2

IRs:
RETURN BONUS2"];
7[label="Node Type: IF 7

EXPRESSION:
_tokens < BONUS_STAGE4

IRs:
TMP_338(bool) = _tokens < BONUS_STAGE4
CONDITION TMP_338"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
BONUS3

IRs:
RETURN BONUS3"];
9[label="Node Type: RETURN 9

EXPRESSION:
BONUS4

IRs:
RETURN BONUS4"];
}
// Function: 1628.sol-WgdSale-getRate(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_token == address(0)

IRs:
TMP_286 = CONVERT 0 to address
TMP_287(bool) = _token == TMP_286
CONDITION TMP_287"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(None,None,rate) = getStage(sold)

IRs:
TUPLE_4(uint8,uint256,uint256) = INTERNAL_CALL, WgdSale.getStage(uint256)(sold)
rate(uint256)= UNPACK TUPLE_4 index: 2 "];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
rate.mul(10 ** 18)

IRs:
TMP_288(uint256) = 10 ** 18
TMP_289(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['rate', 'TMP_288'] 
RETURN TMP_289"];
5[label="Node Type: RETURN 5

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 1628.sol-WgdSale-getRealAmountBonus(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bonus = getAmountBonus(_tokens)

IRs:
TMP_305(uint256) = INTERNAL_CALL, WgdSale.getAmountBonus(uint256)(_tokens)
bonus(uint256) := TMP_305(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
left = _forSale.sub(_sold).sub(_tokens)

IRs:
TMP_306(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_forSale', '_sold'] 
TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_306', '_tokens'] 
left(uint256) := TMP_307(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
left > bonus

IRs:
TMP_308(bool) = left > bonus
CONDITION TMP_308"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
bonus

IRs:
RETURN bonus"];
5[label="Node Type: RETURN 5

EXPRESSION:
left

IRs:
RETURN left"];
}
// Function: 1628.sol-WgdSale-getStage(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_sold < STAGE1

IRs:
TMP_331(bool) = _sold < STAGE1
CONDITION TMP_331"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
(0,STAGE1,RATE1)

IRs:
RETURN 0,STAGE1,RATE1"];
3[label="Node Type: IF 3

EXPRESSION:
_sold < STAGE2

IRs:
TMP_332(bool) = _sold < STAGE2
CONDITION TMP_332"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
(1,STAGE2,RATE2)

IRs:
RETURN 1,STAGE2,RATE2"];
5[label="Node Type: IF 5

EXPRESSION:
_sold < STAGE3

IRs:
TMP_333(bool) = _sold < STAGE3
CONDITION TMP_333"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
(2,STAGE3,RATE3)

IRs:
RETURN 2,STAGE3,RATE3"];
7[label="Node Type: IF 7

EXPRESSION:
_sold < STAGE4

IRs:
TMP_334(bool) = _sold < STAGE4
CONDITION TMP_334"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
(3,STAGE4,RATE4)

IRs:
RETURN 3,STAGE4,RATE4"];
9[label="Node Type: RETURN 9

EXPRESSION:
(4,0,0)

IRs:
RETURN 4,0,0"];
14[label="Node Type: RETURN 14

EXPRESSION:
(stage,limit,rate)

IRs:
RETURN stage,limit,rate"];
}
// Function: 1628.sol-WgdSale-getTokenAmount(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
left = _weiAmount

IRs:
left(uint256) := _weiAmount(uint256)"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3

EXPRESSION:
left > 0

IRs:
TMP_309(bool) = left > 0
CONDITION TMP_309"];
3->4[label="True"];
3->12[label="False"];
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(currentTokens,currentLeft) = getTokensForStage(_sold.add(tokens),left)

IRs:
TMP_310(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_sold', 'tokens'] 
TUPLE_7(uint256,uint256) = INTERNAL_CALL, WgdSale.getTokensForStage(uint256,uint256)(TMP_310,left)
currentTokens(uint256)= UNPACK TUPLE_7 index: 0 
currentLeft(uint256)= UNPACK TUPLE_7 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
left == currentLeft

IRs:
TMP_311(bool) = left == currentLeft
CONDITION TMP_311"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
(tokens,left)

IRs:
RETURN tokens,left"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
left = currentLeft

IRs:
left(uint256) := currentLeft(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tokens = tokens.add(currentTokens)

IRs:
TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'currentTokens'] 
tokens(uint256) := TMP_312(uint256)"];
11->3;
12[label="Node Type: END_LOOP 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
(tokens,left)

IRs:
RETURN tokens,left"];
}
// Function: 1628.sol-WgdSale-getTokensForStage(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
(stage,limit,rate) = getStage(_sold)

IRs:
TUPLE_8(uint8,uint256,uint256) = INTERNAL_CALL, WgdSale.getStage(uint256)(_sold)
stage(uint8)= UNPACK TUPLE_8 index: 0 
limit(uint256)= UNPACK TUPLE_8 index: 1 
rate(uint256)= UNPACK TUPLE_8 index: 2 "];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
stage == 4

IRs:
TMP_313(bool) = stage == 4
CONDITION TMP_313"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
(0,_weiAmount)

IRs:
RETURN 0,_weiAmount"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
stage == 0 && now > END

IRs:
TMP_314(bool) = stage == 0
TMP_315(bool) = now > END
TMP_316(bool) = TMP_314 && TMP_315
CONDITION TMP_316"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
revert(string)(Sale is refundable, unable to buy)

IRs:
TMP_317(None) = SOLIDITY_CALL revert(string)(Sale is refundable, unable to buy)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tokens = _weiAmount.mul(rate)

IRs:
TMP_318(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_weiAmount', 'rate'] 
tokens(uint256) := TMP_318(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
left = 0

IRs:
left(uint256) := 0(uint256)"];
12->13;
13[label="Node Type: NEW VARIABLE 13
"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
(newStage,None,None) = getStage(_sold.add(tokens))

IRs:
TMP_319(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_sold', 'tokens'] 
TUPLE_9(uint8,uint256,uint256) = INTERNAL_CALL, WgdSale.getStage(uint256)(TMP_319)
newStage(uint8)= UNPACK TUPLE_9 index: 0 "];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
newStage != stage

IRs:
TMP_320(bool) = newStage != stage
CONDITION TMP_320"];
15->16[label="True"];
15->19[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
tokens = limit.sub(_sold)

IRs:
TMP_321(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['limit', '_sold'] 
tokens(uint256) := TMP_321(uint256)"];
16->17;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
weiSpent = (tokens.add(rate).sub(1)).div(rate)

IRs:
TMP_322(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'rate'] 
TMP_323(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_322', '1'] 
TMP_324(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_323', 'rate'] 
weiSpent(uint256) := TMP_324(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
left = _weiAmount.sub(weiSpent)

IRs:
TMP_325(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_weiAmount', 'weiSpent'] 
left(uint256) := TMP_325(uint256)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
(tokens,left)

IRs:
RETURN tokens,left"];
}
// Function: 1628.sol-WgdSale-getWhitelists()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
whitelists

IRs:
RETURN whitelists"];
}
// Function: 1628.sol-WgdSale-isRefundable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
(stage,None,None) = getStage(sold)

IRs:
TUPLE_10(uint8,uint256,uint256) = INTERNAL_CALL, WgdSale.getStage(uint256)(sold)
stage(uint8)= UNPACK TUPLE_10 index: 0 "];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
now > END && stage == 0

IRs:
TMP_328(bool) = now > END
TMP_329(bool) = stage == 0
TMP_330(bool) = TMP_328 && TMP_329
RETURN TMP_330"];
}
// Function: 1628.sol-WgdSale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_339(bool) = msg.sender == owner
TMP_340(None) = SOLIDITY_CALL require(bool)(TMP_339)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1628.sol-WgdSale-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_272 = CONVERT 0 to address
owner(address) := TMP_272(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 1628.sol-WgdSale-setWhitelists(Whitelist[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelists = _whitelists

IRs:
whitelists(Whitelist[]) := _whitelists(Whitelist[])"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 1628.sol-WgdSale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
FOR_SALE = 300000000000000000000000000

IRs:
FOR_SALE(uint256) := 300000000000000000000000000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
MINIMAL_WEI = 500000000000000000

IRs:
MINIMAL_WEI(uint256) := 500000000000000000(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
END = 1541592000

IRs:
END(uint256) := 1541592000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
STAGE1 = 20000000000000000000000000

IRs:
STAGE1(uint256) := 20000000000000000000000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
STAGE2 = 60000000000000000000000000

IRs:
STAGE2(uint256) := 60000000000000000000000000(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
STAGE3 = 140000000000000000000000000

IRs:
STAGE3(uint256) := 140000000000000000000000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
STAGE4 = 300000000000000000000000000

IRs:
STAGE4(uint256) := 300000000000000000000000000(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
RATE1 = 28000

IRs:
RATE1(uint256) := 28000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
RATE2 = 24000

IRs:
RATE2(uint256) := 24000(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
RATE3 = 22000

IRs:
RATE3(uint256) := 22000(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
RATE4 = 20000

IRs:
RATE4(uint256) := 20000(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
BONUS_STAGE1 = 100000000000000000000000

IRs:
BONUS_STAGE1(uint256) := 100000000000000000000000(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
BONUS_STAGE2 = 500000000000000000000000

IRs:
BONUS_STAGE2(uint256) := 500000000000000000000000(uint256)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
BONUS_STAGE3 = 1000000000000000000000000

IRs:
BONUS_STAGE3(uint256) := 1000000000000000000000000(uint256)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
BONUS_STAGE4 = 5000000000000000000000000

IRs:
BONUS_STAGE4(uint256) := 5000000000000000000000000(uint256)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
BONUS1 = 1000000000000000000000

IRs:
BONUS1(uint256) := 1000000000000000000000(uint256)"];
15->16;
16[label="Node Type: OTHER_ENTRYPOINT 16

EXPRESSION:
BONUS2 = 25000000000000000000000

IRs:
BONUS2(uint256) := 25000000000000000000000(uint256)"];
16->17;
17[label="Node Type: OTHER_ENTRYPOINT 17

EXPRESSION:
BONUS3 = 100000000000000000000000

IRs:
BONUS3(uint256) := 100000000000000000000000(uint256)"];
17->18;
18[label="Node Type: OTHER_ENTRYPOINT 18

EXPRESSION:
BONUS4 = 750000000000000000000000

IRs:
BONUS4(uint256) := 750000000000000000000000(uint256)"];
}
// Function: 1628.sol-WgdSale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 1628.sol-WgdToken-_burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_who])

IRs:
REF_169(uint256) -> balances[_who]
TMP_134(bool) = _value <= REF_169
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_who] = balances[_who].sub(_value)

IRs:
REF_170(uint256) -> balances[_who]
REF_171(uint256) -> balances[_who]
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_171', '_value'] 
REF_170(uint256) (->balances) := TMP_136(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_137(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(_who,_value)

IRs:
Emit Burn(_who,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_who,address(0),_value)

IRs:
TMP_139 = CONVERT 0 to address
Emit Transfer(_who,TMP_139,_value)"];
}
// Function: 1628.sol-WgdToken-allowance(address,address)
digraph{
}
// Function: 1628.sol-WgdToken-approve(address,uint256)
digraph{
}
// Function: 1628.sol-WgdToken-balanceOf(address)
digraph{
}
// Function: 1628.sol-WgdToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_burn(msg.sender,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(msg.sender,_value)"];
}
// Function: 1628.sol-WgdToken-burnFrom(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_120(mapping(address => uint256)) -> allowed[_from]
REF_121(uint256) -> REF_120[msg.sender]
TMP_104(bool) = _value <= REF_121
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_122(mapping(address => uint256)) -> allowed[_from]
REF_123(uint256) -> REF_122[msg.sender]
REF_124(mapping(address => uint256)) -> allowed[_from]
REF_125(uint256) -> REF_124[msg.sender]
TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_125', '_value'] 
REF_123(uint256) (->allowed) := TMP_106(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_burn(_from,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(_from,_value)"];
}
// Function: 1628.sol-WgdToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[msg.sender] = TOTAL

IRs:
REF_174(uint256) -> balances[msg.sender]
REF_174(uint256) (->balances) := TOTAL(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
totalSupply_ = TOTAL

IRs:
totalSupply_(uint256) := TOTAL(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0),msg.sender,TOTAL)

IRs:
TMP_141 = CONVERT 0 to address
Emit Transfer(TMP_141,msg.sender,TOTAL)"];
}
// Function: 1628.sol-WgdToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_152(mapping(address => uint256)) -> allowed[msg.sender]
REF_153(uint256) -> REF_152[_spender]
oldValue(uint256) := REF_153(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_122(bool) = _subtractedValue > oldValue
CONDITION TMP_122"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_154(mapping(address => uint256)) -> allowed[msg.sender]
REF_155(uint256) -> REF_154[_spender]
REF_155(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_156(mapping(address => uint256)) -> allowed[msg.sender]
REF_157(uint256) -> REF_156[_spender]
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_157(uint256) (->allowed) := TMP_123(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_159(mapping(address => uint256)) -> allowed[msg.sender]
REF_160(uint256) -> REF_159[_spender]
Emit Approval(msg.sender,_spender,REF_160)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-WgdToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_145(mapping(address => uint256)) -> allowed[msg.sender]
REF_146(uint256) -> REF_145[_spender]
REF_147(mapping(address => uint256)) -> allowed[msg.sender]
REF_148(uint256) -> REF_147[_spender]
TMP_120(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_148', '_addedValue'] 
REF_146(uint256) (->allowed) := TMP_120(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_150(mapping(address => uint256)) -> allowed[msg.sender]
REF_151(uint256) -> REF_150[_spender]
Emit Approval(msg.sender,_spender,REF_151)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 1628.sol-WgdToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = webGold

IRs:
name(string) := webGold(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = WGD

IRs:
symbol(string) := WGD(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TOTAL = 387500000000000000000000000

IRs:
TOTAL(uint256) := 387500000000000000000000000(uint256)"];
}
// Function: 1628.sol-WgdToken-totalSupply()
digraph{
}
// Function: 1628.sol-WgdToken-transfer(address,uint256)
digraph{
}
// Function: 1628.sol-WgdToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 1628.sol-Whitelist-isInWhitelist(address)
digraph{
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_deliverTokens(address,uint256)
digraph{
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_getBonus(uint256)
digraph{
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_getTokenAmount(uint256)
digraph{
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super._preValidatePurchase(_beneficiary,_weiAmount)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,_weiAmount)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(canBuy(_beneficiary),investor is not verified by Whitelists)

IRs:
TMP_203(bool) = INTERNAL_CALL, WhitelistDaonomicCrowdsale.canBuy(address)(_beneficiary)
TMP_204(None) = SOLIDITY_CALL require(bool,string)(TMP_203,investor is not verified by Whitelists)"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_deliverTokens(_beneficiary,_tokenAmount)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_197 = CONVERT 0 to address
TMP_198(bool) = _newOwner != TMP_197
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-_updatePurchasingState(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, WhitelistDaonomicCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
(tokens,left) = _getTokenAmount(weiAmount)

IRs:
TUPLE_1(uint256,uint256) = INTERNAL_CALL, DaonomicCrowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256)= UNPACK TUPLE_1 index: 0 
left(uint256)= UNPACK TUPLE_1 index: 1 "];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
weiEarned = weiAmount.sub(left)

IRs:
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['weiAmount', 'left'] 
weiEarned(uint256) := TMP_175(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
bonus = _getBonus(tokens)

IRs:
TMP_176(uint256) = INTERNAL_CALL, DaonomicCrowdsale._getBonus(uint256)(tokens)
bonus(uint256) := TMP_176(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
withBonus = tokens.add(bonus)

IRs:
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'bonus'] 
withBonus(uint256) := TMP_177(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
weiRaised = weiRaised.add(weiEarned)

IRs:
TMP_178(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiEarned'] 
weiRaised(uint256) := TMP_178(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_processPurchase(_beneficiary,withBonus)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._processPurchase(address,uint256)(_beneficiary,withBonus)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Purchase(_beneficiary,address(0),weiEarned,tokens,bonus,)

IRs:
TMP_180 = CONVERT 0 to address
Emit Purchase(_beneficiary,TMP_180,weiEarned,tokens,bonus,)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_updatePurchasingState(_beneficiary,weiEarned,withBonus)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._updatePurchasingState(address,uint256,uint256)(_beneficiary,weiEarned,withBonus)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_postValidatePurchase(_beneficiary,weiEarned)

IRs:
INTERNAL_CALL, DaonomicCrowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiEarned)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
left > 0

IRs:
TMP_184(bool) = left > 0
CONDITION TMP_184"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_beneficiary.transfer(left)

IRs:
Transfer dest:_beneficiary value:left"];
15->16;
16[label="Node Type: END_IF 16
"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-canBuy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < whitelists.length

IRs:
REF_183 -> LENGTH whitelists
TMP_205(bool) = i < REF_183
CONDITION TMP_205"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
whitelists[i].isInWhitelist(_beneficiary)

IRs:
REF_184(Whitelist) -> whitelists[i]
TMP_206(bool) = HIGH_LEVEL_CALL, dest:REF_184(Whitelist), function:isInWhitelist, arguments:['_beneficiary']  
CONDITION TMP_206"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_207(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-constructor(Whitelist[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelists = _whitelists

IRs:
whitelists(Whitelist[]) := _whitelists(Whitelist[])"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, DaonomicCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-getWhitelists()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
whitelists

IRs:
RETURN whitelists"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_208(bool) = msg.sender == owner
TMP_209(None) = SOLIDITY_CALL require(bool)(TMP_208)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_193 = CONVERT 0 to address
owner(address) := TMP_193(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-setWhitelists(Whitelist[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelists = _whitelists

IRs:
whitelists(Whitelist[]) := _whitelists(Whitelist[])"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 1628.sol-WhitelistDaonomicCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
}
