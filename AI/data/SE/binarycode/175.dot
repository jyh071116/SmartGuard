digraph G {
// Function: 175.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 175.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 175.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 175.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 175.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 175.sol-Haltable-Haltable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 175.sol-Haltable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 175.sol-Haltable-halt()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
halted = true

IRs:
halted(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
3->1;
}
// Function: 175.sol-Haltable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_28(bool) = msg.sender == owner
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 175.sol-Haltable-runIfHalted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(halted)

IRs:
TMP_32(None) = SOLIDITY_CALL require(bool)(halted)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 175.sol-Haltable-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
halted = false

IRs:
halted(bool) := False(bool)"];
}
// Function: 175.sol-Haltable-stopIfHalted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! halted)

IRs:
TMP_30 = UnaryType.BANG halted 
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 175.sol-Haltable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = newOwner != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 175.sol-Haltable-unHalt()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
halted = false

IRs:
halted(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
runIfHalted()

IRs:
MODIFIER_CALL, Haltable.runIfHalted()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-Haltable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 175.sol-MiBoodleToken-MiBoodleToken(uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
upgradeMaster = msg.sender

IRs:
upgradeMaster(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isMiBoodleToken = true

IRs:
isMiBoodleToken(bool) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
preFundingtokens = _preFundingtokens

IRs:
preFundingtokens(uint256) := _preFundingtokens(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
fundingTokens = _fundingTokens

IRs:
fundingTokens(uint256) := _fundingTokens(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
preFundingStart = safeAdd(now,_preFundingStart)

IRs:
TMP_66(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(now,_preFundingStart)
preFundingStart(uint256) := TMP_66(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
start = safeAdd(now,_start)

IRs:
TMP_67(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(now,_start)
start(uint256) := TMP_67(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
end = safeAdd(now,_end)

IRs:
TMP_68(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(now,_end)
end(uint256) := TMP_68(uint256)"];
}
// Function: 175.sol-MiBoodleToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 175.sol-MiBoodleToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_8(mapping(address => uint256)) -> allowed[_owner]
REF_9(uint256) -> REF_8[_spender]
RETURN REF_9"];
}
// Function: 175.sol-MiBoodleToken-allowanceToBurn(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowedToBurn[_owner][_spender]

IRs:
REF_10(mapping(address => uint256)) -> allowedToBurn[_owner]
REF_11(uint256) -> REF_10[_spender]
RETURN REF_11"];
}
// Function: 175.sol-MiBoodleToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_spender != 0)

IRs:
TMP_198(bool) = _spender != 0
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_27(mapping(address => uint256)) -> allowed[msg.sender]
REF_28(uint256) -> REF_27[_spender]
REF_28(uint256) (->allowed) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 175.sol-MiBoodleToken-approveForBurn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_canBurn != 0)

IRs:
TMP_201(bool) = _canBurn != 0
TMP_202(None) = SOLIDITY_CALL require(bool)(TMP_201)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowedToBurn[msg.sender][_canBurn] = _value

IRs:
REF_29(mapping(address => uint256)) -> allowedToBurn[msg.sender]
REF_30(uint256) -> REF_29[_canBurn]
REF_30(uint256) (->allowedToBurn) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ApproveBurner(msg.sender,_canBurn,_value)

IRs:
Emit ApproveBurner(msg.sender,_canBurn,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 175.sol-MiBoodleToken-assignTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = safeAdd(totalSupply,_tokens)

IRs:
TMP_114(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,_tokens)
totalSupply(uint256) := TMP_114(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_investor] = safeAdd(balances[_investor],_tokens)

IRs:
REF_0(uint256) -> balances[_investor]
REF_1(uint256) -> balances[_investor]
TMP_115(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_1,_tokens)
REF_0(uint256) (->balances) := TMP_115(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Allocate(_investor,_tokens)

IRs:
Emit Allocate(_investor,_tokens)"];
}
// Function: 175.sol-MiBoodleToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_who]

IRs:
REF_7(uint256) -> balances[_who]
RETURN REF_7"];
}
// Function: 175.sol-MiBoodleToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now >= end)

IRs:
TMP_204(bool) = now >= end
TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_206(bool) = _value > 0
TMP_207(None) = SOLIDITY_CALL require(bool)(TMP_206)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
senderBalance = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
senderBalance(uint256) := REF_31(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(senderBalance >= _value)

IRs:
TMP_208(bool) = senderBalance >= _value
TMP_209(None) = SOLIDITY_CALL require(bool)(TMP_208)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
senderBalance = safeSub(senderBalance,_value)

IRs:
TMP_210(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(senderBalance,_value)
senderBalance(uint256) := TMP_210(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = senderBalance

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := senderBalance(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
totalSupply = safeSub(totalSupply,_value)

IRs:
TMP_211(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,_value)
totalSupply(uint256) := TMP_211(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: RETURN 10

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 175.sol-MiBoodleToken-burnFrom(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now >= end)

IRs:
TMP_213(bool) = now >= end
TMP_214(None) = SOLIDITY_CALL require(bool)(TMP_213)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_from != 0 && _value > 0)

IRs:
TMP_215(bool) = _from != 0
TMP_216(bool) = _value > 0
TMP_217(bool) = TMP_215 && TMP_216
TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowedToBurn[_from][msg.sender] >= _value && balances[_from] >= _value)

IRs:
REF_33(mapping(address => uint256)) -> allowedToBurn[_from]
REF_34(uint256) -> REF_33[msg.sender]
TMP_219(bool) = REF_34 >= _value
REF_35(uint256) -> balances[_from]
TMP_220(bool) = REF_35 >= _value
TMP_221(bool) = TMP_219 && TMP_220
TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = safeSub(balances[_from],_value)

IRs:
REF_36(uint256) -> balances[_from]
REF_37(uint256) -> balances[_from]
TMP_223(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_37,_value)
REF_36(uint256) (->balances) := TMP_223(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = safeSub(totalSupply,_value)

IRs:
TMP_224(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,_value)
totalSupply(uint256) := TMP_224(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowedToBurn[_from][msg.sender] = safeSub(allowedToBurn[_from][msg.sender],_value)

IRs:
REF_38(mapping(address => uint256)) -> allowedToBurn[_from]
REF_39(uint256) -> REF_38[msg.sender]
REF_40(mapping(address => uint256)) -> allowedToBurn[_from]
REF_41(uint256) -> REF_40[msg.sender]
TMP_225(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_41,_value)
REF_39(uint256) (->allowedToBurn) := TMP_225(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
BurnFrom(_from,_value)

IRs:
Emit BurnFrom(_from,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 175.sol-MiBoodleToken-cashInvestment(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_investor != 0)

IRs:
TMP_94(bool) = _investor != 0
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_tokens > 0)

IRs:
TMP_96(bool) = _tokens > 0
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now >= preFundingStart && now <= end)

IRs:
TMP_98(bool) = now >= preFundingStart
TMP_99(bool) = now <= end
TMP_100(bool) = TMP_98 && TMP_99
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
now < start && now >= preFundingStart

IRs:
TMP_102(bool) = now < start
TMP_103(bool) = now >= preFundingStart
TMP_104(bool) = TMP_102 && TMP_103
CONDITION TMP_104"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(safeAdd(totalSupply,_tokens) <= maxTokenForPreSale)

IRs:
TMP_105(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,_tokens)
TMP_106(bool) = TMP_105 <= maxTokenForPreSale
TMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(safeAdd(totalSupply,_tokens) <= maxTokenSale)

IRs:
TMP_108(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,_tokens)
TMP_109(bool) = TMP_108 <= maxTokenSale
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
assignTokens(_investor,_tokens)

IRs:
INTERNAL_CALL, MiBoodleToken.assignTokens(address,uint256)(_investor,_tokens)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
10->1;
}
// Function: 175.sol-MiBoodleToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now <= end && now >= preFundingStart)

IRs:
TMP_151(bool) = now <= end
TMP_152(bool) = now >= preFundingStart
TMP_153(bool) = TMP_151 && TMP_152
TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= minInvest)

IRs:
TMP_155(bool) = msg.value >= minInvest
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(safeAdd(investment[msg.sender],msg.value) <= maxInvest)

IRs:
REF_4(uint256) -> investment[msg.sender]
TMP_157(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_4,msg.value)
TMP_158(bool) = TMP_157 <= maxInvest
TMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
now < start

IRs:
TMP_160(bool) = now < start
CONDITION TMP_160"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
createdTokens = safeMul(msg.value,preFundingtokens)

IRs:
TMP_161(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(msg.value,preFundingtokens)
createdTokens(uint256) := TMP_161(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(safeAdd(totalSupply,createdTokens) <= maxTokenForPreSale)

IRs:
TMP_162(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,createdTokens)
TMP_163(bool) = TMP_162 <= maxTokenForPreSale
TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163)"];
7->10;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
createdTokens = safeMul(msg.value,fundingTokens)

IRs:
TMP_165(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(msg.value,fundingTokens)
createdTokens(uint256) := TMP_165(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(safeAdd(totalSupply,createdTokens) <= maxTokenSale)

IRs:
TMP_166(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,createdTokens)
TMP_167(bool) = TMP_166 <= maxTokenSale
TMP_168(None) = SOLIDITY_CALL require(bool)(TMP_167)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
investment[msg.sender] = safeAdd(investment[msg.sender],msg.value)

IRs:
REF_5(uint256) -> investment[msg.sender]
REF_6(uint256) -> investment[msg.sender]
TMP_169(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_6,msg.value)
REF_5(uint256) (->investment) := TMP_169(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
assignTokens(msg.sender,createdTokens)

IRs:
INTERNAL_CALL, MiBoodleToken.assignTokens(address,uint256)(msg.sender,createdTokens)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
Deposit(msg.sender,createdTokens)

IRs:
Emit Deposit(msg.sender,createdTokens)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
14->1;
}
// Function: 175.sol-MiBoodleToken-finalizeCrowdSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isCrowdSaleFinalized)

IRs:
TMP_131 = UnaryType.BANG isCrowdSaleFinalized 
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(multisig != 0 && vault != 0 && now > end)

IRs:
TMP_133(bool) = multisig != 0
TMP_134(bool) = vault != 0
TMP_135(bool) = TMP_133 && TMP_134
TMP_136(bool) = now > end
TMP_137(bool) = TMP_135 && TMP_136
TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(safeAdd(totalSupply,250000000000000000000000000) <= maxTokenSupply)

IRs:
TMP_139(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,250000000000000000000000000)
TMP_140(bool) = TMP_139 <= maxTokenSupply
TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assignTokens(multisig,250000000000000000000000000)

IRs:
INTERNAL_CALL, MiBoodleToken.assignTokens(address,uint256)(multisig,250000000000000000000000000)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(safeAdd(totalSupply,150000000000000000000000000) <= maxTokenSupply)

IRs:
TMP_143(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,150000000000000000000000000)
TMP_144(bool) = TMP_143 <= maxTokenSupply
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
assignTokens(vault,150000000000000000000000000)

IRs:
INTERNAL_CALL, MiBoodleToken.assignTokens(address,uint256)(vault,150000000000000000000000000)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isCrowdSaleFinalized = true

IRs:
isCrowdSaleFinalized(bool) := True(bool)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(multisig.send(address(this).balance))

IRs:
TMP_147 = CONVERT this to address
TMP_148(uint256) = SOLIDITY_CALL balance(address)(TMP_147)
TMP_149 = SEND dest:multisig value:TMP_148
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)"];
}
// Function: 175.sol-MiBoodleToken-halt()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
halted = true

IRs:
halted(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_257(bool) = msg.sender == owner
TMP_258(None) = SOLIDITY_CALL require(bool)(TMP_257)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 175.sol-MiBoodleToken-runIfHalted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(halted)

IRs:
TMP_256(None) = SOLIDITY_CALL require(bool)(halted)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 175.sol-MiBoodleToken-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_63(uint256) = a + b
c(uint256) := TMP_63(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_64(bool) = c >= a
TMP_65(None) = SOLIDITY_CALL assert(bool)(TMP_64)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-MiBoodleToken-safeDiv(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_59(uint256) = a / b
c(uint256) := TMP_59(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-MiBoodleToken-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_54(bool) = a == 0
CONDITION TMP_54"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_55(uint256) = a * b
c(uint256) := TMP_55(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_56(uint256) = c / a
TMP_57(bool) = TMP_56 == b
TMP_58(None) = SOLIDITY_CALL assert(bool)(TMP_57)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-MiBoodleToken-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_60(bool) = b <= a
TMP_61(None) = SOLIDITY_CALL assert(bool)(TMP_60)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_62(uint256) = a - b
RETURN TMP_62"];
}
// Function: 175.sol-MiBoodleToken-setFundingEndTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
end = now + _end

IRs:
TMP_79(uint256) = now + _end
end(uint256) := TMP_79(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setFundingStartTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
start = now + _start

IRs:
TMP_76(uint256) = now + _start
start(uint256) := TMP_76(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setFundingtokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
fundingTokens = _fundingTokens

IRs:
fundingTokens(uint256) := _fundingTokens(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setMaximumEtherToAccept(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
maxInvest = _maxInvest

IRs:
maxInvest(uint256) := _maxInvest(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setMiBoodleVault(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_vault != 0)

IRs:
TMP_91(bool) = _vault != 0
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
vault = _vault

IRs:
vault(address) := _vault(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setMinimumEtherToAccept(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minInvest = _minInvest

IRs:
minInvest(uint256) := _minInvest(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setMultisigWallet(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_multisig != 0)

IRs:
TMP_88(bool) = _multisig != 0
TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
multisig = _multisig

IRs:
multisig(address) := _multisig(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setPreFundingStartTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
preFundingStart = now + _preFundingStart

IRs:
TMP_73(uint256) = now + _preFundingStart
preFundingStart(uint256) := TMP_73(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setPreFundingtokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
preFundingtokens = _preFundingtokens

IRs:
preFundingtokens(uint256) := _preFundingtokens(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setTransferEnable(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isTransferEnable = _isTransferEnable

IRs:
isTransferEnable(bool) := _isTransferEnable(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-setUpgradeAgent(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(agent != 0x0 && msg.sender == upgradeMaster)

IRs:
TMP_240(bool) = agent != 0
TMP_241(bool) = msg.sender == upgradeMaster
TMP_242(bool) = TMP_240 && TMP_241
TMP_243(None) = SOLIDITY_CALL require(bool)(TMP_242)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
upgradeAgent = UpgradeAgent(agent)

IRs:
TMP_244 = CONVERT agent to UpgradeAgent
upgradeAgent(UpgradeAgent) := TMP_244(UpgradeAgent)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(upgradeAgent.isUpgradeAgent())

IRs:
TMP_245(bool) = HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:isUpgradeAgent, arguments:[]  
TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
upgradeAgentStatus = true

IRs:
upgradeAgentStatus(bool) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
upgradeAgent.setOriginalSupply()

IRs:
HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:setOriginalSupply, arguments:[]  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
UpgradeAgentSet(upgradeAgent)

IRs:
Emit UpgradeAgentSet(upgradeAgent)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 175.sol-MiBoodleToken-setUpgradeMaster(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(master != 0x0 && msg.sender == upgradeMaster)

IRs:
TMP_250(bool) = master != 0
TMP_251(bool) = msg.sender == upgradeMaster
TMP_252(bool) = TMP_250 && TMP_251
TMP_253(None) = SOLIDITY_CALL require(bool)(TMP_252)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
upgradeMaster = master

IRs:
upgradeMaster(address) := master(address)"];
}
// Function: 175.sol-MiBoodleToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = miBoodle

IRs:
name(string) := miBoodle(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = MIBO

IRs:
symbol(string) := MIBO(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint256) := 18(uint256)"];
}
// Function: 175.sol-MiBoodleToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
halted = false

IRs:
halted(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
isMiBoodleToken = false

IRs:
isMiBoodleToken(bool) := False(bool)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
upgradeAgentStatus = false

IRs:
upgradeAgentStatus(bool) := False(bool)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
maxTokenSupply = 600000000000000000000000000

IRs:
maxTokenSupply(uint256) := 600000000000000000000000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
maxTokenSale = 200000000000000000000000000

IRs:
maxTokenSale(uint256) := 200000000000000000000000000(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
maxTokenForPreSale = 100000000000000000000000000

IRs:
maxTokenForPreSale(uint256) := 100000000000000000000000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
isCrowdSaleFinalized = false

IRs:
isCrowdSaleFinalized(bool) := False(bool)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
minInvest = 1000000000000000000

IRs:
minInvest(uint256) := 1000000000000000000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
maxInvest = 50000000000000000000

IRs:
maxInvest(uint256) := 50000000000000000000(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
isTransferEnable = false

IRs:
isTransferEnable(bool) := False(bool)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
isReleasedOnce = false

IRs:
isReleasedOnce(bool) := False(bool)"];
}
// Function: 175.sol-MiBoodleToken-stopIfHalted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! halted)

IRs:
TMP_254 = UnaryType.BANG halted 
TMP_255(None) = SOLIDITY_CALL require(bool)(TMP_254)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 175.sol-MiBoodleToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isTransferEnable)

IRs:
TMP_173(None) = SOLIDITY_CALL require(bool)(isTransferEnable)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_to != 0 && _value > 0)

IRs:
TMP_174(bool) = _to != 0
TMP_175(bool) = _value > 0
TMP_176(bool) = TMP_174 && TMP_175
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
senderBalance = balances[msg.sender]

IRs:
REF_12(uint256) -> balances[msg.sender]
senderBalance(uint256) := REF_12(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(senderBalance >= _value)

IRs:
TMP_178(bool) = senderBalance >= _value
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
senderBalance = safeSub(senderBalance,_value)

IRs:
TMP_180(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(senderBalance,_value)
senderBalance(uint256) := TMP_180(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = senderBalance

IRs:
REF_13(uint256) -> balances[msg.sender]
REF_13(uint256) (->balances) := senderBalance(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = safeAdd(balances[_to],_value)

IRs:
REF_14(uint256) -> balances[_to]
REF_15(uint256) -> balances[_to]
TMP_181(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_15,_value)
REF_14(uint256) (->balances) := TMP_181(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: RETURN 10

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 175.sol-MiBoodleToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isTransferEnable)

IRs:
TMP_183(None) = SOLIDITY_CALL require(bool)(isTransferEnable)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_from != 0 && _to != 0 && _value > 0)

IRs:
TMP_184(bool) = _from != 0
TMP_185(bool) = _to != 0
TMP_186(bool) = TMP_184 && TMP_185
TMP_187(bool) = _value > 0
TMP_188(bool) = TMP_186 && TMP_187
TMP_189(None) = SOLIDITY_CALL require(bool)(TMP_188)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowed[_from][msg.sender] >= _value && balances[_from] >= _value)

IRs:
REF_16(mapping(address => uint256)) -> allowed[_from]
REF_17(uint256) -> REF_16[msg.sender]
TMP_190(bool) = REF_17 >= _value
REF_18(uint256) -> balances[_from]
TMP_191(bool) = REF_18 >= _value
TMP_192(bool) = TMP_190 && TMP_191
TMP_193(None) = SOLIDITY_CALL require(bool)(TMP_192)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = safeSub(balances[_from],_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_194(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_20,_value)
REF_19(uint256) (->balances) := TMP_194(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = safeAdd(balances[_to],_value)

IRs:
REF_21(uint256) -> balances[_to]
REF_22(uint256) -> balances[_to]
TMP_195(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_22,_value)
REF_21(uint256) (->balances) := TMP_195(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value)

IRs:
REF_23(mapping(address => uint256)) -> allowed[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
TMP_196(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_26,_value)
REF_24(uint256) (->allowed) := TMP_196(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: RETURN 9

EXPRESSION:
ok

IRs:
RETURN ok"];
}
// Function: 175.sol-MiBoodleToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_49 = CONVERT 0 to address
TMP_50(bool) = newOwner != TMP_49
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 175.sol-MiBoodleToken-unHalt()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
halted = false

IRs:
halted(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
runIfHalted()

IRs:
MODIFIER_CALL, Haltable.runIfHalted()()"];
3->1;
}
// Function: 175.sol-MiBoodleToken-upgrade(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(upgradeAgentStatus)

IRs:
TMP_227(None) = SOLIDITY_CALL require(bool)(upgradeAgentStatus)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value > 0 && upgradeAgent.owner() != 0x0)

IRs:
TMP_228(bool) = value > 0
TMP_229(address) = HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:owner, arguments:[]  
TMP_230(bool) = TMP_229 != 0
TMP_231(bool) = TMP_228 && TMP_230
TMP_232(None) = SOLIDITY_CALL require(bool)(TMP_231)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(value <= balances[msg.sender])

IRs:
REF_43(uint256) -> balances[msg.sender]
TMP_233(bool) = value <= REF_43
TMP_234(None) = SOLIDITY_CALL require(bool)(TMP_233)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = safeSub(balances[msg.sender],value)

IRs:
REF_44(uint256) -> balances[msg.sender]
REF_45(uint256) -> balances[msg.sender]
TMP_235(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_45,value)
REF_44(uint256) (->balances) := TMP_235(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = safeSub(totalSupply,value)

IRs:
TMP_236(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,value)
totalSupply(uint256) := TMP_236(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalUpgraded = safeAdd(totalUpgraded,value)

IRs:
TMP_237(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalUpgraded,value)
totalUpgraded(uint256) := TMP_237(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
upgradeAgent.upgradeFrom(msg.sender,value)

IRs:
HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:upgradeFrom, arguments:['msg.sender', 'value']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Upgrade(msg.sender,upgradeAgent,value)

IRs:
Emit Upgrade(msg.sender,upgradeAgent,value)"];
}
// Function: 175.sol-MiBoodleToken-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now <= end && multisig != address(0))

IRs:
TMP_117(bool) = now <= end
TMP_118 = CONVERT 0 to address
TMP_119(bool) = multisig != TMP_118
TMP_120(bool) = TMP_117 && TMP_119
TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! isReleasedOnce)

IRs:
TMP_122 = UnaryType.BANG isReleasedOnce 
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(address(this).balance >= 200000000000000000000)

IRs:
TMP_124 = CONVERT this to address
TMP_125(uint256) = SOLIDITY_CALL balance(address)(TMP_124)
TMP_126(bool) = TMP_125 >= 200000000000000000000
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isReleasedOnce = true

IRs:
isReleasedOnce(bool) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(multisig.send(200000000000000000000))

IRs:
TMP_128 = SEND dest:multisig value:200000000000000000000
TMP_129(None) = SOLIDITY_CALL assert(bool)(TMP_128)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 175.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 175.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_17(bool) = msg.sender == owner
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 175.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = newOwner != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 175.sol-SafeMath-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-SafeMath-safeDiv(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_5(uint256) = a / b
c(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-SafeMath-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-SafeMath-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 175.sol-UpgradeAgent-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_42(uint256) = a + b
c(uint256) := TMP_42(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_43(bool) = c >= a
TMP_44(None) = SOLIDITY_CALL assert(bool)(TMP_43)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-UpgradeAgent-safeDiv(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_38(uint256) = a / b
c(uint256) := TMP_38(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-UpgradeAgent-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_33(bool) = a == 0
CONDITION TMP_33"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_34(uint256) = a * b
c(uint256) := TMP_34(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_35(uint256) = c / a
TMP_36(bool) = TMP_35 == b
TMP_37(None) = SOLIDITY_CALL assert(bool)(TMP_36)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 175.sol-UpgradeAgent-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_39(bool) = b <= a
TMP_40(None) = SOLIDITY_CALL assert(bool)(TMP_39)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_41(uint256) = a - b
RETURN TMP_41"];
}
// Function: 175.sol-UpgradeAgent-setOriginalSupply()
digraph{
}
// Function: 175.sol-UpgradeAgent-upgradeFrom(address,uint256)
digraph{
}
}
