digraph G {
// Function: 2.sol-BasicToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_12(uint256) -> balances[_owner]
RETURN REF_12"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 2.sol-BasicToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_32(bool) = msg.sender == owner
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-BasicToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! (msg.data.length < size + 4))

IRs:
REF_13 -> LENGTH msg.data
TMP_34(uint256) = size + 4
TMP_35(bool) = REF_13 < TMP_34
TMP_36 = UnaryType.BANG TMP_35 
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-BasicToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
basisPointsRate = 0

IRs:
basisPointsRate(uint256) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
maximumFee = 0

IRs:
maximumFee(uint256) := 0(uint256)"];
}
// Function: 2.sol-BasicToken-totalSupply()
digraph{
}
// Function: 2.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fee = (_value.mul(basisPointsRate)).div(10000)

IRs:
TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] 
TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_20', '10000'] 
fee(uint256) := TMP_21(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
fee > maximumFee

IRs:
TMP_22(bool) = fee > maximumFee
CONDITION TMP_22"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fee = maximumFee

IRs:
fee(uint256) := maximumFee(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
sendAmount = _value.sub(fee)

IRs:
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] 
sendAmount(uint256) := TMP_23(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_4(uint256) -> balances[msg.sender]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_4', '_value'] 
REF_3(uint256) (->balances) := TMP_24(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(sendAmount)

IRs:
REF_6(uint256) -> balances[_to]
REF_7(uint256) -> balances[_to]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_7', 'sendAmount'] 
REF_6(uint256) (->balances) := TMP_25(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
fee > 0

IRs:
TMP_26(bool) = fee > 0
CONDITION TMP_26"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[owner] = balances[owner].add(fee)

IRs:
REF_9(uint256) -> balances[owner]
REF_10(uint256) -> balances[owner]
TMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_10', 'fee'] 
REF_9(uint256) (->balances) := TMP_27(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Transfer(msg.sender,owner,fee)

IRs:
Emit Transfer(msg.sender,owner,fee)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(msg.sender,_to,sendAmount)

IRs:
Emit Transfer(msg.sender,_to,sendAmount)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_30(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_30)"];
13->1;
}
// Function: 2.sol-BasicToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_17 = CONVERT 0 to address
TMP_18(bool) = newOwner != TMP_17
CONDITION TMP_18"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2.sol-BlackList-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2.sol-BlackList-addBlackList(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isBlackListed[_evilUser] = true

IRs:
REF_65(bool) -> isBlackListed[_evilUser]
REF_65(bool) (->isBlackListed) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
AddedBlackList(_evilUser)

IRs:
Emit AddedBlackList(_evilUser)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 2.sol-BlackList-balanceOf(address)
digraph{
}
// Function: 2.sol-BlackList-destroyBlackFunds(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isBlackListed[_blackListedUser])

IRs:
REF_67(bool) -> isBlackListed[_blackListedUser]
TMP_116(None) = SOLIDITY_CALL require(bool)(REF_67)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
dirtyFunds = balanceOf(_blackListedUser)

IRs:
TMP_117(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_blackListedUser)
dirtyFunds(uint256) := TMP_117(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_blackListedUser] = 0

IRs:
REF_68(uint256) -> balances[_blackListedUser]
REF_68(uint256) (->balances) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_totalSupply -= dirtyFunds

IRs:
_totalSupply(uint256) = _totalSupply - dirtyFunds"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
DestroyedBlackFunds(_blackListedUser,dirtyFunds)

IRs:
Emit DestroyedBlackFunds(_blackListedUser,dirtyFunds)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 2.sol-BlackList-getBlackListStatus(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
isBlackListed[_maker]

IRs:
REF_64(bool) -> isBlackListed[_maker]
RETURN REF_64"];
}
// Function: 2.sol-BlackList-getOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owner

IRs:
RETURN owner"];
}
// Function: 2.sol-BlackList-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_124(bool) = msg.sender == owner
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-BlackList-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! (msg.data.length < size + 4))

IRs:
REF_69 -> LENGTH msg.data
TMP_120(uint256) = size + 4
TMP_121(bool) = REF_69 < TMP_120
TMP_122 = UnaryType.BANG TMP_121 
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-BlackList-removeBlackList(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isBlackListed[_clearedUser] = false

IRs:
REF_66(bool) -> isBlackListed[_clearedUser]
REF_66(bool) (->isBlackListed) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RemovedBlackList(_clearedUser)

IRs:
Emit RemovedBlackList(_clearedUser)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 2.sol-BlackList-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
basisPointsRate = 0

IRs:
basisPointsRate(uint256) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
maximumFee = 0

IRs:
maximumFee(uint256) := 0(uint256)"];
}
// Function: 2.sol-BlackList-totalSupply()
digraph{
}
// Function: 2.sol-BlackList-transfer(address,uint256)
digraph{
}
// Function: 2.sol-BlackList-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_109 = CONVERT 0 to address
TMP_110(bool) = newOwner != TMP_109
CONDITION TMP_110"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 2.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 2.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 2.sol-ERC20-totalSupply()
digraph{
}
// Function: 2.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 2.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 2.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 2.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 2.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 2.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_15(bool) = msg.sender == owner
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = newOwner != TMP_12
CONDITION TMP_13"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2.sol-Pausable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2.sol-Pausable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_92(bool) = msg.sender == owner
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-Pausable-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 2.sol-Pausable-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 2.sol-Pausable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_83 = CONVERT 0 to address
TMP_84(bool) = newOwner != TMP_83
CONDITION TMP_84"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2.sol-Pausable-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 2.sol-Pausable-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_94 = UnaryType.BANG paused 
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-Pausable-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_96(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_5(uint256) = a / b
c(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 2.sol-StandardToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_48(mapping(address => uint256)) -> allowed[_owner]
REF_49(uint256) -> REF_48[_spender]
RETURN REF_49"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 2.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! ((_value != 0) && (allowed[msg.sender][_spender] != 0)))

IRs:
TMP_67(bool) = _value != 0
REF_44(mapping(address => uint256)) -> allowed[msg.sender]
REF_45(uint256) -> REF_44[_spender]
TMP_68(bool) = REF_45 != 0
TMP_69(bool) = TMP_67 && TMP_68
TMP_70 = UnaryType.BANG TMP_69 
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_46(mapping(address => uint256)) -> allowed[msg.sender]
REF_47(uint256) -> REF_46[_spender]
REF_47(uint256) (->allowed) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_73(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_73)"];
4->1;
}
// Function: 2.sol-StandardToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_26(uint256) -> balances[_owner]
RETURN REF_26"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 2.sol-StandardToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_81(bool) = msg.sender == owner
TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-StandardToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! (msg.data.length < size + 4))

IRs:
REF_50 -> LENGTH msg.data
TMP_77(uint256) = size + 4
TMP_78(bool) = REF_50 < TMP_77
TMP_79 = UnaryType.BANG TMP_78 
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-StandardToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_UINT = 2 ** 256 - 1

IRs:
TMP_75(uint256) = 2 ** 256
TMP_76(uint256) = TMP_75 - 1
MAX_UINT(uint256) := TMP_76(uint256)"];
}
// Function: 2.sol-StandardToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
basisPointsRate = 0

IRs:
basisPointsRate(uint256) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
maximumFee = 0

IRs:
maximumFee(uint256) := 0(uint256)"];
}
// Function: 2.sol-StandardToken-totalSupply()
digraph{
}
// Function: 2.sol-StandardToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fee = (_value.mul(basisPointsRate)).div(10000)

IRs:
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] 
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', '10000'] 
fee(uint256) := TMP_39(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
fee > maximumFee

IRs:
TMP_40(bool) = fee > maximumFee
CONDITION TMP_40"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fee = maximumFee

IRs:
fee(uint256) := maximumFee(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
sendAmount = _value.sub(fee)

IRs:
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] 
sendAmount(uint256) := TMP_41(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_17(uint256) -> balances[msg.sender]
REF_18(uint256) -> balances[msg.sender]
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_18', '_value'] 
REF_17(uint256) (->balances) := TMP_42(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(sendAmount)

IRs:
REF_20(uint256) -> balances[_to]
REF_21(uint256) -> balances[_to]
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_21', 'sendAmount'] 
REF_20(uint256) (->balances) := TMP_43(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
fee > 0

IRs:
TMP_44(bool) = fee > 0
CONDITION TMP_44"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[owner] = balances[owner].add(fee)

IRs:
REF_23(uint256) -> balances[owner]
REF_24(uint256) -> balances[owner]
TMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_24', 'fee'] 
REF_23(uint256) (->balances) := TMP_45(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Transfer(msg.sender,owner,fee)

IRs:
Emit Transfer(msg.sender,owner,fee)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(msg.sender,_to,sendAmount)

IRs:
Emit Transfer(msg.sender,_to,sendAmount)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_48(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_48)"];
13->1;
}
// Function: 2.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->17;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_allowance = allowed[_from][msg.sender]

IRs:
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
_allowance(uint256) := REF_28(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
fee = (_value.mul(basisPointsRate)).div(10000)

IRs:
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] 
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_53', '10000'] 
fee(uint256) := TMP_54(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
fee > maximumFee

IRs:
TMP_55(bool) = fee > maximumFee
CONDITION TMP_55"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
fee = maximumFee

IRs:
fee(uint256) := maximumFee(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
_allowance < MAX_UINT

IRs:
TMP_56(bool) = _allowance < MAX_UINT
CONDITION TMP_56"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
allowed[_from][msg.sender] = _allowance.sub(_value)

IRs:
REF_31(mapping(address => uint256)) -> allowed[_from]
REF_32(uint256) -> REF_31[msg.sender]
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_allowance', '_value'] 
REF_32(uint256) (->allowed) := TMP_57(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
sendAmount = _value.sub(fee)

IRs:
TMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] 
sendAmount(uint256) := TMP_58(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_35(uint256) -> balances[_from]
REF_36(uint256) -> balances[_from]
TMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_36', '_value'] 
REF_35(uint256) (->balances) := TMP_59(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
balances[_to] = balances[_to].add(sendAmount)

IRs:
REF_38(uint256) -> balances[_to]
REF_39(uint256) -> balances[_to]
TMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_39', 'sendAmount'] 
REF_38(uint256) (->balances) := TMP_60(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
fee > 0

IRs:
TMP_61(bool) = fee > 0
CONDITION TMP_61"];
12->13[label="True"];
12->15[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
balances[owner] = balances[owner].add(fee)

IRs:
REF_41(uint256) -> balances[owner]
REF_42(uint256) -> balances[owner]
TMP_62(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_42', 'fee'] 
REF_41(uint256) (->balances) := TMP_62(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(_from,owner,fee)

IRs:
Emit Transfer(_from,owner,fee)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Transfer(_from,_to,sendAmount)

IRs:
Emit Transfer(_from,_to,sendAmount)"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
onlyPayloadSize(3 * 32)

IRs:
TMP_65(uint256) = 3 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_65)"];
17->1;
}
// Function: 2.sol-StandardToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_50 = CONVERT 0 to address
TMP_51(bool) = newOwner != TMP_50
CONDITION TMP_51"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2.sol-USDCToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2.sol-USDCToken-USDCToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_totalSupply = 100000000

IRs:
_totalSupply(uint256) := 100000000(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = USDC Token

IRs:
name(string) := USDC Token(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
symbol = USDC

IRs:
symbol(string) := USDC(string)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
decimals = 6

IRs:
decimals(uint256) := 6(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] = _totalSupply

IRs:
REF_148(uint256) -> balances[owner]
REF_148(uint256) (->balances) := _totalSupply(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
deprecated = false

IRs:
deprecated(bool) := False(bool)"];
}
// Function: 2.sol-USDCToken-addBlackList(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isBlackListed[_evilUser] = true

IRs:
REF_108(bool) -> isBlackListed[_evilUser]
REF_108(bool) (->isBlackListed) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
AddedBlackList(_evilUser)

IRs:
Emit AddedBlackList(_evilUser)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 2.sol-USDCToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
deprecated

IRs:
CONDITION deprecated"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
StandardToken(upgradedAddress).allowance(_owner,_spender)

IRs:
TMP_242 = CONVERT upgradedAddress to StandardToken
TMP_243(uint256) = HIGH_LEVEL_CALL, dest:TMP_242(StandardToken), function:allowance, arguments:['_owner', '_spender']  
RETURN TMP_243"];
3[label="Node Type: RETURN 3

EXPRESSION:
super.allowance(_owner,_spender)

IRs:
TMP_244(uint256) = INTERNAL_CALL, StandardToken.allowance(address,address)(_owner,_spender)
RETURN TMP_244"];
5[label="Node Type: RETURN 5

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 2.sol-USDCToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
deprecated

IRs:
CONDITION deprecated"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender,_spender,_value)

IRs:
TMP_237 = CONVERT upgradedAddress to UpgradedStandardToken
HIGH_LEVEL_CALL, dest:TMP_237(UpgradedStandardToken), function:approveByLegacy, arguments:['msg.sender', '_spender', '_value']  
RETURN TMP_238"];
3[label="Node Type: RETURN 3

EXPRESSION:
super.approve(_spender,_value)

IRs:
INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
RETURN TMP_239"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_240(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_240)"];
5->1;
}
// Function: 2.sol-USDCToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
deprecated

IRs:
CONDITION deprecated"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
UpgradedStandardToken(upgradedAddress).balanceOf(who)

IRs:
TMP_234 = CONVERT upgradedAddress to UpgradedStandardToken
TMP_235(uint256) = HIGH_LEVEL_CALL, dest:TMP_234(UpgradedStandardToken), function:balanceOf, arguments:['who']  
RETURN TMP_235"];
3[label="Node Type: RETURN 3

EXPRESSION:
super.balanceOf(who)

IRs:
TMP_236(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(who)
RETURN TMP_236"];
}
// Function: 2.sol-USDCToken-deprecate(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
deprecated = true

IRs:
deprecated(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
upgradedAddress = _upgradedAddress

IRs:
upgradedAddress(address) := _upgradedAddress(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Deprecate(_upgradedAddress)

IRs:
Emit Deprecate(_upgradedAddress)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2.sol-USDCToken-destroyBlackFunds(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isBlackListed[_blackListedUser])

IRs:
REF_110(bool) -> isBlackListed[_blackListedUser]
TMP_175(None) = SOLIDITY_CALL require(bool)(REF_110)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
dirtyFunds = balanceOf(_blackListedUser)

IRs:
TMP_176(uint256) = INTERNAL_CALL, USDCToken.balanceOf(address)(_blackListedUser)
dirtyFunds(uint256) := TMP_176(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_blackListedUser] = 0

IRs:
REF_111(uint256) -> balances[_blackListedUser]
REF_111(uint256) (->balances) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_totalSupply -= dirtyFunds

IRs:
_totalSupply(uint256) = _totalSupply - dirtyFunds"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
DestroyedBlackFunds(_blackListedUser,dirtyFunds)

IRs:
Emit DestroyedBlackFunds(_blackListedUser,dirtyFunds)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 2.sol-USDCToken-getBlackListStatus(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
isBlackListed[_maker]

IRs:
REF_107(bool) -> isBlackListed[_maker]
RETURN REF_107"];
}
// Function: 2.sol-USDCToken-getOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owner

IRs:
RETURN owner"];
}
// Function: 2.sol-USDCToken-issue(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_totalSupply + amount > _totalSupply)

IRs:
TMP_249(uint256) = _totalSupply + amount
TMP_250(bool) = TMP_249 > _totalSupply
TMP_251(None) = SOLIDITY_CALL require(bool)(TMP_250)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[owner] + amount > balances[owner])

IRs:
REF_157(uint256) -> balances[owner]
TMP_252(uint256) = REF_157 + amount
REF_158(uint256) -> balances[owner]
TMP_253(bool) = TMP_252 > REF_158
TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] += amount

IRs:
REF_159(uint256) -> balances[owner]
REF_159(-> balances) = REF_159 + amount"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_totalSupply += amount

IRs:
_totalSupply(uint256) = _totalSupply + amount"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Issue(amount)

IRs:
Emit Issue(amount)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 2.sol-USDCToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_277(bool) = msg.sender == owner
TMP_278(None) = SOLIDITY_CALL require(bool)(TMP_277)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-USDCToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! (msg.data.length < size + 4))

IRs:
REF_163 -> LENGTH msg.data
TMP_273(uint256) = size + 4
TMP_274(bool) = REF_163 < TMP_273
TMP_275 = UnaryType.BANG TMP_274 
TMP_276(None) = SOLIDITY_CALL require(bool)(TMP_275)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-USDCToken-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 2.sol-USDCToken-redeem(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_totalSupply >= amount)

IRs:
TMP_257(bool) = _totalSupply >= amount
TMP_258(None) = SOLIDITY_CALL require(bool)(TMP_257)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[owner] >= amount)

IRs:
REF_160(uint256) -> balances[owner]
TMP_259(bool) = REF_160 >= amount
TMP_260(None) = SOLIDITY_CALL require(bool)(TMP_259)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply -= amount

IRs:
_totalSupply(uint256) = _totalSupply - amount"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[owner] -= amount

IRs:
REF_161(uint256) -> balances[owner]
REF_161(-> balances) = REF_161 - amount"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Redeem(amount)

IRs:
Emit Redeem(amount)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 2.sol-USDCToken-removeBlackList(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isBlackListed[_clearedUser] = false

IRs:
REF_109(bool) -> isBlackListed[_clearedUser]
REF_109(bool) (->isBlackListed) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RemovedBlackList(_clearedUser)

IRs:
Emit RemovedBlackList(_clearedUser)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 2.sol-USDCToken-setParams(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newBasisPoints < 20)

IRs:
TMP_263(bool) = newBasisPoints < 20
TMP_264(None) = SOLIDITY_CALL require(bool)(TMP_263)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(newMaxFee < 50)

IRs:
TMP_265(bool) = newMaxFee < 50
TMP_266(None) = SOLIDITY_CALL require(bool)(TMP_265)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
basisPointsRate = newBasisPoints

IRs:
basisPointsRate(uint256) := newBasisPoints(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
maximumFee = newMaxFee.mul(10 ** decimals)

IRs:
TMP_267(uint256) = 10 ** decimals
TMP_268(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['newMaxFee', 'TMP_267'] 
maximumFee(uint256) := TMP_268(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Params(basisPointsRate,maximumFee)

IRs:
Emit Params(basisPointsRate,maximumFee)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 2.sol-USDCToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_UINT = 2 ** 256 - 1

IRs:
TMP_271(uint256) = 2 ** 256
TMP_272(uint256) = TMP_271 - 1
MAX_UINT(uint256) := TMP_272(uint256)"];
}
// Function: 2.sol-USDCToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
basisPointsRate = 0

IRs:
basisPointsRate(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
maximumFee = 0

IRs:
maximumFee(uint256) := 0(uint256)"];
}
// Function: 2.sol-USDCToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
deprecated

IRs:
CONDITION deprecated"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
StandardToken(upgradedAddress).totalSupply()

IRs:
TMP_247 = CONVERT upgradedAddress to StandardToken
TMP_248(uint256) = HIGH_LEVEL_CALL, dest:TMP_247(StandardToken), function:totalSupply, arguments:[]  
RETURN TMP_248"];
3[label="Node Type: RETURN 3

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply"];
}
// Function: 2.sol-USDCToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isBlackListed[msg.sender])

IRs:
REF_149(bool) -> isBlackListed[msg.sender]
TMP_222 = UnaryType.BANG REF_149 
TMP_223(None) = SOLIDITY_CALL require(bool)(TMP_222)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
deprecated

IRs:
CONDITION deprecated"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender,_to,_value)

IRs:
TMP_224 = CONVERT upgradedAddress to UpgradedStandardToken
HIGH_LEVEL_CALL, dest:TMP_224(UpgradedStandardToken), function:transferByLegacy, arguments:['msg.sender', '_to', '_value']  
RETURN TMP_225"];
4[label="Node Type: RETURN 4

EXPRESSION:
super.transfer(_to,_value)

IRs:
INTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)
RETURN TMP_226"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
6->1;
}
// Function: 2.sol-USDCToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isBlackListed[_from])

IRs:
REF_151(bool) -> isBlackListed[_from]
TMP_228 = UnaryType.BANG REF_151 
TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
deprecated

IRs:
CONDITION deprecated"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender,_from,_to,_value)

IRs:
TMP_230 = CONVERT upgradedAddress to UpgradedStandardToken
HIGH_LEVEL_CALL, dest:TMP_230(UpgradedStandardToken), function:transferFromByLegacy, arguments:['msg.sender', '_from', '_to', '_value']  
RETURN TMP_231"];
4[label="Node Type: RETURN 4

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_232"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
6->1;
}
// Function: 2.sol-USDCToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_191 = CONVERT 0 to address
TMP_192(bool) = newOwner != TMP_191
CONDITION TMP_192"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2.sol-USDCToken-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 2.sol-USDCToken-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_279 = UnaryType.BANG paused 
TMP_280(None) = SOLIDITY_CALL require(bool)(TMP_279)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-USDCToken-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_281(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-UpgradedStandardToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2.sol-UpgradedStandardToken-allowance(address,address)
digraph{
}
// Function: 2.sol-UpgradedStandardToken-approve(address,uint256)
digraph{
}
// Function: 2.sol-UpgradedStandardToken-approveByLegacy(address,address,uint256)
digraph{
}
// Function: 2.sol-UpgradedStandardToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_105(uint256) -> balances[_owner]
RETURN REF_105"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 2.sol-UpgradedStandardToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_169(bool) = msg.sender == owner
TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-UpgradedStandardToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! (msg.data.length < size + 4))

IRs:
REF_106 -> LENGTH msg.data
TMP_165(uint256) = size + 4
TMP_166(bool) = REF_106 < TMP_165
TMP_167 = UnaryType.BANG TMP_166 
TMP_168(None) = SOLIDITY_CALL require(bool)(TMP_167)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2.sol-UpgradedStandardToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_UINT = 2 ** 256 - 1

IRs:
TMP_163(uint256) = 2 ** 256
TMP_164(uint256) = TMP_163 - 1
MAX_UINT(uint256) := TMP_164(uint256)"];
}
// Function: 2.sol-UpgradedStandardToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
basisPointsRate = 0

IRs:
basisPointsRate(uint256) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
maximumFee = 0

IRs:
maximumFee(uint256) := 0(uint256)"];
}
// Function: 2.sol-UpgradedStandardToken-totalSupply()
digraph{
}
// Function: 2.sol-UpgradedStandardToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fee = (_value.mul(basisPointsRate)).div(10000)

IRs:
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] 
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_148', '10000'] 
fee(uint256) := TMP_149(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
fee > maximumFee

IRs:
TMP_150(bool) = fee > maximumFee
CONDITION TMP_150"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fee = maximumFee

IRs:
fee(uint256) := maximumFee(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
sendAmount = _value.sub(fee)

IRs:
TMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] 
sendAmount(uint256) := TMP_151(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_96(uint256) -> balances[msg.sender]
REF_97(uint256) -> balances[msg.sender]
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_97', '_value'] 
REF_96(uint256) (->balances) := TMP_152(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(sendAmount)

IRs:
REF_99(uint256) -> balances[_to]
REF_100(uint256) -> balances[_to]
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_100', 'sendAmount'] 
REF_99(uint256) (->balances) := TMP_153(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
fee > 0

IRs:
TMP_154(bool) = fee > 0
CONDITION TMP_154"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[owner] = balances[owner].add(fee)

IRs:
REF_102(uint256) -> balances[owner]
REF_103(uint256) -> balances[owner]
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_103', 'fee'] 
REF_102(uint256) (->balances) := TMP_155(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Transfer(msg.sender,owner,fee)

IRs:
Emit Transfer(msg.sender,owner,fee)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(msg.sender,_to,sendAmount)

IRs:
Emit Transfer(msg.sender,_to,sendAmount)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_158(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_158)"];
13->1;
}
// Function: 2.sol-UpgradedStandardToken-transferByLegacy(address,address,uint256)
digraph{
}
// Function: 2.sol-UpgradedStandardToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 2.sol-UpgradedStandardToken-transferFromByLegacy(address,address,address,uint256)
digraph{
}
// Function: 2.sol-UpgradedStandardToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
newOwner != address(0)

IRs:
TMP_160 = CONVERT 0 to address
TMP_161(bool) = newOwner != TMP_160
CONDITION TMP_161"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
}
