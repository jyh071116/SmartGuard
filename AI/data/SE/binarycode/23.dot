digraph G {
// Function: 23.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 23.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 23.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_35 = CONVERT 0 to address
TMP_36(bool) = _to != TMP_35
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_38(bool) = _value <= REF_0
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_40(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_41(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 23.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 23.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_16(uint256) -> balances[msg.sender]
TMP_51(bool) = _value <= REF_16
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_17(uint256) -> balances[burner]
REF_18(uint256) -> balances[burner]
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_18', '_value'] 
REF_17(uint256) (->balances) := TMP_53(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_54(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(burner,address(0),_value)

IRs:
TMP_56 = CONVERT 0 to address
Emit Transfer(burner,TMP_56,_value)"];
}
// Function: 23.sol-BurnableToken-totalSupply()
digraph{
}
// Function: 23.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 23.sol-Cloudbric-Cloudbric(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply_ = INITIAL_SUPPLY

IRs:
totalSupply_(uint256) := INITIAL_SUPPLY(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = totalSupply_

IRs:
REF_110(uint256) -> balances[msg.sender]
REF_110(uint256) (->balances) := totalSupply_(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0x0),msg.sender,totalSupply_)

IRs:
TMP_120 = CONVERT 0 to address
Emit Transfer(TMP_120,msg.sender,totalSupply_)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
adminAddr = _adminAddr

IRs:
adminAddr(address) := _adminAddr(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
approve(adminAddr,ADMIN_ALLOWANCE)

IRs:
TMP_122(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(adminAddr,ADMIN_ALLOWANCE)"];
}
// Function: 23.sol-Cloudbric-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 23.sol-Cloudbric-allowance(address,address)
digraph{
}
// Function: 23.sol-Cloudbric-approve(address,uint256)
digraph{
}
// Function: 23.sol-Cloudbric-balanceOf(address)
digraph{
}
// Function: 23.sol-Cloudbric-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transferEnabled)

IRs:
TMP_142(None) = SOLIDITY_CALL require(bool)(transferEnabled)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
super.burn(value)

IRs:
INTERNAL_CALL, BurnableToken.burn(uint256)(value)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 23.sol-Cloudbric-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_101(mapping(address => uint256)) -> allowed[msg.sender]
REF_102(uint256) -> REF_101[_spender]
oldValue(uint256) := REF_102(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_117(bool) = _subtractedValue > oldValue
CONDITION TMP_117"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_103(mapping(address => uint256)) -> allowed[msg.sender]
REF_104(uint256) -> REF_103[_spender]
REF_104(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_105(mapping(address => uint256)) -> allowed[msg.sender]
REF_106(uint256) -> REF_105[_spender]
TMP_118(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_106(uint256) (->allowed) := TMP_118(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_108(mapping(address => uint256)) -> allowed[msg.sender]
REF_109(uint256) -> REF_108[_spender]
Emit Approval(msg.sender,_spender,REF_109)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 23.sol-Cloudbric-disableTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferEnabled = false

IRs:
transferEnabled(bool) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 23.sol-Cloudbric-enableTransfer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferEnabled = true

IRs:
transferEnabled(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
approve(tokenSaleAddr,0)

IRs:
TMP_131(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(tokenSaleAddr,0)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 23.sol-Cloudbric-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_94(mapping(address => uint256)) -> allowed[msg.sender]
REF_95(uint256) -> REF_94[_spender]
REF_96(mapping(address => uint256)) -> allowed[msg.sender]
REF_97(uint256) -> REF_96[_spender]
TMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_97', '_addedValue'] 
REF_95(uint256) (->allowed) := TMP_115(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_99(mapping(address => uint256)) -> allowed[msg.sender]
REF_100(uint256) -> REF_99[_spender]
Emit Approval(msg.sender,_spender,REF_100)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 23.sol-Cloudbric-lockAccount(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_145(bool) = amount > 0
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
lockedAccounts[addr] = amount

IRs:
REF_111(uint256) -> lockedAccounts[addr]
REF_111(uint256) (->lockedAccounts) := amount(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyValidDestination(addr)

IRs:
MODIFIER_CALL, Cloudbric.onlyValidDestination(address)(addr)"];
4->1;
}
// Function: 23.sol-Cloudbric-onlyAllowedAmount(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[from].sub(amount) >= lockedAccounts[from])

IRs:
REF_113(uint256) -> balances[from]
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_113', 'amount'] 
REF_115(uint256) -> lockedAccounts[from]
TMP_182(bool) = TMP_181 >= REF_115
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Cloudbric-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_158(bool) = msg.sender == owner
TMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Cloudbric-onlyValidDestination(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(0x0) && to != address(this) && to != owner && to != adminAddr && to != tokenSaleAddr)

IRs:
TMP_169 = CONVERT 0 to address
TMP_170(bool) = to != TMP_169
TMP_171 = CONVERT this to address
TMP_172(bool) = to != TMP_171
TMP_173(bool) = TMP_170 && TMP_172
TMP_174(bool) = to != owner
TMP_175(bool) = TMP_173 && TMP_174
TMP_176(bool) = to != adminAddr
TMP_177(bool) = TMP_175 && TMP_176
TMP_178(bool) = to != tokenSaleAddr
TMP_179(bool) = TMP_177 && TMP_178
TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Cloudbric-onlyWhenTokenSaleAddrNotSet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tokenSaleAddr == address(0x0))

IRs:
TMP_166 = CONVERT 0 to address
TMP_167(bool) = tokenSaleAddr == TMP_166
TMP_168(None) = SOLIDITY_CALL require(bool)(TMP_167)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Cloudbric-onlyWhenTransferAllowed()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transferEnabled == true || msg.sender == adminAddr || msg.sender == tokenSaleAddr)

IRs:
TMP_160(bool) = transferEnabled == True
TMP_161(bool) = msg.sender == adminAddr
TMP_162(bool) = TMP_160 || TMP_161
TMP_163(bool) = msg.sender == tokenSaleAddr
TMP_164(bool) = TMP_162 || TMP_163
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Cloudbric-setTokenSaleAmount(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! transferEnabled)

IRs:
TMP_123 = UnaryType.BANG transferEnabled 
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)"];
1->8;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amount <= TOKEN_SALE_ALLOWANCE)

IRs:
TMP_125(bool) = amount <= TOKEN_SALE_ALLOWANCE
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
approve(_tokenSaleAddr,amount)

IRs:
TMP_127(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_tokenSaleAddr,amount)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokenSaleAddr = _tokenSaleAddr

IRs:
tokenSaleAddr(address) := _tokenSaleAddr(address)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyWhenTokenSaleAddrNotSet()

IRs:
MODIFIER_CALL, Cloudbric.onlyWhenTokenSaleAddrNotSet()()"];
7->1;
8[label="Node Type: IF 8

EXPRESSION:
(amountForSale == 0)

IRs:
TMP_130(bool) = amountForSale == 0
CONDITION TMP_130"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
amount = TOKEN_SALE_ALLOWANCE

IRs:
amount(uint256) := TOKEN_SALE_ALLOWANCE(uint256)"];
9->11;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
amount = amountForSale

IRs:
amount(uint256) := amountForSale(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->3;
}
// Function: 23.sol-Cloudbric-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
symbol = CLB

IRs:
symbol(string) := CLB(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
name = Cloudbric

IRs:
name(string) := Cloudbric(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals))

IRs:
TMP_151 = CONVERT decimals to uint256
TMP_152(uint256) = 10 ** TMP_151
TMP_153(uint256) = 1000000000 * TMP_152
INITIAL_SUPPLY(uint256) := TMP_153(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
TOKEN_SALE_ALLOWANCE = 540000000 * (10 ** uint256(decimals))

IRs:
TMP_154 = CONVERT decimals to uint256
TMP_155(uint256) = 10 ** TMP_154
TMP_156(uint256) = 540000000 * TMP_155
TOKEN_SALE_ALLOWANCE(uint256) := TMP_156(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
ADMIN_ALLOWANCE = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE

IRs:
TMP_157(uint256) = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE
ADMIN_ALLOWANCE(uint256) := TMP_157(uint256)"];
}
// Function: 23.sol-Cloudbric-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
transferEnabled = false

IRs:
transferEnabled(bool) := False(bool)"];
}
// Function: 23.sol-Cloudbric-totalSupply()
digraph{
}
// Function: 23.sol-Cloudbric-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transfer(to,value)

IRs:
TMP_134(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(to,value)
RETURN TMP_134"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyWhenTransferAllowed()

IRs:
MODIFIER_CALL, Cloudbric.onlyWhenTransferAllowed()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyValidDestination(to)

IRs:
MODIFIER_CALL, Cloudbric.onlyValidDestination(address)(to)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyAllowedAmount(msg.sender,value)

IRs:
MODIFIER_CALL, Cloudbric.onlyAllowedAmount(address,uint256)(msg.sender,value)"];
4->1;
}
// Function: 23.sol-Cloudbric-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transferFrom(from,to,value)

IRs:
TMP_138(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(from,to,value)
RETURN TMP_138"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyWhenTransferAllowed()

IRs:
MODIFIER_CALL, Cloudbric.onlyWhenTransferAllowed()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyValidDestination(to)

IRs:
MODIFIER_CALL, Cloudbric.onlyValidDestination(address)(to)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyAllowedAmount(from,value)

IRs:
MODIFIER_CALL, Cloudbric.onlyAllowedAmount(address,uint256)(from,value)"];
4->1;
}
// Function: 23.sol-Cloudbric-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_83 = CONVERT 0 to address
TMP_84(bool) = newOwner != TMP_83
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 23.sol-Cloudbric-unlockAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
lockedAccounts[addr] = 0

IRs:
REF_112(uint256) -> lockedAccounts[addr]
REF_112(uint256) (->lockedAccounts) := 0(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyValidDestination(addr)

IRs:
MODIFIER_CALL, Cloudbric.onlyValidDestination(address)(addr)"];
3->1;
}
// Function: 23.sol-CloudbricSale-CloudbricSale(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundAddress != address(0))

IRs:
TMP_195 = CONVERT 0 to address
TMP_196(bool) = fundAddress != TMP_195
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenAddress != address(0))

IRs:
TMP_198 = CONVERT 0 to address
TMP_199(bool) = tokenAddress != TMP_198
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token = Cloudbric(tokenAddress)

IRs:
TMP_201 = CONVERT tokenAddress to Cloudbric
token(Cloudbric) := TMP_201(Cloudbric)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
fundAddr = fundAddress

IRs:
fundAddr(address) := fundAddress(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
stage = Stages.Ended

IRs:
REF_116(CloudbricSale.Stages) -> Stages.Ended
stage(CloudbricSale.Stages) := REF_116(CloudbricSale.Stages)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
round = SaleRounds.EarlyInvestment

IRs:
REF_117(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment
round(CloudbricSale.SaleRounds) := REF_117(CloudbricSale.SaleRounds)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
roundIndex = uint8(round)

IRs:
TMP_202 = CONVERT round to uint8
roundIndex(uint8) := TMP_202(uint8)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
roundInfos[roundIndex].minContribution = BASE_MIN_CONTRIBUTION

IRs:
REF_118(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]
REF_119(uint256) -> REF_118.minContribution
REF_119(uint256) (->roundInfos) := BASE_MIN_CONTRIBUTION(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
roundInfos[roundIndex].maxContribution = UINT256_MAX

IRs:
REF_120(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]
REF_121(uint256) -> REF_120.maxContribution
REF_121(uint256) (->roundInfos) := UINT256_MAX(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
roundInfos[roundIndex].hardCap = BASE_HARD_CAP_PER_ROUND

IRs:
REF_122(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]
REF_123(uint256) -> REF_122.hardCap
REF_123(uint256) (->roundInfos) := BASE_HARD_CAP_PER_ROUND(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
roundInfos[roundIndex].weiRaised = 0

IRs:
REF_124(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]
REF_125(uint256) -> REF_124.weiRaised
REF_125(uint256) (->roundInfos) := 0(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
roundInfos[roundIndex].rate = BASE_CLB_TO_ETH_RATE

IRs:
REF_126(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]
REF_127(uint256) -> REF_126.rate
REF_127(uint256) (->roundInfos) := BASE_CLB_TO_ETH_RATE(uint256)"];
}
// Function: 23.sol-CloudbricSale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 23.sol-CloudbricSale-addManyToAllocationList(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(users.length == amounts.length)

IRs:
REF_190 -> LENGTH users
REF_191 -> LENGTH amounts
TMP_285(bool) = REF_190 == REF_191
TMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < users.length

IRs:
REF_192 -> LENGTH users
TMP_287(bool) = i < REF_192
CONDITION TMP_287"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
addToAllocationList(users[i],amounts[i])

IRs:
REF_193(address) -> users[i]
REF_194(uint256) -> amounts[i]
INTERNAL_CALL, CloudbricSale.addToAllocationList(address,uint256)(REF_193,REF_194)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_289(uint32) := i(uint32)
i(uint32) = i + 1"];
7->5;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
atRound(SaleRounds.EarlyInvestment)

IRs:
REF_195(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment
MODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_195)"];
9->1;
}
// Function: 23.sol-CloudbricSale-addManyToWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < users.length

IRs:
REF_130 -> LENGTH users
TMP_206(bool) = i < REF_130
CONDITION TMP_206"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
addToWhitelist(users[i])

IRs:
REF_131(address) -> users[i]
INTERNAL_CALL, CloudbricSale.addToWhitelist(address)(REF_131)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_208(uint32) := i(uint32)
i(uint32) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->3;
}
// Function: 23.sol-CloudbricSale-addToAllocationList(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allocationList[user].isAllowed = true

IRs:
REF_185(CloudbricSale.AllocationInfo) -> allocationList[user]
REF_186(bool) -> REF_185.isAllowed
REF_186(bool) (->allocationList) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allocationList[user].allowedAmount = amount

IRs:
REF_187(CloudbricSale.AllocationInfo) -> allocationList[user]
REF_188(uint256) -> REF_187.allowedAmount
REF_188(uint256) (->allocationList) := amount(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
atRound(SaleRounds.EarlyInvestment)

IRs:
REF_189(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment
MODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_189)"];
4->1;
}
// Function: 23.sol-CloudbricSale-addToWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[user] = true

IRs:
REF_132(bool) -> whitelist[user]
REF_132(bool) (->whitelist) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 23.sol-CloudbricSale-allocateTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(allocationList[to].isAllowed && tokenAmount <= allocationList[to].allowedAmount)

IRs:
REF_202(CloudbricSale.AllocationInfo) -> allocationList[to]
REF_203(bool) -> REF_202.isAllowed
REF_204(CloudbricSale.AllocationInfo) -> allocationList[to]
REF_205(uint256) -> REF_204.allowedAmount
TMP_299(bool) = tokenAmount <= REF_205
TMP_300(bool) = REF_203 && TMP_299
TMP_301(None) = SOLIDITY_CALL require(bool)(TMP_300)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
! token.transferFrom(token.owner(),to,tokenAmount)

IRs:
TMP_302(address) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:owner, arguments:[]  
TMP_303(bool) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:transferFrom, arguments:['TMP_302', 'to', 'tokenAmount']  
TMP_304 = UnaryType.BANG TMP_303 
CONDITION TMP_304"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_305(None) = SOLIDITY_CALL revert()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
atRound(SaleRounds.EarlyInvestment)

IRs:
REF_208(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment
MODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_208)"];
7->1;
}
// Function: 23.sol-CloudbricSale-allocateTokensToMany(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(toList.length == tokenAmountList.length)

IRs:
REF_209 -> LENGTH toList
REF_210 -> LENGTH tokenAmountList
TMP_308(bool) = REF_209 == REF_210
TMP_309(None) = SOLIDITY_CALL require(bool)(TMP_308)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->8;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < toList.length

IRs:
REF_211 -> LENGTH toList
TMP_310(bool) = i < REF_211
CONDITION TMP_310"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allocateTokens(toList[i],tokenAmountList[i])

IRs:
REF_212(address) -> toList[i]
REF_213(uint256) -> tokenAmountList[i]
TMP_311(bool) = INTERNAL_CALL, CloudbricSale.allocateTokens(address,uint256)(REF_212,REF_213)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_312(uint32) := i(uint32)
i(uint32) = i + 1"];
7->5;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
atRound(SaleRounds.EarlyInvestment)

IRs:
REF_214(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment
MODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_214)"];
10->1;
}
// Function: 23.sol-CloudbricSale-atRound(CloudbricSale.SaleRounds)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round == expectedRound)

IRs:
TMP_326(bool) = round == expectedRound
TMP_327(None) = SOLIDITY_CALL require(bool)(TMP_326)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-CloudbricSale-atStage(CloudbricSale.Stages)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(stage == expectedStage)

IRs:
TMP_324(bool) = stage == expectedStage
TMP_325(None) = SOLIDITY_CALL require(bool)(TMP_324)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-CloudbricSale-buy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
purchaser = msg.sender

IRs:
purchaser(address) := msg.sender(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
contributionInWei = msg.value

IRs:
contributionInWei(uint256) := msg.value(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokenAmount = contributionInWei.mul(roundInfos[uint8(round)].rate)

IRs:
TMP_265 = CONVERT round to uint8
REF_168(CloudbricSale.RoundInfo) -> roundInfos[TMP_265]
REF_169(uint256) -> REF_168.rate
TMP_266(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['contributionInWei', 'REF_169'] 
tokenAmount(uint256) := TMP_266(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
! token.transferFrom(token.owner(),purchaser,tokenAmount)

IRs:
TMP_267(address) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:owner, arguments:[]  
TMP_268(bool) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:transferFrom, arguments:['TMP_267', 'purchaser', 'tokenAmount']  
TMP_269 = UnaryType.BANG TMP_268 
CONDITION TMP_269"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_270(None) = SOLIDITY_CALL revert()()"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
totalWeiRaised = totalWeiRaised.add(contributionInWei)

IRs:
TMP_271(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalWeiRaised', 'contributionInWei'] 
totalWeiRaised(uint256) := TMP_271(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
roundInfos[uint8(round)].weiRaised = roundInfos[uint8(round)].weiRaised.add(contributionInWei)

IRs:
TMP_272 = CONVERT round to uint8
REF_173(CloudbricSale.RoundInfo) -> roundInfos[TMP_272]
REF_174(uint256) -> REF_173.weiRaised
TMP_273 = CONVERT round to uint8
REF_175(CloudbricSale.RoundInfo) -> roundInfos[TMP_273]
REF_176(uint256) -> REF_175.weiRaised
TMP_274(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_176', 'contributionInWei'] 
REF_174(uint256) (->roundInfos) := TMP_274(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
contPerRound[purchaser][uint8(round)] = contPerRound[purchaser][uint8(round)].add(contributionInWei)

IRs:
REF_178(mapping(uint8 => uint256)) -> contPerRound[purchaser]
TMP_275 = CONVERT round to uint8
REF_179(uint256) -> REF_178[TMP_275]
REF_180(mapping(uint8 => uint256)) -> contPerRound[purchaser]
TMP_276 = CONVERT round to uint8
REF_181(uint256) -> REF_180[TMP_276]
TMP_277(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_181', 'contributionInWei'] 
REF_179(uint256) (->contPerRound) := TMP_277(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
fundAddr.transfer(contributionInWei)

IRs:
Transfer dest:fundAddr value:contributionInWei"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
TokenPurchase(msg.sender,contributionInWei,tokenAmount)

IRs:
Emit TokenPurchase(msg.sender,contributionInWei,tokenAmount)"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
atStage(Stages.Started)

IRs:
REF_184(CloudbricSale.Stages) -> Stages.Started
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_184)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
onlyValidPurchase()

IRs:
MODIFIER_CALL, CloudbricSale.onlyValidPurchase()()"];
15->1;
}
// Function: 23.sol-CloudbricSale-endSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
endTime = now

IRs:
endTime(uint256) := now(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stage = Stages.Ended

IRs:
REF_165(CloudbricSale.Stages) -> Stages.Ended
stage(CloudbricSale.Stages) := REF_165(CloudbricSale.Stages)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
SaleEnded(endTime,totalWeiRaised,round)

IRs:
Emit SaleEnded(endTime,totalWeiRaised,round)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
atStage(Stages.Started)

IRs:
REF_166(CloudbricSale.Stages) -> Stages.Started
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_166)"];
5->1;
}
// Function: 23.sol-CloudbricSale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buy()

IRs:
TMP_203(bool) = INTERNAL_CALL, CloudbricSale.buy()()"];
}
// Function: 23.sol-CloudbricSale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_322(bool) = msg.sender == owner
TMP_323(None) = SOLIDITY_CALL require(bool)(TMP_322)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-CloudbricSale-onlyValidPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round <= SaleRounds.CrowdSale)

IRs:
REF_215(CloudbricSale.SaleRounds) -> SaleRounds.CrowdSale
TMP_328(bool) = round <= REF_215
TMP_329(None) = SOLIDITY_CALL require(bool)(TMP_328)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now >= startTime && now <= endTime)

IRs:
TMP_330(bool) = now >= startTime
TMP_331(bool) = now <= endTime
TMP_332(bool) = TMP_330 && TMP_331
TMP_333(None) = SOLIDITY_CALL require(bool)(TMP_332)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
contributionInWei = msg.value

IRs:
contributionInWei(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
purchaser = msg.sender

IRs:
purchaser(address) := msg.sender(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(whitelist[purchaser])

IRs:
REF_216(bool) -> whitelist[purchaser]
TMP_334(None) = SOLIDITY_CALL require(bool)(REF_216)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(purchaser != address(0))

IRs:
TMP_335 = CONVERT 0 to address
TMP_336(bool) = purchaser != TMP_335
TMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(contributionInWei >= roundInfos[uint8(round)].minContribution)

IRs:
TMP_338 = CONVERT round to uint8
REF_217(CloudbricSale.RoundInfo) -> roundInfos[TMP_338]
REF_218(uint256) -> REF_217.minContribution
TMP_339(bool) = contributionInWei >= REF_218
TMP_340(None) = SOLIDITY_CALL require(bool)(TMP_339)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(contPerRound[purchaser][uint8(round)].add(contributionInWei) <= roundInfos[uint8(round)].maxContribution)

IRs:
REF_219(mapping(uint8 => uint256)) -> contPerRound[purchaser]
TMP_341 = CONVERT round to uint8
REF_220(uint256) -> REF_219[TMP_341]
TMP_342(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_220', 'contributionInWei'] 
TMP_343 = CONVERT round to uint8
REF_222(CloudbricSale.RoundInfo) -> roundInfos[TMP_343]
REF_223(uint256) -> REF_222.maxContribution
TMP_344(bool) = TMP_342 <= REF_223
TMP_345(None) = SOLIDITY_CALL require(bool)(TMP_344)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(roundInfos[uint8(round)].weiRaised.add(contributionInWei) <= roundInfos[uint8(round)].hardCap)

IRs:
TMP_346 = CONVERT round to uint8
REF_224(CloudbricSale.RoundInfo) -> roundInfos[TMP_346]
REF_225(uint256) -> REF_224.weiRaised
TMP_347(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_225', 'contributionInWei'] 
TMP_348 = CONVERT round to uint8
REF_227(CloudbricSale.RoundInfo) -> roundInfos[TMP_348]
REF_228(uint256) -> REF_227.hardCap
TMP_349(bool) = TMP_347 <= REF_228
TMP_350(None) = SOLIDITY_CALL require(bool)(TMP_349)"];
9->10;
10[label="Node Type: _ 10
"];
}
// Function: 23.sol-CloudbricSale-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 23.sol-CloudbricSale-removeFromAllocationList(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allocationList[user].isAllowed = false

IRs:
REF_196(CloudbricSale.AllocationInfo) -> allocationList[user]
REF_197(bool) -> REF_196.isAllowed
REF_197(bool) (->allocationList) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
atRound(SaleRounds.EarlyInvestment)

IRs:
REF_198(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment
MODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_198)"];
3->1;
}
// Function: 23.sol-CloudbricSale-removeFromWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[user] = false

IRs:
REF_135(bool) -> whitelist[user]
REF_135(bool) (->whitelist) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 23.sol-CloudbricSale-removeManyFromAllocationList(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < users.length

IRs:
REF_199 -> LENGTH users
TMP_294(bool) = i < REF_199
CONDITION TMP_294"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
removeFromAllocationList(users[i])

IRs:
REF_200(address) -> users[i]
INTERNAL_CALL, CloudbricSale.removeFromAllocationList(address)(REF_200)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_296(uint32) := i(uint32)
i(uint32) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
atRound(SaleRounds.EarlyInvestment)

IRs:
REF_201(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment
MODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_201)"];
8->3;
}
// Function: 23.sol-CloudbricSale-removeManyFromWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < users.length

IRs:
REF_133 -> LENGTH users
TMP_211(bool) = i < REF_133
CONDITION TMP_211"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
removeFromWhitelist(users[i])

IRs:
REF_134(address) -> users[i]
INTERNAL_CALL, CloudbricSale.removeFromWhitelist(address)(REF_134)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_213(uint32) := i(uint32)
i(uint32) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->3;
}
// Function: 23.sol-CloudbricSale-setHardCapForRound(CloudbricSale.SaleRounds,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round <= _round)

IRs:
TMP_230(bool) = round <= _round
TMP_231(None) = SOLIDITY_CALL require(bool)(TMP_230)"];
1->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
atStage(Stages.SetUp)

IRs:
REF_146(CloudbricSale.Stages) -> Stages.SetUp
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_146)"];
4->1;
5[label="Node Type: IF 5

EXPRESSION:
(_hardCap == 0)

IRs:
TMP_234(bool) = _hardCap == 0
CONDITION TMP_234"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundInfos[uint8(_round)].hardCap = BASE_HARD_CAP_PER_ROUND

IRs:
TMP_235 = CONVERT _round to uint8
REF_147(CloudbricSale.RoundInfo) -> roundInfos[TMP_235]
REF_148(uint256) -> REF_147.hardCap
REF_148(uint256) (->roundInfos) := BASE_HARD_CAP_PER_ROUND(uint256)"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundInfos[uint8(_round)].hardCap = _hardCap

IRs:
TMP_236 = CONVERT _round to uint8
REF_149(CloudbricSale.RoundInfo) -> roundInfos[TMP_236]
REF_150(uint256) -> REF_149.hardCap
REF_150(uint256) (->roundInfos) := _hardCap(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 23.sol-CloudbricSale-setMaxContributionForRound(CloudbricSale.SaleRounds,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round <= _round)

IRs:
TMP_223(bool) = round <= _round
TMP_224(None) = SOLIDITY_CALL require(bool)(TMP_223)"];
1->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
atStage(Stages.SetUp)

IRs:
REF_141(CloudbricSale.Stages) -> Stages.SetUp
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_141)"];
4->1;
5[label="Node Type: IF 5

EXPRESSION:
(_maxContribution == 0)

IRs:
TMP_227(bool) = _maxContribution == 0
CONDITION TMP_227"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundInfos[uint8(_round)].maxContribution = UINT256_MAX

IRs:
TMP_228 = CONVERT _round to uint8
REF_142(CloudbricSale.RoundInfo) -> roundInfos[TMP_228]
REF_143(uint256) -> REF_142.maxContribution
REF_143(uint256) (->roundInfos) := UINT256_MAX(uint256)"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundInfos[uint8(_round)].maxContribution = _maxContribution

IRs:
TMP_229 = CONVERT _round to uint8
REF_144(CloudbricSale.RoundInfo) -> roundInfos[TMP_229]
REF_145(uint256) -> REF_144.maxContribution
REF_145(uint256) (->roundInfos) := _maxContribution(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 23.sol-CloudbricSale-setMinContributionForRound(CloudbricSale.SaleRounds,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round <= _round)

IRs:
TMP_216(bool) = round <= _round
TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)"];
1->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
atStage(Stages.SetUp)

IRs:
REF_136(CloudbricSale.Stages) -> Stages.SetUp
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_136)"];
4->1;
5[label="Node Type: IF 5

EXPRESSION:
(_minContribution == 0)

IRs:
TMP_220(bool) = _minContribution == 0
CONDITION TMP_220"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundInfos[uint8(_round)].minContribution = BASE_MIN_CONTRIBUTION

IRs:
TMP_221 = CONVERT _round to uint8
REF_137(CloudbricSale.RoundInfo) -> roundInfos[TMP_221]
REF_138(uint256) -> REF_137.minContribution
REF_138(uint256) (->roundInfos) := BASE_MIN_CONTRIBUTION(uint256)"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundInfos[uint8(_round)].minContribution = _minContribution

IRs:
TMP_222 = CONVERT _round to uint8
REF_139(CloudbricSale.RoundInfo) -> roundInfos[TMP_222]
REF_140(uint256) -> REF_139.minContribution
REF_140(uint256) (->roundInfos) := _minContribution(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 23.sol-CloudbricSale-setRateForRound(CloudbricSale.SaleRounds,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round <= _round)

IRs:
TMP_237(bool) = round <= _round
TMP_238(None) = SOLIDITY_CALL require(bool)(TMP_237)"];
1->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
atStage(Stages.SetUp)

IRs:
REF_151(CloudbricSale.Stages) -> Stages.SetUp
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_151)"];
4->1;
5[label="Node Type: IF 5

EXPRESSION:
(_rate == 0)

IRs:
TMP_241(bool) = _rate == 0
CONDITION TMP_241"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
roundInfos[uint8(_round)].rate = BASE_CLB_TO_ETH_RATE

IRs:
TMP_242 = CONVERT _round to uint8
REF_152(CloudbricSale.RoundInfo) -> roundInfos[TMP_242]
REF_153(uint256) -> REF_152.rate
REF_153(uint256) (->roundInfos) := BASE_CLB_TO_ETH_RATE(uint256)"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
roundInfos[uint8(_round)].rate = _rate

IRs:
TMP_243 = CONVERT _round to uint8
REF_154(CloudbricSale.RoundInfo) -> roundInfos[TMP_243]
REF_155(uint256) -> REF_154.rate
REF_155(uint256) (->roundInfos) := _rate(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 23.sol-CloudbricSale-setUpSale(CloudbricSale.SaleRounds,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(round <= _round)

IRs:
TMP_244(bool) = round <= _round
TMP_245(None) = SOLIDITY_CALL require(bool)(TMP_244)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stage = Stages.SetUp

IRs:
REF_156(CloudbricSale.Stages) -> Stages.SetUp
stage(CloudbricSale.Stages) := REF_156(CloudbricSale.Stages)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
round = _round

IRs:
round(CloudbricSale.SaleRounds) := _round(CloudbricSale.SaleRounds)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
setMinContributionForRound(_round,_minContribution)

IRs:
INTERNAL_CALL, CloudbricSale.setMinContributionForRound(CloudbricSale.SaleRounds,uint256)(_round,_minContribution)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
setMaxContributionForRound(_round,_maxContribution)

IRs:
INTERNAL_CALL, CloudbricSale.setMaxContributionForRound(CloudbricSale.SaleRounds,uint256)(_round,_maxContribution)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
setHardCapForRound(_round,_hardCap)

IRs:
INTERNAL_CALL, CloudbricSale.setHardCapForRound(CloudbricSale.SaleRounds,uint256)(_round,_hardCap)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
setRateForRound(_round,_rate)

IRs:
INTERNAL_CALL, CloudbricSale.setRateForRound(CloudbricSale.SaleRounds,uint256)(_round,_rate)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
atStage(Stages.Ended)

IRs:
REF_157(CloudbricSale.Stages) -> Stages.Ended
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_157)"];
9->1;
}
// Function: 23.sol-CloudbricSale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
BASE_HARD_CAP_PER_ROUND = 20000 * 1000000000000000000

IRs:
TMP_315(uint256) = 20000 * 1000000000000000000
BASE_HARD_CAP_PER_ROUND(uint256) := TMP_315(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
UINT256_MAX = ~ uint256(0)

IRs:
TMP_316 = CONVERT 0 to uint256
TMP_317 = UnaryType.TILD TMP_316 
UINT256_MAX(uint256) := TMP_317(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
BASE_CLB_TO_ETH_RATE = 10000

IRs:
BASE_CLB_TO_ETH_RATE(uint256) := 10000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
BASE_MIN_CONTRIBUTION = 0.1 * 1000000000000000000

IRs:
TMP_318(uint256) = 0 * 1000000000000000000
BASE_MIN_CONTRIBUTION(uint256) := TMP_318(uint256)"];
}
// Function: 23.sol-CloudbricSale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 23.sol-CloudbricSale-startSale(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(roundInfos[uint8(round)].minContribution > 0 && roundInfos[uint8(round)].hardCap > 0)

IRs:
TMP_252 = CONVERT round to uint8
REF_158(CloudbricSale.RoundInfo) -> roundInfos[TMP_252]
REF_159(uint256) -> REF_158.minContribution
TMP_253(bool) = REF_159 > 0
TMP_254 = CONVERT round to uint8
REF_160(CloudbricSale.RoundInfo) -> roundInfos[TMP_254]
REF_161(uint256) -> REF_160.hardCap
TMP_255(bool) = REF_161 > 0
TMP_256(bool) = TMP_253 && TMP_255
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
stage = Stages.Started

IRs:
REF_162(CloudbricSale.Stages) -> Stages.Started
stage(CloudbricSale.Stages) := REF_162(CloudbricSale.Stages)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
startTime = now

IRs:
startTime(uint256) := now(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
endTime = startTime.add(durationInSeconds)

IRs:
TMP_258(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startTime', 'durationInSeconds'] 
endTime(uint256) := TMP_258(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
SaleStarted(startTime,endTime,round)

IRs:
Emit SaleStarted(startTime,endTime,round)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
atStage(Stages.SetUp)

IRs:
REF_164(CloudbricSale.Stages) -> Stages.SetUp
MODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_164)"];
7->1;
}
// Function: 23.sol-CloudbricSale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_190 = CONVERT 0 to address
TMP_191(bool) = newOwner != TMP_190
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 23.sol-CloudbricSale-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 23.sol-CloudbricSale-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_319 = UnaryType.BANG paused 
TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-CloudbricSale-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_321(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-CloudbricSale-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
fundAddr.transfer(this.balance)

IRs:
REF_129(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:fundAddr value:REF_129"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 23.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 23.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 23.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 23.sol-ERC20-totalSupply()
digraph{
}
// Function: 23.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 23.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 23.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 23.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 23.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 23.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 23.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_5(bool) = msg.sender == owner
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_0 = CONVERT 0 to address
TMP_1(bool) = newOwner != TMP_0
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 23.sol-Pausable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 23.sol-Pausable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_18(bool) = msg.sender == owner
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Pausable-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 23.sol-Pausable-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 23.sol-Pausable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_7 = CONVERT 0 to address
TMP_8(bool) = newOwner != TMP_7
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 23.sol-Pausable-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 23.sol-Pausable-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_20 = UnaryType.BANG paused 
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-Pausable-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_22(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 23.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_32(uint256) = a + b
c(uint256) := TMP_32(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_33(bool) = c >= a
TMP_34(None) = SOLIDITY_CALL assert(bool)(TMP_33)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 23.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_28(uint256) = a / b
c(uint256) := TMP_28(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 23.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_23(bool) = a == 0
CONDITION TMP_23"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_24(uint256) = a * b
c(uint256) := TMP_24(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_25(uint256) = c / a
TMP_26(bool) = TMP_25 == b
TMP_27(None) = SOLIDITY_CALL assert(bool)(TMP_26)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 23.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_29(bool) = b <= a
TMP_30(None) = SOLIDITY_CALL assert(bool)(TMP_29)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_31(uint256) = a - b
RETURN TMP_31"];
}
// Function: 23.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_45(mapping(address => uint256)) -> allowed[_owner]
REF_46(uint256) -> REF_45[_spender]
RETURN REF_46"];
}
// Function: 23.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 23.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 23.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_54(mapping(address => uint256)) -> allowed[msg.sender]
REF_55(uint256) -> REF_54[_spender]
oldValue(uint256) := REF_55(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_80(bool) = _subtractedValue > oldValue
CONDITION TMP_80"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_56(mapping(address => uint256)) -> allowed[msg.sender]
REF_57(uint256) -> REF_56[_spender]
REF_57(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_58(mapping(address => uint256)) -> allowed[msg.sender]
REF_59(uint256) -> REF_58[_spender]
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_59(uint256) (->allowed) := TMP_81(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_61(mapping(address => uint256)) -> allowed[msg.sender]
REF_62(uint256) -> REF_61[_spender]
Emit Approval(msg.sender,_spender,REF_62)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 23.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_47(mapping(address => uint256)) -> allowed[msg.sender]
REF_48(uint256) -> REF_47[_spender]
REF_49(mapping(address => uint256)) -> allowed[msg.sender]
REF_50(uint256) -> REF_49[_spender]
TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_50', '_addedValue'] 
REF_48(uint256) (->allowed) := TMP_78(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_52(mapping(address => uint256)) -> allowed[msg.sender]
REF_53(uint256) -> REF_52[_spender]
Emit Approval(msg.sender,_spender,REF_53)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 23.sol-StandardToken-totalSupply()
digraph{
}
// Function: 23.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 23.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_66 = CONVERT 0 to address
TMP_67(bool) = _to != TMP_66
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_29(uint256) -> balances[_from]
TMP_69(bool) = _value <= REF_29
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_30(mapping(address => uint256)) -> allowed[_from]
REF_31(uint256) -> REF_30[msg.sender]
TMP_71(bool) = _value <= REF_31
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_32(uint256) -> balances[_from]
REF_33(uint256) -> balances[_from]
TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_33', '_value'] 
REF_32(uint256) (->balances) := TMP_73(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_35(uint256) -> balances[_to]
REF_36(uint256) -> balances[_to]
TMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_36', '_value'] 
REF_35(uint256) (->balances) := TMP_74(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_38(mapping(address => uint256)) -> allowed[_from]
REF_39(uint256) -> REF_38[msg.sender]
REF_40(mapping(address => uint256)) -> allowed[_from]
REF_41(uint256) -> REF_40[msg.sender]
TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_41', '_value'] 
REF_39(uint256) (->allowed) := TMP_75(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
}
