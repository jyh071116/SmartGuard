digraph G {
// Function: 10146.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10146.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 10146.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = _to != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_22(bool) = _value <= REF_0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_24(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_25(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10146.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 10146.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 10146.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 10146.sol-ERC20-totalSupply()
digraph{
}
// Function: 10146.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 10146.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 10146.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 10146.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 10146.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 10146.sol-KOIOSToken-KOIOSToken(string,string,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = _decimals

IRs:
decimals(uint256) := _decimals(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply = _totalSupply

IRs:
totalSupply(uint256) := _totalSupply(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply_ = _totalSupply

IRs:
totalSupply_(uint256) := _totalSupply(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = totalSupply

IRs:
REF_92(uint256) -> balances[msg.sender]
REF_92(uint256) (->balances) := totalSupply(uint256)"];
}
// Function: 10146.sol-KOIOSToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10146.sol-KOIOSToken-allowance(address,address)
digraph{
}
// Function: 10146.sol-KOIOSToken-approve(address,uint256)
digraph{
}
// Function: 10146.sol-KOIOSToken-balanceOf(address)
digraph{
}
// Function: 10146.sol-KOIOSToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
oldValue(uint256) := REF_76(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_71(bool) = _subtractedValue > oldValue
CONDITION TMP_71"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
REF_78(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_80(uint256) (->allowed) := TMP_72(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
Emit Approval(msg.sender,_spender,REF_83)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10146.sol-KOIOSToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_82(None) = SOLIDITY_CALL revert()()"];
}
// Function: 10146.sol-KOIOSToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] 
REF_69(uint256) (->allowed) := TMP_69(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_73(mapping(address => uint256)) -> allowed[msg.sender]
REF_74(uint256) -> REF_73[_spender]
Emit Approval(msg.sender,_spender,REF_74)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10146.sol-KOIOSToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_86(bool) = msg.sender == owner
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10146.sol-KOIOSToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = KOIOS

IRs:
name(string) := KOIOS(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = KOI

IRs:
symbol(string) := KOI(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 5

IRs:
decimals(uint256) := 5(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
totalSupply = 1000000000 * (10 ** uint256(decimals))

IRs:
TMP_83 = CONVERT decimals to uint256
TMP_84(uint256) = 10 ** TMP_83
TMP_85(uint256) = 1000000000 * TMP_84
totalSupply(uint256) := TMP_85(uint256)"];
}
// Function: 10146.sol-KOIOSToken-totalSupply()
digraph{
}
// Function: 10146.sol-KOIOSToken-transfer(address,uint256)
digraph{
}
// Function: 10146.sol-KOIOSToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 10146.sol-KOIOSToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_52 = CONVERT 0 to address
TMP_53(bool) = newOwner != TMP_52
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10146.sol-KOIOSTokenPreSale-KOIOSTokenPreSale(address,uint256,uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token = KOIOSToken(_token)

IRs:
TMP_147 = CONVERT _token to KOIOSToken
token(KOIOSToken) := TMP_147(KOIOSToken)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
startingTimestamp = _startingTimestamp

IRs:
startingTimestamp(uint256) := _startingTimestamp(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
endingTimestamp = _endingTimestamp

IRs:
endingTimestamp(uint256) := _endingTimestamp(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokenPriceInEth = 1E18 / _tokensPerEth

IRs:
TMP_148(uint256) = 1000000000000000000 / _tokensPerEth
tokenPriceInEth(uint256) := TMP_148(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokensForSale = _tokensForSale

IRs:
tokensForSale(uint256) := _tokensForSale(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10146.sol-KOIOSTokenPreSale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10146.sol-KOIOSTokenPreSale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_189 = CONVERT 0 to address
TMP_190(bool) = beneficiary != TMP_189
TMP_191(None) = SOLIDITY_CALL require(bool)(TMP_190)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_value = msg.value

IRs:
_value(uint256) := msg.value(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = calculate(_value)

IRs:
TMP_192(uint256) = INTERNAL_CALL, KOIOSTokenPreSale.calculate(uint256)(_value)
tokens(uint256) := TMP_192(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
bonusTokens = calculate(getBonus(_value))

IRs:
TMP_193(uint256) = INTERNAL_CALL, KOIOSTokenPreSale.getBonus(uint256)(_value)
TMP_194(uint256) = INTERNAL_CALL, KOIOSTokenPreSale.calculate(uint256)(TMP_193)
bonusTokens(uint256) := TMP_194(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
lockBonus(beneficiary,bonusTokens)

IRs:
TMP_195(bool) = INTERNAL_CALL, KOIOSTokenPreSale.lockBonus(address,uint256)(beneficiary,bonusTokens)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_totalTokens = tokens.add(bonusTokens)

IRs:
TMP_196(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'bonusTokens'] 
_totalTokens(uint256) := TMP_196(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(isValidPurchase(_value,_totalTokens))

IRs:
TMP_197(bool) = INTERNAL_CALL, KOIOSTokenPreSale.isValidPurchase(uint256,uint256)(_value,_totalTokens)
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
totalTokenSold = totalTokenSold.add(_totalTokens)

IRs:
TMP_199(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalTokenSold', '_totalTokens'] 
totalTokenSold(uint256) := TMP_199(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalEtherRaised = totalEtherRaised.add(_value)

IRs:
TMP_200(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalEtherRaised', '_value'] 
totalEtherRaised(uint256) := TMP_200(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
etherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(_value)

IRs:
REF_139(uint256) -> etherRaisedPerWallet[msg.sender]
REF_140(uint256) -> etherRaisedPerWallet[msg.sender]
TMP_201(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_140', '_value'] 
REF_139(uint256) (->etherRaisedPerWallet) := TMP_201(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
token.transfer(beneficiary,tokens)

IRs:
TMP_202(bool) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:transfer, arguments:['beneficiary', 'tokens']  "];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,_value,tokens,now)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,_value,tokens,now)"];
}
// Function: 10146.sol-KOIOSTokenPreSale-calculate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenDecimals = token.decimals()

IRs:
TMP_178(uint256) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:decimals, arguments:[]  
tokenDecimals(uint256) := TMP_178(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tokens = value.mul(10 ** tokenDecimals).div(tokenPriceInEth)

IRs:
TMP_179(uint256) = 10 ** tokenDecimals
TMP_180(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', 'TMP_179'] 
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_180', 'tokenPriceInEth'] 
tokens(uint256) := TMP_181(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
tokens

IRs:
RETURN tokens"];
}
// Function: 10146.sol-KOIOSTokenPreSale-close()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = token.balanceOf(this).sub(totalLockedBonus)

IRs:
TMP_241(uint256) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:balanceOf, arguments:['this']  
TMP_242(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_241', 'totalLockedBonus'] 
tokens(uint256) := TMP_242(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.transfer(owner,tokens)

IRs:
TMP_243(bool) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:transfer, arguments:['owner', 'tokens']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
withdraw()

IRs:
INTERNAL_CALL, KOIOSTokenPreSale.withdraw()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isClose = true

IRs:
isClose(bool) := True(bool)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10146.sol-KOIOSTokenPreSale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, KOIOSTokenPreSale.buyTokens(address)(msg.sender)"];
}
// Function: 10146.sol-KOIOSTokenPreSale-getBonus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_value >= 1E18

IRs:
TMP_163(bool) = _value >= 1000000000000000000
CONDITION TMP_163"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bonus = _value.mul(50).div(1000)

IRs:
TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', '50'] 
TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_164', '1000'] 
bonus(uint256) := TMP_165(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
_value >= 5E18

IRs:
TMP_166(bool) = _value >= 5000000000000000000
CONDITION TMP_166"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
bonus = _value.mul(75).div(1000)

IRs:
TMP_167(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', '75'] 
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_167', '1000'] 
bonus(uint256) := TMP_168(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
_value >= 10E18

IRs:
TMP_169(bool) = _value >= 10000000000000000000
CONDITION TMP_169"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
bonus = _value.mul(100).div(1000)

IRs:
TMP_170(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', '100'] 
TMP_171(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_170', '1000'] 
bonus(uint256) := TMP_171(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
_value >= 20E18

IRs:
TMP_172(bool) = _value >= 20000000000000000000
CONDITION TMP_172"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
bonus = _value.mul(150).div(1000)

IRs:
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', '150'] 
TMP_174(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_173', '1000'] 
bonus(uint256) := TMP_174(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
_value >= 30E18

IRs:
TMP_175(bool) = _value >= 30000000000000000000
CONDITION TMP_175"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
bonus = _value.mul(200).div(1000)

IRs:
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', '200'] 
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_176', '1000'] 
bonus(uint256) := TMP_177(uint256)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: RETURN 17

EXPRESSION:
bonus

IRs:
RETURN bonus"];
}
// Function: 10146.sol-KOIOSTokenPreSale-isValidPurchase(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp

IRs:
TMP_149(bool) = startingTimestamp <= block.timestamp
TMP_150(bool) = endingTimestamp >= block.timestamp
TMP_151(bool) = TMP_149 && TMP_150
validTimestamp(bool) := TMP_151(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
validValue = value != 0

IRs:
TMP_152(bool) = value != 0
validValue(bool) := TMP_152(bool)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
validRate = tokenPriceInEth > 0

IRs:
TMP_153(bool) = tokenPriceInEth > 0
validRate(bool) := TMP_153(bool)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0

IRs:
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensForSale', 'totalTokenSold'] 
TMP_155(bool) = TMP_154 >= amount
TMP_156(bool) = amount > 0
TMP_157(bool) = TMP_155 && TMP_156
validAmount(bool) := TMP_157(bool)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
validTimestamp && validValue && validRate && validAmount && ! isClose

IRs:
TMP_158(bool) = validTimestamp && validValue
TMP_159(bool) = TMP_158 && validRate
TMP_160(bool) = TMP_159 && validAmount
TMP_161 = UnaryType.BANG isClose 
TMP_162(bool) = TMP_160 && TMP_161
RETURN TMP_162"];
}
// Function: 10146.sol-KOIOSTokenPreSale-isValidRelease(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
validAmount = amount > 0

IRs:
TMP_204(bool) = amount > 0
validAmount(bool) := TMP_204(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
validAmount

IRs:
RETURN validAmount"];
}
// Function: 10146.sol-KOIOSTokenPreSale-lockBonus(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
lockedBonus = bonusTokens.div(4)

IRs:
TMP_182(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['bonusTokens', '4'] 
lockedBonus(uint256) := TMP_182(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
lockupPhase1[_sender] = lockupPhase1[_sender].add(lockedBonus)

IRs:
REF_123(uint256) -> lockupPhase1[_sender]
REF_124(uint256) -> lockupPhase1[_sender]
TMP_183(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_124', 'lockedBonus'] 
REF_123(uint256) (->lockupPhase1) := TMP_183(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
lockupPhase2[_sender] = lockupPhase2[_sender].add(lockedBonus)

IRs:
REF_126(uint256) -> lockupPhase2[_sender]
REF_127(uint256) -> lockupPhase2[_sender]
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_127', 'lockedBonus'] 
REF_126(uint256) (->lockupPhase2) := TMP_184(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
lockupPhase3[_sender] = lockupPhase3[_sender].add(lockedBonus)

IRs:
REF_129(uint256) -> lockupPhase3[_sender]
REF_130(uint256) -> lockupPhase3[_sender]
TMP_185(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_130', 'lockedBonus'] 
REF_129(uint256) (->lockupPhase3) := TMP_185(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
lockupPhase4[_sender] = lockupPhase4[_sender].add(lockedBonus)

IRs:
REF_132(uint256) -> lockupPhase4[_sender]
REF_133(uint256) -> lockupPhase4[_sender]
TMP_186(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_133', 'lockedBonus'] 
REF_132(uint256) (->lockupPhase4) := TMP_186(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalLockedBonus = totalLockedBonus.add(bonusTokens)

IRs:
TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalLockedBonus', 'bonusTokens'] 
totalLockedBonus(uint256) := TMP_187(uint256)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10146.sol-KOIOSTokenPreSale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_251(bool) = msg.sender == owner
TMP_252(None) = SOLIDITY_CALL require(bool)(TMP_251)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10146.sol-KOIOSTokenPreSale-releasableBonus(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
releaseTokens = 0

IRs:
releaseTokens(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase1Duration))

IRs:
TMP_219(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase1Duration'] 
TMP_220(bool) = block.timestamp > TMP_219
CONDITION TMP_220"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase1[_owner])

IRs:
REF_163(uint256) -> lockupPhase1[_owner]
TMP_221(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_163'] 
releaseTokens(uint256) := TMP_221(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase2Duration))

IRs:
TMP_222(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase2Duration'] 
TMP_223(bool) = block.timestamp > TMP_222
CONDITION TMP_223"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase2[_owner])

IRs:
REF_166(uint256) -> lockupPhase2[_owner]
TMP_224(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_166'] 
releaseTokens(uint256) := TMP_224(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase3Duration))

IRs:
TMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase3Duration'] 
TMP_226(bool) = block.timestamp > TMP_225
CONDITION TMP_226"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase3[_owner])

IRs:
REF_169(uint256) -> lockupPhase3[_owner]
TMP_227(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_169'] 
releaseTokens(uint256) := TMP_227(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase4Duration))

IRs:
TMP_228(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase4Duration'] 
TMP_229(bool) = block.timestamp > TMP_228
CONDITION TMP_229"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase4[_owner])

IRs:
REF_172(uint256) -> lockupPhase4[_owner]
TMP_230(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_172'] 
releaseTokens(uint256) := TMP_230(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
releaseTokens

IRs:
RETURN releaseTokens"];
}
// Function: 10146.sol-KOIOSTokenPreSale-releaseBonus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
releaseTokens = 0

IRs:
releaseTokens(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase1Duration))

IRs:
TMP_205(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase1Duration'] 
TMP_206(bool) = block.timestamp > TMP_205
CONDITION TMP_206"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase1[msg.sender])

IRs:
REF_145(uint256) -> lockupPhase1[msg.sender]
TMP_207(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_145'] 
releaseTokens(uint256) := TMP_207(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
lockupPhase1[msg.sender] = 0

IRs:
REF_146(uint256) -> lockupPhase1[msg.sender]
REF_146(uint256) (->lockupPhase1) := 0(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase2Duration))

IRs:
TMP_208(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase2Duration'] 
TMP_209(bool) = block.timestamp > TMP_208
CONDITION TMP_209"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase2[msg.sender])

IRs:
REF_149(uint256) -> lockupPhase2[msg.sender]
TMP_210(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_149'] 
releaseTokens(uint256) := TMP_210(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
lockupPhase2[msg.sender] = 0

IRs:
REF_150(uint256) -> lockupPhase2[msg.sender]
REF_150(uint256) (->lockupPhase2) := 0(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase3Duration))

IRs:
TMP_211(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase3Duration'] 
TMP_212(bool) = block.timestamp > TMP_211
CONDITION TMP_212"];
10->11[label="True"];
10->13[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase3[msg.sender])

IRs:
REF_153(uint256) -> lockupPhase3[msg.sender]
TMP_213(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_153'] 
releaseTokens(uint256) := TMP_213(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
lockupPhase3[msg.sender] = 0

IRs:
REF_154(uint256) -> lockupPhase3[msg.sender]
REF_154(uint256) (->lockupPhase3) := 0(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
block.timestamp > (startingTimestamp.add(phase4Duration))

IRs:
TMP_214(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startingTimestamp', 'phase4Duration'] 
TMP_215(bool) = block.timestamp > TMP_214
CONDITION TMP_215"];
14->15[label="True"];
14->17[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
releaseTokens = releaseTokens.add(lockupPhase4[msg.sender])

IRs:
REF_157(uint256) -> lockupPhase4[msg.sender]
TMP_216(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['releaseTokens', 'REF_157'] 
releaseTokens(uint256) := TMP_216(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
lockupPhase4[msg.sender] = 0

IRs:
REF_158(uint256) -> lockupPhase4[msg.sender]
REF_158(uint256) (->lockupPhase4) := 0(uint256)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
totalLockedBonus = totalLockedBonus.sub(releaseTokens)

IRs:
TMP_217(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalLockedBonus', 'releaseTokens'] 
totalLockedBonus(uint256) := TMP_217(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
token.transfer(msg.sender,releaseTokens)

IRs:
TMP_218(bool) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:transfer, arguments:['msg.sender', 'releaseTokens']  "];
}
// Function: 10146.sol-KOIOSTokenPreSale-setWallet(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WalletChange(_wallet,now)

IRs:
Emit WalletChange(_wallet,now)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10146.sol-KOIOSTokenPreSale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
startingTimestamp = 1527811200

IRs:
startingTimestamp(uint256) := 1527811200(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
endingTimestamp = 1528156799

IRs:
endingTimestamp(uint256) := 1528156799(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
tokenPriceInEth = 50000000000000

IRs:
tokenPriceInEth(uint256) := 50000000000000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
tokensForSale = 400000000 * 1E5

IRs:
TMP_246(uint256) = 400000000 * 100000
tokensForSale(uint256) := TMP_246(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
isClose = false

IRs:
isClose(bool) := False(bool)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
phase1Duration = 90 * 86400

IRs:
TMP_247(uint256) = 90 * 86400
phase1Duration(uint256) := TMP_247(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
phase2Duration = 120 * 86400

IRs:
TMP_248(uint256) = 120 * 86400
phase2Duration(uint256) := TMP_248(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
phase3Duration = 150 * 86400

IRs:
TMP_249(uint256) = 150 * 86400
phase3Duration(uint256) := TMP_249(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
phase4Duration = 180 * 86400

IRs:
TMP_250(uint256) = 180 * 86400
phase4Duration(uint256) := TMP_250(uint256)"];
}
// Function: 10146.sol-KOIOSTokenPreSale-transferManual(address,uint256,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_231 = CONVERT 0 to address
TMP_232(bool) = _to != TMP_231
TMP_233(None) = SOLIDITY_CALL require(bool)(TMP_232)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.transfer(_to,_value)

IRs:
TMP_234(bool) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:transfer, arguments:['_to', '_value']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
TransferManual(msg.sender,_to,_value,_message)

IRs:
Emit TransferManual(msg.sender,_to,_value,_message)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10146.sol-KOIOSTokenPreSale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_142 = CONVERT 0 to address
TMP_143(bool) = newOwner != TMP_142
TMP_144(None) = SOLIDITY_CALL require(bool)(TMP_143)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10146.sol-KOIOSTokenPreSale-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_175(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_175"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 10146.sol-KOIOSTokenSale-KOIOSTokenSale(address,uint256,uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token = KOIOSToken(_token)

IRs:
TMP_93 = CONVERT _token to KOIOSToken
token(KOIOSToken) := TMP_93(KOIOSToken)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
startingTimestamp = _startingTimestamp

IRs:
startingTimestamp(uint256) := _startingTimestamp(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
endingTimestamp = _endingTimestamp

IRs:
endingTimestamp(uint256) := _endingTimestamp(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokenPriceInEth = 1E18 / _tokensPerEth

IRs:
TMP_94(uint256) = 1000000000000000000 / _tokensPerEth
tokenPriceInEth(uint256) := TMP_94(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tokensForSale = _tokensForSale

IRs:
tokensForSale(uint256) := _tokensForSale(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10146.sol-KOIOSTokenSale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10146.sol-KOIOSTokenSale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_114 = CONVERT 0 to address
TMP_115(bool) = beneficiary != TMP_114
TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
value = msg.value

IRs:
value(uint256) := msg.value(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = calculate(value)

IRs:
TMP_117(uint256) = INTERNAL_CALL, KOIOSTokenSale.calculate(uint256)(value)
tokens(uint256) := TMP_117(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(isValidPurchase(value,tokens))

IRs:
TMP_118(bool) = INTERNAL_CALL, KOIOSTokenSale.isValidPurchase(uint256,uint256)(value,tokens)
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalTokenSold = totalTokenSold.add(tokens)

IRs:
TMP_120(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalTokenSold', 'tokens'] 
totalTokenSold(uint256) := TMP_120(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalEtherRaised = totalEtherRaised.add(value)

IRs:
TMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalEtherRaised', 'value'] 
totalEtherRaised(uint256) := TMP_121(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
etherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(value)

IRs:
REF_99(uint256) -> etherRaisedPerWallet[msg.sender]
REF_100(uint256) -> etherRaisedPerWallet[msg.sender]
TMP_122(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_100', 'value'] 
REF_99(uint256) (->etherRaisedPerWallet) := TMP_122(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
token.transfer(beneficiary,tokens)

IRs:
TMP_123(bool) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:transfer, arguments:['beneficiary', 'tokens']  "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,value,tokens,now)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,value,tokens,now)"];
}
// Function: 10146.sol-KOIOSTokenSale-calculate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenDecimals = token.decimals()

IRs:
TMP_109(uint256) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:decimals, arguments:[]  
tokenDecimals(uint256) := TMP_109(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tokens = value.mul(10 ** tokenDecimals).div(tokenPriceInEth)

IRs:
TMP_110(uint256) = 10 ** tokenDecimals
TMP_111(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', 'TMP_110'] 
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_111', 'tokenPriceInEth'] 
tokens(uint256) := TMP_112(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
tokens

IRs:
RETURN tokens"];
}
// Function: 10146.sol-KOIOSTokenSale-close()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = token.balanceOf(this)

IRs:
TMP_135(uint256) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:balanceOf, arguments:['this']  
tokens(uint256) := TMP_135(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.transfer(owner,tokens)

IRs:
TMP_136(bool) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:transfer, arguments:['owner', 'tokens']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
withdraw()

IRs:
INTERNAL_CALL, KOIOSTokenSale.withdraw()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isClose = true

IRs:
isClose(bool) := True(bool)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10146.sol-KOIOSTokenSale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, KOIOSTokenSale.buyTokens(address)(msg.sender)"];
}
// Function: 10146.sol-KOIOSTokenSale-isValidPurchase(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp

IRs:
TMP_95(bool) = startingTimestamp <= block.timestamp
TMP_96(bool) = endingTimestamp >= block.timestamp
TMP_97(bool) = TMP_95 && TMP_96
validTimestamp(bool) := TMP_97(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
validValue = value != 0

IRs:
TMP_98(bool) = value != 0
validValue(bool) := TMP_98(bool)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
validRate = tokenPriceInEth > 0

IRs:
TMP_99(bool) = tokenPriceInEth > 0
validRate(bool) := TMP_99(bool)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0

IRs:
TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensForSale', 'totalTokenSold'] 
TMP_101(bool) = TMP_100 >= amount
TMP_102(bool) = amount > 0
TMP_103(bool) = TMP_101 && TMP_102
validAmount(bool) := TMP_103(bool)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
validTimestamp && validValue && validRate && validAmount && ! isClose

IRs:
TMP_104(bool) = validTimestamp && validValue
TMP_105(bool) = TMP_104 && validRate
TMP_106(bool) = TMP_105 && validAmount
TMP_107 = UnaryType.BANG isClose 
TMP_108(bool) = TMP_106 && TMP_107
RETURN TMP_108"];
}
// Function: 10146.sol-KOIOSTokenSale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_140(bool) = msg.sender == owner
TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10146.sol-KOIOSTokenSale-setWallet(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
WalletChange(_wallet,now)

IRs:
Emit WalletChange(_wallet,now)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10146.sol-KOIOSTokenSale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
startingTimestamp = 1518696000

IRs:
startingTimestamp(uint256) := 1518696000(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
endingTimestamp = 1521115200

IRs:
endingTimestamp(uint256) := 1521115200(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
tokenPriceInEth = 100000000000000

IRs:
tokenPriceInEth(uint256) := 100000000000000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
tokensForSale = 400000000 * 1E5

IRs:
TMP_139(uint256) = 400000000 * 100000
tokensForSale(uint256) := TMP_139(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
isClose = false

IRs:
isClose(bool) := False(bool)"];
}
// Function: 10146.sol-KOIOSTokenSale-transferManual(address,uint256,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_125 = CONVERT 0 to address
TMP_126(bool) = _to != TMP_125
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.transfer(_to,_value)

IRs:
TMP_128(bool) = HIGH_LEVEL_CALL, dest:token(KOIOSToken), function:transfer, arguments:['_to', '_value']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
TransferManual(msg.sender,_to,_value,_message)

IRs:
Emit TransferManual(msg.sender,_to,_value,_message)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10146.sol-KOIOSTokenSale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_88 = CONVERT 0 to address
TMP_89(bool) = newOwner != TMP_88
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10146.sol-KOIOSTokenSale-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_105(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_105"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 10146.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10146.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_17(bool) = msg.sender == owner
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10146.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = newOwner != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10146.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10146.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_5(uint256) = a / b
c(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10146.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10146.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 10146.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 10146.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10146.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 10146.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_49(bool) = _subtractedValue > oldValue
CONDITION TMP_49"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_50(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_50(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10146.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_47(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10146.sol-StandardToken-totalSupply()
digraph{
}
// Function: 10146.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 10146.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_35 = CONVERT 0 to address
TMP_36(bool) = _to != TMP_35
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_38(bool) = _value <= REF_16
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_40(bool) = _value <= REF_18
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_42(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_43(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_44(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
}
