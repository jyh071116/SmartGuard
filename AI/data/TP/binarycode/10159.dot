digraph G {
// Function: 10159.sol-Authorization-Authorization()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
operator = msg.sender

IRs:
operator(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bank = msg.sender

IRs:
bank(address) := msg.sender(address)"];
}
// Function: 10159.sol-Authorization-assignAgent(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
agentBooks[msg.sender] = agent_

IRs:
REF_1(address) -> agentBooks[msg.sender]
REF_1(address) (->agentBooks) := agent_(address)"];
}
// Function: 10159.sol-Authorization-assignBank(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bank = bank_

IRs:
bank(address) := bank_(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Authorization.onlyOwner()()"];
2->1;
}
// Function: 10159.sol-Authorization-assignOperator(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
operator = user_

IRs:
operator(address) := user_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
agentBooks[bank] = user_

IRs:
REF_0(address) -> agentBooks[bank]
REF_0(address) (->agentBooks) := user_(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Authorization.onlyOwner()()"];
3->1;
}
// Function: 10159.sol-Authorization-getUser(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
isRepresentor(representor_)

IRs:
TMP_25(bool) = INTERNAL_CALL, Authorization.isRepresentor(address)(representor_)
CONDITION TMP_25"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
representor_

IRs:
RETURN representor_"];
4[label="Node Type: RETURN 4

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 10159.sol-Authorization-isRepresentor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
agentBooks[representor_] == msg.sender

IRs:
REF_2(address) -> agentBooks[representor_]
TMP_24(bool) = REF_2 == msg.sender
RETURN TMP_24"];
}
// Function: 10159.sol-Authorization-onlyActive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(powerStatus)

IRs:
TMP_32(None) = SOLIDITY_CALL assert(bool)(powerStatus)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10159.sol-Authorization-onlyOperator()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == operator || msg.sender == owner)

IRs:
TMP_28(bool) = msg.sender == operator
TMP_29(bool) = msg.sender == owner
TMP_30(bool) = TMP_28 || TMP_29
TMP_31(None) = SOLIDITY_CALL assert(bool)(TMP_30)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10159.sol-Authorization-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == owner)

IRs:
TMP_26(bool) = msg.sender == owner
TMP_27(None) = SOLIDITY_CALL assert(bool)(TMP_26)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10159.sol-Authorization-powerSwitch(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
forceOff

IRs:
CONDITION forceOff"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
powerStatus = false

IRs:
powerStatus(bool) := False(bool)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
powerStatus = onOff_

IRs:
powerStatus(bool) := onOff_(bool)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
5->1;
}
// Function: 10159.sol-Authorization-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
powerStatus = true

IRs:
powerStatus(bool) := True(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
forceOff = false

IRs:
forceOff(bool) := False(bool)"];
}
// Function: 10159.sol-Authorization-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner_

IRs:
owner(address) := newOwner_(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Authorization.onlyOwner()()"];
2->1;
}
// Function: 10159.sol-Baliv-getPrice(address,address)
digraph{
}
// Function: 10159.sol-FundAccount-burn(address,uint256)
digraph{
}
// Function: 10159.sol-SafeMath-random(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = keccak256()(block.number,msg.sender,salt)

IRs:
TMP_17(bytes32) = SOLIDITY_CALL keccak256()(block.number,msg.sender,salt)
hash(bytes32) := TMP_17(bytes32)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
uint256(hash) % N

IRs:
TMP_18 = CONVERT hash to uint256
TMP_19(uint256) = TMP_18 % N
RETURN TMP_19"];
}
// Function: 10159.sol-SafeMath-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_0(uint256) = x + y
z(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((z >= x) && (z >= y))

IRs:
TMP_1(bool) = z >= x
TMP_2(bool) = z >= y
TMP_3(bool) = TMP_1 && TMP_2
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 10159.sol-SafeMath-safeDiv(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(y > 0)

IRs:
TMP_14(bool) = y > 0
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x / y

IRs:
TMP_16(uint256) = x / y
RETURN TMP_16"];
}
// Function: 10159.sol-SafeMath-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x * y

IRs:
TMP_8(uint256) = x * y
z(uint256) := TMP_8(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((x == 0) || (z / x == y))

IRs:
TMP_9(bool) = x == 0
TMP_10(uint256) = z / x
TMP_11(bool) = TMP_10 == y
TMP_12(bool) = TMP_9 || TMP_11
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 10159.sol-SafeMath-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(x >= y)

IRs:
TMP_5(bool) = x >= y
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
z = x - y

IRs:
TMP_7(uint256) = x - y
z(uint256) := TMP_7(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 10159.sol-Token-allowance(address,address)
digraph{
}
// Function: 10159.sol-Token-approve(address,uint256)
digraph{
}
// Function: 10159.sol-Token-balanceOf(address)
digraph{
}
// Function: 10159.sol-Token-totalSupply()
digraph{
}
// Function: 10159.sol-Token-transfer(address,uint256)
digraph{
}
// Function: 10159.sol-Token-transferFrom(address,address,uint256)
digraph{
}
// Function: 10159.sol-TokenFactory-createToken(string,string,uint256)
digraph{
}
// Function: 10159.sol-TokenFactory-getAssetLength()
digraph{
}
// Function: 10159.sol-TokenFactory-getAssetToken(uint256)
digraph{
}
// Function: 10159.sol-TokenFactory-getPrice(address)
digraph{
}
// Function: 10159.sol-XPAAssetToken-burn(uint256)
digraph{
}
// Function: 10159.sol-XPAAssetToken-burnFrom(address,uint256)
digraph{
}
// Function: 10159.sol-XPAAssetToken-create(address,uint256)
digraph{
}
// Function: 10159.sol-XPAAssetToken-getDefaultExchangeRate()
digraph{
}
// Function: 10159.sol-XPAAssetToken-getSymbol()
digraph{
}
// Function: 10159.sol-XPAAssets-Authorization()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
operator = msg.sender

IRs:
operator(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bank = msg.sender

IRs:
bank(address) := msg.sender(address)"];
}
// Function: 10159.sol-XPAAssets-XPAAssets(uint256,address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
initCanOffsetTime = initCanOffsetTime_

IRs:
initCanOffsetTime(uint256) := initCanOffsetTime_(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
XPA = XPAAddr

IRs:
XPA(address) := XPAAddr(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenFactory = factoryAddr

IRs:
tokenFactory(address) := factoryAddr(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
oldXPAAssets = oldXPAAssetsAddr

IRs:
oldXPAAssets(address) := oldXPAAssetsAddr(address)"];
}
// Function: 10159.sol-XPAAssets-assignAgent(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
agentBooks[msg.sender] = agent_

IRs:
REF_4(address) -> agentBooks[msg.sender]
REF_4(address) (->agentBooks) := agent_(address)"];
}
// Function: 10159.sol-XPAAssets-assignBank(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bank = bank_

IRs:
bank(address) := bank_(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Authorization.onlyOwner()()"];
2->1;
}
// Function: 10159.sol-XPAAssets-assignOperator(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
operator = user_

IRs:
operator(address) := user_(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
agentBooks[bank] = user_

IRs:
REF_3(address) -> agentBooks[bank]
REF_3(address) (->agentBooks) := user_(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Authorization.onlyOwner()()"];
3->1;
}
// Function: 10159.sol-XPAAssets-burnFundAccount(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
FundAccount(fundAccount).burn(token_,amount_)

IRs:
TMP_277 = CONVERT fundAccount to FundAccount
TMP_278(bool) = HIGH_LEVEL_CALL, dest:TMP_277(FundAccount), function:burn, arguments:['token_', 'amount_']  
CONDITION TMP_278"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
unPaidFundAccount[token_] = safeSub(unPaidFundAccount[token_],amount_)

IRs:
REF_87(uint256) -> unPaidFundAccount[token_]
REF_88(uint256) -> unPaidFundAccount[token_]
TMP_279(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_88,amount_)
REF_87(uint256) (->unPaidFundAccount) := TMP_279(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
4->1;
}
// Function: 10159.sol-XPAAssets-createToken(string,string,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
newAsset = TokenFactory(tokenFactory).createToken(symbol_,name_,defaultExchangeRate_)

IRs:
TMP_62 = CONVERT tokenFactory to TokenFactory
TMP_63(address) = HIGH_LEVEL_CALL, dest:TMP_62(TokenFactory), function:createToken, arguments:['symbol_', 'name_', 'defaultExchangeRate_']  
newAsset(address) := TMP_63(address)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->10;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < xpaAsset.length

IRs:
REF_7 -> LENGTH xpaAsset
TMP_64(bool) = i < REF_7
CONDITION TMP_64"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
xpaAsset[i] == newAsset

IRs:
REF_8(address) -> xpaAsset[i]
TMP_65(bool) = REF_8 == newAsset
CONDITION TMP_65"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_66(uint256) := i(uint256)
i(uint256) = i + 1"];
9->5;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
xpaAsset.push(newAsset)

IRs:
REF_10 -> LENGTH xpaAsset
TMP_68(uint256) := REF_10(uint256)
TMP_69(uint256) = TMP_68 + 1
REF_10(uint256) (->xpaAsset) := TMP_69(uint256)
REF_11(address) -> xpaAsset[TMP_68]
REF_11(address) (->xpaAsset) := newAsset(address)"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
11->1;
}
// Function: 10159.sol-XPAAssets-executeOffset(address,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fromXPAAsset = safeDiv(safeMul(xpaAmount_,getPrice(xpaAssetToken)),1000000000000000000)

IRs:
TMP_189(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(xpaAssetToken)
TMP_190(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(xpaAmount_,TMP_189)
TMP_191(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_190,1000000000000000000)
fromXPAAsset(uint256) := TMP_191(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
userToAmount = toAmountBooks[user_][xpaAssetToken]

IRs:
REF_58(mapping(address => uint256)) -> toAmountBooks[user_]
REF_59(uint256) -> REF_58[xpaAssetToken]
userToAmount(uint256) := REF_59(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
fee = safeDiv(safeMul(userToAmount,feeRate),1000000000000000000)

IRs:
TMP_192(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(userToAmount,feeRate)
TMP_193(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_192,1000000000000000000)
fee(uint256) := TMP_193(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
fromXPAAsset >= safeAdd(userToAmount,fee)

IRs:
TMP_194(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(userToAmount,fee)
TMP_195(bool) = fromXPAAsset >= TMP_194
CONDITION TMP_195"];
6->7[label="True"];
6->15[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
burnXPA = safeDiv(safeMul(safeAdd(userToAmount,fee),1000000000000000000),getPrice(xpaAssetToken))

IRs:
TMP_196(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(userToAmount,fee)
TMP_197(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_196,1000000000000000000)
TMP_198(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(xpaAssetToken)
TMP_199(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_197,TMP_198)
burnXPA(uint256) := TMP_199(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
eExecuteOffset(burnXPA,xpaAssetToken,safeAdd(userToAmount,fee))

IRs:
TMP_200(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(userToAmount,fee)
Emit eExecuteOffset(burnXPA,xpaAssetToken,TMP_200)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
xpaAmount_ = safeSub(xpaAmount_,burnXPA)

IRs:
TMP_202(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(xpaAmount_,burnXPA)
xpaAmount_(uint256) := TMP_202(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
toAmountBooks[user_][xpaAssetToken] = 0

IRs:
REF_60(mapping(address => uint256)) -> toAmountBooks[user_]
REF_61(uint256) -> REF_60[xpaAssetToken]
REF_61(uint256) (->toAmountBooks) := 0(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
profit = safeAdd(profit,safeDiv(safeMul(fee,1000000000000000000),getPrice(xpaAssetToken)))

IRs:
TMP_203(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(fee,1000000000000000000)
TMP_204(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(xpaAssetToken)
TMP_205(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_203,TMP_204)
TMP_206(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(profit,TMP_205)
profit(uint256) := TMP_206(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
! FundAccount(fundAccount).burn(xpaAssetToken,userToAmount)

IRs:
TMP_207 = CONVERT fundAccount to FundAccount
TMP_208(bool) = HIGH_LEVEL_CALL, dest:TMP_207(FundAccount), function:burn, arguments:['xpaAssetToken', 'userToAmount']  
TMP_209 = UnaryType.BANG TMP_208 
CONDITION TMP_209"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken],userToAmount)

IRs:
REF_63(uint256) -> unPaidFundAccount[xpaAssetToken]
REF_64(uint256) -> unPaidFundAccount[xpaAssetToken]
TMP_210(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_64,userToAmount)
REF_63(uint256) (->unPaidFundAccount) := TMP_210(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->24;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
fee = safeDiv(safeMul(xpaAmount_,feeRate),1000000000000000000)

IRs:
TMP_211(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(xpaAmount_,feeRate)
TMP_212(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_211,1000000000000000000)
fee(uint256) := TMP_212(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
profit = safeAdd(profit,fee)

IRs:
TMP_213(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(profit,fee)
profit(uint256) := TMP_213(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
burnXPAAsset = safeDiv(safeMul(safeSub(xpaAmount_,fee),getPrice(xpaAssetToken)),1000000000000000000)

IRs:
TMP_214(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(xpaAmount_,fee)
TMP_215(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(xpaAssetToken)
TMP_216(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_214,TMP_215)
TMP_217(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_216,1000000000000000000)
burnXPAAsset(uint256) := TMP_217(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
toAmountBooks[user_][xpaAssetToken] = safeSub(userToAmount,burnXPAAsset)

IRs:
REF_65(mapping(address => uint256)) -> toAmountBooks[user_]
REF_66(uint256) -> REF_65[xpaAssetToken]
TMP_218(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(userToAmount,burnXPAAsset)
REF_66(uint256) (->toAmountBooks) := TMP_218(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
eExecuteOffset(xpaAmount_,xpaAssetToken,burnXPAAsset)

IRs:
Emit eExecuteOffset(xpaAmount_,xpaAssetToken,burnXPAAsset)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
xpaAmount_ = 0

IRs:
xpaAmount_(uint256) := 0(uint256)"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
! FundAccount(fundAccount).burn(xpaAssetToken,burnXPAAsset)

IRs:
TMP_220 = CONVERT fundAccount to FundAccount
TMP_221(bool) = HIGH_LEVEL_CALL, dest:TMP_220(FundAccount), function:burn, arguments:['xpaAssetToken', 'burnXPAAsset']  
TMP_222 = UnaryType.BANG TMP_221 
CONDITION TMP_222"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken],burnXPAAsset)

IRs:
REF_68(uint256) -> unPaidFundAccount[xpaAssetToken]
REF_69(uint256) -> unPaidFundAccount[xpaAssetToken]
TMP_223(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_69,burnXPAAsset)
REF_68(uint256) (->unPaidFundAccount) := TMP_223(uint256)"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: RETURN 25

EXPRESSION:
xpaAmount_

IRs:
RETURN xpaAmount_"];
}
// Function: 10159.sol-XPAAssets-getClosingLine()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
highestMortgageRate = getHighestMortgageRate()

IRs:
TMP_250(uint256) = INTERNAL_CALL, XPAAssets.getHighestMortgageRate()()
highestMortgageRate(uint256) := TMP_250(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
highestMortgageRate >= 600000000000000000

IRs:
TMP_251(bool) = highestMortgageRate >= 600000000000000000
CONDITION TMP_251"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
safeAdd(highestMortgageRate,100000000000000000)

IRs:
TMP_252(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(highestMortgageRate,100000000000000000)
RETURN TMP_252"];
4[label="Node Type: RETURN 4

EXPRESSION:
600000000000000000

IRs:
RETURN 600000000000000000"];
}
// Function: 10159.sol-XPAAssets-getForceOffsetBooks(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
forceOffsetBooks[user_]

IRs:
REF_120(uint256) -> forceOffsetBooks[user_]
RETURN REF_120"];
}
// Function: 10159.sol-XPAAssets-getFromAmountBooks(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
fromAmountBooks[user_]

IRs:
REF_119(uint256) -> fromAmountBooks[user_]
RETURN REF_119"];
}
// Function: 10159.sol-XPAAssets-getHighestMortgageRate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
totalXPA = Token(XPA).totalSupply()

IRs:
TMP_240 = CONVERT XPA to Token
TMP_241(uint256) = HIGH_LEVEL_CALL, dest:TMP_240(Token), function:totalSupply, arguments:[]  
totalXPA(uint256) := TMP_241(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
issueRate = safeDiv(safeMul(Token(XPA).balanceOf(this),1000000000000000000),totalXPA)

IRs:
TMP_242 = CONVERT XPA to Token
TMP_243(uint256) = HIGH_LEVEL_CALL, dest:TMP_242(Token), function:balanceOf, arguments:['this']  
TMP_244(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_243,1000000000000000000)
TMP_245(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_244,totalXPA)
issueRate(uint256) := TMP_245(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
issueRate >= 700000000000000000

IRs:
TMP_246(bool) = issueRate >= 700000000000000000
CONDITION TMP_246"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
700000000000000000

IRs:
RETURN 700000000000000000"];
5[label="Node Type: IF 5

EXPRESSION:
issueRate >= 600000000000000000

IRs:
TMP_247(bool) = issueRate >= 600000000000000000
CONDITION TMP_247"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
600000000000000000

IRs:
RETURN 600000000000000000"];
7[label="Node Type: IF 7

EXPRESSION:
issueRate >= 500000000000000000

IRs:
TMP_248(bool) = issueRate >= 500000000000000000
CONDITION TMP_248"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
500000000000000000

IRs:
RETURN 500000000000000000"];
9[label="Node Type: IF 9

EXPRESSION:
issueRate >= 300000000000000000

IRs:
TMP_249(bool) = issueRate >= 300000000000000000
CONDITION TMP_249"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
300000000000000000

IRs:
RETURN 300000000000000000"];
11[label="Node Type: RETURN 11

EXPRESSION:
100000000000000000

IRs:
RETURN 100000000000000000"];
}
// Function: 10159.sol-XPAAssets-getLoanAmount(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
toAmountBooks[user_][token_]

IRs:
REF_84(mapping(address => uint256)) -> toAmountBooks[user_]
REF_85(uint256) -> REF_84[token_]
RETURN REF_85"];
}
// Function: 10159.sol-XPAAssets-getMortgageRate(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
fromAmountBooks[user_] != 0

IRs:
REF_71(uint256) -> fromAmountBooks[user_]
TMP_230(bool) = REF_71 != 0
CONDITION TMP_230"];
1->2[label="True"];
1->10[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
totalLoanXPA = 0

IRs:
totalLoanXPA(uint256) := 0(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->9;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < xpaAsset.length

IRs:
REF_72 -> LENGTH xpaAsset
TMP_231(bool) = i < REF_72
CONDITION TMP_231"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
totalLoanXPA = safeAdd(totalLoanXPA,safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]),1000000000000000000),getPrice(xpaAsset[i])))

IRs:
REF_73(address) -> xpaAsset[i]
TMP_232(uint256) = INTERNAL_CALL, XPAAssets.getLoanAmount(address,address)(user_,REF_73)
TMP_233(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_232,1000000000000000000)
REF_74(address) -> xpaAsset[i]
TMP_234(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(REF_74)
TMP_235(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_233,TMP_234)
TMP_236(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalLoanXPA,TMP_235)
totalLoanXPA(uint256) := TMP_236(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_237(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
9[label="Node Type: RETURN 9

EXPRESSION:
safeDiv(safeMul(totalLoanXPA,1000000000000000000),fromAmountBooks[user_])

IRs:
TMP_238(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(totalLoanXPA,1000000000000000000)
REF_75(uint256) -> fromAmountBooks[user_]
TMP_239(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_238,REF_75)
RETURN TMP_239"];
10[label="Node Type: RETURN 10

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 10159.sol-XPAAssets-getPrice(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
TokenFactory(tokenFactory).getPrice(token_)

IRs:
TMP_253 = CONVERT tokenFactory to TokenFactory
TMP_254(uint256) = HIGH_LEVEL_CALL, dest:TMP_253(TokenFactory), function:getPrice, arguments:['token_']  
RETURN TMP_254"];
}
// Function: 10159.sol-XPAAssets-getPunishXPA(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
userFromAmount = fromAmountBooks[user_]

IRs:
REF_70(uint256) -> fromAmountBooks[user_]
userFromAmount(uint256) := REF_70(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
punishXPA = safeDiv(safeMul(userFromAmount,100000000000000000),1000000000000000000)

IRs:
TMP_224(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(userFromAmount,100000000000000000)
TMP_225(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_224,1000000000000000000)
punishXPA(uint256) := TMP_225(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
userFromAmount <= safeAdd(minForceOffsetAmount,100000000000000000000)

IRs:
TMP_226(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(minForceOffsetAmount,100000000000000000000)
TMP_227(bool) = userFromAmount <= TMP_226
CONDITION TMP_227"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
userFromAmount

IRs:
RETURN userFromAmount"];
5[label="Node Type: IF 5

EXPRESSION:
punishXPA < minForceOffsetAmount

IRs:
TMP_228(bool) = punishXPA < minForceOffsetAmount
CONDITION TMP_228"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
minForceOffsetAmount

IRs:
RETURN minForceOffsetAmount"];
7[label="Node Type: IF 7

EXPRESSION:
punishXPA > maxForceOffsetAmount

IRs:
TMP_229(bool) = punishXPA > maxForceOffsetAmount
CONDITION TMP_229"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
maxForceOffsetAmount

IRs:
RETURN maxForceOffsetAmount"];
9[label="Node Type: RETURN 9

EXPRESSION:
punishXPA

IRs:
RETURN punishXPA"];
}
// Function: 10159.sol-XPAAssets-getRemainingAmount(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amount = safeDiv(safeMul(getUsableXPA(user_),getPrice(token_)),1000000000000000000)

IRs:
TMP_270(uint256) = INTERNAL_CALL, XPAAssets.getUsableXPA(address)(user_)
TMP_271(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(token_)
TMP_272(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_270,TMP_271)
TMP_273(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_272,1000000000000000000)
amount(uint256) := TMP_273(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
safeDiv(safeMul(amount,getHighestMortgageRate()),1000000000000000000)

IRs:
TMP_274(uint256) = INTERNAL_CALL, XPAAssets.getHighestMortgageRate()()
TMP_275(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,TMP_274)
TMP_276(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_275,1000000000000000000)
RETURN TMP_276"];
}
// Function: 10159.sol-XPAAssets-getUsableXPA(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
totalLoanXPA = 0

IRs:
totalLoanXPA(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->8;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < xpaAsset.length

IRs:
REF_79 -> LENGTH xpaAsset
TMP_255(bool) = i < REF_79
CONDITION TMP_255"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
totalLoanXPA = safeAdd(totalLoanXPA,safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]),1000000000000000000),getPrice(xpaAsset[i])))

IRs:
REF_80(address) -> xpaAsset[i]
TMP_256(uint256) = INTERNAL_CALL, XPAAssets.getLoanAmount(address,address)(user_,REF_80)
TMP_257(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_256,1000000000000000000)
REF_81(address) -> xpaAsset[i]
TMP_258(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(REF_81)
TMP_259(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_257,TMP_258)
TMP_260(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalLoanXPA,TMP_259)
totalLoanXPA(uint256) := TMP_260(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_261(uint256) := i(uint256)
i(uint256) = i + 1"];
7->5;
8[label="Node Type: IF 8

EXPRESSION:
fromAmountBooks[user_] > safeDiv(safeMul(totalLoanXPA,1000000000000000000),getHighestMortgageRate())

IRs:
REF_82(uint256) -> fromAmountBooks[user_]
TMP_262(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(totalLoanXPA,1000000000000000000)
TMP_263(uint256) = INTERNAL_CALL, XPAAssets.getHighestMortgageRate()()
TMP_264(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_262,TMP_263)
TMP_265(bool) = REF_82 > TMP_264
CONDITION TMP_265"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
safeSub(fromAmountBooks[user_],safeDiv(safeMul(totalLoanXPA,1000000000000000000),getHighestMortgageRate()))

IRs:
REF_83(uint256) -> fromAmountBooks[user_]
TMP_266(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(totalLoanXPA,1000000000000000000)
TMP_267(uint256) = INTERNAL_CALL, XPAAssets.getHighestMortgageRate()()
TMP_268(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_266,TMP_267)
TMP_269(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_83,TMP_268)
RETURN TMP_269"];
10[label="Node Type: RETURN 10

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 10159.sol-XPAAssets-getUser(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
isRepresentor(representor_)

IRs:
TMP_38(bool) = INTERNAL_CALL, Authorization.isRepresentor(address)(representor_)
CONDITION TMP_38"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
representor_

IRs:
RETURN representor_"];
4[label="Node Type: RETURN 4

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 10159.sol-XPAAssets-isRepresentor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
agentBooks[representor_] == msg.sender

IRs:
REF_5(address) -> agentBooks[representor_]
TMP_37(bool) = REF_5 == msg.sender
RETURN TMP_37"];
}
// Function: 10159.sol-XPAAssets-migrate(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newContract_ != address(0))

IRs:
TMP_313 = CONVERT 0 to address
TMP_314(bool) = newContract_ != TMP_313
TMP_315(None) = SOLIDITY_CALL require(bool)(TMP_314)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
newXPAAssets == address(0) && XPAAssets(newContract_).transferXPAAssetAndProfit(xpaAsset,profit) && Token(XPA).transfer(newContract_,Token(XPA).balanceOf(this))

IRs:
TMP_316 = CONVERT 0 to address
TMP_317(bool) = newXPAAssets == TMP_316
TMP_318 = CONVERT newContract_ to XPAAssets
TMP_319(bool) = HIGH_LEVEL_CALL, dest:TMP_318(XPAAssets), function:transferXPAAssetAndProfit, arguments:['xpaAsset', 'profit']  
TMP_320(bool) = TMP_317 && TMP_319
TMP_321 = CONVERT XPA to Token
TMP_322 = CONVERT XPA to Token
TMP_323(uint256) = HIGH_LEVEL_CALL, dest:TMP_322(Token), function:balanceOf, arguments:['this']  
TMP_324(bool) = HIGH_LEVEL_CALL, dest:TMP_321(Token), function:transfer, arguments:['newContract_', 'TMP_323']  
TMP_325(bool) = TMP_320 && TMP_324
CONDITION TMP_325"];
2->3[label="True"];
2->13[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
forceOff = true

IRs:
forceOff(bool) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
powerStatus = false

IRs:
powerStatus(bool) := False(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
newXPAAssets = newContract_

IRs:
newXPAAssets(address) := newContract_(address)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
7->12;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i < xpaAsset.length

IRs:
REF_96 -> LENGTH xpaAsset
TMP_326(bool) = i < REF_96
CONDITION TMP_326"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
XPAAssets(newContract_).transferUnPaidFundAccount(xpaAsset[i],unPaidFundAccount[xpaAsset[i]])

IRs:
TMP_327 = CONVERT newContract_ to XPAAssets
REF_98(address) -> xpaAsset[i]
REF_99(address) -> xpaAsset[i]
REF_100(uint256) -> unPaidFundAccount[REF_99]
TMP_328(bool) = HIGH_LEVEL_CALL, dest:TMP_327(XPAAssets), function:transferUnPaidFundAccount, arguments:['REF_98', 'REF_100']  "];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_329(uint256) := i(uint256)
i(uint256) = i + 1"];
11->9;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
eMigrate(newContract_)

IRs:
Emit eMigrate(newContract_)"];
12->13;
13[label="Node Type: END_IF 13
"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Authorization.onlyOwner()()"];
14->1;
}
// Function: 10159.sol-XPAAssets-migrateAmountBooks(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == oldXPAAssets)

IRs:
TMP_341(bool) = msg.sender == oldXPAAssets
TMP_342(None) = SOLIDITY_CALL require(bool)(TMP_341)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! migrateBooks[user_])

IRs:
REF_103(bool) -> migrateBooks[user_]
TMP_343 = UnaryType.BANG REF_103 
TMP_344(None) = SOLIDITY_CALL require(bool)(TMP_343)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
migrateBooks[user_] = true

IRs:
REF_104(bool) -> migrateBooks[user_]
REF_104(bool) (->migrateBooks) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
fromAmountBooks[user_] = safeAdd(fromAmountBooks[user_],XPAAssets(oldXPAAssets).getFromAmountBooks(user_))

IRs:
REF_105(uint256) -> fromAmountBooks[user_]
REF_106(uint256) -> fromAmountBooks[user_]
TMP_345 = CONVERT oldXPAAssets to XPAAssets
TMP_346(uint256) = HIGH_LEVEL_CALL, dest:TMP_345(XPAAssets), function:getFromAmountBooks, arguments:['user_']  
TMP_347(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_106,TMP_346)
REF_105(uint256) (->fromAmountBooks) := TMP_347(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
forceOffsetBooks[user_] = XPAAssets(oldXPAAssets).getForceOffsetBooks(user_)

IRs:
REF_108(uint256) -> forceOffsetBooks[user_]
TMP_348 = CONVERT oldXPAAssets to XPAAssets
TMP_349(uint256) = HIGH_LEVEL_CALL, dest:TMP_348(XPAAssets), function:getForceOffsetBooks, arguments:['user_']  
REF_108(uint256) (->forceOffsetBooks) := TMP_349(uint256)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
7->12;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i < xpaAsset.length

IRs:
REF_110 -> LENGTH xpaAsset
TMP_350(bool) = i < REF_110
CONDITION TMP_350"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
toAmountBooks[user_][xpaAsset[i]] = safeAdd(toAmountBooks[user_][xpaAsset[i]],XPAAssets(oldXPAAssets).getLoanAmount(user_,xpaAsset[i]))

IRs:
REF_111(mapping(address => uint256)) -> toAmountBooks[user_]
REF_112(address) -> xpaAsset[i]
REF_113(uint256) -> REF_111[REF_112]
REF_114(mapping(address => uint256)) -> toAmountBooks[user_]
REF_115(address) -> xpaAsset[i]
REF_116(uint256) -> REF_114[REF_115]
TMP_351 = CONVERT oldXPAAssets to XPAAssets
REF_118(address) -> xpaAsset[i]
TMP_352(uint256) = HIGH_LEVEL_CALL, dest:TMP_351(XPAAssets), function:getLoanAmount, arguments:['user_', 'REF_118']  
TMP_353(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_116,TMP_352)
REF_113(uint256) (->toAmountBooks) := TMP_353(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_354(uint256) := i(uint256)
i(uint256) = i + 1"];
11->9;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
eMigrateAmount(user_)

IRs:
Emit eMigrateAmount(user_)"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
13->1;
}
// Function: 10159.sol-XPAAssets-migratingAmountBooks(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
XPAAssets(newContract_).migrateAmountBooks(user_)

IRs:
TMP_338 = CONVERT newContract_ to XPAAssets
HIGH_LEVEL_CALL, dest:TMP_338(XPAAssets), function:migrateAmountBooks, arguments:['user_']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
2->1;
}
// Function: 10159.sol-XPAAssets-mortgage(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
user = getUser(representor_)

IRs:
TMP_71(address) = INTERNAL_CALL, Authorization.getUser(address)(representor_)
user(address) := TMP_71(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
amount_ = Token(XPA).allowance(msg.sender,this)

IRs:
TMP_72 = CONVERT XPA to Token
TMP_73(uint256) = HIGH_LEVEL_CALL, dest:TMP_72(Token), function:allowance, arguments:['msg.sender', 'this']  
amount_(uint256) := TMP_73(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
amount_ >= 100000000000000000000 && Token(XPA).transferFrom(msg.sender,this,amount_)

IRs:
TMP_74(bool) = amount_ >= 100000000000000000000
TMP_75 = CONVERT XPA to Token
TMP_76(bool) = HIGH_LEVEL_CALL, dest:TMP_75(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount_']  
TMP_77(bool) = TMP_74 && TMP_76
CONDITION TMP_77"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
fromAmountBooks[user] = safeAdd(fromAmountBooks[user],amount_)

IRs:
REF_14(uint256) -> fromAmountBooks[user]
REF_15(uint256) -> fromAmountBooks[user]
TMP_78(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_15,amount_)
REF_14(uint256) (->fromAmountBooks) := TMP_78(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
eMortgage(user,amount_)

IRs:
Emit eMortgage(user,amount_)"];
5->6;
6[label="Node Type: END_IF 6
"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, Authorization.onlyActive()()"];
7->1;
}
// Function: 10159.sol-XPAAssets-offset(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->41;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.timestamp > initCanOffsetTime)

IRs:
TMP_121(bool) = block.timestamp > initCanOffsetTime
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(userFromAmount > 0)

IRs:
TMP_123(bool) = userFromAmount > 0
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
user = getUser(user_)

IRs:
TMP_125(address) = INTERNAL_CALL, Authorization.getUser(address)(user_)
user(address) := TMP_125(address)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
user_ == user && getLoanAmount(user,token_) > 0

IRs:
TMP_126(bool) = user_ == user
TMP_127(uint256) = INTERNAL_CALL, XPAAssets.getLoanAmount(address,address)(user,token_)
TMP_128(bool) = TMP_127 > 0
TMP_129(bool) = TMP_126 && TMP_128
CONDITION TMP_129"];
5->6[label="True"];
5->13[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
eOffset(user,user_,userFromAmount)

IRs:
Emit eOffset(user,user_,userFromAmount)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
remainingXPA = executeOffset(user_,userFromAmount,token_,offsetFeeRate)

IRs:
TMP_131(uint256) = INTERNAL_CALL, XPAAssets.executeOffset(address,uint256,address,uint256)(user_,userFromAmount,token_,offsetFeeRate)
remainingXPA(uint256) := TMP_131(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
remainingXPA > 0

IRs:
TMP_132(bool) = remainingXPA > 0
CONDITION TMP_132"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(Token(XPA).transfer(fundAccount,safeDiv(safeMul(safeSub(userFromAmount,remainingXPA),1000000000000000000),safeAdd(1000000000000000000,offsetFeeRate))))

IRs:
TMP_133 = CONVERT XPA to Token
TMP_134(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(userFromAmount,remainingXPA)
TMP_135(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_134,1000000000000000000)
TMP_136(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(1000000000000000000,offsetFeeRate)
TMP_137(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_135,TMP_136)
TMP_138(bool) = HIGH_LEVEL_CALL, dest:TMP_133(Token), function:transfer, arguments:['fundAccount', 'TMP_137']  
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)"];
9->11;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(Token(XPA).transfer(fundAccount,safeDiv(safeMul(safeSub(userFromAmount,remainingXPA),safeSub(1000000000000000000,offsetFeeRate)),1000000000000000000)))

IRs:
TMP_140 = CONVERT XPA to Token
TMP_141(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(userFromAmount,remainingXPA)
TMP_142(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(1000000000000000000,offsetFeeRate)
TMP_143(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_141,TMP_142)
TMP_144(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_143,1000000000000000000)
TMP_145(bool) = HIGH_LEVEL_CALL, dest:TMP_140(Token), function:transfer, arguments:['fundAccount', 'TMP_144']  
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
fromAmountBooks[user_] = safeSub(fromAmountBooks[user_],safeSub(userFromAmount,remainingXPA))

IRs:
REF_32(uint256) -> fromAmountBooks[user_]
REF_33(uint256) -> fromAmountBooks[user_]
TMP_147(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(userFromAmount,remainingXPA)
TMP_148(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_33,TMP_147)
REF_32(uint256) (->fromAmountBooks) := TMP_148(uint256)"];
12->40;
13[label="Node Type: IF 13

EXPRESSION:
user_ != user && block.timestamp > (forceOffsetBooks[user_] + 28800) && getMortgageRate(user_) >= getClosingLine()

IRs:
TMP_149(bool) = user_ != user
REF_34(uint256) -> forceOffsetBooks[user_]
TMP_150(uint256) = REF_34 + 28800
TMP_151(bool) = block.timestamp > TMP_150
TMP_152(bool) = TMP_149 && TMP_151
TMP_153(uint256) = INTERNAL_CALL, XPAAssets.getMortgageRate(address)(user_)
TMP_154(uint256) = INTERNAL_CALL, XPAAssets.getClosingLine()()
TMP_155(bool) = TMP_153 >= TMP_154
TMP_156(bool) = TMP_152 && TMP_155
CONDITION TMP_156"];
13->14[label="True"];
13->39[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
forceOffsetBooks[user_] = block.timestamp

IRs:
REF_35(uint256) -> forceOffsetBooks[user_]
REF_35(uint256) (->forceOffsetBooks) := block.timestamp(uint256)"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
punishXPA = getPunishXPA(user_)

IRs:
TMP_157(uint256) = INTERNAL_CALL, XPAAssets.getPunishXPA(address)(user_)
punishXPA(uint256) := TMP_157(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
eOffset(user,user_,punishXPA)

IRs:
Emit eOffset(user,user_,punishXPA)"];
16->17;
17[label="Node Type: NEW VARIABLE 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
forceOffsetFee[0] = safeDiv(safeMul(punishXPA,forceOffsetBasicFeeRate),1000000000000000000)

IRs:
REF_36(uint256) -> forceOffsetFee[0]
TMP_159(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(punishXPA,forceOffsetBasicFeeRate)
TMP_160(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_159,1000000000000000000)
REF_36(uint256) (->forceOffsetFee) := TMP_160(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
forceOffsetFee[1] = safeDiv(safeMul(punishXPA,forceOffsetExtraFeeRate),1000000000000000000)

IRs:
REF_37(uint256) -> forceOffsetFee[1]
TMP_161(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(punishXPA,forceOffsetExtraFeeRate)
TMP_162(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_161,1000000000000000000)
REF_37(uint256) (->forceOffsetFee) := TMP_162(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
forceOffsetFee[2] = safeDiv(safeMul(punishXPA,forceOffsetExecuteFeeRate),1000000000000000000)

IRs:
REF_38(uint256) -> forceOffsetFee[2]
TMP_163(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(punishXPA,forceOffsetExecuteFeeRate)
TMP_164(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_163,1000000000000000000)
REF_38(uint256) (->forceOffsetFee) := TMP_164(uint256)"];
20->46;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
profit = safeAdd(profit,forceOffsetFee[0])

IRs:
REF_39(uint256) -> forceOffsetFee[0]
TMP_165(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(profit,REF_39)
profit(uint256) := TMP_165(uint256)"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
allFee = safeAdd(forceOffsetFee[2],safeAdd(forceOffsetFee[0],forceOffsetFee[1]))

IRs:
REF_40(uint256) -> forceOffsetFee[2]
REF_41(uint256) -> forceOffsetFee[0]
REF_42(uint256) -> forceOffsetFee[1]
TMP_166(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_41,REF_42)
TMP_167(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_40,TMP_166)
allFee(uint256) := TMP_167(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
remainingXPA = safeSub(punishXPA,allFee)

IRs:
TMP_168(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(punishXPA,allFee)
remainingXPA(uint256) := TMP_168(uint256)"];
24->27;
25[label="Node Type: BEGIN_LOOP 25
"];
25->28;
26[label="Node Type: END_LOOP 26
"];
26->36;
27[label="Node Type: NEW VARIABLE 27

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
27->25;
28[label="Node Type: IF_LOOP 28

EXPRESSION:
i < xpaAsset.length

IRs:
REF_43 -> LENGTH xpaAsset
TMP_169(bool) = i < REF_43
CONDITION TMP_169"];
28->29[label="True"];
28->26[label="False"];
29[label="Node Type: IF 29

EXPRESSION:
getLoanAmount(user_,xpaAsset[i]) > 0

IRs:
REF_44(address) -> xpaAsset[i]
TMP_170(uint256) = INTERNAL_CALL, XPAAssets.getLoanAmount(address,address)(user_,REF_44)
TMP_171(bool) = TMP_170 > 0
CONDITION TMP_171"];
29->30[label="True"];
29->34[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
remainingXPA = executeOffset(user_,remainingXPA,xpaAsset[i],0)

IRs:
REF_45(address) -> xpaAsset[i]
TMP_172(uint256) = INTERNAL_CALL, XPAAssets.executeOffset(address,uint256,address,uint256)(user_,remainingXPA,REF_45,0)
remainingXPA(uint256) := TMP_172(uint256)"];
30->31;
31[label="Node Type: IF 31

EXPRESSION:
remainingXPA == 0

IRs:
TMP_173(bool) = remainingXPA == 0
CONDITION TMP_173"];
31->32[label="True"];
31->33[label="False"];
32[label="Node Type: BREAK 32
"];
32->26;
33[label="Node Type: END_IF 33
"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
i ++

IRs:
TMP_174(uint256) := i(uint256)
i(uint256) = i + 1"];
35->28;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
fromAmountBooks[user_] = safeSub(fromAmountBooks[user_],safeSub(punishXPA,remainingXPA))

IRs:
REF_46(uint256) -> fromAmountBooks[user_]
REF_47(uint256) -> fromAmountBooks[user_]
TMP_175(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(punishXPA,remainingXPA)
TMP_176(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_47,TMP_175)
REF_46(uint256) (->fromAmountBooks) := TMP_176(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
require(bool)(Token(XPA).transfer(fundAccount,safeAdd(forceOffsetFee[1],safeSub(safeSub(punishXPA,allFee),remainingXPA))))

IRs:
TMP_177 = CONVERT XPA to Token
REF_49(uint256) -> forceOffsetFee[1]
TMP_178(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(punishXPA,allFee)
TMP_179(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_178,remainingXPA)
TMP_180(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_49,TMP_179)
TMP_181(bool) = HIGH_LEVEL_CALL, dest:TMP_177(Token), function:transfer, arguments:['fundAccount', 'TMP_180']  
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
require(bool)(Token(XPA).transfer(msg.sender,forceOffsetFee[2]))

IRs:
TMP_183 = CONVERT XPA to Token
REF_51(uint256) -> forceOffsetFee[2]
TMP_184(bool) = HIGH_LEVEL_CALL, dest:TMP_183(Token), function:transfer, arguments:['msg.sender', 'REF_51']  
TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: END_IF 40
"];
41[label="Node Type: EXPRESSION 41

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, Authorization.onlyActive()()"];
41->42;
42[label="Node Type: IF 42

EXPRESSION:
fromAmountBooks[user_] >= maxForceOffsetAmount

IRs:
REF_52(uint256) -> fromAmountBooks[user_]
TMP_187(bool) = REF_52 >= maxForceOffsetAmount
CONDITION TMP_187"];
42->43[label="True"];
42->44[label="False"];
43[label="Node Type: EXPRESSION 43

EXPRESSION:
userFromAmount = maxForceOffsetAmount

IRs:
userFromAmount(uint256) := maxForceOffsetAmount(uint256)"];
43->45;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
userFromAmount = fromAmountBooks[user_]

IRs:
REF_53(uint256) -> fromAmountBooks[user_]
userFromAmount(uint256) := REF_53(uint256)"];
44->45;
45[label="Node Type: END_IF 45
"];
45->2;
46[label="Node Type: IF 46

EXPRESSION:
forceOffsetFee[2] > forceOffsetExecuteMaxFee

IRs:
REF_54(uint256) -> forceOffsetFee[2]
TMP_188(bool) = REF_54 > forceOffsetExecuteMaxFee
CONDITION TMP_188"];
46->47[label="True"];
46->48[label="False"];
47[label="Node Type: EXPRESSION 47

EXPRESSION:
forceOffsetFee[2] = forceOffsetExecuteMaxFee

IRs:
REF_55(uint256) -> forceOffsetFee[2]
REF_55(uint256) (->forceOffsetFee) := forceOffsetExecuteMaxFee(uint256)"];
47->49;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
forceOffsetFee[2] = forceOffsetFee[2]

IRs:
REF_56(uint256) -> forceOffsetFee[2]
REF_57(uint256) -> forceOffsetFee[2]
REF_56(uint256) (->forceOffsetFee) := REF_57(uint256)"];
48->49;
49[label="Node Type: END_IF 49
"];
49->22;
}
// Function: 10159.sol-XPAAssets-onlyActive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(powerStatus)

IRs:
TMP_364(None) = SOLIDITY_CALL assert(bool)(powerStatus)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10159.sol-XPAAssets-onlyOperator()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == operator || msg.sender == owner)

IRs:
TMP_360(bool) = msg.sender == operator
TMP_361(bool) = msg.sender == owner
TMP_362(bool) = TMP_360 || TMP_361
TMP_363(None) = SOLIDITY_CALL assert(bool)(TMP_362)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10159.sol-XPAAssets-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == owner)

IRs:
TMP_358(bool) = msg.sender == owner
TMP_359(None) = SOLIDITY_CALL assert(bool)(TMP_358)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10159.sol-XPAAssets-powerSwitch(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
forceOff

IRs:
CONDITION forceOff"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
powerStatus = false

IRs:
powerStatus(bool) := False(bool)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
powerStatus = onOff_

IRs:
powerStatus(bool) := onOff_(bool)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
5->1;
}
// Function: 10159.sol-XPAAssets-random(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
hash = keccak256()(block.number,msg.sender,salt)

IRs:
TMP_56(bytes32) = SOLIDITY_CALL keccak256()(block.number,msg.sender,salt)
hash(bytes32) := TMP_56(bytes32)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
uint256(hash) % N

IRs:
TMP_57 = CONVERT hash to uint256
TMP_58(uint256) = TMP_57 % N
RETURN TMP_58"];
}
// Function: 10159.sol-XPAAssets-repayment(address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
user = getUser(representor_)

IRs:
TMP_115(address) = INTERNAL_CALL, Authorization.getUser(address)(representor_)
user(address) := TMP_115(address)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
XPAAssetToken(token_).burnFrom(user,amount_)

IRs:
TMP_116 = CONVERT token_ to XPAAssetToken
TMP_117(bool) = HIGH_LEVEL_CALL, dest:TMP_116(XPAAssetToken), function:burnFrom, arguments:['user', 'amount_']  
CONDITION TMP_117"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
toAmountBooks[user][token_] = safeSub(toAmountBooks[user][token_],amount_)

IRs:
REF_26(mapping(address => uint256)) -> toAmountBooks[user]
REF_27(uint256) -> REF_26[token_]
REF_28(mapping(address => uint256)) -> toAmountBooks[user]
REF_29(uint256) -> REF_28[token_]
TMP_118(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_29,amount_)
REF_27(uint256) (->toAmountBooks) := TMP_118(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
eRepayment(user,token_,amount_)

IRs:
Emit eRepayment(user,token_,amount_)"];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, Authorization.onlyActive()()"];
6->1;
}
// Function: 10159.sol-XPAAssets-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_39(uint256) = x + y
z(uint256) := TMP_39(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((z >= x) && (z >= y))

IRs:
TMP_40(bool) = z >= x
TMP_41(bool) = z >= y
TMP_42(bool) = TMP_40 && TMP_41
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 10159.sol-XPAAssets-safeDiv(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(y > 0)

IRs:
TMP_53(bool) = y > 0
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
x / y

IRs:
TMP_55(uint256) = x / y
RETURN TMP_55"];
}
// Function: 10159.sol-XPAAssets-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x * y

IRs:
TMP_47(uint256) = x * y
z(uint256) := TMP_47(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((x == 0) || (z / x == y))

IRs:
TMP_48(bool) = x == 0
TMP_49(uint256) = z / x
TMP_50(bool) = TMP_49 == y
TMP_51(bool) = TMP_48 || TMP_50
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 10159.sol-XPAAssets-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(x >= y)

IRs:
TMP_44(bool) = x >= y
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
z = x - y

IRs:
TMP_46(uint256) = x - y
z(uint256) := TMP_46(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 10159.sol-XPAAssets-setFeeRate(uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(withDrawFeerate_ < 50000000000000000)

IRs:
TMP_301(bool) = withDrawFeerate_ < 50000000000000000
TMP_302(None) = SOLIDITY_CALL require(bool)(TMP_301)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(offsetFeerate_ < 50000000000000000)

IRs:
TMP_303(bool) = offsetFeerate_ < 50000000000000000
TMP_304(None) = SOLIDITY_CALL require(bool)(TMP_303)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(forceOffsetBasicFeerate_ < 50000000000000000)

IRs:
TMP_305(bool) = forceOffsetBasicFeerate_ < 50000000000000000
TMP_306(None) = SOLIDITY_CALL require(bool)(TMP_305)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(forceOffsetExecuteFeerate_ < 50000000000000000)

IRs:
TMP_307(bool) = forceOffsetExecuteFeerate_ < 50000000000000000
TMP_308(None) = SOLIDITY_CALL require(bool)(TMP_307)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(forceOffsetExtraFeerate_ < 50000000000000000)

IRs:
TMP_309(bool) = forceOffsetExtraFeerate_ < 50000000000000000
TMP_310(None) = SOLIDITY_CALL require(bool)(TMP_309)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
withdrawFeeRate = withDrawFeerate_

IRs:
withdrawFeeRate(uint256) := withDrawFeerate_(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
offsetFeeRate = offsetFeerate_

IRs:
offsetFeeRate(uint256) := offsetFeerate_(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
forceOffsetBasicFeeRate = forceOffsetBasicFeerate_

IRs:
forceOffsetBasicFeeRate(uint256) := forceOffsetBasicFeerate_(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
forceOffsetExecuteFeeRate = forceOffsetExecuteFeerate_

IRs:
forceOffsetExecuteFeeRate(uint256) := forceOffsetExecuteFeerate_(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
forceOffsetExtraFeeRate = forceOffsetExtraFeerate_

IRs:
forceOffsetExtraFeeRate(uint256) := forceOffsetExtraFeerate_(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
forceOffsetExecuteMaxFee = forceOffsetExecuteMaxFee_

IRs:
forceOffsetExecuteMaxFee(uint256) := forceOffsetExecuteMaxFee_(uint256)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
12->1;
}
// Function: 10159.sol-XPAAssets-setForceOffsetAmount(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
maxForceOffsetAmount = maxForceOffsetAmount_

IRs:
maxForceOffsetAmount(uint256) := maxForceOffsetAmount_(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minForceOffsetAmount = minForceOffsetAmount_

IRs:
minForceOffsetAmount(uint256) := minForceOffsetAmount_(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
3->1;
}
// Function: 10159.sol-XPAAssets-setFundAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
fundAccount_ != address(0)

IRs:
TMP_59 = CONVERT 0 to address
TMP_60(bool) = fundAccount_ != TMP_59
CONDITION TMP_60"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
fundAccount = fundAccount_

IRs:
fundAccount(address) := fundAccount_(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
4->1;
}
// Function: 10159.sol-XPAAssets-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
powerStatus = true

IRs:
powerStatus(bool) := True(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
forceOff = false

IRs:
forceOff(bool) := False(bool)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
version = 0.5.0

IRs:
version(string) := 0.5.0(string)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
XPA = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170

IRs:
XPA(address) := 823935433644048045433872047889176197888928395632(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
oldXPAAssets = 0x00D0F7d665996B745b2399a127D5d84DAcd42D251f

IRs:
oldXPAAssets(address) := 1192997040997033959763270305842996161670862939423(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
newXPAAssets = address(0)

IRs:
TMP_357 = CONVERT 0 to address
newXPAAssets(address) := TMP_357(address)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
tokenFactory = 0x001393F1fb2E243Ee68Efe172eBb6831772633A926

IRs:
tokenFactory(address) := 111770113722953290206371886592910215969554802982(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
maxForceOffsetAmount = 1000000000000000000000000

IRs:
maxForceOffsetAmount(uint256) := 1000000000000000000000000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
minForceOffsetAmount = 10000000000000000000000

IRs:
minForceOffsetAmount(uint256) := 10000000000000000000000(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
profit = 0

IRs:
profit(uint256) := 0(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
initCanOffsetTime = 0

IRs:
initCanOffsetTime(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
withdrawFeeRate = 20000000000000000

IRs:
withdrawFeeRate(uint256) := 20000000000000000(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
offsetFeeRate = 20000000000000000

IRs:
offsetFeeRate(uint256) := 20000000000000000(uint256)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
forceOffsetBasicFeeRate = 20000000000000000

IRs:
forceOffsetBasicFeeRate(uint256) := 20000000000000000(uint256)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
forceOffsetExecuteFeeRate = 10000000000000000

IRs:
forceOffsetExecuteFeeRate(uint256) := 10000000000000000(uint256)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
forceOffsetExtraFeeRate = 50000000000000000

IRs:
forceOffsetExtraFeeRate(uint256) := 50000000000000000(uint256)"];
15->16;
16[label="Node Type: OTHER_ENTRYPOINT 16

EXPRESSION:
forceOffsetExecuteMaxFee = 1000000000000000000000

IRs:
forceOffsetExecuteMaxFee(uint256) := 1000000000000000000000(uint256)"];
}
// Function: 10159.sol-XPAAssets-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner_

IRs:
owner(address) := newOwner_(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Authorization.onlyOwner()()"];
2->1;
}
// Function: 10159.sol-XPAAssets-transferProfit(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount_ > 0)

IRs:
TMP_281(bool) = amount_ > 0
TMP_282(None) = SOLIDITY_CALL require(bool)(TMP_281)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
XPA != token_ && Token(token_).balanceOf(this) >= amount_

IRs:
TMP_283(bool) = XPA != token_
TMP_284 = CONVERT token_ to Token
TMP_285(uint256) = HIGH_LEVEL_CALL, dest:TMP_284(Token), function:balanceOf, arguments:['this']  
TMP_286(bool) = TMP_285 >= amount_
TMP_287(bool) = TMP_283 && TMP_286
CONDITION TMP_287"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(Token(token_).transfer(bank,amount_))

IRs:
TMP_288 = CONVERT token_ to Token
TMP_289(bool) = HIGH_LEVEL_CALL, dest:TMP_288(Token), function:transfer, arguments:['bank', 'amount_']  
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
XPA == token_ && Token(XPA).balanceOf(this) >= amount_

IRs:
TMP_291(bool) = XPA == token_
TMP_292 = CONVERT XPA to Token
TMP_293(uint256) = HIGH_LEVEL_CALL, dest:TMP_292(Token), function:balanceOf, arguments:['this']  
TMP_294(bool) = TMP_293 >= amount_
TMP_295(bool) = TMP_291 && TMP_294
CONDITION TMP_295"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
profit = safeSub(profit,amount_)

IRs:
TMP_296(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(profit,amount_)
profit(uint256) := TMP_296(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(Token(token_).transfer(bank,amount_))

IRs:
TMP_297 = CONVERT token_ to Token
TMP_298(bool) = HIGH_LEVEL_CALL, dest:TMP_297(Token), function:transfer, arguments:['bank', 'amount_']  
TMP_299(None) = SOLIDITY_CALL require(bool)(TMP_298)"];
7->8;
8[label="Node Type: END_IF 8
"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
9->1;
}
// Function: 10159.sol-XPAAssets-transferUnPaidFundAccount(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == oldXPAAssets)

IRs:
TMP_335(bool) = msg.sender == oldXPAAssets
TMP_336(None) = SOLIDITY_CALL require(bool)(TMP_335)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
unPaidFundAccount[xpaAsset_] = unPaidAmount_

IRs:
REF_101(uint256) -> unPaidFundAccount[xpaAsset_]
REF_101(uint256) (->unPaidFundAccount) := unPaidAmount_(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
4->1;
}
// Function: 10159.sol-XPAAssets-transferXPAAssetAndProfit(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == oldXPAAssets)

IRs:
TMP_332(bool) = msg.sender == oldXPAAssets
TMP_333(None) = SOLIDITY_CALL require(bool)(TMP_332)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
xpaAsset = xpaAsset_

IRs:
xpaAsset(address[]) := xpaAsset_(address[])"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
profit = profit_

IRs:
profit(uint256) := profit_(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOperator()

IRs:
MODIFIER_CALL, Authorization.onlyOperator()()"];
5->1;
}
// Function: 10159.sol-XPAAssets-withdraw(address,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
user = getUser(representor_)

IRs:
TMP_81(address) = INTERNAL_CALL, Authorization.getUser(address)(representor_)
user(address) := TMP_81(address)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
token_ != XPA && amount_ > 0 && amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user),getPrice(token_)),1000000000000000000),getHighestMortgageRate()),1000000000000000000)

IRs:
TMP_82(bool) = token_ != XPA
TMP_83(bool) = amount_ > 0
TMP_84(bool) = TMP_82 && TMP_83
TMP_85(uint256) = INTERNAL_CALL, XPAAssets.getUsableXPA(address)(user)
TMP_86(uint256) = INTERNAL_CALL, XPAAssets.getPrice(address)(token_)
TMP_87(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_85,TMP_86)
TMP_88(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_87,1000000000000000000)
TMP_89(uint256) = INTERNAL_CALL, XPAAssets.getHighestMortgageRate()()
TMP_90(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(TMP_88,TMP_89)
TMP_91(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_90,1000000000000000000)
TMP_92(bool) = amount_ <= TMP_91
TMP_93(bool) = TMP_84 && TMP_92
CONDITION TMP_93"];
2->3[label="True"];
2->8[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
toAmountBooks[user][token_] = safeAdd(toAmountBooks[user][token_],amount_)

IRs:
REF_16(mapping(address => uint256)) -> toAmountBooks[user]
REF_17(uint256) -> REF_16[token_]
REF_18(mapping(address => uint256)) -> toAmountBooks[user]
REF_19(uint256) -> REF_18[token_]
TMP_94(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_19,amount_)
REF_17(uint256) (->toAmountBooks) := TMP_94(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
withdrawFee = safeDiv(safeMul(amount_,withdrawFeeRate),1000000000000000000)

IRs:
TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount_,withdrawFeeRate)
TMP_96(uint256) = INTERNAL_CALL, SafeMath.safeDiv(uint256,uint256)(TMP_95,1000000000000000000)
withdrawFee(uint256) := TMP_96(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
XPAAssetToken(token_).create(user,safeSub(amount_,withdrawFee))

IRs:
TMP_97 = CONVERT token_ to XPAAssetToken
TMP_98(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(amount_,withdrawFee)
TMP_99(bool) = HIGH_LEVEL_CALL, dest:TMP_97(XPAAssetToken), function:create, arguments:['user', 'TMP_98']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
XPAAssetToken(token_).create(this,withdrawFee)

IRs:
TMP_100 = CONVERT token_ to XPAAssetToken
TMP_101(bool) = HIGH_LEVEL_CALL, dest:TMP_100(XPAAssetToken), function:create, arguments:['this', 'withdrawFee']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
eWithdraw(user,token_,amount_)

IRs:
Emit eWithdraw(user,token_,amount_)"];
7->8;
8[label="Node Type: END_IF 8
"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, Authorization.onlyActive()()"];
9->1;
}
// Function: 10159.sol-XPAAssets-withdrawXPA(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
user = getUser(representor_)

IRs:
TMP_104(address) = INTERNAL_CALL, Authorization.getUser(address)(representor_)
user(address) := TMP_104(address)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
amount_ >= 100000000000000000000 && amount_ <= getUsableXPA(user)

IRs:
TMP_105(bool) = amount_ >= 100000000000000000000
TMP_106(uint256) = INTERNAL_CALL, XPAAssets.getUsableXPA(address)(user)
TMP_107(bool) = amount_ <= TMP_106
TMP_108(bool) = TMP_105 && TMP_107
CONDITION TMP_108"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fromAmountBooks[user] = safeSub(fromAmountBooks[user],amount_)

IRs:
REF_22(uint256) -> fromAmountBooks[user]
REF_23(uint256) -> fromAmountBooks[user]
TMP_109(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_23,amount_)
REF_22(uint256) (->fromAmountBooks) := TMP_109(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(Token(XPA).transfer(user,amount_))

IRs:
TMP_110 = CONVERT XPA to Token
TMP_111(bool) = HIGH_LEVEL_CALL, dest:TMP_110(Token), function:transfer, arguments:['user', 'amount_']  
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
eWithdraw(user,XPA,amount_)

IRs:
Emit eWithdraw(user,XPA,amount_)"];
5->6;
6[label="Node Type: END_IF 6
"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, Authorization.onlyActive()()"];
7->1;
}
}
