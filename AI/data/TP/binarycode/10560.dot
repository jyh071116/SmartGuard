digraph G {
// Function: 10560.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
}
// Function: 10560.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 10560.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = _to != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_22(bool) = _value <= REF_0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_24(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_25(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-CappedCrowdsale-CappedCrowdsale(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hardCap > 0)

IRs:
TMP_198(bool) = _hardCap > 0
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_tokensToLock > 0)

IRs:
TMP_200(bool) = _tokensToLock > 0
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_releaseTime > endTime)

IRs:
TMP_202(bool) = _releaseTime > endTime
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
hardCap = _hardCap

IRs:
hardCap(uint256) := _hardCap(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
releaseTime = _releaseTime

IRs:
releaseTime(uint256) := _releaseTime(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tokensToLock = _tokensToLock

IRs:
tokensToLock(uint256) := _tokensToLock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
timeLock = new TokenTimelock(token,wallet,releaseTime)

IRs:
TMP_205(TokenTimelock) = new TokenTimelock(token,wallet,releaseTime) 
timeLock(TokenTimelock) := TMP_205(TokenTimelock)"];
}
// Function: 10560.sol-CappedCrowdsale-Crowdsale(uint256,uint256,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_186(bool) = _startTime >= now
TMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_188(bool) = _endTime >= _startTime
TMP_189(None) = SOLIDITY_CALL require(bool)(TMP_188)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_190 = CONVERT 0 to address
TMP_191(bool) = _wallet != TMP_190
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_193(bool) = _rate > 0
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = new HoldToken(_wallet)

IRs:
TMP_196(HoldToken) = new HoldToken(_wallet) 
token(HoldToken) := TMP_196(HoldToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
weiRaised = _initialWeiRaised

IRs:
weiRaised(uint256) := _initialWeiRaised(uint256)"];
}
// Function: 10560.sol-CappedCrowdsale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10560.sol-CappedCrowdsale-finalize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_206 = UnaryType.BANG isFinalized 
TMP_207(None) = SOLIDITY_CALL require(bool)(TMP_206)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.mint(address(timeLock),tokensToLock)

IRs:
TMP_208 = CONVERT timeLock to address
TMP_209(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mint, arguments:['TMP_208', 'tokensToLock']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Finalized()

IRs:
Emit Finalized()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10560.sol-CappedCrowdsale-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.mintingFinished() == false)

IRs:
TMP_212(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mintingFinished, arguments:[]  
TMP_213(bool) = TMP_212 == False
TMP_214(None) = SOLIDITY_CALL require(bool)(TMP_213)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_215(None) = SOLIDITY_CALL require(bool)(isFinalized)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token.finishMinting()

IRs:
TMP_216(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:finishMinting, arguments:[]  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
FinishMinting()

IRs:
Emit FinishMinting()"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10560.sol-CappedCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
capReached = weiRaised >= hardCap

IRs:
TMP_231(bool) = weiRaised >= hardCap
capReached(bool) := TMP_231(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.hasEnded() || capReached || isFinalized

IRs:
TMP_232(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_233(bool) = TMP_232 || capReached
TMP_234(bool) = TMP_233 || isFinalized
RETURN TMP_234"];
}
// Function: 10560.sol-CappedCrowdsale-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! token.mintingFinished())

IRs:
TMP_219(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mintingFinished, arguments:[]  
TMP_220 = UnaryType.BANG TMP_219 
TMP_221(None) = SOLIDITY_CALL require(bool)(TMP_220)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_222(None) = SOLIDITY_CALL require(bool)(isFinalized)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_223(bool) = amount > 0
TMP_224(None) = SOLIDITY_CALL require(bool)(TMP_223)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_225 = CONVERT 0 to address
TMP_226(bool) = beneficiary != TMP_225
TMP_227(None) = SOLIDITY_CALL require(bool)(TMP_226)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token.mint(beneficiary,amount)

IRs:
TMP_228(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mint, arguments:['beneficiary', 'amount']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
TokensMinted(beneficiary,amount)

IRs:
Emit TokensMinted(beneficiary,amount)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 10560.sol-CappedCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_235(bool) = msg.sender == owner
TMP_236(None) = SOLIDITY_CALL require(bool)(TMP_235)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-CappedCrowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFinalized = false

IRs:
isFinalized(bool) := False(bool)"];
}
// Function: 10560.sol-CappedCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_181 = CONVERT 0 to address
TMP_182(bool) = newOwner != TMP_181
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10560.sol-Crowdsale-Crowdsale(uint256,uint256,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_155(bool) = _startTime >= now
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_157(bool) = _endTime >= _startTime
TMP_158(None) = SOLIDITY_CALL require(bool)(TMP_157)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_159 = CONVERT 0 to address
TMP_160(bool) = _wallet != TMP_159
TMP_161(None) = SOLIDITY_CALL require(bool)(TMP_160)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_162(bool) = _rate > 0
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = new HoldToken(_wallet)

IRs:
TMP_165(HoldToken) = new HoldToken(_wallet) 
token(HoldToken) := TMP_165(HoldToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
weiRaised = _initialWeiRaised

IRs:
weiRaised(uint256) := _initialWeiRaised(uint256)"];
}
// Function: 10560.sol-Crowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_166(bool) = now > endTime
RETURN TMP_166"];
}
// Function: 10560.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 10560.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 10560.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 10560.sol-ERC20-totalSupply()
digraph{
}
// Function: 10560.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 10560.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 10560.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 10560.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 10560.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 10560.sol-HoldCrowdsale-CappedCrowdsale(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hardCap > 0)

IRs:
TMP_277(bool) = _hardCap > 0
TMP_278(None) = SOLIDITY_CALL require(bool)(TMP_277)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_tokensToLock > 0)

IRs:
TMP_279(bool) = _tokensToLock > 0
TMP_280(None) = SOLIDITY_CALL require(bool)(TMP_279)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_releaseTime > endTime)

IRs:
TMP_281(bool) = _releaseTime > endTime
TMP_282(None) = SOLIDITY_CALL require(bool)(TMP_281)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
hardCap = _hardCap

IRs:
hardCap(uint256) := _hardCap(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
releaseTime = _releaseTime

IRs:
releaseTime(uint256) := _releaseTime(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tokensToLock = _tokensToLock

IRs:
tokensToLock(uint256) := _tokensToLock(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
timeLock = new TokenTimelock(token,wallet,releaseTime)

IRs:
TMP_284(TokenTimelock) = new TokenTimelock(token,wallet,releaseTime) 
timeLock(TokenTimelock) := TMP_284(TokenTimelock)"];
}
// Function: 10560.sol-HoldCrowdsale-Crowdsale(uint256,uint256,uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_314(bool) = _startTime >= now
TMP_315(None) = SOLIDITY_CALL require(bool)(TMP_314)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_316(bool) = _endTime >= _startTime
TMP_317(None) = SOLIDITY_CALL require(bool)(TMP_316)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_318 = CONVERT 0 to address
TMP_319(bool) = _wallet != TMP_318
TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_321(bool) = _rate > 0
TMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = new HoldToken(_wallet)

IRs:
TMP_324(HoldToken) = new HoldToken(_wallet) 
token(HoldToken) := TMP_324(HoldToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
weiRaised = _initialWeiRaised

IRs:
weiRaised(uint256) := _initialWeiRaised(uint256)"];
}
// Function: 10560.sol-HoldCrowdsale-HoldCrowdsale(uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
referralPercentage = _referralPercentage

IRs:
referralPercentage(uint256) := _referralPercentage(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
individualCap = _individualCap

IRs:
individualCap(uint256) := _individualCap(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OnlyWhiteListedAddresses(_utilityAccount)

IRs:
INTERNAL_CALL, OnlyWhiteListedAddresses.OnlyWhiteListedAddresses(address)(_utilityAccount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
CappedCrowdsale(_icoHardCapWei,_tokensToLock,_releaseTime)

IRs:
INTERNAL_CALL, CappedCrowdsale.CappedCrowdsale(uint256,uint256,uint256)(_icoHardCapWei,_tokensToLock,_releaseTime)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Crowdsale(_startTime,_endTime,_rate,_wallet,_privateWeiRaised)

IRs:
INTERNAL_CALL, Crowdsale.Crowdsale(uint256,uint256,uint256,address,uint256)(_startTime,_endTime,_rate,_wallet,_privateWeiRaised)"];
5->1;
}
// Function: 10560.sol-HoldCrowdsale-OnlyWhiteListedAddresses(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
utilityAccount = _utilityAccount

IRs:
utilityAccount(address) := _utilityAccount(address)"];
}
// Function: 10560.sol-HoldCrowdsale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10560.sol-HoldCrowdsale-addAddressReferrals(address[],address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(users.length == _referrals.length)

IRs:
REF_171 -> LENGTH users
REF_172 -> LENGTH _referrals
TMP_264(bool) = REF_171 == REF_172
TMP_265(None) = SOLIDITY_CALL require(bool)(TMP_264)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->9;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < users.length

IRs:
REF_173 -> LENGTH users
TMP_266(bool) = i < REF_173
CONDITION TMP_266"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(isWhiteListedAddress(users[i]))

IRs:
REF_174(address) -> users[i]
TMP_267(bool) = INTERNAL_CALL, OnlyWhiteListedAddresses.isWhiteListedAddress(address)(REF_174)
TMP_268(None) = SOLIDITY_CALL require(bool)(TMP_267)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
referrals[users[i]] = _referrals[i]

IRs:
REF_175(address) -> users[i]
REF_176(address) -> referrals[REF_175]
REF_177(address) -> _referrals[i]
REF_176(address) (->referrals) := REF_177(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_269(uint256) := i(uint256)
i(uint256) = i + 1"];
8->5;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
ReferralsAdded(users,_referrals)

IRs:
Emit ReferralsAdded(users,_referrals)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyOwnerOrUtility()

IRs:
MODIFIER_CALL, OnlyWhiteListedAddresses.onlyOwnerOrUtility()()"];
10->1;
}
// Function: 10560.sol-HoldCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_330 = UnaryType.BANG isFinalized 
TMP_331(None) = SOLIDITY_CALL require(bool)(TMP_330)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(beneficiary == msg.sender)

IRs:
TMP_332(bool) = beneficiary == msg.sender
TMP_333(None) = SOLIDITY_CALL require(bool)(TMP_332)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value != 0)

IRs:
TMP_334(bool) = msg.value != 0
TMP_335(None) = SOLIDITY_CALL require(bool)(TMP_334)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.value >= individualCap)

IRs:
TMP_336(bool) = msg.value >= individualCap
TMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(isWhiteListedAddress(beneficiary))

IRs:
TMP_338(bool) = INTERNAL_CALL, OnlyWhiteListedAddresses.isWhiteListedAddress(address)(beneficiary)
TMP_339(None) = SOLIDITY_CALL require(bool)(TMP_338)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(validPurchase(weiAmount))

IRs:
TMP_340(bool) = INTERNAL_CALL, HoldCrowdsale.validPurchase(uint256)(weiAmount)
TMP_341(None) = SOLIDITY_CALL require(bool)(TMP_340)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_342(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_342(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
_transactionId = transactionId

IRs:
_transactionId(uint256) := transactionId(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
tokensAmount = weiAmount.mul(rate)

IRs:
TMP_343(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'rate'] 
tokensAmount(uint256) := TMP_343(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
pendingTransactions[_transactionId] = TokenPurchaseRecord(now,weiAmount,beneficiary)

IRs:
REF_186(HoldCrowdsale.TokenPurchaseRecord) -> pendingTransactions[_transactionId]
TMP_344(HoldCrowdsale.TokenPurchaseRecord) = new TokenPurchaseRecord(now,weiAmount,beneficiary)
REF_186(HoldCrowdsale.TokenPurchaseRecord) (->pendingTransactions) := TMP_344(HoldCrowdsale.TokenPurchaseRecord)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
transactionId += 1

IRs:
transactionId(uint256) = transactionId + 1"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
TokenPurchaseRequest(_transactionId,beneficiary,now,weiAmount,tokensAmount)

IRs:
Emit TokenPurchaseRequest(_transactionId,beneficiary,now,weiAmount,tokensAmount)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, HoldCrowdsale.forwardFunds()()"];
}
// Function: 10560.sol-HoldCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, HoldCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10560.sol-HoldCrowdsale-finalize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_285 = UnaryType.BANG isFinalized 
TMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.mint(address(timeLock),tokensToLock)

IRs:
TMP_287 = CONVERT timeLock to address
TMP_288(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mint, arguments:['TMP_287', 'tokensToLock']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Finalized()

IRs:
Emit Finalized()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10560.sol-HoldCrowdsale-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.mintingFinished() == false)

IRs:
TMP_291(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mintingFinished, arguments:[]  
TMP_292(bool) = TMP_291 == False
TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_294(None) = SOLIDITY_CALL require(bool)(isFinalized)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token.finishMinting()

IRs:
TMP_295(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:finishMinting, arguments:[]  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
FinishMinting()

IRs:
Emit FinishMinting()"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10560.sol-HoldCrowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 10560.sol-HoldCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_325(bool) = now > endTime
RETURN TMP_325"];
}
// Function: 10560.sol-HoldCrowdsale-isWhiteListedAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
whitelist[addr]

IRs:
REF_178(bool) -> whitelist[addr]
RETURN REF_178"];
}
// Function: 10560.sol-HoldCrowdsale-issueTokens(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(completedTransactions[_transactionId] != true)

IRs:
REF_192(bool) -> completedTransactions[_transactionId]
TMP_354(bool) = REF_192 != True
TMP_355(None) = SOLIDITY_CALL require(bool)(TMP_354)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(pendingTransactions[_transactionId].timestamp != 0)

IRs:
REF_193(HoldCrowdsale.TokenPurchaseRecord) -> pendingTransactions[_transactionId]
REF_194(uint256) -> REF_193.timestamp
TMP_356(bool) = REF_194 != 0
TMP_357(None) = SOLIDITY_CALL require(bool)(TMP_356)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
record = pendingTransactions[_transactionId]

IRs:
REF_195(HoldCrowdsale.TokenPurchaseRecord) -> pendingTransactions[_transactionId]
record(HoldCrowdsale.TokenPurchaseRecord) := REF_195(HoldCrowdsale.TokenPurchaseRecord)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = record.weiAmount.mul(rate)

IRs:
REF_196(uint256) -> record.weiAmount
TMP_358(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_196', 'rate'] 
tokens(uint256) := TMP_358(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
referralAddress = referrals[record.beneficiary]

IRs:
REF_198(address) -> record.beneficiary
REF_199(address) -> referrals[REF_198]
referralAddress(address) := REF_199(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.mint(record.beneficiary,tokens)

IRs:
REF_201(address) -> record.beneficiary
TMP_359(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mint, arguments:['REF_201', 'tokens']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(record.beneficiary,record.weiAmount,tokens,_transactionId)

IRs:
REF_202(address) -> record.beneficiary
REF_203(uint256) -> record.weiAmount
Emit TokenPurchase(REF_202,REF_203,tokens,_transactionId)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
completedTransactions[_transactionId] = true

IRs:
REF_204(bool) -> completedTransactions[_transactionId]
REF_204(bool) (->completedTransactions) := True(bool)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
bonusTokensAmount != 0

IRs:
TMP_361(bool) = bonusTokensAmount != 0
CONDITION TMP_361"];
9->10[label="True"];
9->13[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(bonusTokensAmount != 0)

IRs:
TMP_362(bool) = bonusTokensAmount != 0
TMP_363(None) = SOLIDITY_CALL require(bool)(TMP_362)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
token.mint(record.beneficiary,bonusTokensAmount)

IRs:
REF_206(address) -> record.beneficiary
TMP_364(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mint, arguments:['REF_206', 'bonusTokensAmount']  "];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
BonusTokensSent(record.beneficiary,bonusTokensAmount,_transactionId)

IRs:
REF_207(address) -> record.beneficiary
Emit BonusTokensSent(REF_207,bonusTokensAmount,_transactionId)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
referralAddress != address(0)

IRs:
TMP_366 = CONVERT 0 to address
TMP_367(bool) = referralAddress != TMP_366
CONDITION TMP_367"];
14->15[label="True"];
14->18[label="False"];
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
referralAmount = tokens.mul(referralPercentage).div(uint256(100))

IRs:
TMP_368(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'referralPercentage'] 
TMP_369 = CONVERT 100 to uint256
TMP_370(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_368', 'TMP_369'] 
referralAmount(uint256) := TMP_370(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
token.mint(referralAddress,referralAmount)

IRs:
TMP_371(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mint, arguments:['referralAddress', 'referralAmount']  "];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
ReferralTokensSent(referralAddress,referralAmount,_transactionId)

IRs:
Emit ReferralTokensSent(referralAddress,referralAmount,_transactionId)"];
17->18;
18[label="Node Type: END_IF 18
"];
}
// Function: 10560.sol-HoldCrowdsale-issueTokensMultiple(uint256[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_347(None) = SOLIDITY_CALL require(bool)(isFinalized)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_transactionIds.length == bonusTokensAmounts.length)

IRs:
REF_187 -> LENGTH _transactionIds
REF_188 -> LENGTH bonusTokensAmounts
TMP_348(bool) = REF_187 == REF_188
TMP_349(None) = SOLIDITY_CALL require(bool)(TMP_348)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < _transactionIds.length

IRs:
REF_189 -> LENGTH _transactionIds
TMP_350(bool) = i < REF_189
CONDITION TMP_350"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
issueTokens(_transactionIds[i],bonusTokensAmounts[i])

IRs:
REF_190(uint256) -> _transactionIds[i]
REF_191(uint256) -> bonusTokensAmounts[i]
INTERNAL_CALL, HoldCrowdsale.issueTokens(uint256,uint256)(REF_190,REF_191)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_352(uint256) := i(uint256)
i(uint256) = i + 1"];
8->6;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
9->1;
}
// Function: 10560.sol-HoldCrowdsale-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! token.mintingFinished())

IRs:
TMP_298(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mintingFinished, arguments:[]  
TMP_299 = UnaryType.BANG TMP_298 
TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_301(None) = SOLIDITY_CALL require(bool)(isFinalized)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_302(bool) = amount > 0
TMP_303(None) = SOLIDITY_CALL require(bool)(TMP_302)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_304 = CONVERT 0 to address
TMP_305(bool) = beneficiary != TMP_304
TMP_306(None) = SOLIDITY_CALL require(bool)(TMP_305)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token.mint(beneficiary,amount)

IRs:
TMP_307(bool) = HIGH_LEVEL_CALL, dest:token(HoldToken), function:mint, arguments:['beneficiary', 'amount']  "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
TokensMinted(beneficiary,amount)

IRs:
Emit TokensMinted(beneficiary,amount)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 10560.sol-HoldCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_384(bool) = msg.sender == owner
TMP_385(None) = SOLIDITY_CALL require(bool)(TMP_384)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-HoldCrowdsale-onlyOwnerOrUtility()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == utilityAccount)

IRs:
TMP_380(bool) = msg.sender == owner
TMP_381(bool) = msg.sender == utilityAccount
TMP_382(bool) = TMP_380 || TMP_381
TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-HoldCrowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFinalized = false

IRs:
isFinalized(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
transactionId = 1

IRs:
transactionId(uint256) := 1(uint256)"];
}
// Function: 10560.sol-HoldCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_272 = CONVERT 0 to address
TMP_273(bool) = newOwner != TMP_272
TMP_274(None) = SOLIDITY_CALL require(bool)(TMP_273)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10560.sol-HoldCrowdsale-validPurchase(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinCap = weiRaised.add(weiAmount) <= hardCap

IRs:
TMP_373(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
TMP_374(bool) = TMP_373 <= hardCap
withinCap(bool) := TMP_374(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
withinCrowdsaleInterval = now >= startTime && now <= endTime

IRs:
TMP_375(bool) = now >= startTime
TMP_376(bool) = now <= endTime
TMP_377(bool) = TMP_375 && TMP_376
withinCrowdsaleInterval(bool) := TMP_377(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
withinCrowdsaleInterval && withinCap

IRs:
TMP_378(bool) = withinCrowdsaleInterval && withinCap
RETURN TMP_378"];
}
// Function: 10560.sol-HoldCrowdsale-whitelistAddress(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->7;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < users.length

IRs:
REF_168 -> LENGTH users
TMP_260(bool) = i < REF_168
CONDITION TMP_260"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
whitelist[users[i]] = true

IRs:
REF_169(address) -> users[i]
REF_170(bool) -> whitelist[REF_169]
REF_170(bool) (->whitelist) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_261(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
WhitelistedAddresses(users)

IRs:
Emit WhitelistedAddresses(users)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwnerOrUtility()

IRs:
MODIFIER_CALL, OnlyWhiteListedAddresses.onlyOwnerOrUtility()()"];
8->3;
}
// Function: 10560.sol-HoldToken-HoldToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
burnerRole = _burner

IRs:
burnerRole(address) := _burner(address)"];
}
// Function: 10560.sol-HoldToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10560.sol-HoldToken-allowance(address,address)
digraph{
}
// Function: 10560.sol-HoldToken-approve(address,uint256)
digraph{
}
// Function: 10560.sol-HoldToken-balanceOf(address)
digraph{
}
// Function: 10560.sol-HoldToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_142(uint256) -> balances[msg.sender]
TMP_141(bool) = _value <= REF_142
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_143(uint256) -> balances[msg.sender]
REF_144(uint256) -> balances[msg.sender]
TMP_143(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_144', '_value'] 
REF_143(uint256) (->balances) := TMP_143(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_144(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,address(0),_value)

IRs:
TMP_146 = CONVERT 0 to address
Emit Transfer(msg.sender,TMP_146,_value)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyBurner()

IRs:
MODIFIER_CALL, HoldToken.onlyBurner()()"];
6->1;
}
// Function: 10560.sol-HoldToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_149 = UnaryType.BANG mintingFinished 
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-HoldToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_125(mapping(address => uint256)) -> allowed[msg.sender]
REF_126(uint256) -> REF_125[_spender]
oldValue(uint256) := REF_126(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_125(bool) = _subtractedValue > oldValue
CONDITION TMP_125"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_127(mapping(address => uint256)) -> allowed[msg.sender]
REF_128(uint256) -> REF_127[_spender]
REF_128(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_129(mapping(address => uint256)) -> allowed[msg.sender]
REF_130(uint256) -> REF_129[_spender]
TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_130(uint256) (->allowed) := TMP_126(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_132(mapping(address => uint256)) -> allowed[msg.sender]
REF_133(uint256) -> REF_132[_spender]
Emit Approval(msg.sender,_spender,REF_133)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-HoldToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 10560.sol-HoldToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_118(mapping(address => uint256)) -> allowed[msg.sender]
REF_119(uint256) -> REF_118[_spender]
REF_120(mapping(address => uint256)) -> allowed[msg.sender]
REF_121(uint256) -> REF_120[_spender]
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_121', '_addedValue'] 
REF_119(uint256) (->allowed) := TMP_123(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_123(mapping(address => uint256)) -> allowed[msg.sender]
REF_124(uint256) -> REF_123[_spender]
Emit Approval(msg.sender,_spender,REF_124)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-HoldToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply_ = totalSupply_.add(_amount)

IRs:
TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
totalSupply_(uint256) := TMP_96(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_97(uint256) -> balances[_to]
REF_98(uint256) -> balances[_to]
TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_98', '_amount'] 
REF_97(uint256) (->balances) := TMP_97(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_99 = CONVERT 0 to address
Emit Transfer(TMP_99,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 10560.sol-HoldToken-onlyBurner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == burnerRole)

IRs:
TMP_153(bool) = msg.sender == burnerRole
TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-HoldToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_151(bool) = msg.sender == owner
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-HoldToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
name = HOLD

IRs:
name(string) := HOLD(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
symbol = HOLD

IRs:
symbol(string) := HOLD(string)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
}
// Function: 10560.sol-HoldToken-totalSupply()
digraph{
}
// Function: 10560.sol-HoldToken-transfer(address,uint256)
digraph{
}
// Function: 10560.sol-HoldToken-transferBurnRole(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newBurner != address(0))

IRs:
TMP_136 = CONVERT 0 to address
TMP_137(bool) = newBurner != TMP_136
TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
BurnTransferred(burnerRole,newBurner)

IRs:
Emit BurnTransferred(burnerRole,newBurner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
burnerRole = newBurner

IRs:
burnerRole(address) := newBurner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyBurner()

IRs:
MODIFIER_CALL, HoldToken.onlyBurner()()"];
4->1;
}
// Function: 10560.sol-HoldToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 10560.sol-HoldToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_106 = CONVERT 0 to address
TMP_107(bool) = newOwner != TMP_106
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10560.sol-Migrations-Migrations()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10560.sol-Migrations-restricted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_390(bool) = msg.sender == owner
CONDITION TMP_390"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 10560.sol-Migrations-setCompleted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
last_completed_migration = completed

IRs:
last_completed_migration(uint256) := completed(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
restricted()

IRs:
MODIFIER_CALL, Migrations.restricted()()"];
2->1;
}
// Function: 10560.sol-Migrations-upgrade(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
upgraded = Migrations(new_address)

IRs:
TMP_387 = CONVERT new_address to Migrations
upgraded(Migrations) := TMP_387(Migrations)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
upgraded.setCompleted(last_completed_migration)

IRs:
HIGH_LEVEL_CALL, dest:upgraded(Migrations), function:setCompleted, arguments:['last_completed_migration']  "];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
restricted()

IRs:
MODIFIER_CALL, Migrations.restricted()()"];
3->1;
}
// Function: 10560.sol-MintableToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10560.sol-MintableToken-allowance(address,address)
digraph{
}
// Function: 10560.sol-MintableToken-approve(address,uint256)
digraph{
}
// Function: 10560.sol-MintableToken-balanceOf(address)
digraph{
}
// Function: 10560.sol-MintableToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_94 = UnaryType.BANG mintingFinished 
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-MintableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
oldValue(uint256) := REF_76(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_71(bool) = _subtractedValue > oldValue
CONDITION TMP_71"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
REF_78(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_80(uint256) (->allowed) := TMP_72(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
Emit Approval(msg.sender,_spender,REF_83)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-MintableToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 10560.sol-MintableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] 
REF_69(uint256) (->allowed) := TMP_69(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_73(mapping(address => uint256)) -> allowed[msg.sender]
REF_74(uint256) -> REF_73[_spender]
Emit Approval(msg.sender,_spender,REF_74)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-MintableToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply_ = totalSupply_.add(_amount)

IRs:
TMP_82(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
totalSupply_(uint256) := TMP_82(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_93(uint256) -> balances[_to]
REF_94(uint256) -> balances[_to]
TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_94', '_amount'] 
REF_93(uint256) (->balances) := TMP_83(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_85 = CONVERT 0 to address
Emit Transfer(TMP_85,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 10560.sol-MintableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_92(bool) = msg.sender == owner
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-MintableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
}
// Function: 10560.sol-MintableToken-totalSupply()
digraph{
}
// Function: 10560.sol-MintableToken-transfer(address,uint256)
digraph{
}
// Function: 10560.sol-MintableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 10560.sol-MintableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_52 = CONVERT 0 to address
TMP_53(bool) = newOwner != TMP_52
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10560.sol-OnlyWhiteListedAddresses-OnlyWhiteListedAddresses(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
utilityAccount = _utilityAccount

IRs:
utilityAccount(address) := _utilityAccount(address)"];
}
// Function: 10560.sol-OnlyWhiteListedAddresses-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10560.sol-OnlyWhiteListedAddresses-addAddressReferrals(address[],address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(users.length == _referrals.length)

IRs:
REF_160 -> LENGTH users
REF_161 -> LENGTH _referrals
TMP_246(bool) = REF_160 == REF_161
TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->9;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < users.length

IRs:
REF_162 -> LENGTH users
TMP_248(bool) = i < REF_162
CONDITION TMP_248"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(isWhiteListedAddress(users[i]))

IRs:
REF_163(address) -> users[i]
TMP_249(bool) = INTERNAL_CALL, OnlyWhiteListedAddresses.isWhiteListedAddress(address)(REF_163)
TMP_250(None) = SOLIDITY_CALL require(bool)(TMP_249)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
referrals[users[i]] = _referrals[i]

IRs:
REF_164(address) -> users[i]
REF_165(address) -> referrals[REF_164]
REF_166(address) -> _referrals[i]
REF_165(address) (->referrals) := REF_166(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_251(uint256) := i(uint256)
i(uint256) = i + 1"];
8->5;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
ReferralsAdded(users,_referrals)

IRs:
Emit ReferralsAdded(users,_referrals)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyOwnerOrUtility()

IRs:
MODIFIER_CALL, OnlyWhiteListedAddresses.onlyOwnerOrUtility()()"];
10->1;
}
// Function: 10560.sol-OnlyWhiteListedAddresses-isWhiteListedAddress(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
whitelist[addr]

IRs:
REF_167(bool) -> whitelist[addr]
RETURN REF_167"];
}
// Function: 10560.sol-OnlyWhiteListedAddresses-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_254(bool) = msg.sender == owner
TMP_255(None) = SOLIDITY_CALL require(bool)(TMP_254)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-OnlyWhiteListedAddresses-onlyOwnerOrUtility()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == utilityAccount)

IRs:
TMP_256(bool) = msg.sender == owner
TMP_257(bool) = msg.sender == utilityAccount
TMP_258(bool) = TMP_256 || TMP_257
TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-OnlyWhiteListedAddresses-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_237 = CONVERT 0 to address
TMP_238(bool) = newOwner != TMP_237
TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10560.sol-OnlyWhiteListedAddresses-whitelistAddress(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->7;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < users.length

IRs:
REF_157 -> LENGTH users
TMP_242(bool) = i < REF_157
CONDITION TMP_242"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
whitelist[users[i]] = true

IRs:
REF_158(address) -> users[i]
REF_159(bool) -> whitelist[REF_158]
REF_159(bool) (->whitelist) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_243(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
WhitelistedAddresses(users)

IRs:
Emit WhitelistedAddresses(users)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwnerOrUtility()

IRs:
MODIFIER_CALL, OnlyWhiteListedAddresses.onlyOwnerOrUtility()()"];
8->3;
}
// Function: 10560.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10560.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_17(bool) = msg.sender == owner
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10560.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = newOwner != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10560.sol-SafeERC20-safeApprove(ERC20,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(token.approve(spender,value))

IRs:
TMP_171(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['spender', 'value']  
TMP_172(None) = SOLIDITY_CALL assert(bool)(TMP_171)"];
}
// Function: 10560.sol-SafeERC20-safeTransfer(ERC20Basic,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(token.transfer(to,value))

IRs:
TMP_167(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['to', 'value']  
TMP_168(None) = SOLIDITY_CALL assert(bool)(TMP_167)"];
}
// Function: 10560.sol-SafeERC20-safeTransferFrom(ERC20,address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(token.transferFrom(from,to,value))

IRs:
TMP_169(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['from', 'to', 'value']  
TMP_170(None) = SOLIDITY_CALL assert(bool)(TMP_169)"];
}
// Function: 10560.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10560.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a / b

IRs:
TMP_5(uint256) = a / b
RETURN TMP_5"];
}
// Function: 10560.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10560.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 10560.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 10560.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 10560.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_49(bool) = _subtractedValue > oldValue
CONDITION TMP_49"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_50(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_50(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_47(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-StandardToken-totalSupply()
digraph{
}
// Function: 10560.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 10560.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_35 = CONVERT 0 to address
TMP_36(bool) = _to != TMP_35
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_38(bool) = _value <= REF_16
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_40(bool) = _value <= REF_18
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_42(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_43(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_44(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10560.sol-TokenTimelock-TokenTimelock(ERC20Basic,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_releaseTime > block.timestamp)

IRs:
TMP_173(bool) = _releaseTime > block.timestamp
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token = _token

IRs:
token(ERC20Basic) := _token(ERC20Basic)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
beneficiary = _beneficiary

IRs:
beneficiary(address) := _beneficiary(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
releaseTime = _releaseTime

IRs:
releaseTime(uint256) := _releaseTime(uint256)"];
}
// Function: 10560.sol-TokenTimelock-release()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp >= releaseTime)

IRs:
TMP_175(bool) = block.timestamp >= releaseTime
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
amount = token.balanceOf(this)

IRs:
TMP_177(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  
amount(uint256) := TMP_177(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_178(bool) = amount > 0
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
token.safeTransfer(beneficiary,amount)

IRs:
LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', 'beneficiary', 'amount'] "];
}
}
