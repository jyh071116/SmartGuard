digraph G {
// Function: 10755.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = _to != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_15(bool) = _value <= REF_0
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_17(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_18(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-BonusableCrowdsale-Crowdsale(uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_754(bool) = _startTime >= now
TMP_755(None) = SOLIDITY_CALL require(bool)(TMP_754)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_756(bool) = _endTime >= _startTime
TMP_757(None) = SOLIDITY_CALL require(bool)(TMP_756)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_758(bool) = _rate > 0
TMP_759(None) = SOLIDITY_CALL require(bool)(TMP_758)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_760 = CONVERT 0 to address
TMP_761(bool) = _wallet != TMP_760
TMP_762(None) = SOLIDITY_CALL require(bool)(TMP_761)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = createTokenContract()

IRs:
TMP_763(MintableToken) = INTERNAL_CALL, Crowdsale.createTokenContract()()
token(MintableToken) := TMP_763(MintableToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10755.sol-BonusableCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_784 = CONVERT 0 to address
TMP_785(bool) = beneficiary != TMP_784
TMP_786(None) = SOLIDITY_CALL require(bool)(TMP_785)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_787(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_788(None) = SOLIDITY_CALL require(bool)(TMP_787)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
bonusRate = getBonusRate(weiAmount)

IRs:
TMP_789(uint256) = INTERNAL_CALL, BonusableCrowdsale.getBonusRate(uint256)(weiAmount)
bonusRate(uint256) := TMP_789(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
tokens = weiAmount.mul(bonusRate).div(1000000000000000000)

IRs:
TMP_790(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'bonusRate'] 
TMP_791(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_790', '1000000000000000000'] 
tokens(uint256) := TMP_791(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_792(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_792(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_793(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'tokens']  "];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()"];
}
// Function: 10755.sol-BonusableCrowdsale-createTokenContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
new MintableToken()

IRs:
TMP_765(MintableToken) = new MintableToken() 
RETURN TMP_765"];
}
// Function: 10755.sol-BonusableCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, BonusableCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10755.sol-BonusableCrowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 10755.sol-BonusableCrowdsale-getBonusRate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bonusRate = rate

IRs:
bonusRate(uint256) := rate(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
weiRaisedStartsBoundaries = (uint256(0),uint256(0),uint256(0),uint256(0))

IRs:
TMP_796 = CONVERT 0 to uint256
TMP_797 = CONVERT 0 to uint256
TMP_798 = CONVERT 0 to uint256
TMP_799 = CONVERT 0 to uint256
weiRaisedStartsBoundaries(uint256[4]) = ['TMP_796(uint256)', 'TMP_797(uint256)', 'TMP_798(uint256)', 'TMP_799(uint256)']"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiRaisedEndsBoundaries = (uint256(20000000000000000000000),uint256(20000000000000000000000),uint256(20000000000000000000000),uint256(20000000000000000000000))

IRs:
TMP_800 = CONVERT 20000000000000000000000 to uint256
TMP_801 = CONVERT 20000000000000000000000 to uint256
TMP_802 = CONVERT 20000000000000000000000 to uint256
TMP_803 = CONVERT 20000000000000000000000 to uint256
weiRaisedEndsBoundaries(uint256[4]) = ['TMP_800(uint256)', 'TMP_801(uint256)', 'TMP_802(uint256)', 'TMP_803(uint256)']"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
timeStartsBoundaries = (uint64(1531087260),uint64(1532383140),uint64(1534197540),uint64(1536011940))

IRs:
TMP_804 = CONVERT 1531087260 to uint64
TMP_805 = CONVERT 1532383140 to uint64
TMP_806 = CONVERT 1534197540 to uint64
TMP_807 = CONVERT 1536011940 to uint64
timeStartsBoundaries(uint64[4]) = ['TMP_804(uint64)', 'TMP_805(uint64)', 'TMP_806(uint64)', 'TMP_807(uint64)']"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
timeEndsBoundaries = (uint64(1532383140),uint64(1534197540),uint64(1536011940),uint64(1537221540))

IRs:
TMP_808 = CONVERT 1532383140 to uint64
TMP_809 = CONVERT 1534197540 to uint64
TMP_810 = CONVERT 1536011940 to uint64
TMP_811 = CONVERT 1537221540 to uint64
timeEndsBoundaries(uint64[4]) = ['TMP_808(uint64)', 'TMP_809(uint64)', 'TMP_810(uint64)', 'TMP_811(uint64)']"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
weiRaisedAndTimeRates = (uint256(400),uint256(300),uint256(200),uint256(100))

IRs:
TMP_812 = CONVERT 400 to uint256
TMP_813 = CONVERT 300 to uint256
TMP_814 = CONVERT 200 to uint256
TMP_815 = CONVERT 100 to uint256
weiRaisedAndTimeRates(uint256[4]) = ['TMP_812(uint256)', 'TMP_813(uint256)', 'TMP_814(uint256)', 'TMP_815(uint256)']"];
6->9;
7[label="Node Type: BEGIN_LOOP 7
"];
7->10;
8[label="Node Type: END_LOOP 8
"];
8->17;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
9->7;
10[label="Node Type: IF_LOOP 10

EXPRESSION:
i < 4

IRs:
TMP_816(bool) = i < 4
CONDITION TMP_816"];
10->11[label="True"];
10->8[label="False"];
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i])

IRs:
REF_470(uint256) -> weiRaisedStartsBoundaries[i]
TMP_817(bool) = REF_470 <= weiRaised
REF_471(uint256) -> weiRaisedEndsBoundaries[i]
TMP_818(bool) = weiRaised < REF_471
TMP_819(bool) = TMP_817 && TMP_818
weiRaisedInBound(bool) := TMP_819(bool)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i])

IRs:
REF_472(uint64) -> timeStartsBoundaries[i]
TMP_820(bool) = REF_472 <= now
REF_473(uint64) -> timeEndsBoundaries[i]
TMP_821(bool) = now < REF_473
TMP_822(bool) = TMP_820 && TMP_821
timeInBound(bool) := TMP_822(bool)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
weiRaisedInBound && timeInBound

IRs:
TMP_823(bool) = weiRaisedInBound && timeInBound
CONDITION TMP_823"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000

IRs:
REF_474(uint256) -> weiRaisedAndTimeRates[i]
TMP_824(uint256) = bonusRate * REF_474
TMP_825(uint256) = TMP_824 / 1000
bonusRate(uint256) = bonusRate + TMP_825"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_826(uint256) := i(uint256)
i(uint256) = i + 1"];
16->10;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
weiAmountBoundaries = (uint256(20000000000000000000),uint256(10000000000000000000))

IRs:
TMP_827 = CONVERT 20000000000000000000 to uint256
TMP_828 = CONVERT 10000000000000000000 to uint256
weiAmountBoundaries(uint256[2]) = ['TMP_827(uint256)', 'TMP_828(uint256)']"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
weiAmountRates = (uint256(0),uint256(50))

IRs:
TMP_829 = CONVERT 0 to uint256
TMP_830 = CONVERT 50 to uint256
weiAmountRates(uint256[2]) = ['TMP_829(uint256)', 'TMP_830(uint256)']"];
18->21;
19[label="Node Type: BEGIN_LOOP 19
"];
19->22;
20[label="Node Type: END_LOOP 20
"];
20->28;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
21->19;
22[label="Node Type: IF_LOOP 22

EXPRESSION:
j < 2

IRs:
TMP_831(bool) = j < 2
CONDITION TMP_831"];
22->23[label="True"];
22->20[label="False"];
23[label="Node Type: IF 23

EXPRESSION:
weiAmount >= weiAmountBoundaries[j]

IRs:
REF_475(uint256) -> weiAmountBoundaries[j]
TMP_832(bool) = weiAmount >= REF_475
CONDITION TMP_832"];
23->24[label="True"];
23->26[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
bonusRate += bonusRate * weiAmountRates[j] / 1000

IRs:
REF_476(uint256) -> weiAmountRates[j]
TMP_833(uint256) = bonusRate * REF_476
TMP_834(uint256) = TMP_833 / 1000
bonusRate(uint256) = bonusRate + TMP_834"];
24->25;
25[label="Node Type: BREAK 25
"];
25->20;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
j ++

IRs:
TMP_835(uint256) := j(uint256)
j(uint256) = j + 1"];
27->22;
28[label="Node Type: RETURN 28

EXPRESSION:
bonusRate

IRs:
RETURN bonusRate"];
}
// Function: 10755.sol-BonusableCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_783(bool) = now > endTime
RETURN TMP_783"];
}
// Function: 10755.sol-BonusableCrowdsale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
TOKEN_DECIMALS = 18

IRs:
TOKEN_DECIMALS(uint256) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
TOKEN_DECIMALS_UINT8 = 18

IRs:
TOKEN_DECIMALS_UINT8(uint8) := 18(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS

IRs:
TMP_836(uint256) = 10 ** TOKEN_DECIMALS
TOKEN_DECIMAL_MULTIPLIER(uint256) := TMP_836(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TOKEN_NAME = Word of mouth pro

IRs:
TOKEN_NAME(string) := Word of mouth pro(string)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
TOKEN_SYMBOL = wmp

IRs:
TOKEN_SYMBOL(string) := wmp(string)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
PAUSED = true

IRs:
PAUSED(bool) := True(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
TARGET_USER = 0x63DA42f4151F88c7EAAeBb67783D855b4ac8AdD7

IRs:
TARGET_USER(address) := 570057481232686336990038773061472884575540129239(address)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
START_TIME = 1531087260

IRs:
START_TIME(uint256) := 1531087260(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
CONTINUE_MINTING = false

IRs:
CONTINUE_MINTING(bool) := False(bool)"];
}
// Function: 10755.sol-BonusableCrowdsale-validPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinPeriod = now >= startTime && now <= endTime

IRs:
TMP_778(bool) = now >= startTime
TMP_779(bool) = now <= endTime
TMP_780(bool) = TMP_778 && TMP_779
withinPeriod(bool) := TMP_780(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
nonZeroPurchase = msg.value != 0

IRs:
TMP_781(bool) = msg.value != 0
nonZeroPurchase(bool) := TMP_781(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
withinPeriod && nonZeroPurchase

IRs:
TMP_782(bool) = withinPeriod && nonZeroPurchase
RETURN TMP_782"];
}
// Function: 10755.sol-BurnableToken-allowance(address,address)
digraph{
}
// Function: 10755.sol-BurnableToken-approve(address,uint256)
digraph{
}
// Function: 10755.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 10755.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_302(bool) = _value > 0
TMP_303(None) = SOLIDITY_CALL require(bool)(TMP_302)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_237(uint256) -> balances[msg.sender]
TMP_304(bool) = _value <= REF_237
TMP_305(None) = SOLIDITY_CALL require(bool)(TMP_304)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_238(uint256) -> balances[burner]
REF_239(uint256) -> balances[burner]
TMP_306(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_239', '_value'] 
REF_238(uint256) (->balances) := TMP_306(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = totalSupply.sub(_value)

IRs:
TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] 
totalSupply(uint256) := TMP_307(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
}
// Function: 10755.sol-BurnableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_220(mapping(address => uint256)) -> allowed[msg.sender]
REF_221(uint256) -> REF_220[_spender]
oldValue(uint256) := REF_221(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_291(bool) = _subtractedValue > oldValue
CONDITION TMP_291"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_222(mapping(address => uint256)) -> allowed[msg.sender]
REF_223(uint256) -> REF_222[_spender]
REF_223(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_224(mapping(address => uint256)) -> allowed[msg.sender]
REF_225(uint256) -> REF_224[_spender]
TMP_292(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_225(uint256) (->allowed) := TMP_292(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_227(mapping(address => uint256)) -> allowed[msg.sender]
REF_228(uint256) -> REF_227[_spender]
Emit Approval(msg.sender,_spender,REF_228)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-BurnableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_213(mapping(address => uint256)) -> allowed[msg.sender]
REF_214(uint256) -> REF_213[_spender]
REF_215(mapping(address => uint256)) -> allowed[msg.sender]
REF_216(uint256) -> REF_215[_spender]
TMP_289(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_216', '_addedValue'] 
REF_214(uint256) (->allowed) := TMP_289(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_218(mapping(address => uint256)) -> allowed[msg.sender]
REF_219(uint256) -> REF_218[_spender]
Emit Approval(msg.sender,_spender,REF_219)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-BurnableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 10755.sol-CappedCrowdsale-CappedCrowdsale(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_cap > 0)

IRs:
TMP_609(bool) = _cap > 0
TMP_610(None) = SOLIDITY_CALL require(bool)(TMP_609)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
cap = _cap

IRs:
cap(uint256) := _cap(uint256)"];
}
// Function: 10755.sol-CappedCrowdsale-Crowdsale(uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_579(bool) = _startTime >= now
TMP_580(None) = SOLIDITY_CALL require(bool)(TMP_579)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_581(bool) = _endTime >= _startTime
TMP_582(None) = SOLIDITY_CALL require(bool)(TMP_581)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_583(bool) = _rate > 0
TMP_584(None) = SOLIDITY_CALL require(bool)(TMP_583)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_585 = CONVERT 0 to address
TMP_586(bool) = _wallet != TMP_585
TMP_587(None) = SOLIDITY_CALL require(bool)(TMP_586)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = createTokenContract()

IRs:
TMP_588(MintableToken) = INTERNAL_CALL, Crowdsale.createTokenContract()()
token(MintableToken) := TMP_588(MintableToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10755.sol-CappedCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_592 = CONVERT 0 to address
TMP_593(bool) = beneficiary != TMP_592
TMP_594(None) = SOLIDITY_CALL require(bool)(TMP_593)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_595(bool) = INTERNAL_CALL, CappedCrowdsale.validPurchase()()
TMP_596(None) = SOLIDITY_CALL require(bool)(TMP_595)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = weiAmount.mul(rate)

IRs:
TMP_597(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'rate'] 
tokens(uint256) := TMP_597(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_598(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_598(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_599(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'tokens']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()"];
}
// Function: 10755.sol-CappedCrowdsale-createTokenContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
new MintableToken()

IRs:
TMP_590(MintableToken) = new MintableToken() 
RETURN TMP_590"];
}
// Function: 10755.sol-CappedCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10755.sol-CappedCrowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 10755.sol-CappedCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
capReached = weiRaised >= cap

IRs:
TMP_615(bool) = weiRaised >= cap
capReached(bool) := TMP_615(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.hasEnded() || capReached

IRs:
TMP_616(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_617(bool) = TMP_616 || capReached
RETURN TMP_617"];
}
// Function: 10755.sol-CappedCrowdsale-validPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinCap = weiRaised.add(msg.value) <= cap

IRs:
TMP_611(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'msg.value'] 
TMP_612(bool) = TMP_611 <= cap
withinCap(bool) := TMP_612(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.validPurchase() && withinCap

IRs:
TMP_613(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_614(bool) = TMP_613 && withinCap
RETURN TMP_614"];
}
// Function: 10755.sol-Checkable-Checkable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
serviceAccount = msg.sender

IRs:
serviceAccount(address) := msg.sender(address)"];
}
// Function: 10755.sol-Checkable-changeServiceAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(_account != 0)

IRs:
TMP_741(bool) = _account != 0
TMP_742(None) = SOLIDITY_CALL assert(bool)(TMP_741)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
serviceAccount = _account

IRs:
serviceAccount(address) := _account(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyService()

IRs:
MODIFIER_CALL, Checkable.onlyService()()"];
3->1;
}
// Function: 10755.sol-Checkable-check()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: IF 1

EXPRESSION:
internalCheck()

IRs:
TMP_745(bool) = INTERNAL_CALL, Checkable.internalCheck()()
CONDITION TMP_745"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Triggered(this.balance)

IRs:
REF_461(uint256) = SOLIDITY_CALL balance(address)(this)
Emit Triggered(REF_461)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
triggered = true

IRs:
triggered(bool) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
internalAction()

IRs:
INTERNAL_CALL, Checkable.internalAction()()"];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyService()

IRs:
MODIFIER_CALL, Checkable.onlyService()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notTriggered()

IRs:
MODIFIER_CALL, Checkable.notTriggered()()"];
7->1;
}
// Function: 10755.sol-Checkable-internalAction()
digraph{
}
// Function: 10755.sol-Checkable-internalCheck()
digraph{
}
// Function: 10755.sol-Checkable-isServiceAccount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender == serviceAccount

IRs:
TMP_744(bool) = msg.sender == serviceAccount
RETURN TMP_744"];
}
// Function: 10755.sol-Checkable-notTriggered()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! triggered)

IRs:
TMP_752 = UnaryType.BANG triggered 
TMP_753(None) = SOLIDITY_CALL require(bool)(TMP_752)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-Checkable-onlyService()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == serviceAccount)

IRs:
TMP_750(bool) = msg.sender == serviceAccount
TMP_751(None) = SOLIDITY_CALL require(bool)(TMP_750)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-Checkable-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
triggered = false

IRs:
triggered(bool) := False(bool)"];
}
// Function: 10755.sol-Consts-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
TOKEN_DECIMALS = 18

IRs:
TOKEN_DECIMALS(uint256) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
TOKEN_DECIMALS_UINT8 = 18

IRs:
TOKEN_DECIMALS_UINT8(uint8) := 18(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS

IRs:
TMP_432(uint256) = 10 ** TOKEN_DECIMALS
TOKEN_DECIMAL_MULTIPLIER(uint256) := TMP_432(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TOKEN_NAME = Word of mouth pro

IRs:
TOKEN_NAME(string) := Word of mouth pro(string)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
TOKEN_SYMBOL = wmp

IRs:
TOKEN_SYMBOL(string) := wmp(string)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
PAUSED = true

IRs:
PAUSED(bool) := True(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
TARGET_USER = 0x63DA42f4151F88c7EAAeBb67783D855b4ac8AdD7

IRs:
TARGET_USER(address) := 570057481232686336990038773061472884575540129239(address)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
START_TIME = 1531087260

IRs:
START_TIME(uint256) := 1531087260(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
CONTINUE_MINTING = false

IRs:
CONTINUE_MINTING(bool) := False(bool)"];
}
// Function: 10755.sol-Crowdsale-Crowdsale(uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_96(bool) = _startTime >= now
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_98(bool) = _endTime >= _startTime
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_100(bool) = _rate > 0
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_102 = CONVERT 0 to address
TMP_103(bool) = _wallet != TMP_102
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = createTokenContract()

IRs:
TMP_105(MintableToken) = INTERNAL_CALL, Crowdsale.createTokenContract()()
token(MintableToken) := TMP_105(MintableToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10755.sol-Crowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_109 = CONVERT 0 to address
TMP_110(bool) = beneficiary != TMP_109
TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_112(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = weiAmount.mul(rate)

IRs:
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'rate'] 
tokens(uint256) := TMP_114(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_115(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_116(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'tokens']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()"];
}
// Function: 10755.sol-Crowdsale-createTokenContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
new MintableToken()

IRs:
TMP_107(MintableToken) = new MintableToken() 
RETURN TMP_107"];
}
// Function: 10755.sol-Crowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10755.sol-Crowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 10755.sol-Crowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_125(bool) = now > endTime
RETURN TMP_125"];
}
// Function: 10755.sol-Crowdsale-validPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinPeriod = now >= startTime && now <= endTime

IRs:
TMP_120(bool) = now >= startTime
TMP_121(bool) = now <= endTime
TMP_122(bool) = TMP_120 && TMP_121
withinPeriod(bool) := TMP_122(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
nonZeroPurchase = msg.value != 0

IRs:
TMP_123(bool) = msg.value != 0
nonZeroPurchase(bool) := TMP_123(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
withinPeriod && nonZeroPurchase

IRs:
TMP_124(bool) = withinPeriod && nonZeroPurchase
RETURN TMP_124"];
}
// Function: 10755.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 10755.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 10755.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 10755.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 10755.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 10755.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-ERC223Basic-balanceOf(address)
digraph{
}
// Function: 10755.sol-ERC223Basic-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-ERC223Basic-transfer(address,uint256,bytes)
digraph{
}
// Function: 10755.sol-ERC223Receiver-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 10755.sol-ERC223Token-balanceOf(address)
digraph{
}
// Function: 10755.sol-ERC223Token-tokenFallback(address,uint256,bytes)
digraph{
}
// Function: 10755.sol-ERC223Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
transfer(_to,_value,empty)

IRs:
TMP_448(bool) = INTERNAL_CALL, ERC223Token.transfer(address,uint256,bytes)(_to,_value,empty)
RETURN TMP_448"];
}
// Function: 10755.sol-ERC223Token-transfer(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_337(uint256) -> balances[msg.sender]
REF_338(uint256) -> balances[msg.sender]
TMP_442(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_338', '_value'] 
REF_337(uint256) (->balances) := TMP_442(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_340(uint256) -> balances[_to]
REF_341(uint256) -> balances[_to]
TMP_443(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_341', '_value'] 
REF_340(uint256) (->balances) := TMP_443(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
codeLength > 0

IRs:
TMP_444(bool) = codeLength > 0
CONDITION TMP_444"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
receiver = ERC223Receiver(_to)

IRs:
TMP_445 = CONVERT _to to ERC223Receiver
receiver(ERC223Receiver) := TMP_445(ERC223Receiver)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223Receiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  "];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-FailingERC223Receiver-tokenFallback(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_276(None) = SOLIDITY_CALL revert()()"];
}
// Function: 10755.sol-FinalizableCrowdsale-Crowdsale(uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_131(bool) = _startTime >= now
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_133(bool) = _endTime >= _startTime
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_135(bool) = _rate > 0
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_137 = CONVERT 0 to address
TMP_138(bool) = _wallet != TMP_137
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = createTokenContract()

IRs:
TMP_140(MintableToken) = INTERNAL_CALL, Crowdsale.createTokenContract()()
token(MintableToken) := TMP_140(MintableToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10755.sol-FinalizableCrowdsale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-FinalizableCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_144 = CONVERT 0 to address
TMP_145(bool) = beneficiary != TMP_144
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_147(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = weiAmount.mul(rate)

IRs:
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'rate'] 
tokens(uint256) := TMP_149(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_150(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_151(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'tokens']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()"];
}
// Function: 10755.sol-FinalizableCrowdsale-createTokenContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
new MintableToken()

IRs:
TMP_142(MintableToken) = new MintableToken() 
RETURN TMP_142"];
}
// Function: 10755.sol-FinalizableCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10755.sol-FinalizableCrowdsale-finalization()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 10755.sol-FinalizableCrowdsale-finalize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_161 = UnaryType.BANG isFinalized 
TMP_162(None) = SOLIDITY_CALL require(bool)(TMP_161)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_163(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, FinalizableCrowdsale.finalization()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Finalized()

IRs:
Emit Finalized()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 10755.sol-FinalizableCrowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 10755.sol-FinalizableCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_160(bool) = now > endTime
RETURN TMP_160"];
}
// Function: 10755.sol-FinalizableCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_168(bool) = msg.sender == owner
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-FinalizableCrowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFinalized = false

IRs:
isFinalized(bool) := False(bool)"];
}
// Function: 10755.sol-FinalizableCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_126 = CONVERT 0 to address
TMP_127(bool) = newOwner != TMP_126
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-FinalizableCrowdsale-validPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinPeriod = now >= startTime && now <= endTime

IRs:
TMP_155(bool) = now >= startTime
TMP_156(bool) = now <= endTime
TMP_157(bool) = TMP_155 && TMP_156
withinPeriod(bool) := TMP_157(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
nonZeroPurchase = msg.value != 0

IRs:
TMP_158(bool) = msg.value != 0
nonZeroPurchase(bool) := TMP_158(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
withinPeriod && nonZeroPurchase

IRs:
TMP_159(bool) = withinPeriod && nonZeroPurchase
RETURN TMP_159"];
}
// Function: 10755.sol-FreezableMintableToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-FreezableMintableToken-actualBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
super.balanceOf(_owner)

IRs:
TMP_367(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_owner)
RETURN TMP_367"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-FreezableMintableToken-allowance(address,address)
digraph{
}
// Function: 10755.sol-FreezableMintableToken-approve(address,uint256)
digraph{
}
// Function: 10755.sol-FreezableMintableToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
super.balanceOf(_owner) + freezingBalance[_owner]

IRs:
TMP_365(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_owner)
REF_288(uint256) -> freezingBalance[_owner]
TMP_366(uint256) = TMP_365 + REF_288
RETURN TMP_366"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-FreezableMintableToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_428 = UnaryType.BANG mintingFinished 
TMP_429(None) = SOLIDITY_CALL require(bool)(TMP_428)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-FreezableMintableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_271(mapping(address => uint256)) -> allowed[msg.sender]
REF_272(uint256) -> REF_271[_spender]
oldValue(uint256) := REF_272(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_354(bool) = _subtractedValue > oldValue
CONDITION TMP_354"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_273(mapping(address => uint256)) -> allowed[msg.sender]
REF_274(uint256) -> REF_273[_spender]
REF_274(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_275(mapping(address => uint256)) -> allowed[msg.sender]
REF_276(uint256) -> REF_275[_spender]
TMP_355(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_276(uint256) (->allowed) := TMP_355(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_278(mapping(address => uint256)) -> allowed[msg.sender]
REF_279(uint256) -> REF_278[_spender]
Emit Approval(msg.sender,_spender,REF_279)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-FreezableMintableToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 10755.sol-FreezableMintableToken-freeze(address,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_until > block.timestamp)

IRs:
TMP_405(bool) = _until > block.timestamp
TMP_406(None) = SOLIDITY_CALL require(bool)(TMP_405)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
key = toKey(_to,_until)

IRs:
TMP_407(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
key(bytes32) := TMP_407(bytes32)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
parentKey = toKey(_to,uint64(0))

IRs:
TMP_408 = CONVERT 0 to uint64
TMP_409(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,TMP_408)
parentKey(bytes32) := TMP_409(bytes32)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
next = chains[parentKey]

IRs:
REF_317(uint64) -> chains[parentKey]
next(uint64) := REF_317(uint64)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
next == 0

IRs:
TMP_410(bool) = next == 0
CONDITION TMP_410"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
chains[parentKey] = _until

IRs:
REF_318(uint64) -> chains[parentKey]
REF_318(uint64) (->chains) := _until(uint64)"];
6->7;
7[label="Node Type: RETURN 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
nextKey = toKey(_to,next)

IRs:
TMP_411(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,next)
nextKey(bytes32) := TMP_411(bytes32)"];
9->10;
10[label="Node Type: NEW VARIABLE 10
"];
10->11;
11[label="Node Type: BEGIN_LOOP 11
"];
11->12;
12[label="Node Type: IF_LOOP 12

EXPRESSION:
next != 0 && _until > next

IRs:
TMP_412(bool) = next != 0
TMP_413(bool) = _until > next
TMP_414(bool) = TMP_412 && TMP_413
CONDITION TMP_414"];
12->13[label="True"];
12->17[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
parent = next

IRs:
parent(uint256) := next(uint64)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
parentKey = nextKey

IRs:
parentKey(bytes32) := nextKey(bytes32)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
next = chains[nextKey]

IRs:
REF_319(uint64) -> chains[nextKey]
next(uint64) := REF_319(uint64)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
nextKey = toKey(_to,next)

IRs:
TMP_415(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,next)
nextKey(bytes32) := TMP_415(bytes32)"];
16->12;
17[label="Node Type: END_LOOP 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
_until == next

IRs:
TMP_416(bool) = _until == next
CONDITION TMP_416"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: RETURN 19
"];
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
next != 0

IRs:
TMP_417(bool) = next != 0
CONDITION TMP_417"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
chains[key] = next

IRs:
REF_320(uint64) -> chains[key]
REF_320(uint64) (->chains) := next(uint64)"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
chains[parentKey] = _until

IRs:
REF_321(uint64) -> chains[parentKey]
REF_321(uint64) (->chains) := _until(uint64)"];
}
// Function: 10755.sol-FreezableMintableToken-freezeTo(address,uint256,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_378 = CONVERT 0 to address
TMP_379(bool) = _to != TMP_378
TMP_380(None) = SOLIDITY_CALL require(bool)(TMP_379)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= balances[msg.sender])

IRs:
REF_294(uint256) -> balances[msg.sender]
TMP_381(bool) = _amount <= REF_294
TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_amount)

IRs:
REF_295(uint256) -> balances[msg.sender]
REF_296(uint256) -> balances[msg.sender]
TMP_383(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_296', '_amount'] 
REF_295(uint256) (->balances) := TMP_383(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
currentKey = toKey(_to,_until)

IRs:
TMP_384(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
currentKey(bytes32) := TMP_384(bytes32)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
freezings[currentKey] = freezings[currentKey].add(_amount)

IRs:
REF_298(uint256) -> freezings[currentKey]
REF_299(uint256) -> freezings[currentKey]
TMP_385(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_299', '_amount'] 
REF_298(uint256) (->freezings) := TMP_385(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
freezingBalance[_to] = freezingBalance[_to].add(_amount)

IRs:
REF_301(uint256) -> freezingBalance[_to]
REF_302(uint256) -> freezingBalance[_to]
TMP_386(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_302', '_amount'] 
REF_301(uint256) (->freezingBalance) := TMP_386(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
freeze(_to,_until)

IRs:
INTERNAL_CALL, FreezableToken.freeze(address,uint64)(_to,_until)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Freezed(_to,_until,_amount)

IRs:
Emit Freezed(_to,_until,_amount)"];
}
// Function: 10755.sol-FreezableMintableToken-freezingBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
freezingBalance[_owner]

IRs:
REF_289(uint256) -> freezingBalance[_owner]
RETURN REF_289"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-FreezableMintableToken-freezingCount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
release = chains[toKey(_addr,0)]

IRs:
TMP_368(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,0)
REF_290(uint64) -> chains[TMP_368]
release(uint64) := REF_290(uint64)"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3

EXPRESSION:
release != 0

IRs:
TMP_369(bool) = release != 0
CONDITION TMP_369"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
count ++

IRs:
TMP_370(uint256) := count(uint256)
count(uint256) = count + 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
release = chains[toKey(_addr,release)]

IRs:
TMP_371(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,release)
REF_291(uint64) -> chains[TMP_371]
release(uint64) := REF_291(uint64)"];
5->3;
6[label="Node Type: END_LOOP 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 10755.sol-FreezableMintableToken-getFreezing(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _index + 1

IRs:
TMP_372(uint256) = _index + 1
TMP_373(bool) = i < TMP_372
CONDITION TMP_373"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_release = chains[toKey(_addr,_release)]

IRs:
TMP_374(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,_release)
REF_292(uint64) -> chains[TMP_374]
_release(uint64) := REF_292(uint64)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
_release == 0

IRs:
TMP_375(bool) = _release == 0
CONDITION TMP_375"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_376(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_balance = freezings[toKey(_addr,_release)]

IRs:
TMP_377(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,_release)
REF_293(uint256) -> freezings[TMP_377]
_balance(uint256) := REF_293(uint256)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
(_release,_balance)

IRs:
RETURN _release,_balance"];
}
// Function: 10755.sol-FreezableMintableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_264(mapping(address => uint256)) -> allowed[msg.sender]
REF_265(uint256) -> REF_264[_spender]
REF_266(mapping(address => uint256)) -> allowed[msg.sender]
REF_267(uint256) -> REF_266[_spender]
TMP_352(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_267', '_addedValue'] 
REF_265(uint256) (->allowed) := TMP_352(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_269(mapping(address => uint256)) -> allowed[msg.sender]
REF_270(uint256) -> REF_269[_spender]
Emit Approval(msg.sender,_spender,REF_270)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-FreezableMintableToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply.add(_amount)

IRs:
TMP_325(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_325(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_243(uint256) -> balances[_to]
REF_244(uint256) -> balances[_to]
TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_244', '_amount'] 
REF_243(uint256) (->balances) := TMP_326(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_328 = CONVERT 0 to address
Emit Transfer(TMP_328,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 10755.sol-FreezableMintableToken-mintAndFreeze(address,uint256,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply.add(_amount)

IRs:
TMP_418(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_418(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
currentKey = toKey(_to,_until)

IRs:
TMP_419(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
currentKey(bytes32) := TMP_419(bytes32)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
freezings[currentKey] = freezings[currentKey].add(_amount)

IRs:
REF_323(uint256) -> freezings[currentKey]
REF_324(uint256) -> freezings[currentKey]
TMP_420(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_324', '_amount'] 
REF_323(uint256) (->freezings) := TMP_420(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
freezingBalance[_to] = freezingBalance[_to].add(_amount)

IRs:
REF_326(uint256) -> freezingBalance[_to]
REF_327(uint256) -> freezingBalance[_to]
TMP_421(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_327', '_amount'] 
REF_326(uint256) (->freezingBalance) := TMP_421(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
freeze(_to,_until)

IRs:
INTERNAL_CALL, FreezableToken.freeze(address,uint64)(_to,_until)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Freezed(_to,_until,_amount)

IRs:
Emit Freezed(_to,_until,_amount)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
11->1;
}
// Function: 10755.sol-FreezableMintableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_430(bool) = msg.sender == owner
TMP_431(None) = SOLIDITY_CALL require(bool)(TMP_430)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-FreezableMintableToken-releaseAll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(release,balance) = getFreezing(msg.sender,0)

IRs:
TUPLE_2(uint64,uint256) = INTERNAL_CALL, FreezableToken.getFreezing(address,uint256)(msg.sender,0)
release(uint256)= UNPACK TUPLE_2 index: 0 
balance(uint256)= UNPACK TUPLE_2 index: 1 "];
3->4;
4[label="Node Type: BEGIN_LOOP 4
"];
4->5;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
release != 0 && block.timestamp > release

IRs:
TMP_401(bool) = release != 0
TMP_402(bool) = block.timestamp > release
TMP_403(bool) = TMP_401 && TMP_402
CONDITION TMP_403"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
releaseOnce()

IRs:
INTERNAL_CALL, FreezableToken.releaseOnce()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokens += balance

IRs:
tokens(uint256) = tokens + balance"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
(release,balance) = getFreezing(msg.sender,0)

IRs:
TUPLE_3(uint64,uint256) = INTERNAL_CALL, FreezableToken.getFreezing(address,uint256)(msg.sender,0)
release(uint256)= UNPACK TUPLE_3 index: 0 
balance(uint256)= UNPACK TUPLE_3 index: 1 "];
8->5;
9[label="Node Type: END_LOOP 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
tokens

IRs:
RETURN tokens"];
}
// Function: 10755.sol-FreezableMintableToken-releaseOnce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
headKey = toKey(msg.sender,0)

IRs:
TMP_390(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(msg.sender,0)
headKey(bytes32) := TMP_390(bytes32)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
head = chains[headKey]

IRs:
REF_304(uint64) -> chains[headKey]
head(uint64) := REF_304(uint64)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(head != 0)

IRs:
TMP_391(bool) = head != 0
TMP_392(None) = SOLIDITY_CALL require(bool)(TMP_391)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(uint64(block.timestamp) > head)

IRs:
TMP_393 = CONVERT block.timestamp to uint64
TMP_394(bool) = TMP_393 > head
TMP_395(None) = SOLIDITY_CALL require(bool)(TMP_394)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
currentKey = toKey(msg.sender,head)

IRs:
TMP_396(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(msg.sender,head)
currentKey(bytes32) := TMP_396(bytes32)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
next = chains[currentKey]

IRs:
REF_305(uint64) -> chains[currentKey]
next(uint64) := REF_305(uint64)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
amount = freezings[currentKey]

IRs:
REF_306(uint256) -> freezings[currentKey]
amount(uint256) := REF_306(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
delete freezings[currentKey]

IRs:
REF_307(uint256) -> freezings[currentKey]
freezings = delete REF_307 "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(amount)

IRs:
REF_308(uint256) -> balances[msg.sender]
REF_309(uint256) -> balances[msg.sender]
TMP_397(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_309', 'amount'] 
REF_308(uint256) (->balances) := TMP_397(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount)

IRs:
REF_311(uint256) -> freezingBalance[msg.sender]
REF_312(uint256) -> freezingBalance[msg.sender]
TMP_398(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_312', 'amount'] 
REF_311(uint256) (->freezingBalance) := TMP_398(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
next == 0

IRs:
TMP_399(bool) = next == 0
CONDITION TMP_399"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
delete chains[headKey]

IRs:
REF_314(uint64) -> chains[headKey]
chains = delete REF_314 "];
12->15;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
chains[headKey] = next

IRs:
REF_315(uint64) -> chains[headKey]
REF_315(uint64) (->chains) := next(uint64)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
delete chains[currentKey]

IRs:
REF_316(uint64) -> chains[currentKey]
chains = delete REF_316 "];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Released(msg.sender,amount)

IRs:
Emit Released(msg.sender,amount)"];
}
// Function: 10755.sol-FreezableMintableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
}
// Function: 10755.sol-FreezableMintableToken-toKey(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
result = 0x5749534800000000000000000000000000000000000000000000000000000000

IRs:
result(bytes32) := 39480772448535941496179204954862169494691089619604794184232587696854102179840(uint256)"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 10755.sol-FreezableMintableToken-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-FreezableMintableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 10755.sol-FreezableMintableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_335 = CONVERT 0 to address
TMP_336(bool) = newOwner != TMP_335
TMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-FreezableToken-actualBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
super.balanceOf(_owner)

IRs:
TMP_224(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_owner)
RETURN TMP_224"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-FreezableToken-allowance(address,address)
digraph{
}
// Function: 10755.sol-FreezableToken-approve(address,uint256)
digraph{
}
// Function: 10755.sol-FreezableToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
super.balanceOf(_owner) + freezingBalance[_owner]

IRs:
TMP_222(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_owner)
REF_161(uint256) -> freezingBalance[_owner]
TMP_223(uint256) = TMP_222 + REF_161
RETURN TMP_223"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-FreezableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_144(mapping(address => uint256)) -> allowed[msg.sender]
REF_145(uint256) -> REF_144[_spender]
oldValue(uint256) := REF_145(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_211(bool) = _subtractedValue > oldValue
CONDITION TMP_211"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_146(mapping(address => uint256)) -> allowed[msg.sender]
REF_147(uint256) -> REF_146[_spender]
REF_147(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_148(mapping(address => uint256)) -> allowed[msg.sender]
REF_149(uint256) -> REF_148[_spender]
TMP_212(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_149(uint256) (->allowed) := TMP_212(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_151(mapping(address => uint256)) -> allowed[msg.sender]
REF_152(uint256) -> REF_151[_spender]
Emit Approval(msg.sender,_spender,REF_152)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-FreezableToken-freeze(address,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_until > block.timestamp)

IRs:
TMP_262(bool) = _until > block.timestamp
TMP_263(None) = SOLIDITY_CALL require(bool)(TMP_262)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
key = toKey(_to,_until)

IRs:
TMP_264(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
key(bytes32) := TMP_264(bytes32)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
parentKey = toKey(_to,uint64(0))

IRs:
TMP_265 = CONVERT 0 to uint64
TMP_266(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,TMP_265)
parentKey(bytes32) := TMP_266(bytes32)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
next = chains[parentKey]

IRs:
REF_190(uint64) -> chains[parentKey]
next(uint64) := REF_190(uint64)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
next == 0

IRs:
TMP_267(bool) = next == 0
CONDITION TMP_267"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
chains[parentKey] = _until

IRs:
REF_191(uint64) -> chains[parentKey]
REF_191(uint64) (->chains) := _until(uint64)"];
6->7;
7[label="Node Type: RETURN 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
nextKey = toKey(_to,next)

IRs:
TMP_268(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,next)
nextKey(bytes32) := TMP_268(bytes32)"];
9->10;
10[label="Node Type: NEW VARIABLE 10
"];
10->11;
11[label="Node Type: BEGIN_LOOP 11
"];
11->12;
12[label="Node Type: IF_LOOP 12

EXPRESSION:
next != 0 && _until > next

IRs:
TMP_269(bool) = next != 0
TMP_270(bool) = _until > next
TMP_271(bool) = TMP_269 && TMP_270
CONDITION TMP_271"];
12->13[label="True"];
12->17[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
parent = next

IRs:
parent(uint256) := next(uint64)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
parentKey = nextKey

IRs:
parentKey(bytes32) := nextKey(bytes32)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
next = chains[nextKey]

IRs:
REF_192(uint64) -> chains[nextKey]
next(uint64) := REF_192(uint64)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
nextKey = toKey(_to,next)

IRs:
TMP_272(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,next)
nextKey(bytes32) := TMP_272(bytes32)"];
16->12;
17[label="Node Type: END_LOOP 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
_until == next

IRs:
TMP_273(bool) = _until == next
CONDITION TMP_273"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: RETURN 19
"];
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
next != 0

IRs:
TMP_274(bool) = next != 0
CONDITION TMP_274"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
chains[key] = next

IRs:
REF_193(uint64) -> chains[key]
REF_193(uint64) (->chains) := next(uint64)"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
chains[parentKey] = _until

IRs:
REF_194(uint64) -> chains[parentKey]
REF_194(uint64) (->chains) := _until(uint64)"];
}
// Function: 10755.sol-FreezableToken-freezeTo(address,uint256,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_235 = CONVERT 0 to address
TMP_236(bool) = _to != TMP_235
TMP_237(None) = SOLIDITY_CALL require(bool)(TMP_236)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= balances[msg.sender])

IRs:
REF_167(uint256) -> balances[msg.sender]
TMP_238(bool) = _amount <= REF_167
TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_amount)

IRs:
REF_168(uint256) -> balances[msg.sender]
REF_169(uint256) -> balances[msg.sender]
TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_169', '_amount'] 
REF_168(uint256) (->balances) := TMP_240(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
currentKey = toKey(_to,_until)

IRs:
TMP_241(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
currentKey(bytes32) := TMP_241(bytes32)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
freezings[currentKey] = freezings[currentKey].add(_amount)

IRs:
REF_171(uint256) -> freezings[currentKey]
REF_172(uint256) -> freezings[currentKey]
TMP_242(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_172', '_amount'] 
REF_171(uint256) (->freezings) := TMP_242(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
freezingBalance[_to] = freezingBalance[_to].add(_amount)

IRs:
REF_174(uint256) -> freezingBalance[_to]
REF_175(uint256) -> freezingBalance[_to]
TMP_243(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_175', '_amount'] 
REF_174(uint256) (->freezingBalance) := TMP_243(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
freeze(_to,_until)

IRs:
INTERNAL_CALL, FreezableToken.freeze(address,uint64)(_to,_until)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Freezed(_to,_until,_amount)

IRs:
Emit Freezed(_to,_until,_amount)"];
}
// Function: 10755.sol-FreezableToken-freezingBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
freezingBalance[_owner]

IRs:
REF_162(uint256) -> freezingBalance[_owner]
RETURN REF_162"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-FreezableToken-freezingCount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
release = chains[toKey(_addr,0)]

IRs:
TMP_225(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,0)
REF_163(uint64) -> chains[TMP_225]
release(uint64) := REF_163(uint64)"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3

EXPRESSION:
release != 0

IRs:
TMP_226(bool) = release != 0
CONDITION TMP_226"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
count ++

IRs:
TMP_227(uint256) := count(uint256)
count(uint256) = count + 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
release = chains[toKey(_addr,release)]

IRs:
TMP_228(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,release)
REF_164(uint64) -> chains[TMP_228]
release(uint64) := REF_164(uint64)"];
5->3;
6[label="Node Type: END_LOOP 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 10755.sol-FreezableToken-getFreezing(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _index + 1

IRs:
TMP_229(uint256) = _index + 1
TMP_230(bool) = i < TMP_229
CONDITION TMP_230"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_release = chains[toKey(_addr,_release)]

IRs:
TMP_231(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,_release)
REF_165(uint64) -> chains[TMP_231]
_release(uint64) := REF_165(uint64)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
_release == 0

IRs:
TMP_232(bool) = _release == 0
CONDITION TMP_232"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_233(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_balance = freezings[toKey(_addr,_release)]

IRs:
TMP_234(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,_release)
REF_166(uint256) -> freezings[TMP_234]
_balance(uint256) := REF_166(uint256)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
(_release,_balance)

IRs:
RETURN _release,_balance"];
}
// Function: 10755.sol-FreezableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_137(mapping(address => uint256)) -> allowed[msg.sender]
REF_138(uint256) -> REF_137[_spender]
REF_139(mapping(address => uint256)) -> allowed[msg.sender]
REF_140(uint256) -> REF_139[_spender]
TMP_209(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_140', '_addedValue'] 
REF_138(uint256) (->allowed) := TMP_209(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_142(mapping(address => uint256)) -> allowed[msg.sender]
REF_143(uint256) -> REF_142[_spender]
Emit Approval(msg.sender,_spender,REF_143)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-FreezableToken-releaseAll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(release,balance) = getFreezing(msg.sender,0)

IRs:
TUPLE_0(uint64,uint256) = INTERNAL_CALL, FreezableToken.getFreezing(address,uint256)(msg.sender,0)
release(uint256)= UNPACK TUPLE_0 index: 0 
balance(uint256)= UNPACK TUPLE_0 index: 1 "];
3->4;
4[label="Node Type: BEGIN_LOOP 4
"];
4->5;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
release != 0 && block.timestamp > release

IRs:
TMP_258(bool) = release != 0
TMP_259(bool) = block.timestamp > release
TMP_260(bool) = TMP_258 && TMP_259
CONDITION TMP_260"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
releaseOnce()

IRs:
INTERNAL_CALL, FreezableToken.releaseOnce()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokens += balance

IRs:
tokens(uint256) = tokens + balance"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
(release,balance) = getFreezing(msg.sender,0)

IRs:
TUPLE_1(uint64,uint256) = INTERNAL_CALL, FreezableToken.getFreezing(address,uint256)(msg.sender,0)
release(uint256)= UNPACK TUPLE_1 index: 0 
balance(uint256)= UNPACK TUPLE_1 index: 1 "];
8->5;
9[label="Node Type: END_LOOP 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
tokens

IRs:
RETURN tokens"];
}
// Function: 10755.sol-FreezableToken-releaseOnce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
headKey = toKey(msg.sender,0)

IRs:
TMP_247(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(msg.sender,0)
headKey(bytes32) := TMP_247(bytes32)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
head = chains[headKey]

IRs:
REF_177(uint64) -> chains[headKey]
head(uint64) := REF_177(uint64)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(head != 0)

IRs:
TMP_248(bool) = head != 0
TMP_249(None) = SOLIDITY_CALL require(bool)(TMP_248)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(uint64(block.timestamp) > head)

IRs:
TMP_250 = CONVERT block.timestamp to uint64
TMP_251(bool) = TMP_250 > head
TMP_252(None) = SOLIDITY_CALL require(bool)(TMP_251)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
currentKey = toKey(msg.sender,head)

IRs:
TMP_253(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(msg.sender,head)
currentKey(bytes32) := TMP_253(bytes32)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
next = chains[currentKey]

IRs:
REF_178(uint64) -> chains[currentKey]
next(uint64) := REF_178(uint64)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
amount = freezings[currentKey]

IRs:
REF_179(uint256) -> freezings[currentKey]
amount(uint256) := REF_179(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
delete freezings[currentKey]

IRs:
REF_180(uint256) -> freezings[currentKey]
freezings = delete REF_180 "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(amount)

IRs:
REF_181(uint256) -> balances[msg.sender]
REF_182(uint256) -> balances[msg.sender]
TMP_254(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_182', 'amount'] 
REF_181(uint256) (->balances) := TMP_254(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount)

IRs:
REF_184(uint256) -> freezingBalance[msg.sender]
REF_185(uint256) -> freezingBalance[msg.sender]
TMP_255(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_185', 'amount'] 
REF_184(uint256) (->freezingBalance) := TMP_255(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
next == 0

IRs:
TMP_256(bool) = next == 0
CONDITION TMP_256"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
delete chains[headKey]

IRs:
REF_187(uint64) -> chains[headKey]
chains = delete REF_187 "];
12->15;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
chains[headKey] = next

IRs:
REF_188(uint64) -> chains[headKey]
REF_188(uint64) (->chains) := next(uint64)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
delete chains[currentKey]

IRs:
REF_189(uint64) -> chains[currentKey]
chains = delete REF_189 "];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Released(msg.sender,amount)

IRs:
Emit Released(msg.sender,amount)"];
}
// Function: 10755.sol-FreezableToken-toKey(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
result = 0x5749534800000000000000000000000000000000000000000000000000000000

IRs:
result(bytes32) := 39480772448535941496179204954862169494691089619604794184232587696854102179840(uint256)"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 10755.sol-FreezableToken-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-FreezableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 10755.sol-MainCrowdsale-Crowdsale(uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_690(bool) = _startTime >= now
TMP_691(None) = SOLIDITY_CALL require(bool)(TMP_690)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_692(bool) = _endTime >= _startTime
TMP_693(None) = SOLIDITY_CALL require(bool)(TMP_692)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_694(bool) = _rate > 0
TMP_695(None) = SOLIDITY_CALL require(bool)(TMP_694)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_696 = CONVERT 0 to address
TMP_697(bool) = _wallet != TMP_696
TMP_698(None) = SOLIDITY_CALL require(bool)(TMP_697)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = createTokenContract()

IRs:
TMP_699(MintableToken) = INTERNAL_CALL, Crowdsale.createTokenContract()()
token(MintableToken) := TMP_699(MintableToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10755.sol-MainCrowdsale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-MainCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_727 = CONVERT 0 to address
TMP_728(bool) = beneficiary != TMP_727
TMP_729(None) = SOLIDITY_CALL require(bool)(TMP_728)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_730(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_731(None) = SOLIDITY_CALL require(bool)(TMP_730)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = weiAmount.mul(rate).div(1000000000000000000)

IRs:
TMP_732(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'rate'] 
TMP_733(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_732', '1000000000000000000'] 
tokens(uint256) := TMP_733(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_734(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_734(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_735(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'tokens']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()"];
}
// Function: 10755.sol-MainCrowdsale-createTokenContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
new MintableToken()

IRs:
TMP_701(MintableToken) = new MintableToken() 
RETURN TMP_701"];
}
// Function: 10755.sol-MainCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, MainCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10755.sol-MainCrowdsale-finalization()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.finalization()

IRs:
INTERNAL_CALL, FinalizableCrowdsale.finalization()()"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
PAUSED

IRs:
CONDITION PAUSED"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
MainToken(token).unpause()

IRs:
TMP_722 = CONVERT token to MainToken
HIGH_LEVEL_CALL, dest:TMP_722(MainToken), function:unpause, arguments:[]  "];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! CONTINUE_MINTING

IRs:
TMP_724 = UnaryType.BANG CONTINUE_MINTING 
CONDITION TMP_724"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.finishMinting()

IRs:
TMP_725(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  "];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
token.transferOwnership(TARGET_USER)

IRs:
HIGH_LEVEL_CALL, dest:token(MintableToken), function:transferOwnership, arguments:['TARGET_USER']  "];
}
// Function: 10755.sol-MainCrowdsale-finalize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_678 = UnaryType.BANG isFinalized 
TMP_679(None) = SOLIDITY_CALL require(bool)(TMP_678)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_680(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_681(None) = SOLIDITY_CALL require(bool)(TMP_680)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, MainCrowdsale.finalization()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Finalized()

IRs:
Emit Finalized()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 10755.sol-MainCrowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 10755.sol-MainCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_719(bool) = now > endTime
RETURN TMP_719"];
}
// Function: 10755.sol-MainCrowdsale-hasStarted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now >= startTime

IRs:
TMP_720(bool) = now >= startTime
RETURN TMP_720"];
}
// Function: 10755.sol-MainCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_739(bool) = msg.sender == owner
TMP_740(None) = SOLIDITY_CALL require(bool)(TMP_739)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-MainCrowdsale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
TOKEN_DECIMALS = 18

IRs:
TOKEN_DECIMALS(uint256) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
TOKEN_DECIMALS_UINT8 = 18

IRs:
TOKEN_DECIMALS_UINT8(uint8) := 18(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS

IRs:
TMP_738(uint256) = 10 ** TOKEN_DECIMALS
TOKEN_DECIMAL_MULTIPLIER(uint256) := TMP_738(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TOKEN_NAME = Word of mouth pro

IRs:
TOKEN_NAME(string) := Word of mouth pro(string)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
TOKEN_SYMBOL = wmp

IRs:
TOKEN_SYMBOL(string) := wmp(string)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
PAUSED = true

IRs:
PAUSED(bool) := True(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
TARGET_USER = 0x63DA42f4151F88c7EAAeBb67783D855b4ac8AdD7

IRs:
TARGET_USER(address) := 570057481232686336990038773061472884575540129239(address)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
START_TIME = 1531087260

IRs:
START_TIME(uint256) := 1531087260(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
CONTINUE_MINTING = false

IRs:
CONTINUE_MINTING(bool) := False(bool)"];
}
// Function: 10755.sol-MainCrowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFinalized = false

IRs:
isFinalized(bool) := False(bool)"];
}
// Function: 10755.sol-MainCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_685 = CONVERT 0 to address
TMP_686(bool) = newOwner != TMP_685
TMP_687(None) = SOLIDITY_CALL require(bool)(TMP_686)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-MainCrowdsale-validPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinPeriod = now >= startTime && now <= endTime

IRs:
TMP_714(bool) = now >= startTime
TMP_715(bool) = now <= endTime
TMP_716(bool) = TMP_714 && TMP_715
withinPeriod(bool) := TMP_716(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
nonZeroPurchase = msg.value != 0

IRs:
TMP_717(bool) = msg.value != 0
nonZeroPurchase(bool) := TMP_717(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
withinPeriod && nonZeroPurchase

IRs:
TMP_718(bool) = withinPeriod && nonZeroPurchase
RETURN TMP_718"];
}
// Function: 10755.sol-MainToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-MainToken-actualBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
super.balanceOf(_owner)

IRs:
TMP_514(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_owner)
RETURN TMP_514"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-MainToken-allowance(address,address)
digraph{
}
// Function: 10755.sol-MainToken-approve(address,uint256)
digraph{
}
// Function: 10755.sol-MainToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
super.balanceOf(_owner) + freezingBalance[_owner]

IRs:
TMP_512(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_owner)
REF_402(uint256) -> freezingBalance[_owner]
TMP_513(uint256) = TMP_512 + REF_402
RETURN TMP_513"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-MainToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_460(bool) = _value > 0
TMP_461(None) = SOLIDITY_CALL require(bool)(TMP_460)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_344(uint256) -> balances[msg.sender]
TMP_462(bool) = _value <= REF_344
TMP_463(None) = SOLIDITY_CALL require(bool)(TMP_462)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_345(uint256) -> balances[burner]
REF_346(uint256) -> balances[burner]
TMP_464(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_346', '_value'] 
REF_345(uint256) (->balances) := TMP_464(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = totalSupply.sub(_value)

IRs:
TMP_465(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] 
totalSupply(uint256) := TMP_465(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
}
// Function: 10755.sol-MainToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_577 = UnaryType.BANG mintingFinished 
TMP_578(None) = SOLIDITY_CALL require(bool)(TMP_577)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-MainToken-decimals()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
TOKEN_DECIMALS_UINT8

IRs:
RETURN TOKEN_DECIMALS_UINT8"];
2[label="Node Type: RETURN 2

EXPRESSION:
_decimals

IRs:
RETURN _decimals"];
}
// Function: 10755.sol-MainToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_374(mapping(address => uint256)) -> allowed[msg.sender]
REF_375(uint256) -> REF_374[_spender]
oldValue(uint256) := REF_375(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_481(bool) = _subtractedValue > oldValue
CONDITION TMP_481"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_376(mapping(address => uint256)) -> allowed[msg.sender]
REF_377(uint256) -> REF_376[_spender]
REF_377(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_378(mapping(address => uint256)) -> allowed[msg.sender]
REF_379(uint256) -> REF_378[_spender]
TMP_482(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_379(uint256) (->allowed) := TMP_482(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_381(mapping(address => uint256)) -> allowed[msg.sender]
REF_382(uint256) -> REF_381[_spender]
Emit Approval(msg.sender,_spender,REF_382)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-MainToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 10755.sol-MainToken-freeze(address,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_until > block.timestamp)

IRs:
TMP_552(bool) = _until > block.timestamp
TMP_553(None) = SOLIDITY_CALL require(bool)(TMP_552)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
key = toKey(_to,_until)

IRs:
TMP_554(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
key(bytes32) := TMP_554(bytes32)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
parentKey = toKey(_to,uint64(0))

IRs:
TMP_555 = CONVERT 0 to uint64
TMP_556(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,TMP_555)
parentKey(bytes32) := TMP_556(bytes32)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
next = chains[parentKey]

IRs:
REF_431(uint64) -> chains[parentKey]
next(uint64) := REF_431(uint64)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
next == 0

IRs:
TMP_557(bool) = next == 0
CONDITION TMP_557"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
chains[parentKey] = _until

IRs:
REF_432(uint64) -> chains[parentKey]
REF_432(uint64) (->chains) := _until(uint64)"];
6->7;
7[label="Node Type: RETURN 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
nextKey = toKey(_to,next)

IRs:
TMP_558(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,next)
nextKey(bytes32) := TMP_558(bytes32)"];
9->10;
10[label="Node Type: NEW VARIABLE 10
"];
10->11;
11[label="Node Type: BEGIN_LOOP 11
"];
11->12;
12[label="Node Type: IF_LOOP 12

EXPRESSION:
next != 0 && _until > next

IRs:
TMP_559(bool) = next != 0
TMP_560(bool) = _until > next
TMP_561(bool) = TMP_559 && TMP_560
CONDITION TMP_561"];
12->13[label="True"];
12->17[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
parent = next

IRs:
parent(uint256) := next(uint64)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
parentKey = nextKey

IRs:
parentKey(bytes32) := nextKey(bytes32)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
next = chains[nextKey]

IRs:
REF_433(uint64) -> chains[nextKey]
next(uint64) := REF_433(uint64)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
nextKey = toKey(_to,next)

IRs:
TMP_562(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,next)
nextKey(bytes32) := TMP_562(bytes32)"];
16->12;
17[label="Node Type: END_LOOP 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
_until == next

IRs:
TMP_563(bool) = _until == next
CONDITION TMP_563"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: RETURN 19
"];
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
next != 0

IRs:
TMP_564(bool) = next != 0
CONDITION TMP_564"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
chains[key] = next

IRs:
REF_434(uint64) -> chains[key]
REF_434(uint64) (->chains) := next(uint64)"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
chains[parentKey] = _until

IRs:
REF_435(uint64) -> chains[parentKey]
REF_435(uint64) (->chains) := _until(uint64)"];
}
// Function: 10755.sol-MainToken-freezeTo(address,uint256,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_525 = CONVERT 0 to address
TMP_526(bool) = _to != TMP_525
TMP_527(None) = SOLIDITY_CALL require(bool)(TMP_526)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= balances[msg.sender])

IRs:
REF_408(uint256) -> balances[msg.sender]
TMP_528(bool) = _amount <= REF_408
TMP_529(None) = SOLIDITY_CALL require(bool)(TMP_528)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_amount)

IRs:
REF_409(uint256) -> balances[msg.sender]
REF_410(uint256) -> balances[msg.sender]
TMP_530(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_410', '_amount'] 
REF_409(uint256) (->balances) := TMP_530(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
currentKey = toKey(_to,_until)

IRs:
TMP_531(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
currentKey(bytes32) := TMP_531(bytes32)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
freezings[currentKey] = freezings[currentKey].add(_amount)

IRs:
REF_412(uint256) -> freezings[currentKey]
REF_413(uint256) -> freezings[currentKey]
TMP_532(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_413', '_amount'] 
REF_412(uint256) (->freezings) := TMP_532(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
freezingBalance[_to] = freezingBalance[_to].add(_amount)

IRs:
REF_415(uint256) -> freezingBalance[_to]
REF_416(uint256) -> freezingBalance[_to]
TMP_533(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_416', '_amount'] 
REF_415(uint256) (->freezingBalance) := TMP_533(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
freeze(_to,_until)

IRs:
INTERNAL_CALL, FreezableToken.freeze(address,uint64)(_to,_until)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Freezed(_to,_until,_amount)

IRs:
Emit Freezed(_to,_until,_amount)"];
}
// Function: 10755.sol-MainToken-freezingBalanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
freezingBalance[_owner]

IRs:
REF_403(uint256) -> freezingBalance[_owner]
RETURN REF_403"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 10755.sol-MainToken-freezingCount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
release = chains[toKey(_addr,0)]

IRs:
TMP_515(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,0)
REF_404(uint64) -> chains[TMP_515]
release(uint64) := REF_404(uint64)"];
1->2;
2[label="Node Type: BEGIN_LOOP 2
"];
2->3;
3[label="Node Type: IF_LOOP 3

EXPRESSION:
release != 0

IRs:
TMP_516(bool) = release != 0
CONDITION TMP_516"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
count ++

IRs:
TMP_517(uint256) := count(uint256)
count(uint256) = count + 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
release = chains[toKey(_addr,release)]

IRs:
TMP_518(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,release)
REF_405(uint64) -> chains[TMP_518]
release(uint64) := REF_405(uint64)"];
5->3;
6[label="Node Type: END_LOOP 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 10755.sol-MainToken-getFreezing(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _index + 1

IRs:
TMP_519(uint256) = _index + 1
TMP_520(bool) = i < TMP_519
CONDITION TMP_520"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_release = chains[toKey(_addr,_release)]

IRs:
TMP_521(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,_release)
REF_406(uint64) -> chains[TMP_521]
_release(uint64) := REF_406(uint64)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
_release == 0

IRs:
TMP_522(bool) = _release == 0
CONDITION TMP_522"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7
"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_523(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_balance = freezings[toKey(_addr,_release)]

IRs:
TMP_524(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_addr,_release)
REF_407(uint256) -> freezings[TMP_524]
_balance(uint256) := REF_407(uint256)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
(_release,_balance)

IRs:
RETURN _release,_balance"];
}
// Function: 10755.sol-MainToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_367(mapping(address => uint256)) -> allowed[msg.sender]
REF_368(uint256) -> REF_367[_spender]
REF_369(mapping(address => uint256)) -> allowed[msg.sender]
REF_370(uint256) -> REF_369[_spender]
TMP_479(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_370', '_addedValue'] 
REF_368(uint256) (->allowed) := TMP_479(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_372(mapping(address => uint256)) -> allowed[msg.sender]
REF_373(uint256) -> REF_372[_spender]
Emit Approval(msg.sender,_spender,REF_373)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-MainToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply.add(_amount)

IRs:
TMP_502(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_502(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_399(uint256) -> balances[_to]
REF_400(uint256) -> balances[_to]
TMP_503(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_400', '_amount'] 
REF_399(uint256) (->balances) := TMP_503(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_505 = CONVERT 0 to address
Emit Transfer(TMP_505,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 10755.sol-MainToken-mintAndFreeze(address,uint256,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply.add(_amount)

IRs:
TMP_492(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_492(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
currentKey = toKey(_to,_until)

IRs:
TMP_493(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(_to,_until)
currentKey(bytes32) := TMP_493(bytes32)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
freezings[currentKey] = freezings[currentKey].add(_amount)

IRs:
REF_392(uint256) -> freezings[currentKey]
REF_393(uint256) -> freezings[currentKey]
TMP_494(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_393', '_amount'] 
REF_392(uint256) (->freezings) := TMP_494(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
freezingBalance[_to] = freezingBalance[_to].add(_amount)

IRs:
REF_395(uint256) -> freezingBalance[_to]
REF_396(uint256) -> freezingBalance[_to]
TMP_495(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_396', '_amount'] 
REF_395(uint256) (->freezingBalance) := TMP_495(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
freeze(_to,_until)

IRs:
INTERNAL_CALL, FreezableToken.freeze(address,uint64)(_to,_until)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Freezed(_to,_until,_amount)

IRs:
Emit Freezed(_to,_until,_amount)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
11->1;
}
// Function: 10755.sol-MainToken-name()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
TOKEN_NAME

IRs:
RETURN TOKEN_NAME"];
2[label="Node Type: RETURN 2

EXPRESSION:
_name

IRs:
RETURN _name"];
}
// Function: 10755.sol-MainToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_575(bool) = msg.sender == owner
TMP_576(None) = SOLIDITY_CALL require(bool)(TMP_575)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-MainToken-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 10755.sol-MainToken-releaseAll()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(release,balance) = getFreezing(msg.sender,0)

IRs:
TUPLE_4(uint64,uint256) = INTERNAL_CALL, FreezableToken.getFreezing(address,uint256)(msg.sender,0)
release(uint256)= UNPACK TUPLE_4 index: 0 
balance(uint256)= UNPACK TUPLE_4 index: 1 "];
3->4;
4[label="Node Type: BEGIN_LOOP 4
"];
4->5;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
release != 0 && block.timestamp > release

IRs:
TMP_548(bool) = release != 0
TMP_549(bool) = block.timestamp > release
TMP_550(bool) = TMP_548 && TMP_549
CONDITION TMP_550"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
releaseOnce()

IRs:
INTERNAL_CALL, FreezableToken.releaseOnce()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokens += balance

IRs:
tokens(uint256) = tokens + balance"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
(release,balance) = getFreezing(msg.sender,0)

IRs:
TUPLE_5(uint64,uint256) = INTERNAL_CALL, FreezableToken.getFreezing(address,uint256)(msg.sender,0)
release(uint256)= UNPACK TUPLE_5 index: 0 
balance(uint256)= UNPACK TUPLE_5 index: 1 "];
8->5;
9[label="Node Type: END_LOOP 9
"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
tokens

IRs:
RETURN tokens"];
}
// Function: 10755.sol-MainToken-releaseOnce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
headKey = toKey(msg.sender,0)

IRs:
TMP_537(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(msg.sender,0)
headKey(bytes32) := TMP_537(bytes32)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
head = chains[headKey]

IRs:
REF_418(uint64) -> chains[headKey]
head(uint64) := REF_418(uint64)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(head != 0)

IRs:
TMP_538(bool) = head != 0
TMP_539(None) = SOLIDITY_CALL require(bool)(TMP_538)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(uint64(block.timestamp) > head)

IRs:
TMP_540 = CONVERT block.timestamp to uint64
TMP_541(bool) = TMP_540 > head
TMP_542(None) = SOLIDITY_CALL require(bool)(TMP_541)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
currentKey = toKey(msg.sender,head)

IRs:
TMP_543(bytes32) = INTERNAL_CALL, FreezableToken.toKey(address,uint256)(msg.sender,head)
currentKey(bytes32) := TMP_543(bytes32)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
next = chains[currentKey]

IRs:
REF_419(uint64) -> chains[currentKey]
next(uint64) := REF_419(uint64)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
amount = freezings[currentKey]

IRs:
REF_420(uint256) -> freezings[currentKey]
amount(uint256) := REF_420(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
delete freezings[currentKey]

IRs:
REF_421(uint256) -> freezings[currentKey]
freezings = delete REF_421 "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(amount)

IRs:
REF_422(uint256) -> balances[msg.sender]
REF_423(uint256) -> balances[msg.sender]
TMP_544(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_423', 'amount'] 
REF_422(uint256) (->balances) := TMP_544(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount)

IRs:
REF_425(uint256) -> freezingBalance[msg.sender]
REF_426(uint256) -> freezingBalance[msg.sender]
TMP_545(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_426', 'amount'] 
REF_425(uint256) (->freezingBalance) := TMP_545(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
next == 0

IRs:
TMP_546(bool) = next == 0
CONDITION TMP_546"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
delete chains[headKey]

IRs:
REF_428(uint64) -> chains[headKey]
chains = delete REF_428 "];
12->15;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
chains[headKey] = next

IRs:
REF_429(uint64) -> chains[headKey]
REF_429(uint64) (->chains) := next(uint64)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
delete chains[currentKey]

IRs:
REF_430(uint64) -> chains[currentKey]
chains = delete REF_430 "];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Released(msg.sender,amount)

IRs:
Emit Released(msg.sender,amount)"];
}
// Function: 10755.sol-MainToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
TOKEN_DECIMALS = 18

IRs:
TOKEN_DECIMALS(uint256) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
TOKEN_DECIMALS_UINT8 = 18

IRs:
TOKEN_DECIMALS_UINT8(uint8) := 18(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS

IRs:
TMP_571(uint256) = 10 ** TOKEN_DECIMALS
TOKEN_DECIMAL_MULTIPLIER(uint256) := TMP_571(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TOKEN_NAME = Word of mouth pro

IRs:
TOKEN_NAME(string) := Word of mouth pro(string)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
TOKEN_SYMBOL = wmp

IRs:
TOKEN_SYMBOL(string) := wmp(string)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
PAUSED = true

IRs:
PAUSED(bool) := True(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
TARGET_USER = 0x63DA42f4151F88c7EAAeBb67783D855b4ac8AdD7

IRs:
TARGET_USER(address) := 570057481232686336990038773061472884575540129239(address)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
START_TIME = 1531087260

IRs:
START_TIME(uint256) := 1531087260(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
CONTINUE_MINTING = false

IRs:
CONTINUE_MINTING(bool) := False(bool)"];
}
// Function: 10755.sol-MainToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 10755.sol-MainToken-symbol()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
TOKEN_SYMBOL

IRs:
RETURN TOKEN_SYMBOL"];
2[label="Node Type: RETURN 2

EXPRESSION:
_symbol

IRs:
RETURN _symbol"];
}
// Function: 10755.sol-MainToken-toKey(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
result = 0x5749534800000000000000000000000000000000000000000000000000000000

IRs:
result(bytes32) := 39480772448535941496179204954862169494691089619604794184232587696854102179840(uint256)"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 10755.sol-MainToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_568 = UnaryType.BANG paused 
TMP_569(None) = SOLIDITY_CALL require(bool)(TMP_568)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_570(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)
RETURN TMP_570"];
3[label="Node Type: RETURN 3

EXPRESSION:
_success

IRs:
RETURN _success"];
}
// Function: 10755.sol-MainToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_565 = UnaryType.BANG paused 
TMP_566(None) = SOLIDITY_CALL require(bool)(TMP_565)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_567(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_567"];
3[label="Node Type: RETURN 3

EXPRESSION:
_success

IRs:
RETURN _success"];
}
// Function: 10755.sol-MainToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_455 = CONVERT 0 to address
TMP_456(bool) = newOwner != TMP_455
TMP_457(None) = SOLIDITY_CALL require(bool)(TMP_456)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-MainToken-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 10755.sol-MainToken-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_572 = UnaryType.BANG paused 
TMP_573(None) = SOLIDITY_CALL require(bool)(TMP_572)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-MainToken-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_574(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-MintableToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-MintableToken-allowance(address,address)
digraph{
}
// Function: 10755.sol-MintableToken-approve(address,uint256)
digraph{
}
// Function: 10755.sol-MintableToken-balanceOf(address)
digraph{
}
// Function: 10755.sol-MintableToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_94 = UnaryType.BANG mintingFinished 
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-MintableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
oldValue(uint256) := REF_76(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_71(bool) = _subtractedValue > oldValue
CONDITION TMP_71"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
REF_78(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_80(uint256) (->allowed) := TMP_72(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
Emit Approval(msg.sender,_spender,REF_83)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-MintableToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 10755.sol-MintableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] 
REF_69(uint256) (->allowed) := TMP_69(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_73(mapping(address => uint256)) -> allowed[msg.sender]
REF_74(uint256) -> REF_73[_spender]
Emit Approval(msg.sender,_spender,REF_74)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-MintableToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply.add(_amount)

IRs:
TMP_82(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_82(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_93(uint256) -> balances[_to]
REF_94(uint256) -> balances[_to]
TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_94', '_amount'] 
REF_93(uint256) (->balances) := TMP_83(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_85 = CONVERT 0 to address
Emit Transfer(TMP_85,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 10755.sol-MintableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_92(bool) = msg.sender == owner
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-MintableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
}
// Function: 10755.sol-MintableToken-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-MintableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 10755.sol-MintableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_52 = CONVERT 0 to address
TMP_53(bool) = newOwner != TMP_52
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_50(bool) = msg.sender == owner
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_45 = CONVERT 0 to address
TMP_46(bool) = newOwner != TMP_45
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-Pausable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-Pausable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_320(bool) = msg.sender == owner
TMP_321(None) = SOLIDITY_CALL require(bool)(TMP_320)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-Pausable-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 10755.sol-Pausable-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 10755.sol-Pausable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_309 = CONVERT 0 to address
TMP_310(bool) = newOwner != TMP_309
TMP_311(None) = SOLIDITY_CALL require(bool)(TMP_310)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-Pausable-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 10755.sol-Pausable-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_322 = UnaryType.BANG paused 
TMP_323(None) = SOLIDITY_CALL require(bool)(TMP_322)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-Pausable-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_324(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-RefundVault-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-RefundVault-RefundVault(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_175 = CONVERT 0 to address
TMP_176(bool) = _wallet != TMP_175
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
state = State.Active

IRs:
REF_104(RefundVault.State) -> State.Active
state(RefundVault.State) := REF_104(RefundVault.State)"];
}
// Function: 10755.sol-RefundVault-close()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_109(RefundVault.State) -> State.Active
TMP_182(bool) = state == REF_109
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_110(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_110(RefundVault.State)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_112(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_112"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 10755.sol-RefundVault-deposit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_105(RefundVault.State) -> State.Active
TMP_178(bool) = state == REF_105
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
deposited[investor] = deposited[investor].add(msg.value)

IRs:
REF_106(uint256) -> deposited[investor]
REF_107(uint256) -> deposited[investor]
TMP_180(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_107', 'msg.value'] 
REF_106(uint256) (->deposited) := TMP_180(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 10755.sol-RefundVault-enableRefunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_113(RefundVault.State) -> State.Active
TMP_187(bool) = state == REF_113
TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
state = State.Refunding

IRs:
REF_114(RefundVault.State) -> State.Refunding
state(RefundVault.State) := REF_114(RefundVault.State)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RefundsEnabled()

IRs:
Emit RefundsEnabled()"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-RefundVault-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_195(bool) = msg.sender == owner
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-RefundVault-refund(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_115(RefundVault.State) -> State.Refunding
TMP_191(bool) = state == REF_115
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_116(uint256) -> deposited[investor]
depositedValue(uint256) := REF_116(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_117(uint256) -> deposited[investor]
REF_117(uint256) (->deposited) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)"];
}
// Function: 10755.sol-RefundVault-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_170 = CONVERT 0 to address
TMP_171(bool) = newOwner != TMP_170
TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-RefundableCrowdsale-Crowdsale(uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_630(bool) = _startTime >= now
TMP_631(None) = SOLIDITY_CALL require(bool)(TMP_630)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_632(bool) = _endTime >= _startTime
TMP_633(None) = SOLIDITY_CALL require(bool)(TMP_632)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_634(bool) = _rate > 0
TMP_635(None) = SOLIDITY_CALL require(bool)(TMP_634)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_636 = CONVERT 0 to address
TMP_637(bool) = _wallet != TMP_636
TMP_638(None) = SOLIDITY_CALL require(bool)(TMP_637)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = createTokenContract()

IRs:
TMP_639(MintableToken) = INTERNAL_CALL, Crowdsale.createTokenContract()()
token(MintableToken) := TMP_639(MintableToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10755.sol-RefundableCrowdsale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-RefundableCrowdsale-RefundableCrowdsale(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_goal > 0)

IRs:
TMP_660(bool) = _goal > 0
TMP_661(None) = SOLIDITY_CALL require(bool)(TMP_660)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
vault = new RefundVault(wallet)

IRs:
TMP_663(RefundVault) = new RefundVault(wallet) 
vault(RefundVault) := TMP_663(RefundVault)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
goal = _goal

IRs:
goal(uint256) := _goal(uint256)"];
}
// Function: 10755.sol-RefundableCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_643 = CONVERT 0 to address
TMP_644(bool) = beneficiary != TMP_643
TMP_645(None) = SOLIDITY_CALL require(bool)(TMP_644)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_646(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_647(None) = SOLIDITY_CALL require(bool)(TMP_646)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = weiAmount.mul(rate)

IRs:
TMP_648(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'rate'] 
tokens(uint256) := TMP_648(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_649(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_649(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_650(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'tokens']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, RefundableCrowdsale.forwardFunds()()"];
}
// Function: 10755.sol-RefundableCrowdsale-claimRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_666(None) = SOLIDITY_CALL require(bool)(isFinalized)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! goalReached())

IRs:
TMP_667(bool) = INTERNAL_CALL, RefundableCrowdsale.goalReached()()
TMP_668 = UnaryType.BANG TMP_667 
TMP_669(None) = SOLIDITY_CALL require(bool)(TMP_668)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
vault.refund(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:refund, arguments:['msg.sender']  "];
}
// Function: 10755.sol-RefundableCrowdsale-createTokenContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
new MintableToken()

IRs:
TMP_641(MintableToken) = new MintableToken() 
RETURN TMP_641"];
}
// Function: 10755.sol-RefundableCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10755.sol-RefundableCrowdsale-finalization()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
goalReached()

IRs:
TMP_671(bool) = INTERNAL_CALL, RefundableCrowdsale.goalReached()()
CONDITION TMP_671"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
vault.close()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  "];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
vault.enableRefunds()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  "];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
super.finalization()

IRs:
INTERNAL_CALL, FinalizableCrowdsale.finalization()()"];
}
// Function: 10755.sol-RefundableCrowdsale-finalize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_618 = UnaryType.BANG isFinalized 
TMP_619(None) = SOLIDITY_CALL require(bool)(TMP_618)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_620(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_621(None) = SOLIDITY_CALL require(bool)(TMP_620)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, RefundableCrowdsale.finalization()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Finalized()

IRs:
Emit Finalized()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 10755.sol-RefundableCrowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
vault.deposit.value(msg.value)(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:deposit, arguments:['msg.sender'] value:msg.value "];
}
// Function: 10755.sol-RefundableCrowdsale-goalReached()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
weiRaised >= goal

IRs:
TMP_675(bool) = weiRaised >= goal
RETURN TMP_675"];
}
// Function: 10755.sol-RefundableCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_659(bool) = now > endTime
RETURN TMP_659"];
}
// Function: 10755.sol-RefundableCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_676(bool) = msg.sender == owner
TMP_677(None) = SOLIDITY_CALL require(bool)(TMP_676)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-RefundableCrowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFinalized = false

IRs:
isFinalized(bool) := False(bool)"];
}
// Function: 10755.sol-RefundableCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_625 = CONVERT 0 to address
TMP_626(bool) = newOwner != TMP_625
TMP_627(None) = SOLIDITY_CALL require(bool)(TMP_626)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-RefundableCrowdsale-validPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinPeriod = now >= startTime && now <= endTime

IRs:
TMP_654(bool) = now >= startTime
TMP_655(bool) = now <= endTime
TMP_656(bool) = TMP_654 && TMP_655
withinPeriod(bool) := TMP_656(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
nonZeroPurchase = msg.value != 0

IRs:
TMP_657(bool) = msg.value != 0
nonZeroPurchase(bool) := TMP_657(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
withinPeriod && nonZeroPurchase

IRs:
TMP_658(bool) = withinPeriod && nonZeroPurchase
RETURN TMP_658"];
}
// Function: 10755.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10755.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_5(uint256) = a / b
c(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10755.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 10755.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 10755.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 10755.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 10755.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_42(bool) = _subtractedValue > oldValue
CONDITION TMP_42"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_43(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_40(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 10755.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_28 = CONVERT 0 to address
TMP_29(bool) = _to != TMP_28
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_31(bool) = _value <= REF_16
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_33(bool) = _value <= REF_18
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_35(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_36(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_37(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 10755.sol-SuccessfulERC223Receiver-tokenFallback(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Invoked(_from,_value,_data)

IRs:
Emit Invoked(_from,_value,_data)"];
}
// Function: 10755.sol-TemplateCrowdsale-CappedCrowdsale(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_cap > 0)

IRs:
TMP_837(bool) = _cap > 0
TMP_838(None) = SOLIDITY_CALL require(bool)(TMP_837)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
cap = _cap

IRs:
cap(uint256) := _cap(uint256)"];
}
// Function: 10755.sol-TemplateCrowdsale-Crowdsale(uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now)

IRs:
TMP_846(bool) = _startTime >= now
TMP_847(None) = SOLIDITY_CALL require(bool)(TMP_846)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTime >= _startTime)

IRs:
TMP_848(bool) = _endTime >= _startTime
TMP_849(None) = SOLIDITY_CALL require(bool)(TMP_848)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_850(bool) = _rate > 0
TMP_851(None) = SOLIDITY_CALL require(bool)(TMP_850)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_852 = CONVERT 0 to address
TMP_853(bool) = _wallet != TMP_852
TMP_854(None) = SOLIDITY_CALL require(bool)(TMP_853)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
token = createTokenContract()

IRs:
TMP_855(MintableToken) = INTERNAL_CALL, TemplateCrowdsale.createTokenContract()()
token(MintableToken) := TMP_855(MintableToken)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
}
// Function: 10755.sol-TemplateCrowdsale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 10755.sol-TemplateCrowdsale-RefundableCrowdsale(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_goal > 0)

IRs:
TMP_876(bool) = _goal > 0
TMP_877(None) = SOLIDITY_CALL require(bool)(TMP_876)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
vault = new RefundVault(wallet)

IRs:
TMP_879(RefundVault) = new RefundVault(wallet) 
vault(RefundVault) := TMP_879(RefundVault)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
goal = _goal

IRs:
goal(uint256) := _goal(uint256)"];
}
// Function: 10755.sol-TemplateCrowdsale-TemplateCrowdsale(MintableToken)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token = _token

IRs:
token(MintableToken) := _token(MintableToken)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
CappedCrowdsale(20000000000000000000000)

IRs:
INTERNAL_CALL, CappedCrowdsale.CappedCrowdsale(uint256)(20000000000000000000000)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
RefundableCrowdsale(1000000000000000000000)

IRs:
INTERNAL_CALL, RefundableCrowdsale.RefundableCrowdsale(uint256)(1000000000000000000000)"];
4->1;
5[label="Node Type: IF 5

EXPRESSION:
START_TIME > now

IRs:
TMP_976(bool) = START_TIME > now
CONDITION TMP_976"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Crowdsale(START_TIME,1546297140,1500 * TOKEN_DECIMAL_MULTIPLIER,0x8F988d90C96282402b47b01D7EADE079eA6eBe36)

IRs:
TMP_977(uint256) = 1500 * TOKEN_DECIMAL_MULTIPLIER
INTERNAL_CALL, Crowdsale.Crowdsale(uint256,uint256,uint256,address)(START_TIME,1546297140,TMP_977,819787725598649235534918816425756261781599075894)"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Crowdsale(now,1546297140,1500 * TOKEN_DECIMAL_MULTIPLIER,0x8F988d90C96282402b47b01D7EADE079eA6eBe36)

IRs:
TMP_979(uint256) = 1500 * TOKEN_DECIMAL_MULTIPLIER
INTERNAL_CALL, Crowdsale.Crowdsale(uint256,uint256,uint256,address)(now,1546297140,TMP_979,819787725598649235534918816425756261781599075894)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->3;
}
// Function: 10755.sol-TemplateCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_963 = CONVERT 0 to address
TMP_964(bool) = beneficiary != TMP_963
TMP_965(None) = SOLIDITY_CALL require(bool)(TMP_964)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_966(bool) = INTERNAL_CALL, CappedCrowdsale.validPurchase()()
TMP_967(None) = SOLIDITY_CALL require(bool)(TMP_966)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = weiAmount.mul(rate).div(1000000000000000000)

IRs:
TMP_968(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'rate'] 
TMP_969(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_968', '1000000000000000000'] 
tokens(uint256) := TMP_969(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_970(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_970(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_971(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'tokens']  "];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, RefundableCrowdsale.forwardFunds()()"];
}
// Function: 10755.sol-TemplateCrowdsale-claimRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_882(None) = SOLIDITY_CALL require(bool)(isFinalized)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! goalReached())

IRs:
TMP_883(bool) = INTERNAL_CALL, RefundableCrowdsale.goalReached()()
TMP_884 = UnaryType.BANG TMP_883 
TMP_885(None) = SOLIDITY_CALL require(bool)(TMP_884)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
vault.refund(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:refund, arguments:['msg.sender']  "];
}
// Function: 10755.sol-TemplateCrowdsale-createTokenContract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
MintableToken(0)

IRs:
TMP_1007 = CONVERT 0 to MintableToken
RETURN TMP_1007"];
}
// Function: 10755.sol-TemplateCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, BonusableCrowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 10755.sol-TemplateCrowdsale-finalization()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.finalization()

IRs:
INTERNAL_CALL, FinalizableCrowdsale.finalization()()"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
PAUSED

IRs:
CONDITION PAUSED"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
MainToken(token).unpause()

IRs:
TMP_958 = CONVERT token to MainToken
HIGH_LEVEL_CALL, dest:TMP_958(MainToken), function:unpause, arguments:[]  "];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! CONTINUE_MINTING

IRs:
TMP_960 = UnaryType.BANG CONTINUE_MINTING 
CONDITION TMP_960"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token.finishMinting()

IRs:
TMP_961(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  "];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
token.transferOwnership(TARGET_USER)

IRs:
HIGH_LEVEL_CALL, dest:token(MintableToken), function:transferOwnership, arguments:['TARGET_USER']  "];
}
// Function: 10755.sol-TemplateCrowdsale-finalize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_892 = UnaryType.BANG isFinalized 
TMP_893(None) = SOLIDITY_CALL require(bool)(TMP_892)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_894(bool) = INTERNAL_CALL, CappedCrowdsale.hasEnded()()
TMP_895(None) = SOLIDITY_CALL require(bool)(TMP_894)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, RefundableCrowdsale.finalization()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Finalized()

IRs:
Emit Finalized()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->1;
}
// Function: 10755.sol-TemplateCrowdsale-forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
vault.deposit.value(msg.value)(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:deposit, arguments:['msg.sender'] value:msg.value "];
}
// Function: 10755.sol-TemplateCrowdsale-getBonusRate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bonusRate = rate

IRs:
bonusRate(uint256) := rate(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
weiRaisedStartsBoundaries = (uint256(0),uint256(0),uint256(0),uint256(0))

IRs:
TMP_916 = CONVERT 0 to uint256
TMP_917 = CONVERT 0 to uint256
TMP_918 = CONVERT 0 to uint256
TMP_919 = CONVERT 0 to uint256
weiRaisedStartsBoundaries(uint256[4]) = ['TMP_916(uint256)', 'TMP_917(uint256)', 'TMP_918(uint256)', 'TMP_919(uint256)']"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
weiRaisedEndsBoundaries = (uint256(20000000000000000000000),uint256(20000000000000000000000),uint256(20000000000000000000000),uint256(20000000000000000000000))

IRs:
TMP_920 = CONVERT 20000000000000000000000 to uint256
TMP_921 = CONVERT 20000000000000000000000 to uint256
TMP_922 = CONVERT 20000000000000000000000 to uint256
TMP_923 = CONVERT 20000000000000000000000 to uint256
weiRaisedEndsBoundaries(uint256[4]) = ['TMP_920(uint256)', 'TMP_921(uint256)', 'TMP_922(uint256)', 'TMP_923(uint256)']"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
timeStartsBoundaries = (uint64(1531087260),uint64(1532383140),uint64(1534197540),uint64(1536011940))

IRs:
TMP_924 = CONVERT 1531087260 to uint64
TMP_925 = CONVERT 1532383140 to uint64
TMP_926 = CONVERT 1534197540 to uint64
TMP_927 = CONVERT 1536011940 to uint64
timeStartsBoundaries(uint64[4]) = ['TMP_924(uint64)', 'TMP_925(uint64)', 'TMP_926(uint64)', 'TMP_927(uint64)']"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
timeEndsBoundaries = (uint64(1532383140),uint64(1534197540),uint64(1536011940),uint64(1537221540))

IRs:
TMP_928 = CONVERT 1532383140 to uint64
TMP_929 = CONVERT 1534197540 to uint64
TMP_930 = CONVERT 1536011940 to uint64
TMP_931 = CONVERT 1537221540 to uint64
timeEndsBoundaries(uint64[4]) = ['TMP_928(uint64)', 'TMP_929(uint64)', 'TMP_930(uint64)', 'TMP_931(uint64)']"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
weiRaisedAndTimeRates = (uint256(400),uint256(300),uint256(200),uint256(100))

IRs:
TMP_932 = CONVERT 400 to uint256
TMP_933 = CONVERT 300 to uint256
TMP_934 = CONVERT 200 to uint256
TMP_935 = CONVERT 100 to uint256
weiRaisedAndTimeRates(uint256[4]) = ['TMP_932(uint256)', 'TMP_933(uint256)', 'TMP_934(uint256)', 'TMP_935(uint256)']"];
6->9;
7[label="Node Type: BEGIN_LOOP 7
"];
7->10;
8[label="Node Type: END_LOOP 8
"];
8->17;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
9->7;
10[label="Node Type: IF_LOOP 10

EXPRESSION:
i < 4

IRs:
TMP_936(bool) = i < 4
CONDITION TMP_936"];
10->11[label="True"];
10->8[label="False"];
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i])

IRs:
REF_491(uint256) -> weiRaisedStartsBoundaries[i]
TMP_937(bool) = REF_491 <= weiRaised
REF_492(uint256) -> weiRaisedEndsBoundaries[i]
TMP_938(bool) = weiRaised < REF_492
TMP_939(bool) = TMP_937 && TMP_938
weiRaisedInBound(bool) := TMP_939(bool)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i])

IRs:
REF_493(uint64) -> timeStartsBoundaries[i]
TMP_940(bool) = REF_493 <= now
REF_494(uint64) -> timeEndsBoundaries[i]
TMP_941(bool) = now < REF_494
TMP_942(bool) = TMP_940 && TMP_941
timeInBound(bool) := TMP_942(bool)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
weiRaisedInBound && timeInBound

IRs:
TMP_943(bool) = weiRaisedInBound && timeInBound
CONDITION TMP_943"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000

IRs:
REF_495(uint256) -> weiRaisedAndTimeRates[i]
TMP_944(uint256) = bonusRate * REF_495
TMP_945(uint256) = TMP_944 / 1000
bonusRate(uint256) = bonusRate + TMP_945"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_946(uint256) := i(uint256)
i(uint256) = i + 1"];
16->10;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
weiAmountBoundaries = (uint256(20000000000000000000),uint256(10000000000000000000))

IRs:
TMP_947 = CONVERT 20000000000000000000 to uint256
TMP_948 = CONVERT 10000000000000000000 to uint256
weiAmountBoundaries(uint256[2]) = ['TMP_947(uint256)', 'TMP_948(uint256)']"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
weiAmountRates = (uint256(0),uint256(50))

IRs:
TMP_949 = CONVERT 0 to uint256
TMP_950 = CONVERT 50 to uint256
weiAmountRates(uint256[2]) = ['TMP_949(uint256)', 'TMP_950(uint256)']"];
18->21;
19[label="Node Type: BEGIN_LOOP 19
"];
19->22;
20[label="Node Type: END_LOOP 20
"];
20->28;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
21->19;
22[label="Node Type: IF_LOOP 22

EXPRESSION:
j < 2

IRs:
TMP_951(bool) = j < 2
CONDITION TMP_951"];
22->23[label="True"];
22->20[label="False"];
23[label="Node Type: IF 23

EXPRESSION:
weiAmount >= weiAmountBoundaries[j]

IRs:
REF_496(uint256) -> weiAmountBoundaries[j]
TMP_952(bool) = weiAmount >= REF_496
CONDITION TMP_952"];
23->24[label="True"];
23->26[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
bonusRate += bonusRate * weiAmountRates[j] / 1000

IRs:
REF_497(uint256) -> weiAmountRates[j]
TMP_953(uint256) = bonusRate * REF_497
TMP_954(uint256) = TMP_953 / 1000
bonusRate(uint256) = bonusRate + TMP_954"];
24->25;
25[label="Node Type: BREAK 25
"];
25->20;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
j ++

IRs:
TMP_955(uint256) := j(uint256)
j(uint256) = j + 1"];
27->22;
28[label="Node Type: RETURN 28

EXPRESSION:
bonusRate

IRs:
RETURN bonusRate"];
}
// Function: 10755.sol-TemplateCrowdsale-goalReached()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
weiRaised >= goal

IRs:
TMP_891(bool) = weiRaised >= goal
RETURN TMP_891"];
}
// Function: 10755.sol-TemplateCrowdsale-hasEnded()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now > endTime

IRs:
TMP_875(bool) = now > endTime
RETURN TMP_875"];
}
// Function: 10755.sol-TemplateCrowdsale-hasStarted()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now >= startTime

IRs:
TMP_956(bool) = now >= startTime
RETURN TMP_956"];
}
// Function: 10755.sol-TemplateCrowdsale-init()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->20;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! initialized)

IRs:
TMP_981 = UnaryType.BANG initialized 
TMP_982(None) = SOLIDITY_CALL require(bool)(TMP_981)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
initialized = true

IRs:
initialized(bool) := True(bool)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
PAUSED

IRs:
CONDITION PAUSED"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
MainToken(token).pause()

IRs:
TMP_983 = CONVERT token to MainToken
HIGH_LEVEL_CALL, dest:TMP_983(MainToken), function:pause, arguments:[]  "];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
addresses = (address(0x192ff136cd853ab6b9b5097bf017024d7da709c3),address(0xa00be5796cf65147a7494f2f27de08cca6847cbb),address(0xb1c1113f071fa97318074486e27efd8e753f6b54),address(0xbd3e941f88c892118a8fc50ffa8ccd1199e30704))

IRs:
TMP_985 = CONVERT 143793917004267800818448701676489184164142582211 to address
TMP_986 = CONVERT 913703821561478508386016607620109927821827407035 to address
TMP_987 = CONVERT 1014796912615254956017906174160821952691985935188 to address
TMP_988 = CONVERT 1080394805236902273200454633613964049953897776900 to address
addresses(address[4]) = ['TMP_985(address)', 'TMP_986(address)', 'TMP_987(address)', 'TMP_988(address)']"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
amounts = (uint256(1500000000000000000000000),uint256(5000000000000000000000000),uint256(10000000000000000000000000),uint256(3500000000000000000000000))

IRs:
TMP_989 = CONVERT 1500000000000000000000000 to uint256
TMP_990 = CONVERT 5000000000000000000000000 to uint256
TMP_991 = CONVERT 10000000000000000000000000 to uint256
TMP_992 = CONVERT 3500000000000000000000000 to uint256
amounts(uint256[4]) = ['TMP_989(uint256)', 'TMP_990(uint256)', 'TMP_991(uint256)', 'TMP_992(uint256)']"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
freezes = (uint64(1577746808),uint64(1577746809),uint64(0),uint64(1561845608))

IRs:
TMP_993 = CONVERT 1577746808 to uint64
TMP_994 = CONVERT 1577746809 to uint64
TMP_995 = CONVERT 0 to uint64
TMP_996 = CONVERT 1561845608 to uint64
freezes(uint64[4]) = ['TMP_993(uint64)', 'TMP_994(uint64)', 'TMP_995(uint64)', 'TMP_996(uint64)']"];
8->11;
9[label="Node Type: BEGIN_LOOP 9
"];
9->12;
10[label="Node Type: END_LOOP 10
"];
10->18;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
11->9;
12[label="Node Type: IF_LOOP 12

EXPRESSION:
i < addresses.length

IRs:
REF_506 -> LENGTH addresses
TMP_997(bool) = i < REF_506
CONDITION TMP_997"];
12->13[label="True"];
12->10[label="False"];
13[label="Node Type: IF 13

EXPRESSION:
freezes[i] == 0

IRs:
REF_507(uint64) -> freezes[i]
TMP_998(bool) = REF_507 == 0
CONDITION TMP_998"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
MainToken(token).mint(addresses[i],amounts[i])

IRs:
TMP_999 = CONVERT token to MainToken
REF_509(address) -> addresses[i]
REF_510(uint256) -> amounts[i]
TMP_1000(bool) = HIGH_LEVEL_CALL, dest:TMP_999(MainToken), function:mint, arguments:['REF_509', 'REF_510']  "];
14->16;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
MainToken(token).mintAndFreeze(addresses[i],amounts[i],freezes[i])

IRs:
TMP_1001 = CONVERT token to MainToken
REF_512(address) -> addresses[i]
REF_513(uint256) -> amounts[i]
REF_514(uint64) -> freezes[i]
TMP_1002(bool) = HIGH_LEVEL_CALL, dest:TMP_1001(MainToken), function:mintAndFreeze, arguments:['REF_512', 'REF_513', 'REF_514']  "];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_1003(uint256) := i(uint256)
i(uint256) = i + 1"];
17->12;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
transferOwnership(TARGET_USER)

IRs:
INTERNAL_CALL, Ownable.transferOwnership(address)(TARGET_USER)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
Initialized()

IRs:
Emit Initialized()"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
20->1;
}
// Function: 10755.sol-TemplateCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_1009(bool) = msg.sender == owner
TMP_1010(None) = SOLIDITY_CALL require(bool)(TMP_1009)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 10755.sol-TemplateCrowdsale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
TOKEN_DECIMALS = 18

IRs:
TOKEN_DECIMALS(uint256) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
TOKEN_DECIMALS_UINT8 = 18

IRs:
TOKEN_DECIMALS_UINT8(uint8) := 18(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS

IRs:
TMP_1008(uint256) = 10 ** TOKEN_DECIMALS
TOKEN_DECIMAL_MULTIPLIER(uint256) := TMP_1008(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TOKEN_NAME = Word of mouth pro

IRs:
TOKEN_NAME(string) := Word of mouth pro(string)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
TOKEN_SYMBOL = wmp

IRs:
TOKEN_SYMBOL(string) := wmp(string)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
PAUSED = true

IRs:
PAUSED(bool) := True(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
TARGET_USER = 0x63DA42f4151F88c7EAAeBb67783D855b4ac8AdD7

IRs:
TARGET_USER(address) := 570057481232686336990038773061472884575540129239(address)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
START_TIME = 1531087260

IRs:
START_TIME(uint256) := 1531087260(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
CONTINUE_MINTING = false

IRs:
CONTINUE_MINTING(bool) := False(bool)"];
}
// Function: 10755.sol-TemplateCrowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isFinalized = false

IRs:
isFinalized(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
initialized = false

IRs:
initialized(bool) := False(bool)"];
}
// Function: 10755.sol-TemplateCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_899 = CONVERT 0 to address
TMP_900(bool) = newOwner != TMP_899
TMP_901(None) = SOLIDITY_CALL require(bool)(TMP_900)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 10755.sol-TemplateCrowdsale-validPurchase()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
withinPeriod = now >= startTime && now <= endTime

IRs:
TMP_870(bool) = now >= startTime
TMP_871(bool) = now <= endTime
TMP_872(bool) = TMP_870 && TMP_871
withinPeriod(bool) := TMP_872(bool)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
nonZeroPurchase = msg.value != 0

IRs:
TMP_873(bool) = msg.value != 0
nonZeroPurchase(bool) := TMP_873(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
withinPeriod && nonZeroPurchase

IRs:
TMP_874(bool) = withinPeriod && nonZeroPurchase
RETURN TMP_874"];
}
}
