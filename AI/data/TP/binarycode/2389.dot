digraph G {
// Function: 2389.sol-AddressExtension-isAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: INLINE ASM 1
"];
1->2;
2[label="Node Type: END INLINE ASM 2
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 2389.sol-AddressExtension-isValid(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
0 != _address

IRs:
TMP_0(bool) = 0 != _address
RETURN TMP_0"];
}
// Function: 2389.sol-AddressExtension-toBytes(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: INLINE ASM 1
"];
1->2;
2[label="Node Type: END INLINE ASM 2
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 2389.sol-Authorizable-constructor(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
fstkAuthority = _fstkAuthority

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)"];
}
// Function: 2389.sol-Authorizable-onlyFsTKApproved(bytes32,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isApproved(hash,approveTime,approveToken))

IRs:
TMP_49(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isApproved, arguments:['hash', 'approveTime', 'approveToken']  
TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-Authorizable-onlyFsTKAuthorized()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isAuthorized(msg.sender,this,msg.data))

IRs:
TMP_47(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isAuthorized, arguments:['msg.sender', 'this', 'msg.data']  
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-Authorizable-setFsTKAuthority(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_fstkAuthority.validate() == _fstkAuthority.validate.selector)

IRs:
TMP_42(bytes4) = HIGH_LEVEL_CALL, dest:_fstkAuthority(FsTKAuthority), function:validate, arguments:[]  
REF_17(bytes4) (->None) := 1761736296(uint256)
TMP_43(bool) = TMP_42 == REF_17
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetFsTKAuthority(fstkAuthority = _fstkAuthority)

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)
Emit SetFsTKAuthority(fstkAuthority)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
3->1;
}
// Function: 2389.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 2389.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 2389.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 2389.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 2389.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 2389.sol-ERC20Like-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[owner].instruments[spender].allowance

IRs:
REF_22(FsTKToken.Account) -> accounts[owner]
REF_23(mapping(address => FsTKToken.Instrument)) -> REF_22.instruments
REF_24(FsTKToken.Instrument) -> REF_23[spender]
REF_25(uint256) -> REF_24.allowance
RETURN REF_25"];
}
// Function: 2389.sol-ERC20Like-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_43(FsTKToken.Account) -> accounts[msg.sender]
REF_44(mapping(address => FsTKToken.Instrument)) -> REF_43.instruments
REF_45(FsTKToken.Instrument) -> REF_44[spender]
spenderInstrument(FsTKToken.Instrument) := REF_45(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
erc20ApproveChecking

IRs:
CONDITION erc20ApproveChecking"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)((value == 0) || (spenderInstrument.allowance == 0))

IRs:
TMP_58(bool) = value == 0
REF_46(uint256) -> spenderInstrument.allowance
TMP_59(bool) = REF_46 == 0
TMP_60(bool) = TMP_58 || TMP_59
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = value)

IRs:
REF_47(uint256) -> spenderInstrument.allowance
REF_47(uint256) (->spenderInstrument) := value(uint256)
Emit Approval(msg.sender,spender,REF_47)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2389.sol-ERC20Like-approve(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_48(FsTKToken.Account) -> accounts[msg.sender]
REF_49(mapping(address => FsTKToken.Instrument)) -> REF_48.instruments
REF_50(FsTKToken.Instrument) -> REF_49[spender]
spenderInstrument(FsTKToken.Instrument) := REF_50(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(spenderInstrument.allowance == expectedValue)

IRs:
REF_51(uint256) -> spenderInstrument.allowance
TMP_64(bool) = REF_51 == expectedValue
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = newValue)

IRs:
REF_52(uint256) -> spenderInstrument.allowance
REF_52(uint256) (->spenderInstrument) := newValue(uint256)
Emit Approval(msg.sender,spender,REF_52)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2389.sol-ERC20Like-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[owner].balance

IRs:
REF_20(FsTKToken.Account) -> accounts[owner]
REF_21(uint256) -> REF_20.balance
RETURN REF_21"];
}
// Function: 2389.sol-ERC20Like-canDelegate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDelegateEnable)

IRs:
TMP_170(None) = SOLIDITY_CALL require(bool)(isDelegateEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-ERC20Like-canUseDirectDebit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDirectDebitEnable)

IRs:
TMP_169(None) = SOLIDITY_CALL require(bool)(isDirectDebitEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-ERC20Like-constructor(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
metadata = _metadata

IRs:
metadata(string) := _metadata(string)"];
}
// Function: 2389.sol-ERC20Like-decreaseAllowance(address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_59(FsTKToken.Account) -> accounts[msg.sender]
REF_60(mapping(address => FsTKToken.Instrument)) -> REF_59.instruments
REF_61(FsTKToken.Instrument) -> REF_60[spender]
spenderInstrument(FsTKToken.Instrument) := REF_61(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
currentValue = spenderInstrument.allowance

IRs:
REF_62(uint256) -> spenderInstrument.allowance
currentValue(uint256) := REF_62(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
strict

IRs:
CONDITION strict"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
newValue = currentValue.sub(value)

IRs:
TMP_69(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['currentValue', 'value'] 
newValue(uint256) := TMP_69(uint256)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
value < currentValue

IRs:
TMP_70(bool) = value < currentValue
CONDITION TMP_70"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
newValue = currentValue - value

IRs:
TMP_71(uint256) = currentValue - value
newValue(uint256) := TMP_71(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = newValue)

IRs:
REF_64(uint256) -> spenderInstrument.allowance
REF_64(uint256) (->spenderInstrument) := newValue(uint256)
Emit Approval(msg.sender,spender,REF_64)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2389.sol-ERC20Like-delegateTransferAndCall(uint256,uint256,uint256,address,uint256,bytes,FsTKToken.DelegateMode,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->41;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(this))

IRs:
TMP_99 = CONVERT this to address
TMP_100(bool) = to != TMP_99
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
mode == DelegateMode.PublicMsgSender

IRs:
REF_88(FsTKToken.DelegateMode) -> DelegateMode.PublicMsgSender
TMP_102(bool) = mode == REF_88
CONDITION TMP_102"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
signer = ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(abi.encodePacked(this,nonce,fee,gasAmount,to,value,data,mode,address(0))),v,r,s)

IRs:
TMP_103 = CONVERT 0 to address
TMP_104(bytes) = SOLIDITY_CALL abi.encodePacked()(this,nonce,fee,gasAmount,to,value,data,mode,TMP_103)
TMP_105(bytes32) = SOLIDITY_CALL keccak256()(TMP_104)
TMP_106(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_105,v,r,s)
signer(address) := TMP_106(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
relayer = msg.sender

IRs:
relayer(address) := msg.sender(address)"];
6->20;
7[label="Node Type: IF 7

EXPRESSION:
mode == DelegateMode.PublicTxOrigin

IRs:
REF_90(FsTKToken.DelegateMode) -> DelegateMode.PublicTxOrigin
TMP_107(bool) = mode == REF_90
CONDITION TMP_107"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
signer = ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(abi.encodePacked(this,nonce,fee,gasAmount,to,value,data,mode,address(0))),v,r,s)

IRs:
TMP_108 = CONVERT 0 to address
TMP_109(bytes) = SOLIDITY_CALL abi.encodePacked()(this,nonce,fee,gasAmount,to,value,data,mode,TMP_108)
TMP_110(bytes32) = SOLIDITY_CALL keccak256()(TMP_109)
TMP_111(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_110,v,r,s)
signer(address) := TMP_111(address)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
relayer = tx.origin

IRs:
relayer(address) := tx.origin(address)"];
9->19;
10[label="Node Type: IF 10

EXPRESSION:
mode == DelegateMode.PrivateMsgSender

IRs:
REF_92(FsTKToken.DelegateMode) -> DelegateMode.PrivateMsgSender
TMP_112(bool) = mode == REF_92
CONDITION TMP_112"];
10->11[label="True"];
10->13[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
signer = ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(abi.encodePacked(this,nonce,fee,gasAmount,to,value,data,mode,msg.sender)),v,r,s)

IRs:
TMP_113(bytes) = SOLIDITY_CALL abi.encodePacked()(this,nonce,fee,gasAmount,to,value,data,mode,msg.sender)
TMP_114(bytes32) = SOLIDITY_CALL keccak256()(TMP_113)
TMP_115(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_114,v,r,s)
signer(address) := TMP_115(address)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
relayer = msg.sender

IRs:
relayer(address) := msg.sender(address)"];
12->18;
13[label="Node Type: IF 13

EXPRESSION:
mode == DelegateMode.PrivateTxOrigin

IRs:
REF_94(FsTKToken.DelegateMode) -> DelegateMode.PrivateTxOrigin
TMP_116(bool) = mode == REF_94
CONDITION TMP_116"];
13->14[label="True"];
13->16[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
signer = ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(abi.encodePacked(this,nonce,fee,gasAmount,to,value,data,mode,tx.origin)),v,r,s)

IRs:
TMP_117(bytes) = SOLIDITY_CALL abi.encodePacked()(this,nonce,fee,gasAmount,to,value,data,mode,tx.origin)
TMP_118(bytes32) = SOLIDITY_CALL keccak256()(TMP_117)
TMP_119(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_118,v,r,s)
signer(address) := TMP_119(address)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
relayer = tx.origin

IRs:
relayer(address) := tx.origin(address)"];
15->17;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
revert()()

IRs:
TMP_120(None) = SOLIDITY_CALL revert()()"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
signerAccount = accounts[signer]

IRs:
REF_96(FsTKToken.Account) -> accounts[signer]
signerAccount(FsTKToken.Account) := REF_96(FsTKToken.Account)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
require(bool)(nonce == signerAccount.nonce)

IRs:
REF_97(uint256) -> signerAccount.nonce
TMP_121(bool) = nonce == REF_97
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
IncreaseNonce(signer,signerAccount.nonce += 1)

IRs:
REF_98(uint256) -> signerAccount.nonce
REF_98(-> signerAccount) = REF_98 + 1
Emit IncreaseNonce(signer,REF_98)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
signerAccount.balance = signerAccount.balance.sub(value.add(fee))

IRs:
REF_99(uint256) -> signerAccount.balance
REF_100(uint256) -> signerAccount.balance
TMP_124(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['value', 'fee'] 
TMP_125(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_100', 'TMP_124'] 
REF_99(uint256) (->signerAccount) := TMP_125(uint256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
accounts[to].balance += value

IRs:
REF_103(FsTKToken.Account) -> accounts[to]
REF_104(uint256) -> REF_103.balance
REF_104(-> accounts) = REF_104 + value"];
25->26;
26[label="Node Type: IF 26

EXPRESSION:
fee != 0

IRs:
TMP_126(bool) = fee != 0
CONDITION TMP_126"];
26->27[label="True"];
26->29[label="False"];
27[label="Node Type: EXPRESSION 27

EXPRESSION:
accounts[relayer].balance += fee

IRs:
REF_105(FsTKToken.Account) -> accounts[relayer]
REF_106(uint256) -> REF_105.balance
REF_106(-> accounts) = REF_106 + fee"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
Transfer(signer,relayer,fee)

IRs:
Emit Transfer(signer,relayer,fee)"];
28->29;
29[label="Node Type: END_IF 29
"];
29->30;
30[label="Node Type: IF 30

EXPRESSION:
! to.isAccount() && data.length >= 68

IRs:
TMP_128(bool) = LIBRARY_CALL, dest:AddressExtension, function:AddressExtension.isAccount(address), arguments:['to'] 
TMP_129 = UnaryType.BANG TMP_128 
REF_108 -> LENGTH data
TMP_130(bool) = REF_108 >= 68
TMP_131(bool) = TMP_129 && TMP_130
CONDITION TMP_131"];
30->31[label="True"];
30->38[label="False"];
31[label="Node Type: INLINE ASM 31
"];
31->32;
32[label="Node Type: END INLINE ASM 32
"];
32->33;
33[label="Node Type: IF 33

EXPRESSION:
to.call.gas(gasAmount)(data)

IRs:
TMP_133(bool) = LOW_LEVEL_CALL, dest:to, function:call, arguments:['data']  gas:gasAmount
CONDITION TMP_133"];
33->34[label="True"];
33->35[label="False"];
34[label="Node Type: EXPRESSION 34

EXPRESSION:
Transfer(signer,to,value)

IRs:
Emit Transfer(signer,to,value)"];
34->37;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
signerAccount.balance += value

IRs:
REF_111(uint256) -> signerAccount.balance
REF_111(-> signerAccount) = REF_111 + value"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
accounts[to].balance -= value

IRs:
REF_112(FsTKToken.Account) -> accounts[to]
REF_113(uint256) -> REF_112.balance
REF_113(-> accounts) = REF_113 - value"];
36->37;
37[label="Node Type: END_IF 37
"];
37->39;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
Transfer(signer,to,value)

IRs:
Emit Transfer(signer,to,value)"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: RETURN 40

EXPRESSION:
true

IRs:
RETURN True"];
41[label="Node Type: EXPRESSION 41

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
canDelegate()

IRs:
MODIFIER_CALL, ERC20Like.canDelegate()()"];
42->1;
}
// Function: 2389.sol-ERC20Like-directDebit(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[debtor].instruments[receiver].directDebit

IRs:
REF_114(FsTKToken.Account) -> accounts[debtor]
REF_115(mapping(address => FsTKToken.Instrument)) -> REF_114.instruments
REF_116(FsTKToken.Instrument) -> REF_115[receiver]
REF_117(FsTKToken.DirectDebit) -> REF_116.directDebit
RETURN REF_117"];
}
// Function: 2389.sol-ERC20Like-increaseAllowance(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_53(FsTKToken.Account) -> accounts[msg.sender]
REF_54(mapping(address => FsTKToken.Instrument)) -> REF_53.instruments
REF_55(FsTKToken.Instrument) -> REF_54[spender]
spenderInstrument(FsTKToken.Instrument) := REF_55(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = spenderInstrument.allowance.add(value))

IRs:
REF_56(uint256) -> spenderInstrument.allowance
REF_57(uint256) -> spenderInstrument.allowance
TMP_67(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['REF_57', 'value'] 
REF_56(uint256) (->spenderInstrument) := TMP_67(uint256)
Emit Approval(msg.sender,spender,REF_56)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2389.sol-ERC20Like-increaseNonce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
IncreaseNonce(msg.sender,accounts[msg.sender].nonce += 1)

IRs:
REF_86(FsTKToken.Account) -> accounts[msg.sender]
REF_87(uint256) -> REF_86.nonce
REF_87(-> accounts) = REF_87 + 1
Emit IncreaseNonce(msg.sender,REF_87)"];
}
// Function: 2389.sol-ERC20Like-liquid()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLiquid)

IRs:
TMP_168(None) = SOLIDITY_CALL require(bool)(isLiquid)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-ERC20Like-nonceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[owner].nonce

IRs:
REF_84(FsTKToken.Account) -> accounts[owner]
REF_85(uint256) -> REF_84.nonce
RETURN REF_85"];
}
// Function: 2389.sol-ERC20Like-setDelegate(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetDelegate(isDelegateEnable = delegate)

IRs:
isDelegateEnable(bool) := delegate(bool)
Emit SetDelegate(isDelegateEnable)"];
}
// Function: 2389.sol-ERC20Like-setDirectDebit(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetDirectDebit(isDirectDebitEnable = directDebit)

IRs:
isDirectDebitEnable(bool) := directDebit(bool)
Emit SetDirectDebit(isDirectDebitEnable)"];
}
// Function: 2389.sol-ERC20Like-setERC20ApproveChecking(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetERC20ApproveChecking(erc20ApproveChecking = approveChecking)

IRs:
erc20ApproveChecking(bool) := approveChecking(bool)
Emit SetERC20ApproveChecking(erc20ApproveChecking)"];
}
// Function: 2389.sol-ERC20Like-setLiquid0(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetLiquid(isLiquid = liquidity)

IRs:
isLiquid(bool) := liquidity(bool)
Emit SetLiquid(isLiquid)"];
}
// Function: 2389.sol-ERC20Like-setMetadata0(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetMetadata(metadata = _metadata)

IRs:
metadata(string) := _metadata(string)
Emit SetMetadata(metadata)"];
}
// Function: 2389.sol-ERC20Like-setupDirectDebit(address,FsTKToken.DirectDebitInfo)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({info:info,epoch:0})

IRs:
REF_118(FsTKToken.Account) -> accounts[msg.sender]
REF_119(mapping(address => FsTKToken.Instrument)) -> REF_118.instruments
REF_120(FsTKToken.Instrument) -> REF_119[receiver]
REF_121(FsTKToken.DirectDebit) -> REF_120.directDebit
TMP_138(FsTKToken.DirectDebit) = new DirectDebit(info,0)
REF_121(FsTKToken.DirectDebit) (->accounts) := TMP_138(FsTKToken.DirectDebit)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetupDirectDebit(msg.sender,receiver,info)

IRs:
Emit SetupDirectDebit(msg.sender,receiver,info)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2389.sol-ERC20Like-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isLiquid = true

IRs:
isLiquid(bool) := True(bool)"];
}
// Function: 2389.sol-ERC20Like-spendableAllowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
ownerAccount = accounts[owner]

IRs:
REF_65(FsTKToken.Account) -> accounts[owner]
ownerAccount(FsTKToken.Account) := REF_65(FsTKToken.Account)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
Math.min(ownerAccount.instruments[spender].allowance,ownerAccount.balance)

IRs:
REF_67(mapping(address => FsTKToken.Instrument)) -> ownerAccount.instruments
REF_68(FsTKToken.Instrument) -> REF_67[spender]
REF_69(uint256) -> REF_68.allowance
REF_70(uint256) -> ownerAccount.balance
TMP_77(uint256) = LIBRARY_CALL, dest:Math, function:Math.min(uint256,uint256), arguments:['REF_69', 'REF_70'] 
RETURN TMP_77"];
}
// Function: 2389.sol-ERC20Like-terminateDirectDebit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
delete accounts[msg.sender].instruments[receiver].directDebit

IRs:
REF_122(FsTKToken.Account) -> accounts[msg.sender]
REF_123(mapping(address => FsTKToken.Instrument)) -> REF_122.instruments
REF_124(FsTKToken.Instrument) -> REF_123[receiver]
REF_125(FsTKToken.DirectDebit) -> REF_124.directDebit
REF_124 = delete REF_125 "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
TerminateDirectDebit(msg.sender,receiver)

IRs:
Emit TerminateDirectDebit(msg.sender,receiver)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2389.sol-ERC20Like-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
senderAccount = accounts[msg.sender]

IRs:
REF_26(FsTKToken.Account) -> accounts[msg.sender]
senderAccount(FsTKToken.Account) := REF_26(FsTKToken.Account)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
senderAccount.balance = senderAccount.balance.sub(value)

IRs:
REF_27(uint256) -> senderAccount.balance
REF_28(uint256) -> senderAccount.balance
TMP_51(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_28', 'value'] 
REF_27(uint256) (->senderAccount) := TMP_51(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
accounts[to].balance += value

IRs:
REF_30(FsTKToken.Account) -> accounts[to]
REF_31(uint256) -> REF_30.balance
REF_31(-> accounts) = REF_31 + value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
6->1;
}
// Function: 2389.sol-ERC20Like-transfer(uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->15;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
senderAccount = accounts[msg.sender]

IRs:
REF_71(FsTKToken.Account) -> accounts[msg.sender]
senderAccount(FsTKToken.Account) := REF_71(FsTKToken.Account)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->13;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < data.length

IRs:
REF_72 -> LENGTH data
TMP_78(bool) = i < REF_72
CONDITION TMP_78"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
receiver = address(data[i] >> 96)

IRs:
REF_73(uint256) -> data[i]
TMP_79(uint256) = REF_73 >> 96
TMP_80 = CONVERT TMP_79 to address
receiver(address) := TMP_80(address)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
value = data[i] & 0xffffffffffffffffffffffff

IRs:
REF_74(uint256) -> data[i]
TMP_81(uint256) = REF_74 & 79228162514264337593543950335
value(uint256) := TMP_81(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalValue = totalValue.add(value)

IRs:
TMP_82(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['totalValue', 'value'] 
totalValue(uint256) := TMP_82(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
accounts[receiver].balance += value

IRs:
REF_76(FsTKToken.Account) -> accounts[receiver]
REF_77(uint256) -> REF_76.balance
REF_77(-> accounts) = REF_77 + value"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Transfer(msg.sender,receiver,value)

IRs:
Emit Transfer(msg.sender,receiver,value)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_84(uint256) := i(uint256)
i(uint256) = i + 1"];
12->6;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
senderAccount.balance = senderAccount.balance.sub(totalValue)

IRs:
REF_78(uint256) -> senderAccount.balance
REF_79(uint256) -> senderAccount.balance
TMP_85(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_79', 'totalValue'] 
REF_78(uint256) (->senderAccount) := TMP_85(uint256)"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
true

IRs:
RETURN True"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
15->1;
}
// Function: 2389.sol-ERC20Like-transferAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(this) && data.length >= 68 && transfer(to,value))

IRs:
TMP_87 = CONVERT this to address
TMP_88(bool) = to != TMP_87
REF_81 -> LENGTH data
TMP_89(bool) = REF_81 >= 68
TMP_90(bool) = TMP_88 && TMP_89
TMP_91(bool) = INTERNAL_CALL, ERC20Like.transfer(address,uint256)(to,value)
TMP_92(bool) = TMP_90 && TMP_91
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(to.call.value(msg.value)(data))

IRs:
TMP_95(bool) = LOW_LEVEL_CALL, dest:to, function:call, arguments:['data'] value:msg.value 
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
6->1;
}
// Function: 2389.sol-ERC20Like-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fromAccount = accounts[from]

IRs:
REF_32(FsTKToken.Account) -> accounts[from]
fromAccount(FsTKToken.Account) := REF_32(FsTKToken.Account)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
senderInstrument = fromAccount.instruments[msg.sender]

IRs:
REF_33(mapping(address => FsTKToken.Instrument)) -> fromAccount.instruments
REF_34(FsTKToken.Instrument) -> REF_33[msg.sender]
senderInstrument(FsTKToken.Instrument) := REF_34(FsTKToken.Instrument)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fromAccount.balance = fromAccount.balance.sub(value)

IRs:
REF_35(uint256) -> fromAccount.balance
REF_36(uint256) -> fromAccount.balance
TMP_54(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_36', 'value'] 
REF_35(uint256) (->fromAccount) := TMP_54(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
senderInstrument.allowance = senderInstrument.allowance.sub(value)

IRs:
REF_38(uint256) -> senderInstrument.allowance
REF_39(uint256) -> senderInstrument.allowance
TMP_55(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_39', 'value'] 
REF_38(uint256) (->senderInstrument) := TMP_55(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
accounts[to].balance += value

IRs:
REF_41(FsTKToken.Account) -> accounts[to]
REF_42(uint256) -> REF_41.balance
REF_42(-> accounts) = REF_42 + value"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
8->1;
}
// Function: 2389.sol-ERC20Like-withdrawDirectDebit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
debtorAccount = accounts[debtor]

IRs:
REF_126(FsTKToken.Account) -> accounts[debtor]
debtorAccount(FsTKToken.Account) := REF_126(FsTKToken.Account)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
debit = debtorAccount.instruments[msg.sender].directDebit

IRs:
REF_127(mapping(address => FsTKToken.Instrument)) -> debtorAccount.instruments
REF_128(FsTKToken.Instrument) -> REF_127[msg.sender]
REF_129(FsTKToken.DirectDebit) -> REF_128.directDebit
debit(FsTKToken.DirectDebit) := REF_129(FsTKToken.DirectDebit)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1)

IRs:
REF_131(FsTKToken.DirectDebitInfo) -> debit.info
REF_132(uint256) -> REF_131.startTime
TMP_141(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['block.timestamp', 'REF_132'] 
REF_133(FsTKToken.DirectDebitInfo) -> debit.info
REF_134(uint256) -> REF_133.interval
TMP_142(uint256) = TMP_141 / REF_134
TMP_143(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_142', '1'] 
epoch(uint256) := TMP_143(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
amount = epoch.sub(debit.epoch).mul(debit.info.amount)

IRs:
REF_137(uint256) -> debit.epoch
TMP_144(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['epoch', 'REF_137'] 
REF_139(FsTKToken.DirectDebitInfo) -> debit.info
REF_140(uint256) -> REF_139.amount
TMP_145(uint256) = LIBRARY_CALL, dest:Math, function:Math.mul(uint256,uint256), arguments:['TMP_144', 'REF_140'] 
amount(uint256) := TMP_145(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_146(bool) = amount > 0
TMP_147(None) = SOLIDITY_CALL require(bool)(TMP_146)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
debtorAccount.balance = debtorAccount.balance.sub(amount)

IRs:
REF_141(uint256) -> debtorAccount.balance
REF_142(uint256) -> debtorAccount.balance
TMP_148(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_142', 'amount'] 
REF_141(uint256) (->debtorAccount) := TMP_148(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
accounts[msg.sender].balance += amount

IRs:
REF_144(FsTKToken.Account) -> accounts[msg.sender]
REF_145(uint256) -> REF_144.balance
REF_145(-> accounts) = REF_145 + amount"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
debit.epoch = epoch

IRs:
REF_146(uint256) -> debit.epoch
REF_146(uint256) (->debit) := epoch(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(debtor,msg.sender,amount)

IRs:
Emit Transfer(debtor,msg.sender,amount)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
canUseDirectDebit()

IRs:
MODIFIER_CALL, ERC20Like.canUseDirectDebit()()"];
12->1;
}
// Function: 2389.sol-ERC20Like-withdrawDirectDebit(address[],bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->28;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
receiverAccount = accounts[msg.sender]

IRs:
REF_147(FsTKToken.Account) -> accounts[msg.sender]
receiverAccount(FsTKToken.Account) := REF_147(FsTKToken.Account)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
result = true

IRs:
result(bool) := True(bool)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->27;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < debtors.length

IRs:
REF_148 -> LENGTH debtors
TMP_152(bool) = i < REF_148
CONDITION TMP_152"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
debtor = debtors[i]

IRs:
REF_149(address) -> debtors[i]
debtor(address) := REF_149(address)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
debtorAccount = accounts[debtor]

IRs:
REF_150(FsTKToken.Account) -> accounts[debtor]
debtorAccount(FsTKToken.Account) := REF_150(FsTKToken.Account)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
debit = debtorAccount.instruments[msg.sender].directDebit

IRs:
REF_151(mapping(address => FsTKToken.Instrument)) -> debtorAccount.instruments
REF_152(FsTKToken.Instrument) -> REF_151[msg.sender]
REF_153(FsTKToken.DirectDebit) -> REF_152.directDebit
debit(FsTKToken.DirectDebit) := REF_153(FsTKToken.DirectDebit)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1)

IRs:
REF_155(FsTKToken.DirectDebitInfo) -> debit.info
REF_156(uint256) -> REF_155.startTime
TMP_153(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['block.timestamp', 'REF_156'] 
REF_157(FsTKToken.DirectDebitInfo) -> debit.info
REF_158(uint256) -> REF_157.interval
TMP_154(uint256) = TMP_153 / REF_158
TMP_155(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_154', '1'] 
epoch(uint256) := TMP_155(uint256)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
amount = epoch.sub(debit.epoch).mul(debit.info.amount)

IRs:
REF_161(uint256) -> debit.epoch
TMP_156(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['epoch', 'REF_161'] 
REF_163(FsTKToken.DirectDebitInfo) -> debit.info
REF_164(uint256) -> REF_163.amount
TMP_157(uint256) = LIBRARY_CALL, dest:Math, function:Math.mul(uint256,uint256), arguments:['TMP_156', 'REF_164'] 
amount(uint256) := TMP_157(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_158(bool) = amount > 0
TMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
debtorBalance = debtorAccount.balance

IRs:
REF_165(uint256) -> debtorAccount.balance
debtorBalance(uint256) := REF_165(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
amount > debtorBalance

IRs:
TMP_160(bool) = amount > debtorBalance
CONDITION TMP_160"];
15->16[label="True"];
15->21[label="False"];
16[label="Node Type: IF 16

EXPRESSION:
strict

IRs:
CONDITION strict"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
revert()()

IRs:
TMP_161(None) = SOLIDITY_CALL revert()()"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
result = false

IRs:
result(bool) := False(bool)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
WithdrawDirectDebitFailure(debtor,msg.sender)

IRs:
Emit WithdrawDirectDebitFailure(debtor,msg.sender)"];
20->25;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
debtorAccount.balance = debtorBalance - amount

IRs:
REF_166(uint256) -> debtorAccount.balance
TMP_163(uint256) = debtorBalance - amount
REF_166(uint256) (->debtorAccount) := TMP_163(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
total += amount

IRs:
total(uint256) = total + amount"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
debit.epoch = epoch

IRs:
REF_167(uint256) -> debit.epoch
REF_167(uint256) (->debit) := epoch(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
Transfer(debtor,msg.sender,amount)

IRs:
Emit Transfer(debtor,msg.sender,amount)"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
i ++

IRs:
TMP_165(uint256) := i(uint256)
i(uint256) = i + 1"];
26->7;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
receiverAccount.balance += total

IRs:
REF_168(uint256) -> receiverAccount.balance
REF_168(-> receiverAccount) = REF_168 + total"];
27->30;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
canUseDirectDebit()

IRs:
MODIFIER_CALL, ERC20Like.canUseDirectDebit()()"];
29->1;
30[label="Node Type: RETURN 30

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 2389.sol-FsTKAllocation-initialize(uint256)
digraph{
}
// Function: 2389.sol-FsTKAuthority-isApproved(bytes32,uint256,bytes)
digraph{
}
// Function: 2389.sol-FsTKAuthority-isAuthorized(address,address,bytes)
digraph{
}
// Function: 2389.sol-FsTKAuthority-validate()
digraph{
}
// Function: 2389.sol-FsTKToken-delegateTransferAndCall(uint256,uint256,uint256,address,uint256,bytes,FsTKToken.DelegateMode,uint8,bytes32,bytes32)
digraph{
}
// Function: 2389.sol-FsTKToken-directDebit(address,address)
digraph{
}
// Function: 2389.sol-FsTKToken-increaseNonce()
digraph{
}
// Function: 2389.sol-FsTKToken-nonceOf(address)
digraph{
}
// Function: 2389.sol-FsTKToken-setupDirectDebit(address,FsTKToken.DirectDebitInfo)
digraph{
}
// Function: 2389.sol-FsTKToken-spendableAllowance(address,address)
digraph{
}
// Function: 2389.sol-FsTKToken-terminateDirectDebit(address)
digraph{
}
// Function: 2389.sol-FsTKToken-transfer(uint256[])
digraph{
}
// Function: 2389.sol-FsTKToken-transferAndCall(address,uint256,bytes)
digraph{
}
// Function: 2389.sol-FsTKToken-withdrawDirectDebit(address)
digraph{
}
// Function: 2389.sol-FsTKToken-withdrawDirectDebit(address[],bool)
digraph{
}
// Function: 2389.sol-FunderSmartToken-allowance(address,address)
digraph{
}
// Function: 2389.sol-FunderSmartToken-approve(address,uint256)
digraph{
}
// Function: 2389.sol-FunderSmartToken-approve(address,uint256,uint256)
digraph{
}
// Function: 2389.sol-FunderSmartToken-balanceOf(address)
digraph{
}
// Function: 2389.sol-FunderSmartToken-canDelegate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDelegateEnable)

IRs:
TMP_316(None) = SOLIDITY_CALL require(bool)(isDelegateEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-FunderSmartToken-canUseDirectDebit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDirectDebitEnable)

IRs:
TMP_315(None) = SOLIDITY_CALL require(bool)(isDirectDebitEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-FunderSmartToken-constructor(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
fstkAuthority = _fstkAuthority

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)"];
}
// Function: 2389.sol-FunderSmartToken-constructor(FsTKAuthority,string,address,FsTKAllocation)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
vestedAmount = totalSupply / 12

IRs:
TMP_293(uint256) = totalSupply / 12
vestedAmount(uint256) := TMP_293(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[allocation].balance = vestedAmount

IRs:
REF_321(FsTKToken.Account) -> accounts[allocation]
REF_322(uint256) -> REF_321.balance
REF_322(uint256) (->accounts) := vestedAmount(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0),allocation,vestedAmount)

IRs:
TMP_294 = CONVERT 0 to address
Emit Transfer(TMP_294,allocation,vestedAmount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allocation.initialize(vestedAmount)

IRs:
HIGH_LEVEL_CALL, dest:allocation(FsTKAllocation), function:initialize, arguments:['vestedAmount']  "];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
releaseAmount = totalSupply - vestedAmount

IRs:
TMP_297(uint256) = totalSupply - vestedAmount
releaseAmount(uint256) := TMP_297(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
accounts[coldWallet].balance = releaseAmount

IRs:
REF_324(FsTKToken.Account) -> accounts[coldWallet]
REF_325(uint256) -> REF_324.balance
REF_325(uint256) (->accounts) := releaseAmount(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(address(0),coldWallet,releaseAmount)

IRs:
TMP_298 = CONVERT 0 to address
Emit Transfer(TMP_298,coldWallet,releaseAmount)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Authorizable(_fstkAuthority)

IRs:
INTERNAL_CALL, Authorizable.constructor(FsTKAuthority)(_fstkAuthority)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
ERC20Like(_metadata)

IRs:
INTERNAL_CALL, ERC20Like.constructor(string)(_metadata)"];
9->1;
}
// Function: 2389.sol-FunderSmartToken-constructor(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
metadata = _metadata

IRs:
metadata(string) := _metadata(string)"];
}
// Function: 2389.sol-FunderSmartToken-decreaseAllowance(address,uint256,bool)
digraph{
}
// Function: 2389.sol-FunderSmartToken-delegateTransferAndCall(uint256,uint256,uint256,address,uint256,bytes,FsTKToken.DelegateMode,uint8,bytes32,bytes32)
digraph{
}
// Function: 2389.sol-FunderSmartToken-directDebit(address,address)
digraph{
}
// Function: 2389.sol-FunderSmartToken-increaseAllowance(address,uint256)
digraph{
}
// Function: 2389.sol-FunderSmartToken-increaseNonce()
digraph{
}
// Function: 2389.sol-FunderSmartToken-liquid()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLiquid)

IRs:
TMP_314(None) = SOLIDITY_CALL require(bool)(isLiquid)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-FunderSmartToken-nonceOf(address)
digraph{
}
// Function: 2389.sol-FunderSmartToken-onlyFsTKApproved(bytes32,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isApproved(hash,approveTime,approveToken))

IRs:
TMP_319(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isApproved, arguments:['hash', 'approveTime', 'approveToken']  
TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-FunderSmartToken-onlyFsTKAuthorized()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isAuthorized(msg.sender,this,msg.data))

IRs:
TMP_317(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isAuthorized, arguments:['msg.sender', 'this', 'msg.data']  
TMP_318(None) = SOLIDITY_CALL require(bool)(TMP_317)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2389.sol-FunderSmartToken-setDelegate(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.setDelegate(delegate)

IRs:
INTERNAL_CALL, ERC20Like.setDelegate(bool)(delegate)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
2->1;
}
// Function: 2389.sol-FunderSmartToken-setDirectDebit(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.setDirectDebit(directDebit)

IRs:
INTERNAL_CALL, ERC20Like.setDirectDebit(bool)(directDebit)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
2->1;
}
// Function: 2389.sol-FunderSmartToken-setERC20ApproveChecking(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.setERC20ApproveChecking(approveChecking)

IRs:
INTERNAL_CALL, ERC20Like.setERC20ApproveChecking(bool)(approveChecking)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
2->1;
}
// Function: 2389.sol-FunderSmartToken-setFsTKAuthority(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_fstkAuthority.validate() == _fstkAuthority.validate.selector)

IRs:
TMP_288(bytes4) = HIGH_LEVEL_CALL, dest:_fstkAuthority(FsTKAuthority), function:validate, arguments:[]  
REF_320(bytes4) (->None) := 1761736296(uint256)
TMP_289(bool) = TMP_288 == REF_320
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetFsTKAuthority(fstkAuthority = _fstkAuthority)

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)
Emit SetFsTKAuthority(fstkAuthority)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
3->1;
}
// Function: 2389.sol-FunderSmartToken-setLiquid(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
setLiquid0(liquidity)

IRs:
INTERNAL_CALL, ERC20Like.setLiquid0(bool)(liquidity)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
2->1;
}
// Function: 2389.sol-FunderSmartToken-setLiquid0(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetLiquid(isLiquid = liquidity)

IRs:
isLiquid(bool) := liquidity(bool)
Emit SetLiquid(isLiquid)"];
}
// Function: 2389.sol-FunderSmartToken-setMetadata(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
setMetadata0(infoUrl)

IRs:
INTERNAL_CALL, ERC20Like.setMetadata0(string)(infoUrl)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
2->1;
}
// Function: 2389.sol-FunderSmartToken-setMetadata0(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetMetadata(metadata = _metadata)

IRs:
metadata(string) := _metadata(string)
Emit SetMetadata(metadata)"];
}
// Function: 2389.sol-FunderSmartToken-setupDirectDebit(address,FsTKToken.DirectDebitInfo)
digraph{
}
// Function: 2389.sol-FunderSmartToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Funder Smart Token

IRs:
name(string) := Funder Smart Token(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = FST

IRs:
symbol(string) := FST(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
totalSupply = 330000000000000000000000000

IRs:
totalSupply(uint256) := 330000000000000000000000000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
}
// Function: 2389.sol-FunderSmartToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isLiquid = true

IRs:
isLiquid(bool) := True(bool)"];
}
// Function: 2389.sol-FunderSmartToken-spendableAllowance(address,address)
digraph{
}
// Function: 2389.sol-FunderSmartToken-terminateDirectDebit(address)
digraph{
}
// Function: 2389.sol-FunderSmartToken-transfer(address,uint256)
digraph{
}
// Function: 2389.sol-FunderSmartToken-transfer(uint256[])
digraph{
}
// Function: 2389.sol-FunderSmartToken-transferAndCall(address,uint256,bytes)
digraph{
}
// Function: 2389.sol-FunderSmartToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 2389.sol-FunderSmartToken-transferToken(ERC20,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
erc20.transfer(to,value)

IRs:
TMP_312(bool) = HIGH_LEVEL_CALL, dest:erc20(ERC20), function:transfer, arguments:['to', 'value']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
2->1;
}
// Function: 2389.sol-FunderSmartToken-withdrawDirectDebit(address)
digraph{
}
// Function: 2389.sol-FunderSmartToken-withdrawDirectDebit(address[],bool)
digraph{
}
// Function: 2389.sol-Math-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((r = a + b) >= a)

IRs:
TMP_14(uint256) = a + b
r(uint256) := TMP_14(uint256)
TMP_15(bool) = r >= a
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-Math-div(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDiv(x,f.denominator,f.numerator)

IRs:
REF_6(uint256) -> f.denominator
REF_7(uint256) -> f.numerator
TMP_37(uint256) = INTERNAL_CALL, Math.mulDiv(uint256,uint256,uint256)(x,REF_6,REF_7)
RETURN TMP_37"];
}
// Function: 2389.sol-Math-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = a / b

IRs:
TMP_10(uint256) = a / b
r(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-Math-divCeil(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDivCeil(x,f.denominator,f.numerator)

IRs:
REF_8(uint256) -> f.denominator
REF_9(uint256) -> f.numerator
TMP_38(uint256) = INTERNAL_CALL, Math.mulDivCeil(uint256,uint256,uint256)(x,REF_8,REF_9)
RETURN TMP_38"];
}
// Function: 2389.sol-Math-isPositive(Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
fraction.numerator > 0 && fraction.denominator > 0

IRs:
REF_0(uint256) -> fraction.numerator
TMP_1(bool) = REF_0 > 0
REF_1(uint256) -> fraction.denominator
TMP_2(bool) = REF_1 > 0
TMP_3(bool) = TMP_1 && TMP_2
RETURN TMP_3"];
}
// Function: 2389.sol-Math-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_18(bool) = x >= y
CONDITION TMP_18"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-Math-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_17(bool) = x <= y
CONDITION TMP_17"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-Math-mul(Math.Fraction,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
Math.Fraction({numerator:mul(x.numerator,y.numerator),denominator:mul(x.denominator,y.denominator)})

IRs:
REF_11(uint256) -> x.numerator
REF_12(uint256) -> y.numerator
TMP_39(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(REF_11,REF_12)
REF_13(uint256) -> x.denominator
REF_14(uint256) -> y.denominator
TMP_40(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(REF_13,REF_14)
TMP_41(Math.Fraction) = new Fraction(TMP_39,TMP_40)
RETURN TMP_41"];
}
// Function: 2389.sol-Math-mul(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDiv(x,f.numerator,f.denominator)

IRs:
REF_2(uint256) -> f.numerator
REF_3(uint256) -> f.denominator
TMP_35(uint256) = INTERNAL_CALL, Math.mulDiv(uint256,uint256,uint256)(x,REF_2,REF_3)
RETURN TMP_35"];
}
// Function: 2389.sol-Math-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = a * b

IRs:
TMP_4(uint256) = a * b
r(uint256) := TMP_4(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((a == 0) || (r / a == b))

IRs:
TMP_5(bool) = a == 0
TMP_6(uint256) = r / a
TMP_7(bool) = TMP_6 == b
TMP_8(bool) = TMP_5 || TMP_7
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-Math-mulCeil(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDivCeil(x,f.numerator,f.denominator)

IRs:
REF_4(uint256) -> f.numerator
REF_5(uint256) -> f.denominator
TMP_36(uint256) = INTERNAL_CALL, Math.mulDivCeil(uint256,uint256,uint256)(x,REF_4,REF_5)
RETURN TMP_36"];
}
// Function: 2389.sol-Math-mulDiv(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = value * m

IRs:
TMP_19(uint256) = value * m
r(uint256) := TMP_19(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
r / value == m

IRs:
TMP_20(uint256) = r / value
TMP_21(bool) = TMP_20 == m
CONDITION TMP_21"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
r /= d

IRs:
r(uint256) = r / d"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
r = mul(value / d,m)

IRs:
TMP_22(uint256) = value / d
TMP_23(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(TMP_22,m)
r(uint256) := TMP_23(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-Math-mulDivCeil(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = value * m

IRs:
TMP_24(uint256) = value * m
r(uint256) := TMP_24(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
r / value == m

IRs:
TMP_25(uint256) = r / value
TMP_26(bool) = TMP_25 == m
CONDITION TMP_26"];
2->3[label="True"];
2->7[label="False"];
3[label="Node Type: IF 3

EXPRESSION:
r % d == 0

IRs:
TMP_27(uint256) = r % d
TMP_28(bool) = TMP_27 == 0
CONDITION TMP_28"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
r /= d

IRs:
r(uint256) = r / d"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
r = (r / d) + 1

IRs:
TMP_29(uint256) = r / d
TMP_30(uint256) = TMP_29 + 1
r(uint256) := TMP_30(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->11;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
r = mul(value / d,m)

IRs:
TMP_31(uint256) = value / d
TMP_32(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(TMP_31,m)
r(uint256) := TMP_32(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
value % d != 0

IRs:
TMP_33(uint256) = value % d
TMP_34(bool) = TMP_33 != 0
CONDITION TMP_34"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
r += 1

IRs:
r(uint256) = r + 1"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-Math-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((r = a - b) <= a)

IRs:
TMP_11(uint256) = a - b
r(uint256) := TMP_11(uint256)
TMP_12(bool) = r <= a
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 2389.sol-SecureERC20-allowance(address,address)
digraph{
}
// Function: 2389.sol-SecureERC20-approve(address,uint256)
digraph{
}
// Function: 2389.sol-SecureERC20-approve(address,uint256,uint256)
digraph{
}
// Function: 2389.sol-SecureERC20-balanceOf(address)
digraph{
}
// Function: 2389.sol-SecureERC20-decreaseAllowance(address,uint256,bool)
digraph{
}
// Function: 2389.sol-SecureERC20-increaseAllowance(address,uint256)
digraph{
}
// Function: 2389.sol-SecureERC20-setERC20ApproveChecking(bool)
digraph{
}
// Function: 2389.sol-SecureERC20-transfer(address,uint256)
digraph{
}
// Function: 2389.sol-SecureERC20-transferFrom(address,address,uint256)
digraph{
}
}
