digraph G {
// Function: 2688.sol-F3d-BuyKeys(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
registerUserIfNeeded(ref)

IRs:
INTERNAL_CALL, F3d.registerUserIfNeeded(uint256)(ref)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
core(currentRound,playerIds[msg.sender],msg.value)

IRs:
REF_242(uint256) -> playerIds[msg.sender]
INTERNAL_CALL, F3d.core(uint256,uint256,uint256)(currentRound,REF_242,msg.value)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, F3d.whenNotPaused()()"];
3->1;
}
// Function: 2688.sol-F3d-Price(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a.mul(key).add(b)

IRs:
TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['a', 'key'] 
TMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_73', 'b'] 
RETURN TMP_74"];
}
// Function: 2688.sol-F3d-ReloadKeys(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
registerUserIfNeeded(ref)

IRs:
INTERNAL_CALL, F3d.registerUserIfNeeded(uint256)(ref)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
players[playerIds[msg.sender]].wallet = retrieveEarnings().sub(value)

IRs:
REF_243(uint256) -> playerIds[msg.sender]
REF_244(F3d.PlayerStatus) -> players[REF_243]
REF_245(uint256) -> REF_244.wallet
TMP_178(uint256) = INTERNAL_CALL, F3d.retrieveEarnings()()
TMP_179(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_178', 'value'] 
REF_245(uint256) (->players) := TMP_179(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
core(currentRound,playerIds[msg.sender],value)

IRs:
REF_247(uint256) -> playerIds[msg.sender]
INTERNAL_CALL, F3d.core(uint256,uint256,uint256)(currentRound,REF_247,value)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, F3d.whenNotPaused()()"];
4->1;
}
// Function: 2688.sol-F3d-calculateMasked(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
roundData = playerRoundData[_pID][_round]

IRs:
REF_42(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_43(F3d.PlayerRound) -> REF_42[_round]
roundData(F3d.PlayerRound) := REF_43(F3d.PlayerRound)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
rounds[_round].mask.mul(roundData.keys).sub(roundData.mask)

IRs:
REF_44(F3d.Round) -> rounds[_round]
REF_45(uint256) -> REF_44.mask
REF_47(uint256) -> roundData.keys
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_45', 'REF_47'] 
REF_49(uint256) -> roundData.mask
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_34', 'REF_49'] 
RETURN TMP_35"];
}
// Function: 2688.sol-F3d-constructor(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
a = _a

IRs:
a(uint256) := _a(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
b = _b

IRs:
b(uint256) := _b(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ta = _ta

IRs:
ta(uint256) := _ta(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tb = _tb

IRs:
tb(uint256) := _tb(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tc = _tc

IRs:
tc(uint256) := _tc(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
td = _td

IRs:
td(uint256) := _td(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
te = _te

IRs:
te(uint256) := _te(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
wa = _wa

IRs:
wa(uint256) := _wa(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
wb = _wb

IRs:
wb(uint256) := _wb(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
wc = _wc

IRs:
wc(uint256) := _wc(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
wd = _wd

IRs:
wd(uint256) := _wd(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
we = _we

IRs:
we(uint256) := _we(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(ta.add(tb).add(tc).add(td).add(te) == 1000)

IRs:
TMP_1(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['ta', 'tb'] 
TMP_2(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_1', 'tc'] 
TMP_3(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_2', 'td'] 
TMP_4(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_3', 'te'] 
TMP_5(bool) = TMP_4 == 1000
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(wa.add(wb).add(wc).add(wd).add(we) == 1000)

IRs:
TMP_7(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['wa', 'wb'] 
TMP_8(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_7', 'wc'] 
TMP_9(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_8', 'wd'] 
TMP_10(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_9', 'we'] 
TMP_11(bool) = TMP_10 == 1000
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
owner = _owner

IRs:
owner(address) := _owner(address)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
currentRound = 1

IRs:
currentRound(uint256) := 1(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
rounds[currentRound] = Round(0,0,0,owner,0,block.timestamp.add(_maxTimeRemain))

IRs:
REF_8(F3d.Round) -> rounds[currentRound]
TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['block.timestamp', '_maxTimeRemain'] 
TMP_14(F3d.Round) = new Round(0,0,0,owner,0,TMP_13)
REF_8(F3d.Round) (->rounds) := TMP_14(F3d.Round)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
maxTimeRemain = _maxTimeRemain

IRs:
maxTimeRemain(uint256) := _maxTimeRemain(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
timeGap = _gap

IRs:
timeGap(uint256) := _gap(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
admin = msg.sender

IRs:
admin(address) := msg.sender(address)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
players.push(PlayerStatus(owner,0,0,0,0,0))

IRs:
TMP_15(F3d.PlayerStatus) = new PlayerStatus(owner,0,0,0,0,0)
REF_11 -> LENGTH players
TMP_17(uint256) := REF_11(uint256)
TMP_18(uint256) = TMP_17 + 1
REF_11(uint256) (->players) := TMP_18(uint256)
REF_12(F3d.PlayerStatus) -> players[TMP_17]
REF_12(F3d.PlayerStatus) (->players) := TMP_15(F3d.PlayerStatus)"];
}
// Function: 2688.sol-F3d-core(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
current = rounds[currentRound]

IRs:
REF_145(F3d.Round) -> rounds[currentRound]
current(F3d.Round) := REF_145(F3d.Round)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
playerRoundData[_pID][_round].keys == 0

IRs:
REF_146(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_147(F3d.PlayerRound) -> REF_146[_round]
REF_148(uint256) -> REF_147.keys
TMP_117(bool) = REF_148 == 0
CONDITION TMP_117"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
updatePlayer(_pID)

IRs:
INTERNAL_CALL, F3d.updatePlayer(uint256)(_pID)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
block.timestamp > current.endTime

IRs:
REF_149(uint256) -> current.endTime
TMP_119(bool) = block.timestamp > REF_149
CONDITION TMP_119"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
finalize(players[_pID].referer)

IRs:
REF_150(F3d.PlayerStatus) -> players[_pID]
REF_151(uint256) -> REF_150.referer
INTERNAL_CALL, F3d.finalize(uint256)(REF_151)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updatePlayer(_pID)

IRs:
INTERNAL_CALL, F3d.updatePlayer(uint256)(_pID)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
current_now = rounds[currentRound]

IRs:
REF_152(F3d.Round) -> rounds[currentRound]
current_now(F3d.Round) := REF_152(F3d.Round)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
_keys = keys(_eth)

IRs:
TMP_122(uint256) = INTERNAL_CALL, F3d.keys(uint256)(_eth)
_keys(uint256) := TMP_122(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
_keys <= 0

IRs:
TMP_123(bool) = _keys <= 0
CONDITION TMP_123"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
players[_pID].wallet = _eth.add(players[_pID].wallet)

IRs:
REF_153(F3d.PlayerStatus) -> players[_pID]
REF_154(uint256) -> REF_153.wallet
REF_156(F3d.PlayerStatus) -> players[_pID]
REF_157(uint256) -> REF_156.wallet
TMP_124(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_eth', 'REF_157'] 
REF_154(uint256) (->players) := TMP_124(uint256)"];
12->13;
13[label="Node Type: RETURN 13
"];
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
_keys >= decimals

IRs:
TMP_125(bool) = _keys >= decimals
CONDITION TMP_125"];
15->16[label="True"];
15->21[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
current_now.winner = players[_pID].addr

IRs:
REF_158(address) -> current_now.winner
REF_159(F3d.PlayerStatus) -> players[_pID]
REF_160(address) -> REF_159.addr
REF_158(address) (->current_now) := REF_160(address)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
current_now.endTime = current_now.endTime.add(timeGap)

IRs:
REF_161(uint256) -> current_now.endTime
REF_162(uint256) -> current_now.endTime
TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_162', 'timeGap'] 
REF_161(uint256) (->current_now) := TMP_126(uint256)"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
current_now.endTime.sub(block.timestamp) > maxTimeRemain

IRs:
REF_164(uint256) -> current_now.endTime
TMP_127(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_164', 'block.timestamp'] 
TMP_128(bool) = TMP_127 > maxTimeRemain
CONDITION TMP_128"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
current_now.endTime = block.timestamp.add(maxTimeRemain)

IRs:
REF_166(uint256) -> current_now.endTime
TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['block.timestamp', 'maxTimeRemain'] 
REF_166(uint256) (->current_now) := TMP_129(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
toOwner = _eth.sub(_eth.mul(ta) / 1000)

IRs:
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'ta'] 
TMP_131(uint256) = TMP_130 / 1000
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_eth', 'TMP_131'] 
toOwner(uint256) := TMP_132(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
toOwner = toOwner.sub(_eth.mul(tb) / 1000)

IRs:
TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'tb'] 
TMP_134(uint256) = TMP_133 / 1000
TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['toOwner', 'TMP_134'] 
toOwner(uint256) := TMP_135(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
toOwner = toOwner.sub(_eth.mul(tc) / 1000)

IRs:
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'tc'] 
TMP_137(uint256) = TMP_136 / 1000
TMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['toOwner', 'TMP_137'] 
toOwner(uint256) := TMP_138(uint256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
toOwner = toOwner.sub(_eth.mul(td) / 1000)

IRs:
TMP_139(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'td'] 
TMP_140(uint256) = TMP_139 / 1000
TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['toOwner', 'TMP_140'] 
toOwner(uint256) := TMP_141(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
current_now.pool = (_eth.mul(ta) / 1000).add(current_now.pool)

IRs:
REF_176(uint256) -> current_now.pool
TMP_142(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'ta'] 
TMP_143(uint256) = TMP_142 / 1000
REF_179(uint256) -> current_now.pool
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_143', 'REF_179'] 
REF_176(uint256) (->current_now) := TMP_144(uint256)"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
current_now.keys == 0

IRs:
REF_180(uint256) -> current_now.keys
TMP_145(bool) = REF_180 == 0
CONDITION TMP_145"];
27->28[label="True"];
27->30[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
toOwner = toOwner.add((_eth.mul(tb) / 1000))

IRs:
TMP_146(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'tb'] 
TMP_147(uint256) = TMP_146 / 1000
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['toOwner', 'TMP_147'] 
toOwner(uint256) := TMP_148(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
players[0].wallet = toOwner.add(players[0].wallet)

IRs:
REF_183(F3d.PlayerStatus) -> players[0]
REF_184(uint256) -> REF_183.wallet
REF_186(F3d.PlayerStatus) -> players[0]
REF_187(uint256) -> REF_186.wallet
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['toOwner', 'REF_187'] 
REF_184(uint256) (->players) := TMP_149(uint256)"];
29->33;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
current_now.mask = current_now.mask.add((_eth.mul(tb) / 1000) / current_now.keys)

IRs:
REF_188(uint256) -> current_now.mask
REF_189(uint256) -> current_now.mask
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'tb'] 
TMP_151(uint256) = TMP_150 / 1000
REF_192(uint256) -> current_now.keys
TMP_152(uint256) = TMP_151 / REF_192
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_189', 'TMP_152'] 
REF_188(uint256) (->current_now) := TMP_153(uint256)"];
30->31;
31[label="Node Type: NEW VARIABLE 31

EXPRESSION:
dust = (_eth.mul(tb) / 1000).sub(_eth.mul(tb) / 1000 / current_now.keys * current_now.keys)

IRs:
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'tb'] 
TMP_155(uint256) = TMP_154 / 1000
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'tb'] 
TMP_157(uint256) = TMP_156 / 1000
REF_196(uint256) -> current_now.keys
TMP_158(uint256) = TMP_157 / REF_196
REF_197(uint256) -> current_now.keys
TMP_159(uint256) = TMP_158 * REF_197
TMP_160(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_155', 'TMP_159'] 
dust(uint256) := TMP_160(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
players[0].wallet = toOwner.add(dust).add(players[0].wallet)

IRs:
REF_198(F3d.PlayerStatus) -> players[0]
REF_199(uint256) -> REF_198.wallet
TMP_161(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['toOwner', 'dust'] 
REF_202(F3d.PlayerStatus) -> players[0]
REF_203(uint256) -> REF_202.wallet
TMP_162(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_161', 'REF_203'] 
REF_199(uint256) (->players) := TMP_162(uint256)"];
32->33;
33[label="Node Type: END_IF 33
"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
playerRoundData[_pID][currentRound].keys = _keys.add(playerRoundData[_pID][currentRound].keys)

IRs:
REF_204(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_205(F3d.PlayerRound) -> REF_204[currentRound]
REF_206(uint256) -> REF_205.keys
REF_208(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_209(F3d.PlayerRound) -> REF_208[currentRound]
REF_210(uint256) -> REF_209.keys
TMP_163(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_keys', 'REF_210'] 
REF_206(uint256) (->playerRoundData) := TMP_163(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
current_now.keys = _keys.add(current_now.keys)

IRs:
REF_211(uint256) -> current_now.keys
REF_213(uint256) -> current_now.keys
TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_keys', 'REF_213'] 
REF_211(uint256) (->current_now) := TMP_164(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
current_now.eth = _eth.add(current_now.eth)

IRs:
REF_214(uint256) -> current_now.eth
REF_216(uint256) -> current_now.eth
TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_eth', 'REF_216'] 
REF_214(uint256) (->current_now) := TMP_165(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
playerRoundData[_pID][currentRound].mask = current_now.mask.mul(_keys).add(playerRoundData[_pID][currentRound].mask)

IRs:
REF_217(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_218(F3d.PlayerRound) -> REF_217[currentRound]
REF_219(uint256) -> REF_218.mask
REF_220(uint256) -> current_now.mask
TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_220', '_keys'] 
REF_223(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_224(F3d.PlayerRound) -> REF_223[currentRound]
REF_225(uint256) -> REF_224.mask
TMP_167(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_166', 'REF_225'] 
REF_219(uint256) (->playerRoundData) := TMP_167(uint256)"];
37->38;
38[label="Node Type: NEW VARIABLE 38

EXPRESSION:
referer1 = players[_pID].referer

IRs:
REF_226(F3d.PlayerStatus) -> players[_pID]
REF_227(uint256) -> REF_226.referer
referer1(uint256) := REF_227(uint256)"];
38->39;
39[label="Node Type: NEW VARIABLE 39

EXPRESSION:
referer2 = players[referer1].referer

IRs:
REF_228(F3d.PlayerStatus) -> players[referer1]
REF_229(uint256) -> REF_228.referer
referer2(uint256) := REF_229(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
players[referer1].affiliate = (_eth.mul(tc) / 1000).add(players[referer1].affiliate)

IRs:
REF_230(F3d.PlayerStatus) -> players[referer1]
REF_231(uint256) -> REF_230.affiliate
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'tc'] 
TMP_169(uint256) = TMP_168 / 1000
REF_234(F3d.PlayerStatus) -> players[referer1]
REF_235(uint256) -> REF_234.affiliate
TMP_170(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_169', 'REF_235'] 
REF_231(uint256) (->players) := TMP_170(uint256)"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
players[referer2].affiliate = (_eth.mul(td) / 1000).add(players[referer2].affiliate)

IRs:
REF_236(F3d.PlayerStatus) -> players[referer2]
REF_237(uint256) -> REF_236.affiliate
TMP_171(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'td'] 
TMP_172(uint256) = TMP_171 / 1000
REF_240(F3d.PlayerStatus) -> players[referer2]
REF_241(uint256) -> REF_240.affiliate
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_172', 'REF_241'] 
REF_237(uint256) (->players) := TMP_173(uint256)"];
}
// Function: 2688.sol-F3d-ethForKey(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
current = rounds[currentRound]

IRs:
REF_114(F3d.Round) -> rounds[currentRound]
current(F3d.Round) := REF_114(F3d.Round)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
c_key = (current.keys / decimals)

IRs:
REF_115(uint256) -> current.keys
TMP_75(uint256) = REF_115 / decimals
c_key(uint256) := TMP_75(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
c_key.mul(decimals) != current.keys

IRs:
TMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['c_key', 'decimals'] 
REF_117(uint256) -> current.keys
TMP_77(bool) = TMP_76 != REF_117
CONDITION TMP_77"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c_key = c_key.add(1)

IRs:
TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['c_key', '1'] 
c_key(uint256) := TMP_78(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_price = price(c_key)

IRs:
TMP_79(uint256) = INTERNAL_CALL, F3d.price(uint256)(c_key)
_price(uint256) := TMP_79(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
remainKeys = c_key.mul(decimals).sub(current.keys)

IRs:
TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['c_key', 'decimals'] 
REF_121(uint256) -> current.keys
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_80', 'REF_121'] 
remainKeys(uint256) := TMP_81(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
remainKeys >= _keys

IRs:
TMP_82(bool) = remainKeys >= _keys
CONDITION TMP_82"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
_price.mul(_keys) / decimals

IRs:
TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_price', '_keys'] 
TMP_84(uint256) = TMP_83 / decimals
RETURN TMP_84"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
costEth = _price.mul(_keys) / decimals

IRs:
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_price', '_keys'] 
TMP_86(uint256) = TMP_85 / decimals
costEth(uint256) := TMP_86(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_keys = _keys.sub(remainKeys)

IRs:
TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_keys', 'remainKeys'] 
_keys(uint256) := TMP_87(uint256)"];
12->13;
13[label="Node Type: BEGIN_LOOP 13
"];
13->14;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
_keys >= decimals

IRs:
TMP_88(bool) = _keys >= decimals
CONDITION TMP_88"];
14->15[label="True"];
14->19[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
c_key = c_key.add(1)

IRs:
TMP_89(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['c_key', '1'] 
c_key(uint256) := TMP_89(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
_price = price(c_key)

IRs:
TMP_90(uint256) = INTERNAL_CALL, F3d.price(uint256)(c_key)
_price(uint256) := TMP_90(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
costEth = costEth.add(_price)

IRs:
TMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['costEth', '_price'] 
costEth(uint256) := TMP_91(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_keys = _keys.sub(decimals)

IRs:
TMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_keys', 'decimals'] 
_keys(uint256) := TMP_92(uint256)"];
18->14;
19[label="Node Type: END_LOOP 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
c_key = c_key.add(1)

IRs:
TMP_93(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['c_key', '1'] 
c_key(uint256) := TMP_93(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
_price = price(c_key)

IRs:
TMP_94(uint256) = INTERNAL_CALL, F3d.price(uint256)(c_key)
_price(uint256) := TMP_94(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
costEth = costEth.add(_price.mul(_keys) / decimals)

IRs:
TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_price', '_keys'] 
TMP_96(uint256) = TMP_95 / decimals
TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['costEth', 'TMP_96'] 
costEth(uint256) := TMP_97(uint256)"];
22->23;
23[label="Node Type: RETURN 23

EXPRESSION:
costEth

IRs:
RETURN costEth"];
}
// Function: 2688.sol-F3d-finalize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
lastOne = rounds[currentRound]

IRs:
REF_57(F3d.Round) -> rounds[currentRound]
lastOne(F3d.Round) := REF_57(F3d.Round)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.timestamp > lastOne.endTime)

IRs:
REF_58(uint256) -> lastOne.endTime
TMP_43(bool) = block.timestamp > REF_58
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
registerUserIfNeeded(ref)

IRs:
INTERNAL_CALL, F3d.registerUserIfNeeded(uint256)(ref)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
currentRound = currentRound.add(1)

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['currentRound', '1'] 
currentRound(uint256) := TMP_46(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_round = rounds[currentRound]

IRs:
REF_60(F3d.Round) -> rounds[currentRound]
_round(F3d.Round) := REF_60(F3d.Round)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_round.endTime = block.timestamp.add(maxTimeRemain)

IRs:
REF_61(uint256) -> _round.endTime
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['block.timestamp', 'maxTimeRemain'] 
REF_61(uint256) (->_round) := TMP_47(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_round.winner = owner

IRs:
REF_63(address) -> _round.winner
REF_63(address) (->_round) := owner(address)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
money = lastOne.pool

IRs:
REF_64(uint256) -> lastOne.pool
money(uint256) := REF_64(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
money == 0

IRs:
TMP_48(bool) = money == 0
CONDITION TMP_48"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10
"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_round.pool = money.mul(wb) / 1000

IRs:
REF_65(uint256) -> _round.pool
TMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['money', 'wb'] 
TMP_50(uint256) = TMP_49 / 1000
REF_65(uint256) (->_round) := TMP_50(uint256)"];
12->13;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
toWinner = money.mul(wa) / 1000

IRs:
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['money', 'wa'] 
TMP_52(uint256) = TMP_51 / 1000
toWinner(uint256) := TMP_52(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
players[playerIds[lastOne.winner]].win = toWinner.add(players[playerIds[lastOne.winner]].win)

IRs:
REF_68(address) -> lastOne.winner
REF_69(uint256) -> playerIds[REF_68]
REF_70(F3d.PlayerStatus) -> players[REF_69]
REF_71(uint256) -> REF_70.win
REF_73(address) -> lastOne.winner
REF_74(uint256) -> playerIds[REF_73]
REF_75(F3d.PlayerStatus) -> players[REF_74]
REF_76(uint256) -> REF_75.win
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['toWinner', 'REF_76'] 
REF_71(uint256) (->players) := TMP_53(uint256)"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
toRevealer = money.mul(wc) / 1000

IRs:
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['money', 'wc'] 
TMP_55(uint256) = TMP_54 / 1000
toRevealer(uint256) := TMP_55(uint256)"];
15->16;
16[label="Node Type: NEW VARIABLE 16

EXPRESSION:
revealId = playerIds[msg.sender]

IRs:
REF_78(uint256) -> playerIds[msg.sender]
revealId(uint256) := REF_78(uint256)"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
msg.sender == lastOne.winner

IRs:
REF_79(address) -> lastOne.winner
TMP_56(bool) = msg.sender == REF_79
CONDITION TMP_56"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
revealId = 0

IRs:
revealId(uint256) := 0(uint256)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
players[revealId].win = players[revealId].win.add(toRevealer)

IRs:
REF_80(F3d.PlayerStatus) -> players[revealId]
REF_81(uint256) -> REF_80.win
REF_82(F3d.PlayerStatus) -> players[revealId]
REF_83(uint256) -> REF_82.win
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_83', 'toRevealer'] 
REF_81(uint256) (->players) := TMP_57(uint256)"];
20->21;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
toOwner = money.mul(wd) / 1000

IRs:
TMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['money', 'wd'] 
TMP_59(uint256) = TMP_58 / 1000
toOwner(uint256) := TMP_59(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
players[0].win = players[0].win.add(toOwner)

IRs:
REF_86(F3d.PlayerStatus) -> players[0]
REF_87(uint256) -> REF_86.win
REF_88(F3d.PlayerStatus) -> players[0]
REF_89(uint256) -> REF_88.win
TMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_89', 'toOwner'] 
REF_87(uint256) (->players) := TMP_60(uint256)"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
split = money.sub(_round.pool).sub(toWinner).sub(toRevealer).sub(toOwner)

IRs:
REF_92(uint256) -> _round.pool
TMP_61(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['money', 'REF_92'] 
TMP_62(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_61', 'toWinner'] 
TMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_62', 'toRevealer'] 
TMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_63', 'toOwner'] 
split(uint256) := TMP_64(uint256)"];
23->24;
24[label="Node Type: IF 24

EXPRESSION:
lastOne.keys != 0

IRs:
REF_96(uint256) -> lastOne.keys
TMP_65(bool) = REF_96 != 0
CONDITION TMP_65"];
24->25[label="True"];
24->27[label="False"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
lastOne.mask = lastOne.mask.add(split / lastOne.keys)

IRs:
REF_97(uint256) -> lastOne.mask
REF_98(uint256) -> lastOne.mask
REF_100(uint256) -> lastOne.keys
TMP_66(uint256) = split / REF_100
TMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_98', 'TMP_66'] 
REF_97(uint256) (->lastOne) := TMP_67(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
players[0].wallet = players[0].wallet.add(split.sub((split / lastOne.keys) * lastOne.keys))

IRs:
REF_101(F3d.PlayerStatus) -> players[0]
REF_102(uint256) -> REF_101.wallet
REF_103(F3d.PlayerStatus) -> players[0]
REF_104(uint256) -> REF_103.wallet
REF_107(uint256) -> lastOne.keys
TMP_68(uint256) = split / REF_107
REF_108(uint256) -> lastOne.keys
TMP_69(uint256) = TMP_68 * REF_108
TMP_70(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['split', 'TMP_69'] 
TMP_71(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_104', 'TMP_70'] 
REF_102(uint256) (->players) := TMP_71(uint256)"];
26->28;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
_round.pool = split.add(_round.pool)

IRs:
REF_109(uint256) -> _round.pool
REF_111(uint256) -> _round.pool
TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['split', 'REF_111'] 
REF_109(uint256) (->_round) := TMP_72(uint256)"];
27->28;
28[label="Node Type: END_IF 28
"];
}
// Function: 2688.sol-F3d-keys(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
current = rounds[currentRound]

IRs:
REF_131(F3d.Round) -> rounds[currentRound]
current(F3d.Round) := REF_131(F3d.Round)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
c_key = (current.keys / decimals).add(1)

IRs:
REF_132(uint256) -> current.keys
TMP_98(uint256) = REF_132 / decimals
TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_98', '1'] 
c_key(uint256) := TMP_99(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_price = price(c_key)

IRs:
TMP_100(uint256) = INTERNAL_CALL, F3d.price(uint256)(c_key)
_price(uint256) := TMP_100(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
remainKeys = c_key.mul(decimals).sub(current.keys)

IRs:
TMP_101(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['c_key', 'decimals'] 
REF_136(uint256) -> current.keys
TMP_102(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_101', 'REF_136'] 
remainKeys(uint256) := TMP_102(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
remain = remainKeys.mul(_price) / decimals

IRs:
TMP_103(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['remainKeys', '_price'] 
TMP_104(uint256) = TMP_103 / decimals
remain(uint256) := TMP_104(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
remain >= _eth

IRs:
TMP_105(bool) = remain >= _eth
CONDITION TMP_105"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
_eth.mul(decimals) / _price

IRs:
TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'decimals'] 
TMP_107(uint256) = TMP_106 / _price
RETURN TMP_107"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
boughtKeys = remainKeys

IRs:
boughtKeys(uint256) := remainKeys(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_eth = _eth.sub(remain)

IRs:
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_eth', 'remain'] 
_eth(uint256) := TMP_108(uint256)"];
10->11;
11[label="Node Type: BEGIN_LOOP 11
"];
11->12;
12[label="Node Type: IF_LOOP 12

EXPRESSION:
true

IRs:
CONDITION True"];
12->13[label="True"];
12->21[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
c_key = c_key.add(1)

IRs:
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['c_key', '1'] 
c_key(uint256) := TMP_109(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_price = price(c_key)

IRs:
TMP_110(uint256) = INTERNAL_CALL, F3d.price(uint256)(c_key)
_price(uint256) := TMP_110(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
_price <= _eth

IRs:
TMP_111(bool) = _price <= _eth
CONDITION TMP_111"];
15->16[label="True"];
15->18[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
boughtKeys = boughtKeys.add(decimals)

IRs:
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['boughtKeys', 'decimals'] 
boughtKeys(uint256) := TMP_112(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
_eth = _eth.sub(_price)

IRs:
TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_eth', '_price'] 
_eth(uint256) := TMP_113(uint256)"];
17->20;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
boughtKeys = boughtKeys.add(_eth.mul(decimals) / _price)

IRs:
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'decimals'] 
TMP_115(uint256) = TMP_114 / _price
TMP_116(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['boughtKeys', 'TMP_115'] 
boughtKeys(uint256) := TMP_116(uint256)"];
18->19;
19[label="Node Type: BREAK 19
"];
19->21;
20[label="Node Type: END_IF 20
"];
20->12;
21[label="Node Type: END_LOOP 21
"];
21->22;
22[label="Node Type: RETURN 22

EXPRESSION:
boughtKeys

IRs:
RETURN boughtKeys"];
}
// Function: 2688.sol-F3d-onlyAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == admin)

IRs:
TMP_199(bool) = msg.sender == admin
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2688.sol-F3d-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_195(bool) = msg.sender == owner
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2688.sol-F3d-playerCount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
players.length

IRs:
REF_259 -> LENGTH players
RETURN REF_259"];
}
// Function: 2688.sol-F3d-profit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
id = playerIds[msg.sender]

IRs:
REF_33(uint256) -> playerIds[msg.sender]
id(uint256) := REF_33(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
id == 0 && msg.sender != owner

IRs:
TMP_27(bool) = id == 0
TMP_28(bool) = msg.sender != owner
TMP_29(bool) = TMP_27 && TMP_28
CONDITION TMP_29"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
player = players[id]

IRs:
REF_34(F3d.PlayerStatus) -> players[id]
player(F3d.PlayerStatus) := REF_34(F3d.PlayerStatus)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
player.wallet.add(player.affiliate).add(player.win).add(calculateMasked(id,player.lrnd))

IRs:
REF_35(uint256) -> player.wallet
REF_37(uint256) -> player.affiliate
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_35', 'REF_37'] 
REF_39(uint256) -> player.win
TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_30', 'REF_39'] 
REF_41(uint256) -> player.lrnd
TMP_32(uint256) = INTERNAL_CALL, F3d.calculateMasked(uint256,uint256)(id,REF_41)
TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_31', 'TMP_32'] 
RETURN TMP_33"];
}
// Function: 2688.sol-F3d-register(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
registerUserIfNeeded(ref)

IRs:
INTERNAL_CALL, F3d.registerUserIfNeeded(uint256)(ref)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, F3d.whenNotPaused()()"];
2->1;
}
// Function: 2688.sol-F3d-registerUserIfNeeded(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_36(bool) = msg.sender != owner
CONDITION TMP_36"];
1->2[label="True"];
1->9[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
playerIds[msg.sender] == 0

IRs:
REF_50(uint256) -> playerIds[msg.sender]
TMP_37(bool) = REF_50 == 0
CONDITION TMP_37"];
2->3[label="True"];
2->8[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
playerIds[msg.sender] = players.length

IRs:
REF_51(uint256) -> playerIds[msg.sender]
REF_52 -> LENGTH players
REF_51(uint256) (->playerIds) := REF_52(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
ref >= players.length

IRs:
REF_53 -> LENGTH players
TMP_38(bool) = ref >= REF_53
CONDITION TMP_38"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ref = 0

IRs:
ref(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
players.push(PlayerStatus(msg.sender,0,0,0,0,ref))

IRs:
TMP_39(F3d.PlayerStatus) = new PlayerStatus(msg.sender,0,0,0,0,ref)
REF_55 -> LENGTH players
TMP_41(uint256) := REF_55(uint256)
TMP_42(uint256) = TMP_41 + 1
REF_55(uint256) (->players) := TMP_42(uint256)
REF_56(F3d.PlayerStatus) -> players[TMP_41]
REF_56(F3d.PlayerStatus) (->players) := TMP_39(F3d.PlayerStatus)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
}
// Function: 2688.sol-F3d-remainTime()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
rounds[currentRound].endTime <= block.timestamp

IRs:
REF_260(F3d.Round) -> rounds[currentRound]
REF_261(uint256) -> REF_260.endTime
TMP_193(bool) = REF_261 <= block.timestamp
CONDITION TMP_193"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: RETURN 3

EXPRESSION:
rounds[currentRound].endTime - block.timestamp

IRs:
REF_262(F3d.Round) -> rounds[currentRound]
REF_263(uint256) -> REF_262.endTime
TMP_194(uint256) = REF_263 - block.timestamp
RETURN TMP_194"];
}
// Function: 2688.sol-F3d-retrieveEarnings()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
id = playerIds[msg.sender]

IRs:
REF_248(uint256) -> playerIds[msg.sender]
id(uint256) := REF_248(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
updatePlayer(id)

IRs:
INTERNAL_CALL, F3d.updatePlayer(uint256)(id)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
player = players[id]

IRs:
REF_249(F3d.PlayerStatus) -> players[id]
player(F3d.PlayerStatus) := REF_249(F3d.PlayerStatus)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
earnings = player.wallet.add(player.affiliate).add(player.win)

IRs:
REF_250(uint256) -> player.wallet
REF_252(uint256) -> player.affiliate
TMP_183(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_250', 'REF_252'] 
REF_254(uint256) -> player.win
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_183', 'REF_254'] 
earnings(uint256) := TMP_184(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
earnings == 0

IRs:
TMP_185(bool) = earnings == 0
CONDITION TMP_185"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
player.wallet = 0

IRs:
REF_255(uint256) -> player.wallet
REF_255(uint256) (->player) := 0(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
player.affiliate = 0

IRs:
REF_256(uint256) -> player.affiliate
REF_256(uint256) (->player) := 0(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
player.win = 0

IRs:
REF_257(uint256) -> player.win
REF_257(uint256) (->player) := 0(uint256)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
earnings

IRs:
RETURN earnings"];
}
// Function: 2688.sol-F3d-setPause(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pause = _pause

IRs:
pause(bool) := _pause(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, F3d.onlyAdmin()()"];
2->1;
}
// Function: 2688.sol-F3d-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 1000000

IRs:
decimals(uint256) := 1000000(uint256)"];
}
// Function: 2688.sol-F3d-updatePlayer(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
players[_pID].lrnd != 0

IRs:
REF_15(F3d.PlayerStatus) -> players[_pID]
REF_16(uint256) -> REF_15.lrnd
TMP_21(bool) = REF_16 != 0
CONDITION TMP_21"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
updateWallet(_pID,players[_pID].lrnd)

IRs:
REF_17(F3d.PlayerStatus) -> players[_pID]
REF_18(uint256) -> REF_17.lrnd
INTERNAL_CALL, F3d.updateWallet(uint256,uint256)(_pID,REF_18)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
players[_pID].lrnd = currentRound

IRs:
REF_19(F3d.PlayerStatus) -> players[_pID]
REF_20(uint256) -> REF_19.lrnd
REF_20(uint256) (->players) := currentRound(uint256)"];
}
// Function: 2688.sol-F3d-updateWallet(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
earnings = calculateMasked(_pID,_round)

IRs:
TMP_23(uint256) = INTERNAL_CALL, F3d.calculateMasked(uint256,uint256)(_pID,_round)
earnings(uint256) := TMP_23(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
earnings > 0

IRs:
TMP_24(bool) = earnings > 0
CONDITION TMP_24"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
players[_pID].wallet = earnings.add(players[_pID].wallet)

IRs:
REF_21(F3d.PlayerStatus) -> players[_pID]
REF_22(uint256) -> REF_21.wallet
REF_24(F3d.PlayerStatus) -> players[_pID]
REF_25(uint256) -> REF_24.wallet
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['earnings', 'REF_25'] 
REF_22(uint256) (->players) := TMP_25(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
playerRoundData[_pID][_round].mask = earnings.add(playerRoundData[_pID][_round].mask)

IRs:
REF_26(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_27(F3d.PlayerRound) -> REF_26[_round]
REF_28(uint256) -> REF_27.mask
REF_30(mapping(uint256 => F3d.PlayerRound)) -> playerRoundData[_pID]
REF_31(F3d.PlayerRound) -> REF_30[_round]
REF_32(uint256) -> REF_31.mask
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['earnings', 'REF_32'] 
REF_28(uint256) (->playerRoundData) := TMP_26(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
}
// Function: 2688.sol-F3d-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! pause)

IRs:
TMP_197 = UnaryType.BANG pause 
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2688.sol-F3d-withdrawal(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
registerUserIfNeeded(ref)

IRs:
INTERNAL_CALL, F3d.registerUserIfNeeded(uint256)(ref)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
earnings = retrieveEarnings()

IRs:
TMP_187(uint256) = INTERNAL_CALL, F3d.retrieveEarnings()()
earnings(uint256) := TMP_187(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
earnings == 0

IRs:
TMP_188(bool) = earnings == 0
CONDITION TMP_188"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4
"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(earnings)

IRs:
Transfer dest:msg.sender value:earnings"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, F3d.whenNotPaused()()"];
7->1;
}
// Function: 2688.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_209(uint256) = a + b
c(uint256) := TMP_209(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(c >= a,SafeMath add failed)

IRs:
TMP_210(bool) = c >= a
TMP_211(None) = SOLIDITY_CALL require(bool,string)(TMP_210,SafeMath add failed)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2688.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_201(bool) = a == 0
CONDITION TMP_201"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_202(uint256) = a * b
c(uint256) := TMP_202(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(c / a == b,SafeMath mul failed)

IRs:
TMP_203(uint256) = c / a
TMP_204(bool) = TMP_203 == b
TMP_205(None) = SOLIDITY_CALL require(bool,string)(TMP_204,SafeMath mul failed)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2688.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(b <= a,SafeMath sub failed)

IRs:
TMP_206(bool) = b <= a
TMP_207(None) = SOLIDITY_CALL require(bool,string)(TMP_206,SafeMath sub failed)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_208(uint256) = a - b
RETURN TMP_208"];
}
}
