digraph G {
// Function: 2861.sol-BurnableToken-allowance(address,address)
digraph{
}
// Function: 2861.sol-BurnableToken-approve(address,uint256)
digraph{
}
// Function: 2861.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 2861.sol-BurnableToken-batchTransfer(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_toList.length <= 100)

IRs:
REF_43 -> LENGTH _toList
TMP_59(bool) = REF_43 <= 100
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_toList.length == _tokensList.length)

IRs:
REF_44 -> LENGTH _toList
REF_45 -> LENGTH _tokensList
TMP_61(bool) = REF_44 == REF_45
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
sum = 0

IRs:
sum(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->10;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
index = 0

IRs:
index(uint32) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
index < _tokensList.length

IRs:
REF_46 -> LENGTH _tokensList
TMP_63(bool) = index < REF_46
CONDITION TMP_63"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
sum = sum.add(_tokensList[index])

IRs:
REF_48(uint256) -> _tokensList[index]
TMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sum', 'REF_48'] 
sum(uint256) := TMP_64(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
index ++

IRs:
TMP_65(uint32) := index(uint32)
index(uint32) = index + 1"];
9->7;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(balances[msg.sender] >= sum)

IRs:
REF_49(uint256) -> balances[msg.sender]
TMP_66(bool) = REF_49 >= sum
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
12->17;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < _toList.length

IRs:
REF_50 -> LENGTH _toList
TMP_68(bool) = i < REF_50
CONDITION TMP_68"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
transfer(_toList[i],_tokensList[i])

IRs:
REF_51(address) -> _toList[i]
REF_52(uint256) -> _tokensList[i]
TMP_69(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256)(REF_51,REF_52)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_70(uint32) := i(uint32)
i(uint32) = i + 1"];
16->14;
17[label="Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_83(bool) = _value > 0
TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_72(uint256) -> balances[msg.sender]
TMP_85(bool) = _value <= REF_72
TMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_73(uint256) -> balances[burner]
REF_74(uint256) -> balances[burner]
TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_74', '_value'] 
REF_73(uint256) (->balances) := TMP_87(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = totalSupply.sub(_value)

IRs:
TMP_88(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] 
totalSupply(uint256) := TMP_88(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
}
// Function: 2861.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 2861.sol-BurnableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 2861.sol-DELCToken-addToVestMap(address,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_349 = CONVERT 0 to address
TMP_350(bool) = _beneficiary != TMP_349
TMP_351(None) = SOLIDITY_CALL require(bool)(TMP_350)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_cliff <= _duration)

IRs:
TMP_352(bool) = _cliff <= _duration
TMP_353(None) = SOLIDITY_CALL require(bool)(TMP_352)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_start > block.timestamp)

IRs:
TMP_354(bool) = _start > block.timestamp
TMP_355(None) = SOLIDITY_CALL require(bool)(TMP_354)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! vestToMap[_beneficiary].exist)

IRs:
REF_249(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_250(bool) -> REF_249.exist
TMP_356 = UnaryType.BANG REF_250 
TMP_357(None) = SOLIDITY_CALL require(bool)(TMP_356)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
vestToMap[_beneficiary] = tokenToVest(true,_start,_start.add(_cliff),_duration,_torelease,uint256(0))

IRs:
REF_251(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
TMP_358(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_start', '_cliff'] 
TMP_359 = CONVERT 0 to uint256
TMP_360(TokenVesting.tokenToVest) = new tokenToVest(True,_start,TMP_358,_duration,_torelease,TMP_359)
REF_251(TokenVesting.tokenToVest) (->vestToMap) := TMP_360(TokenVesting.tokenToVest)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
AddToVestMap(_beneficiary)

IRs:
Emit AddToVestMap(_beneficiary)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 2861.sol-DELCToken-allowance(address,address)
digraph{
}
// Function: 2861.sol-DELCToken-approve(address,uint256)
digraph{
}
// Function: 2861.sol-DELCToken-balanceOf(address)
digraph{
}
// Function: 2861.sol-DELCToken-batchTransfer(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_toList.length <= 100)

IRs:
REF_286 -> LENGTH _toList
TMP_395(bool) = REF_286 <= 100
TMP_396(None) = SOLIDITY_CALL require(bool)(TMP_395)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_toList.length == _tokensList.length)

IRs:
REF_287 -> LENGTH _toList
REF_288 -> LENGTH _tokensList
TMP_397(bool) = REF_287 == REF_288
TMP_398(None) = SOLIDITY_CALL require(bool)(TMP_397)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
sum = 0

IRs:
sum(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->10;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
index = 0

IRs:
index(uint32) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
index < _tokensList.length

IRs:
REF_289 -> LENGTH _tokensList
TMP_399(bool) = index < REF_289
CONDITION TMP_399"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
sum = sum.add(_tokensList[index])

IRs:
REF_291(uint256) -> _tokensList[index]
TMP_400(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sum', 'REF_291'] 
sum(uint256) := TMP_400(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
index ++

IRs:
TMP_401(uint32) := index(uint32)
index(uint32) = index + 1"];
9->7;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(balances[msg.sender] >= sum)

IRs:
REF_292(uint256) -> balances[msg.sender]
TMP_402(bool) = REF_292 >= sum
TMP_403(None) = SOLIDITY_CALL require(bool)(TMP_402)"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
12->17;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < _toList.length

IRs:
REF_293 -> LENGTH _toList
TMP_404(bool) = i < REF_293
CONDITION TMP_404"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
transfer(_toList[i],_tokensList[i])

IRs:
REF_294(address) -> _toList[i]
REF_295(uint256) -> _tokensList[i]
TMP_405(bool) = INTERNAL_CALL, PausableToken.transfer(address,uint256)(REF_294,REF_295)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_406(uint32) := i(uint32)
i(uint32) = i + 1"];
16->14;
17[label="Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-DELCToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_427(bool) = _value > 0
TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_319(uint256) -> balances[msg.sender]
TMP_429(bool) = _value <= REF_319
TMP_430(None) = SOLIDITY_CALL require(bool)(TMP_429)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_320(uint256) -> balances[burner]
REF_321(uint256) -> balances[burner]
TMP_431(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_321', '_value'] 
REF_320(uint256) (->balances) := TMP_431(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = totalSupply.sub(_value)

IRs:
TMP_432(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] 
totalSupply(uint256) := TMP_432(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
}
// Function: 2861.sol-DELCToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_444 = UnaryType.BANG mintingFinished 
TMP_445(None) = SOLIDITY_CALL require(bool)(TMP_444)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-DELCToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = DELC Relation Person Token

IRs:
name(string) := DELC Relation Person Token(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = DELC

IRs:
symbol(string) := DELC(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply = 10000000000 * 10 ** uint256(decimals)

IRs:
TMP_434 = CONVERT decimals to uint256
TMP_435(uint256) = 10 ** TMP_434
TMP_436(uint256) = 10000000000 * TMP_435
totalSupply(uint256) := TMP_436(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = totalSupply

IRs:
REF_324(uint256) -> balances[msg.sender]
REF_324(uint256) (->balances) := totalSupply(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(address(0),msg.sender,totalSupply)

IRs:
TMP_437 = CONVERT 0 to address
Emit Transfer(TMP_437,msg.sender,totalSupply)"];
}
// Function: 2861.sol-DELCToken-delFromVestMap(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_363 = CONVERT 0 to address
TMP_364(bool) = _beneficiary != TMP_363
TMP_365(None) = SOLIDITY_CALL require(bool)(TMP_364)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(vestToMap[_beneficiary].exist)

IRs:
REF_253(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_254(bool) -> REF_253.exist
TMP_366(None) = SOLIDITY_CALL require(bool)(REF_254)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete vestToMap[_beneficiary]

IRs:
REF_255(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
vestToMap = delete REF_255 "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
DelFromVestMap(_beneficiary)

IRs:
Emit DelFromVestMap(_beneficiary)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 2861.sol-DELCToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-DELCToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply.add(_amount)

IRs:
TMP_419(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_419(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_316(uint256) -> balances[_to]
REF_317(uint256) -> balances[_to]
TMP_420(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_317', '_amount'] 
REF_316(uint256) (->balances) := TMP_420(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(0x0,_to,_amount)

IRs:
Emit Transfer(0,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 2861.sol-DELCToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_442(bool) = msg.sender == owner
TMP_443(None) = SOLIDITY_CALL require(bool)(TMP_442)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-DELCToken-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 2861.sol-DELCToken-releasableAmount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
vestedAmount(_beneficiary).sub(vestToMap[_beneficiary].released)

IRs:
TMP_379(uint256) = INTERNAL_CALL, TokenVesting.vestedAmount(address)(_beneficiary)
REF_266(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_267(uint256) -> REF_266.released
TMP_380(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_379', 'REF_267'] 
RETURN TMP_380"];
}
// Function: 2861.sol-DELCToken-release(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = vestToMap[_beneficiary]

IRs:
REF_256(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
value(TokenVesting.tokenToVest) := REF_256(TokenVesting.tokenToVest)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value.exist)

IRs:
REF_257(bool) -> value.exist
TMP_369(None) = SOLIDITY_CALL require(bool)(REF_257)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
unreleased = releasableAmount(_beneficiary)

IRs:
TMP_370(uint256) = INTERNAL_CALL, TokenVesting.releasableAmount(address)(_beneficiary)
unreleased(uint256) := TMP_370(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(unreleased > 0)

IRs:
TMP_371(bool) = unreleased > 0
TMP_372(None) = SOLIDITY_CALL require(bool)(TMP_371)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(unreleased + value.released <= value.torelease)

IRs:
REF_258(uint256) -> value.released
TMP_373(uint256) = unreleased + REF_258
REF_259(uint256) -> value.torelease
TMP_374(bool) = TMP_373 <= REF_259
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
vestToMap[_beneficiary].released = vestToMap[_beneficiary].released.add(unreleased)

IRs:
REF_260(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_261(uint256) -> REF_260.released
REF_262(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_263(uint256) -> REF_262.released
TMP_376(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_263', 'unreleased'] 
REF_261(uint256) (->vestToMap) := TMP_376(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfer(_beneficiary,unreleased)

IRs:
TMP_377(bool) = INTERNAL_CALL, PausableToken.transfer(address,uint256)(_beneficiary,unreleased)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Released(_beneficiary,unreleased)

IRs:
Emit Released(_beneficiary,unreleased)"];
}
// Function: 2861.sol-DELCToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 2861.sol-DELCToken-transfer(address,uint256)
digraph{
}
// Function: 2861.sol-DELCToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 2861.sol-DELCToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_344 = CONVERT 0 to address
TMP_345(bool) = newOwner != TMP_344
TMP_346(None) = SOLIDITY_CALL require(bool)(TMP_345)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-DELCToken-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 2861.sol-DELCToken-vestedAmount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = vestToMap[_beneficiary]

IRs:
REF_268(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
value(TokenVesting.tokenToVest) := REF_268(TokenVesting.tokenToVest)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
totalBalance = value.torelease

IRs:
REF_269(uint256) -> value.torelease
totalBalance(uint256) := REF_269(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
block.timestamp < value.cliff

IRs:
REF_270(uint256) -> value.cliff
TMP_381(bool) = block.timestamp < REF_270
CONDITION TMP_381"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
5[label="Node Type: IF 5

EXPRESSION:
block.timestamp >= value.start.add(value.duration)

IRs:
REF_271(uint256) -> value.start
REF_273(uint256) -> value.duration
TMP_382(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_271', 'REF_273'] 
TMP_383(bool) = block.timestamp >= TMP_382
CONDITION TMP_383"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
totalBalance

IRs:
RETURN totalBalance"];
7[label="Node Type: RETURN 7

EXPRESSION:
totalBalance.mul(block.timestamp.sub(value.start)).div(value.duration)

IRs:
REF_276(uint256) -> value.start
TMP_384(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.timestamp', 'REF_276'] 
TMP_385(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalBalance', 'TMP_384'] 
REF_278(uint256) -> value.duration
TMP_386(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_385', 'REF_278'] 
RETURN TMP_386"];
}
// Function: 2861.sol-DELCToken-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_439 = UnaryType.BANG paused 
TMP_440(None) = SOLIDITY_CALL require(bool)(TMP_439)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-DELCToken-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_441(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-ERC20Basic-allowance(address,address)
digraph{
}
// Function: 2861.sol-ERC20Basic-approve(address,uint256)
digraph{
}
// Function: 2861.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 2861.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 2861.sol-ERC20Basic-transferFrom(address,address,uint256)
digraph{
}
// Function: 2861.sol-MintableToken-allowance(address,address)
digraph{
}
// Function: 2861.sol-MintableToken-approve(address,uint256)
digraph{
}
// Function: 2861.sol-MintableToken-balanceOf(address)
digraph{
}
// Function: 2861.sol-MintableToken-batchTransfer(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_toList.length <= 100)

IRs:
REF_84 -> LENGTH _toList
TMP_103(bool) = REF_84 <= 100
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_toList.length == _tokensList.length)

IRs:
REF_85 -> LENGTH _toList
REF_86 -> LENGTH _tokensList
TMP_105(bool) = REF_85 == REF_86
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
sum = 0

IRs:
sum(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->10;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
index = 0

IRs:
index(uint32) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
index < _tokensList.length

IRs:
REF_87 -> LENGTH _tokensList
TMP_107(bool) = index < REF_87
CONDITION TMP_107"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
sum = sum.add(_tokensList[index])

IRs:
REF_89(uint256) -> _tokensList[index]
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sum', 'REF_89'] 
sum(uint256) := TMP_108(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
index ++

IRs:
TMP_109(uint32) := index(uint32)
index(uint32) = index + 1"];
9->7;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(balances[msg.sender] >= sum)

IRs:
REF_90(uint256) -> balances[msg.sender]
TMP_110(bool) = REF_90 >= sum
TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110)"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
12->17;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < _toList.length

IRs:
REF_91 -> LENGTH _toList
TMP_112(bool) = i < REF_91
CONDITION TMP_112"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
transfer(_toList[i],_tokensList[i])

IRs:
REF_92(address) -> _toList[i]
REF_93(uint256) -> _tokensList[i]
TMP_113(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256)(REF_92,REF_93)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_114(uint32) := i(uint32)
i(uint32) = i + 1"];
16->14;
17[label="Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-MintableToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_137 = UnaryType.BANG mintingFinished 
TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-MintableToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2861.sol-MintableToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-MintableToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply.add(_amount)

IRs:
TMP_127(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_amount'] 
totalSupply(uint256) := TMP_127(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_114(uint256) -> balances[_to]
REF_115(uint256) -> balances[_to]
TMP_128(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_115', '_amount'] 
REF_114(uint256) (->balances) := TMP_128(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(0x0,_to,_amount)

IRs:
Emit Transfer(0,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 2861.sol-MintableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_135(bool) = msg.sender == owner
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-MintableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
}
// Function: 2861.sol-MintableToken-transfer(address,uint256)
digraph{
}
// Function: 2861.sol-MintableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 2861.sol-MintableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_90 = CONVERT 0 to address
TMP_91(bool) = newOwner != TMP_90
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-Ownable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2861.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_17(bool) = msg.sender == owner
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = newOwner != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-Pausable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2861.sol-Pausable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_150(bool) = msg.sender == owner
TMP_151(None) = SOLIDITY_CALL require(bool)(TMP_150)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-Pausable-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 2861.sol-Pausable-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 2861.sol-Pausable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_139 = CONVERT 0 to address
TMP_140(bool) = newOwner != TMP_139
TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-Pausable-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 2861.sol-Pausable-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_152 = UnaryType.BANG paused 
TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-Pausable-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_154(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-PausableToken-addToVestMap(address,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_243 = CONVERT 0 to address
TMP_244(bool) = _beneficiary != TMP_243
TMP_245(None) = SOLIDITY_CALL require(bool)(TMP_244)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_cliff <= _duration)

IRs:
TMP_246(bool) = _cliff <= _duration
TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_start > block.timestamp)

IRs:
TMP_248(bool) = _start > block.timestamp
TMP_249(None) = SOLIDITY_CALL require(bool)(TMP_248)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! vestToMap[_beneficiary].exist)

IRs:
REF_183(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_184(bool) -> REF_183.exist
TMP_250 = UnaryType.BANG REF_184 
TMP_251(None) = SOLIDITY_CALL require(bool)(TMP_250)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
vestToMap[_beneficiary] = tokenToVest(true,_start,_start.add(_cliff),_duration,_torelease,uint256(0))

IRs:
REF_185(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
TMP_252(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_start', '_cliff'] 
TMP_253 = CONVERT 0 to uint256
TMP_254(TokenVesting.tokenToVest) = new tokenToVest(True,_start,TMP_252,_duration,_torelease,TMP_253)
REF_185(TokenVesting.tokenToVest) (->vestToMap) := TMP_254(TokenVesting.tokenToVest)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
AddToVestMap(_beneficiary)

IRs:
Emit AddToVestMap(_beneficiary)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 2861.sol-PausableToken-allowance(address,address)
digraph{
}
// Function: 2861.sol-PausableToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.approve(_spender,_value)

IRs:
TMP_319(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
RETURN TMP_319"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 2861.sol-PausableToken-balanceOf(address)
digraph{
}
// Function: 2861.sol-PausableToken-batchTransfer(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.batchTransfer(_toList,_tokensList)

IRs:
TMP_315(bool) = INTERNAL_CALL, StandardToken.batchTransfer(address[],uint256[])(_toList,_tokensList)
RETURN TMP_315"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 2861.sol-PausableToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2861.sol-PausableToken-delFromVestMap(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_257 = CONVERT 0 to address
TMP_258(bool) = _beneficiary != TMP_257
TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(vestToMap[_beneficiary].exist)

IRs:
REF_187(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_188(bool) -> REF_187.exist
TMP_260(None) = SOLIDITY_CALL require(bool)(REF_188)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete vestToMap[_beneficiary]

IRs:
REF_189(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
vestToMap = delete REF_189 "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
DelFromVestMap(_beneficiary)

IRs:
Emit DelFromVestMap(_beneficiary)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 2861.sol-PausableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_326(bool) = msg.sender == owner
TMP_327(None) = SOLIDITY_CALL require(bool)(TMP_326)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-PausableToken-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 2861.sol-PausableToken-releasableAmount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
vestedAmount(_beneficiary).sub(vestToMap[_beneficiary].released)

IRs:
TMP_273(uint256) = INTERNAL_CALL, TokenVesting.vestedAmount(address)(_beneficiary)
REF_200(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_201(uint256) -> REF_200.released
TMP_274(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_273', 'REF_201'] 
RETURN TMP_274"];
}
// Function: 2861.sol-PausableToken-release(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.release(_beneficiary)

IRs:
INTERNAL_CALL, TokenVesting.release(address)(_beneficiary)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 2861.sol-PausableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 2861.sol-PausableToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_313(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256)(_to,_value)
RETURN TMP_313"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 2861.sol-PausableToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_317(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_317"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 2861.sol-PausableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_238 = CONVERT 0 to address
TMP_239(bool) = newOwner != TMP_238
TMP_240(None) = SOLIDITY_CALL require(bool)(TMP_239)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-PausableToken-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 2861.sol-PausableToken-vestedAmount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = vestToMap[_beneficiary]

IRs:
REF_202(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
value(TokenVesting.tokenToVest) := REF_202(TokenVesting.tokenToVest)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
totalBalance = value.torelease

IRs:
REF_203(uint256) -> value.torelease
totalBalance(uint256) := REF_203(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
block.timestamp < value.cliff

IRs:
REF_204(uint256) -> value.cliff
TMP_275(bool) = block.timestamp < REF_204
CONDITION TMP_275"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
5[label="Node Type: IF 5

EXPRESSION:
block.timestamp >= value.start.add(value.duration)

IRs:
REF_205(uint256) -> value.start
REF_207(uint256) -> value.duration
TMP_276(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_205', 'REF_207'] 
TMP_277(bool) = block.timestamp >= TMP_276
CONDITION TMP_277"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
totalBalance

IRs:
RETURN totalBalance"];
7[label="Node Type: RETURN 7

EXPRESSION:
totalBalance.mul(block.timestamp.sub(value.start)).div(value.duration)

IRs:
REF_210(uint256) -> value.start
TMP_278(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.timestamp', 'REF_210'] 
TMP_279(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalBalance', 'TMP_278'] 
REF_212(uint256) -> value.duration
TMP_280(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_279', 'REF_212'] 
RETURN TMP_280"];
}
// Function: 2861.sol-PausableToken-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_323 = UnaryType.BANG paused 
TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-PausableToken-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_325(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2861.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_5(uint256) = a / b
c(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2861.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 2861.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 2861.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_34(mapping(address => uint256)) -> allowed[_owner]
REF_35(uint256) -> REF_34[_spender]
RETURN REF_35"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 2861.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_32(mapping(address => uint256)) -> allowed[msg.sender]
REF_33(uint256) -> REF_32[_spender]
REF_33(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-StandardToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_17(uint256) -> balances[_owner]
RETURN REF_17"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 2861.sol-StandardToken-batchTransfer(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_toList.length <= 100)

IRs:
REF_7 -> LENGTH _toList
TMP_27(bool) = REF_7 <= 100
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_toList.length == _tokensList.length)

IRs:
REF_8 -> LENGTH _toList
REF_9 -> LENGTH _tokensList
TMP_29(bool) = REF_8 == REF_9
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
sum = 0

IRs:
sum(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->10;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
index = 0

IRs:
index(uint32) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
index < _tokensList.length

IRs:
REF_10 -> LENGTH _tokensList
TMP_31(bool) = index < REF_10
CONDITION TMP_31"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
sum = sum.add(_tokensList[index])

IRs:
REF_12(uint256) -> _tokensList[index]
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sum', 'REF_12'] 
sum(uint256) := TMP_32(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
index ++

IRs:
TMP_33(uint32) := index(uint32)
index(uint32) = index + 1"];
9->7;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(balances[msg.sender] >= sum)

IRs:
REF_13(uint256) -> balances[msg.sender]
TMP_34(bool) = REF_13 >= sum
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
12->17;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < _toList.length

IRs:
REF_14 -> LENGTH _toList
TMP_36(bool) = i < REF_14
CONDITION TMP_36"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
transfer(_toList[i],_tokensList[i])

IRs:
REF_15(address) -> _toList[i]
REF_16(uint256) -> _tokensList[i]
TMP_37(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256)(REF_15,REF_16)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_38(uint32) := i(uint32)
i(uint32) = i + 1"];
16->14;
17[label="Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-StandardToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = _to != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_22(bool) = _value <= REF_0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_24(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_25(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_39 = CONVERT 0 to address
TMP_40(bool) = _to != TMP_39
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_18(uint256) -> balances[_from]
TMP_42(bool) = _value <= REF_18
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_19(mapping(address => uint256)) -> allowed[_from]
REF_20(uint256) -> REF_19[msg.sender]
TMP_44(bool) = _value <= REF_20
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_21(uint256) -> balances[_from]
REF_22(uint256) -> balances[_from]
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_22', '_value'] 
REF_21(uint256) (->balances) := TMP_46(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_24(uint256) -> balances[_to]
REF_25(uint256) -> balances[_to]
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_25', '_value'] 
REF_24(uint256) (->balances) := TMP_47(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
REF_29(mapping(address => uint256)) -> allowed[_from]
REF_30(uint256) -> REF_29[msg.sender]
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_30', '_value'] 
REF_28(uint256) (->allowed) := TMP_48(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-TokenVesting-addToVestMap(address,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_192 = CONVERT 0 to address
TMP_193(bool) = _beneficiary != TMP_192
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_cliff <= _duration)

IRs:
TMP_195(bool) = _cliff <= _duration
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_start > block.timestamp)

IRs:
TMP_197(bool) = _start > block.timestamp
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! vestToMap[_beneficiary].exist)

IRs:
REF_153(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_154(bool) -> REF_153.exist
TMP_199 = UnaryType.BANG REF_154 
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
vestToMap[_beneficiary] = tokenToVest(true,_start,_start.add(_cliff),_duration,_torelease,uint256(0))

IRs:
REF_155(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
TMP_201(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_start', '_cliff'] 
TMP_202 = CONVERT 0 to uint256
TMP_203(TokenVesting.tokenToVest) = new tokenToVest(True,_start,TMP_201,_duration,_torelease,TMP_202)
REF_155(TokenVesting.tokenToVest) (->vestToMap) := TMP_203(TokenVesting.tokenToVest)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
AddToVestMap(_beneficiary)

IRs:
Emit AddToVestMap(_beneficiary)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
}
// Function: 2861.sol-TokenVesting-allowance(address,address)
digraph{
}
// Function: 2861.sol-TokenVesting-approve(address,uint256)
digraph{
}
// Function: 2861.sol-TokenVesting-balanceOf(address)
digraph{
}
// Function: 2861.sol-TokenVesting-batchTransfer(address[],uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_toList.length <= 100)

IRs:
REF_124 -> LENGTH _toList
TMP_168(bool) = REF_124 <= 100
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_toList.length == _tokensList.length)

IRs:
REF_125 -> LENGTH _toList
REF_126 -> LENGTH _tokensList
TMP_170(bool) = REF_125 == REF_126
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
sum = 0

IRs:
sum(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->10;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
index = 0

IRs:
index(uint32) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
index < _tokensList.length

IRs:
REF_127 -> LENGTH _tokensList
TMP_172(bool) = index < REF_127
CONDITION TMP_172"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
sum = sum.add(_tokensList[index])

IRs:
REF_129(uint256) -> _tokensList[index]
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sum', 'REF_129'] 
sum(uint256) := TMP_173(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
index ++

IRs:
TMP_174(uint32) := index(uint32)
index(uint32) = index + 1"];
9->7;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(balances[msg.sender] >= sum)

IRs:
REF_130(uint256) -> balances[msg.sender]
TMP_175(bool) = REF_130 >= sum
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
12->17;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint32) := 0(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < _toList.length

IRs:
REF_131 -> LENGTH _toList
TMP_177(bool) = i < REF_131
CONDITION TMP_177"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
transfer(_toList[i],_tokensList[i])

IRs:
REF_132(address) -> _toList[i]
REF_133(uint256) -> _tokensList[i]
TMP_178(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256)(REF_132,REF_133)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_179(uint32) := i(uint32)
i(uint32) = i + 1"];
16->14;
17[label="Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 2861.sol-TokenVesting-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 2861.sol-TokenVesting-delFromVestMap(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_206 = CONVERT 0 to address
TMP_207(bool) = _beneficiary != TMP_206
TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(vestToMap[_beneficiary].exist)

IRs:
REF_157(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_158(bool) -> REF_157.exist
TMP_209(None) = SOLIDITY_CALL require(bool)(REF_158)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete vestToMap[_beneficiary]

IRs:
REF_159(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
vestToMap = delete REF_159 "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
DelFromVestMap(_beneficiary)

IRs:
Emit DelFromVestMap(_beneficiary)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 2861.sol-TokenVesting-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_230(bool) = msg.sender == owner
TMP_231(None) = SOLIDITY_CALL require(bool)(TMP_230)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 2861.sol-TokenVesting-releasableAmount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
vestedAmount(_beneficiary).sub(vestToMap[_beneficiary].released)

IRs:
TMP_222(uint256) = INTERNAL_CALL, TokenVesting.vestedAmount(address)(_beneficiary)
REF_170(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_171(uint256) -> REF_170.released
TMP_223(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_222', 'REF_171'] 
RETURN TMP_223"];
}
// Function: 2861.sol-TokenVesting-release(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = vestToMap[_beneficiary]

IRs:
REF_160(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
value(TokenVesting.tokenToVest) := REF_160(TokenVesting.tokenToVest)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value.exist)

IRs:
REF_161(bool) -> value.exist
TMP_212(None) = SOLIDITY_CALL require(bool)(REF_161)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
unreleased = releasableAmount(_beneficiary)

IRs:
TMP_213(uint256) = INTERNAL_CALL, TokenVesting.releasableAmount(address)(_beneficiary)
unreleased(uint256) := TMP_213(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(unreleased > 0)

IRs:
TMP_214(bool) = unreleased > 0
TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(unreleased + value.released <= value.torelease)

IRs:
REF_162(uint256) -> value.released
TMP_216(uint256) = unreleased + REF_162
REF_163(uint256) -> value.torelease
TMP_217(bool) = TMP_216 <= REF_163
TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
vestToMap[_beneficiary].released = vestToMap[_beneficiary].released.add(unreleased)

IRs:
REF_164(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_165(uint256) -> REF_164.released
REF_166(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
REF_167(uint256) -> REF_166.released
TMP_219(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_167', 'unreleased'] 
REF_165(uint256) (->vestToMap) := TMP_219(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transfer(_beneficiary,unreleased)

IRs:
TMP_220(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256)(_beneficiary,unreleased)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Released(_beneficiary,unreleased)

IRs:
Emit Released(_beneficiary,unreleased)"];
}
// Function: 2861.sol-TokenVesting-transfer(address,uint256)
digraph{
}
// Function: 2861.sol-TokenVesting-transferFrom(address,address,uint256)
digraph{
}
// Function: 2861.sol-TokenVesting-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_155 = CONVERT 0 to address
TMP_156(bool) = newOwner != TMP_155
TMP_157(None) = SOLIDITY_CALL require(bool)(TMP_156)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 2861.sol-TokenVesting-vestedAmount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
value = vestToMap[_beneficiary]

IRs:
REF_172(TokenVesting.tokenToVest) -> vestToMap[_beneficiary]
value(TokenVesting.tokenToVest) := REF_172(TokenVesting.tokenToVest)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
totalBalance = value.torelease

IRs:
REF_173(uint256) -> value.torelease
totalBalance(uint256) := REF_173(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
block.timestamp < value.cliff

IRs:
REF_174(uint256) -> value.cliff
TMP_224(bool) = block.timestamp < REF_174
CONDITION TMP_224"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
5[label="Node Type: IF 5

EXPRESSION:
block.timestamp >= value.start.add(value.duration)

IRs:
REF_175(uint256) -> value.start
REF_177(uint256) -> value.duration
TMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_175', 'REF_177'] 
TMP_226(bool) = block.timestamp >= TMP_225
CONDITION TMP_226"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
totalBalance

IRs:
RETURN totalBalance"];
7[label="Node Type: RETURN 7

EXPRESSION:
totalBalance.mul(block.timestamp.sub(value.start)).div(value.duration)

IRs:
REF_180(uint256) -> value.start
TMP_227(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.timestamp', 'REF_180'] 
TMP_228(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalBalance', 'TMP_227'] 
REF_182(uint256) -> value.duration
TMP_229(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_228', 'REF_182'] 
RETURN TMP_229"];
}
}
