digraph G {
// Function: 3125.sol-NekoToken-NekoToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
administrators[msg.sender] = true

IRs:
REF_0(bool) -> administrators[msg.sender]
REF_0(bool) (->administrators) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ambassadors_[0xa9eB31931417d89b233681dfb319783b1703C998] = true

IRs:
REF_1(bool) -> ambassadors_[970064433941110545698884090444202200350438181272]
REF_1(bool) (->ambassadors_) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ambassadors_[0x3662496Bd906054f535D534c46d130A4ee36624C] = true

IRs:
REF_2(bool) -> ambassadors_[310477370549503350978231953468558615992432222796]
REF_2(bool) (->ambassadors_) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ambassadors_[0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285] = true

IRs:
REF_3(bool) -> ambassadors_[752180421556321703533816132954626702293071168133]
REF_3(bool) (->ambassadors_) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ambassadors_[0xAD6D6c25FCDAb2e737e8de31795df4c6bB6D9Bae] = true

IRs:
REF_4(bool) -> ambassadors_[990095605632593286036999846472272173000953797550]
REF_4(bool) (->ambassadors_) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ambassadors_[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true

IRs:
REF_5(bool) -> ambassadors_[452766396536057077178306851167341941448351481006]
REF_5(bool) (->ambassadors_) := True(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Master = msg.sender

IRs:
Master(address) := msg.sender(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyAmbassadors = true

IRs:
onlyAmbassadors(bool) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
jackpotThreshold = random() * 1e15 * jackpotFactor

IRs:
TMP_0(uint8) = INTERNAL_CALL, NekoToken.random()()
TMP_1(uint8) = TMP_0 * 1000000000000000
TMP_2(uint8) = TMP_1 * jackpotFactor
jackpotThreshold(uint256) := TMP_2(uint8)"];
}
// Function: 3125.sol-NekoToken-antiEarlyWhale(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_)

IRs:
TMP_187(uint256) = INTERNAL_CALL, NekoToken.totalEthereumBalance()()
TMP_188(uint256) = TMP_187 - _amountOfEthereum
TMP_189(bool) = TMP_188 <= ambassadorQuota_
TMP_190(bool) = onlyAmbassadors && TMP_189
CONDITION TMP_190"];
2->3[label="True"];
2->6[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_)

IRs:
REF_76(bool) -> ambassadors_[_customerAddress]
TMP_191(bool) = REF_76 == True
REF_77(uint256) -> ambassadorAccumulatedQuota_[_customerAddress]
TMP_192(uint256) = REF_77 + _amountOfEthereum
TMP_193(bool) = TMP_192 <= ambassadorMaxPurchase_
TMP_194(bool) = TMP_191 && TMP_193
TMP_195(None) = SOLIDITY_CALL require(bool)(TMP_194)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress],_amountOfEthereum)

IRs:
REF_78(uint256) -> ambassadorAccumulatedQuota_[_customerAddress]
REF_80(uint256) -> ambassadorAccumulatedQuota_[_customerAddress]
TMP_196(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_80', '_amountOfEthereum'] 
REF_78(uint256) (->ambassadorAccumulatedQuota_) := TMP_196(uint256)"];
4->5;
5[label="Node Type: _ 5
"];
5->8;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAmbassadors = false

IRs:
onlyAmbassadors(bool) := False(bool)"];
6->7;
7[label="Node Type: _ 7
"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 3125.sol-NekoToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
tokenBalanceLedger_[_customerAddress]

IRs:
REF_39(uint256) -> tokenBalanceLedger_[_customerAddress]
RETURN REF_39"];
}
// Function: 3125.sol-NekoToken-buy(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
purchaseTokens(msg.value,_referredBy)

IRs:
TMP_3(uint256) = INTERNAL_CALL, NekoToken.purchaseTokens(uint256,address)(msg.value,_referredBy)"];
}
// Function: 3125.sol-NekoToken-buyPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tokenSupply_ == 0

IRs:
TMP_79(bool) = tokenSupply_ == 0
CONDITION TMP_79"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
tokenPriceInitial_ + tokenPriceIncremental_

IRs:
TMP_80(uint256) = tokenPriceInitial_ + tokenPriceIncremental_
RETURN TMP_80"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_ethereum = tokensToEthereum_(1e18)

IRs:
TMP_81(uint256) = INTERNAL_CALL, NekoToken.tokensToEthereum_(uint256)(1000000000000000000)
_ethereum(uint256) := TMP_81(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_dividends = SafeMath.div(_ethereum,dividendFee_)

IRs:
TMP_82(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_ethereum', 'dividendFee_'] 
_dividends(uint256) := TMP_82(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_taxedEthereum = SafeMath.add(_ethereum,_dividends)

IRs:
TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_ethereum', '_dividends'] 
_taxedEthereum(uint256) := TMP_83(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
_taxedEthereum

IRs:
RETURN _taxedEthereum"];
}
// Function: 3125.sol-NekoToken-calculateEthereumReceived(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_tokensToSell <= tokenSupply_)

IRs:
TMP_87(bool) = _tokensToSell <= tokenSupply_
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_ethereum = tokensToEthereum_(_tokensToSell)

IRs:
TMP_89(uint256) = INTERNAL_CALL, NekoToken.tokensToEthereum_(uint256)(_tokensToSell)
_ethereum(uint256) := TMP_89(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_dividends = SafeMath.div(_ethereum,dividendFee_)

IRs:
TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_ethereum', 'dividendFee_'] 
_dividends(uint256) := TMP_90(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_taxedEthereum = SafeMath.sub(_ethereum,_dividends)

IRs:
TMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereum', '_dividends'] 
_taxedEthereum(uint256) := TMP_91(uint256)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_taxedEthereum

IRs:
RETURN _taxedEthereum"];
}
// Function: 3125.sol-NekoToken-calculateTokensReceived(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_dividends = SafeMath.div(_ethereumToSpend,dividendFee_)

IRs:
TMP_84(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_ethereumToSpend', 'dividendFee_'] 
_dividends(uint256) := TMP_84(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_taxedEthereum = SafeMath.sub(_ethereumToSpend,_dividends)

IRs:
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereumToSpend', '_dividends'] 
_taxedEthereum(uint256) := TMP_85(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_amountOfTokens = ethereumToTokens_(_taxedEthereum)

IRs:
TMP_86(uint256) = INTERNAL_CALL, NekoToken.ethereumToTokens_(uint256)(_taxedEthereum)
_amountOfTokens(uint256) := TMP_86(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
_amountOfTokens

IRs:
RETURN _amountOfTokens"];
}
// Function: 3125.sol-NekoToken-checkJackpot(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
jackpotCounter >= jackpotThreshold

IRs:
TMP_133(bool) = jackpotCounter >= jackpotThreshold
CONDITION TMP_133"];
1->2[label="True"];
1->10[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
winnings = jackpot_

IRs:
winnings(uint256) := jackpot_(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
referralBalance_[_jackpotAddress] = SafeMath.add(referralBalance_[_jackpotAddress],jackpot_)

IRs:
REF_70(uint256) -> referralBalance_[_jackpotAddress]
REF_72(uint256) -> referralBalance_[_jackpotAddress]
TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_72', 'jackpot_'] 
REF_70(uint256) (->referralBalance_) := TMP_134(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
jackpot_ = 0

IRs:
jackpot_(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
jackpotCounter = 0

IRs:
jackpotCounter(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
jackpotThreshold = random() * 1e15 * jackpotFactor

IRs:
TMP_135(uint8) = INTERNAL_CALL, NekoToken.random()()
TMP_136(uint8) = TMP_135 * 1000000000000000
TMP_137(uint8) = TMP_136 * jackpotFactor
jackpotThreshold(uint256) := TMP_137(uint8)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
lastWinner = _jackpotAddress

IRs:
lastWinner(address) := _jackpotAddress(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onWin(msg.sender,winnings)

IRs:
Emit onWin(msg.sender,winnings)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
winnings

IRs:
RETURN winnings"];
10[label="Node Type: END_IF 10
"];
}
// Function: 3125.sol-NekoToken-disableInitialStage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
onlyAmbassadors = true

IRs:
onlyAmbassadors(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, NekoToken.onlyAdministrator()()"];
2->1;
}
// Function: 3125.sol-NekoToken-dividendsOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_40(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_69(uint256) = profitPerShare_ * REF_40
TMP_70 = CONVERT TMP_69 to int256
REF_41(int256) -> payoutsTo_[_customerAddress]
TMP_71(int256) = TMP_70 - REF_41
TMP_72 = CONVERT TMP_71 to uint256
TMP_73(uint256) = TMP_72 / magnitude
RETURN TMP_73"];
}
// Function: 3125.sol-NekoToken-ethereumToTokens_(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_tokenPriceInitial = tokenPriceInitial_ * 1e18

IRs:
TMP_139(uint256) = tokenPriceInitial_ * 1000000000000000000
_tokenPriceInitial(uint256) := TMP_139(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_tokensReceived = ((SafeMath.sub((sqrt((_tokenPriceInitial ** 2) + (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18)) + (((tokenPriceIncremental_) ** 2) * (tokenSupply_ ** 2)) + (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_))),_tokenPriceInitial)) / (tokenPriceIncremental_)) - (tokenSupply_)

IRs:
TMP_140(uint256) = _tokenPriceInitial ** 2
TMP_141(uint256) = tokenPriceIncremental_ * 1000000000000000000
TMP_142(uint256) = 2 * TMP_141
TMP_143(uint256) = _ethereum * 1000000000000000000
TMP_144(uint256) = TMP_142 * TMP_143
TMP_145(uint256) = TMP_140 + TMP_144
TMP_146(uint256) = tokenPriceIncremental_ ** 2
TMP_147(uint256) = tokenSupply_ ** 2
TMP_148(uint256) = TMP_146 * TMP_147
TMP_149(uint256) = TMP_145 + TMP_148
TMP_150(uint256) = 2 * tokenPriceIncremental_
TMP_151(uint256) = TMP_150 * _tokenPriceInitial
TMP_152(uint256) = TMP_151 * tokenSupply_
TMP_153(uint256) = TMP_149 + TMP_152
TMP_154(uint256) = INTERNAL_CALL, NekoToken.sqrt(uint256)(TMP_153)
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_154', '_tokenPriceInitial'] 
TMP_156(uint256) = TMP_155 / tokenPriceIncremental_
TMP_157(uint256) = TMP_156 - tokenSupply_
_tokensReceived(uint256) := TMP_157(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
_tokensReceived

IRs:
RETURN _tokensReceived"];
}
// Function: 3125.sol-NekoToken-exit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_tokens = tokenBalanceLedger_[_customerAddress]

IRs:
REF_9(uint256) -> tokenBalanceLedger_[_customerAddress]
_tokens(uint256) := REF_9(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_tokens > 0

IRs:
TMP_11(bool) = _tokens > 0
CONDITION TMP_11"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
sell(_tokens)

IRs:
INTERNAL_CALL, NekoToken.sell(uint256)(_tokens)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
withdraw()

IRs:
INTERNAL_CALL, NekoToken.withdraw()()"];
}
// Function: 3125.sol-NekoToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
purchaseTokens(msg.value,0x0)

IRs:
TMP_4(uint256) = INTERNAL_CALL, NekoToken.purchaseTokens(uint256,address)(msg.value,0)"];
}
// Function: 3125.sol-NekoToken-getLastWinner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
lastWinner

IRs:
RETURN lastWinner"];
}
// Function: 3125.sol-NekoToken-jackpot()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
jackpot_

IRs:
RETURN jackpot_"];
}
// Function: 3125.sol-NekoToken-myDividends(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->3;
3[label="Node Type: IF 3

EXPRESSION:
_includeReferralBonus

IRs:
CONDITION _includeReferralBonus"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
dividendsOf(_customerAddress) + referralBalance_[_customerAddress]

IRs:
TMP_66(uint256) = INTERNAL_CALL, NekoToken.dividendsOf(address)(_customerAddress)
REF_38(uint256) -> referralBalance_[_customerAddress]
TMP_67(uint256) = TMP_66 + REF_38
RETURN TMP_67"];
5[label="Node Type: RETURN 5

EXPRESSION:
dividendsOf(_customerAddress)

IRs:
TMP_68(uint256) = INTERNAL_CALL, NekoToken.dividendsOf(address)(_customerAddress)
RETURN TMP_68"];
}
// Function: 3125.sol-NekoToken-myTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
balanceOf(_customerAddress)

IRs:
TMP_65(uint256) = INTERNAL_CALL, NekoToken.balanceOf(address)(_customerAddress)
RETURN TMP_65"];
}
// Function: 3125.sol-NekoToken-onlyAdministrator()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(administrators[_customerAddress])

IRs:
REF_75(bool) -> administrators[_customerAddress]
TMP_186(None) = SOLIDITY_CALL require(bool)(REF_75)"];
2->3;
3[label="Node Type: _ 3
"];
}
// Function: 3125.sol-NekoToken-onlyBagholders()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(myTokens() > 0)

IRs:
TMP_180(uint256) = INTERNAL_CALL, NekoToken.myTokens()()
TMP_181(bool) = TMP_180 > 0
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3125.sol-NekoToken-onlyStronghands()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(myDividends(true) > 0)

IRs:
TMP_183(uint256) = INTERNAL_CALL, NekoToken.myDividends(bool)(True)
TMP_184(bool) = TMP_183 > 0
TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 3125.sol-NekoToken-purchaseTokens(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->29;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_undividedDividends = SafeMath.div(_incomingEthereum,dividendFee_)

IRs:
TMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_incomingEthereum', 'dividendFee_'] 
_undividedDividends(uint256) := TMP_92(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_referralBonus = SafeMath.div(_undividedDividends,4)

IRs:
TMP_93(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_undividedDividends', '4'] 
_referralBonus(uint256) := TMP_93(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_dividends = SafeMath.sub(_undividedDividends,_referralBonus)

IRs:
TMP_94(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_undividedDividends', '_referralBonus'] 
_dividends(uint256) := TMP_94(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_dividends = SafeMath.sub(_dividends,_referralBonus)

IRs:
TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_dividends', '_referralBonus'] 
_dividends(uint256) := TMP_95(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_taxedEthereum = SafeMath.sub(_incomingEthereum,_undividedDividends)

IRs:
TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_incomingEthereum', '_undividedDividends'] 
_taxedEthereum(uint256) := TMP_96(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
_amountOfTokens = ethereumToTokens_(_taxedEthereum)

IRs:
TMP_97(uint256) = INTERNAL_CALL, NekoToken.ethereumToTokens_(uint256)(_taxedEthereum)
_amountOfTokens(uint256) := TMP_97(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
_fee = _dividends * magnitude

IRs:
TMP_98(uint256) = _dividends * magnitude
_fee(uint256) := TMP_98(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
jackpotCounter += _incomingEthereum

IRs:
jackpotCounter(uint256) = jackpotCounter + _incomingEthereum"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_))

IRs:
TMP_99(bool) = _amountOfTokens > 0
TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_amountOfTokens', 'tokenSupply_'] 
TMP_101(bool) = TMP_100 > tokenSupply_
TMP_102(bool) = TMP_99 && TMP_101
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
_referredBy != 0x0000000000000000000000000000000000000000 && _referredBy != _customerAddress && tokenBalanceLedger_[_referredBy] >= stakingRequirement

IRs:
TMP_104(bool) = _referredBy != 0
TMP_105(bool) = _referredBy != _customerAddress
TMP_106(bool) = TMP_104 && TMP_105
REF_56(uint256) -> tokenBalanceLedger_[_referredBy]
TMP_107(bool) = REF_56 >= stakingRequirement
TMP_108(bool) = TMP_106 && TMP_107
CONDITION TMP_108"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy],_referralBonus)

IRs:
REF_57(uint256) -> referralBalance_[_referredBy]
REF_59(uint256) -> referralBalance_[_referredBy]
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_59', '_referralBonus'] 
REF_57(uint256) (->referralBalance_) := TMP_109(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
jackpot_ = SafeMath.add(jackpot_,_referralBonus)

IRs:
TMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['jackpot_', '_referralBonus'] 
jackpot_(uint256) := TMP_110(uint256)"];
13->16;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
jackpot_ = SafeMath.add(jackpot_,_referralBonus)

IRs:
TMP_111(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['jackpot_', '_referralBonus'] 
jackpot_(uint256) := TMP_111(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
referralBalance_[Master] = SafeMath.add(referralBalance_[Master],_referralBonus)

IRs:
REF_62(uint256) -> referralBalance_[Master]
REF_64(uint256) -> referralBalance_[Master]
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_64', '_referralBonus'] 
REF_62(uint256) (->referralBalance_) := TMP_112(uint256)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
tokenSupply_ > 0

IRs:
TMP_113(bool) = tokenSupply_ > 0
CONDITION TMP_113"];
17->18[label="True"];
17->21[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
tokenSupply_ = SafeMath.add(tokenSupply_,_amountOfTokens)

IRs:
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenSupply_', '_amountOfTokens'] 
tokenSupply_(uint256) := TMP_114(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
profitPerShare_ += (_dividends * magnitude / (tokenSupply_))

IRs:
TMP_115(uint256) = _dividends * magnitude
TMP_116(uint256) = TMP_115 / tokenSupply_
profitPerShare_(uint256) = profitPerShare_ + TMP_116"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
_fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / (tokenSupply_))))

IRs:
TMP_117(uint256) = _dividends * magnitude
TMP_118(uint256) = TMP_117 / tokenSupply_
TMP_119(uint256) = _amountOfTokens * TMP_118
TMP_120(uint256) = _fee - TMP_119
TMP_121(uint256) = _fee - TMP_120
_fee(uint256) := TMP_121(uint256)"];
20->22;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
tokenSupply_ = _amountOfTokens

IRs:
tokenSupply_(uint256) := _amountOfTokens(uint256)"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress],_amountOfTokens)

IRs:
REF_66(uint256) -> tokenBalanceLedger_[_customerAddress]
REF_68(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_122(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_68', '_amountOfTokens'] 
REF_66(uint256) (->tokenBalanceLedger_) := TMP_122(uint256)"];
23->24;
24[label="Node Type: NEW VARIABLE 24

EXPRESSION:
_updatedPayouts = int256((profitPerShare_ * _amountOfTokens) - _fee)

IRs:
TMP_123(uint256) = profitPerShare_ * _amountOfTokens
TMP_124(uint256) = TMP_123 - _fee
TMP_125 = CONVERT TMP_124 to int256
_updatedPayouts(int256) := TMP_125(int256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
payoutsTo_[_customerAddress] += _updatedPayouts

IRs:
REF_69(int256) -> payoutsTo_[_customerAddress]
REF_69(-> payoutsTo_) = REF_69 + _updatedPayouts"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
onTokenPurchase(_customerAddress,_incomingEthereum,_amountOfTokens,_referredBy)

IRs:
Emit onTokenPurchase(_customerAddress,_incomingEthereum,_amountOfTokens,_referredBy)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
checkJackpot(msg.sender)

IRs:
TMP_127(uint256) = INTERNAL_CALL, NekoToken.checkJackpot(address)(msg.sender)"];
27->28;
28[label="Node Type: RETURN 28

EXPRESSION:
_amountOfTokens

IRs:
RETURN _amountOfTokens"];
29[label="Node Type: EXPRESSION 29

EXPRESSION:
antiEarlyWhale(_incomingEthereum)

IRs:
MODIFIER_CALL, NekoToken.antiEarlyWhale(uint256)(_incomingEthereum)"];
29->1;
}
// Function: 3125.sol-NekoToken-random()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint8(uint256(keccak256()(block.timestamp,block.difficulty)) % 251)

IRs:
TMP_129(bytes32) = SOLIDITY_CALL keccak256()(block.timestamp,block.difficulty)
TMP_130 = CONVERT TMP_129 to uint256
TMP_131(uint256) = TMP_130 % 251
TMP_132 = CONVERT TMP_131 to uint8
RETURN TMP_132"];
}
// Function: 3125.sol-NekoToken-reinvest()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_dividends = myDividends(false)

IRs:
TMP_5(uint256) = INTERNAL_CALL, NekoToken.myDividends(bool)(False)
_dividends(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
payoutsTo_[_customerAddress] += int256(_dividends * magnitude)

IRs:
REF_6(int256) -> payoutsTo_[_customerAddress]
TMP_6(uint256) = _dividends * magnitude
TMP_7 = CONVERT TMP_6 to int256
REF_6(-> payoutsTo_) = REF_6 + TMP_7"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_dividends += referralBalance_[_customerAddress]

IRs:
REF_7(uint256) -> referralBalance_[_customerAddress]
_dividends(uint256) = _dividends + REF_7"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
referralBalance_[_customerAddress] = 0

IRs:
REF_8(uint256) -> referralBalance_[_customerAddress]
REF_8(uint256) (->referralBalance_) := 0(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_tokens = purchaseTokens(_dividends,0x0)

IRs:
TMP_8(uint256) = INTERNAL_CALL, NekoToken.purchaseTokens(uint256,address)(_dividends,0)
_tokens(uint256) := TMP_8(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onReinvestment(_customerAddress,_dividends,_tokens)

IRs:
Emit onReinvestment(_customerAddress,_dividends,_tokens)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyStronghands()

IRs:
MODIFIER_CALL, NekoToken.onlyStronghands()()"];
8->1;
}
// Function: 3125.sol-NekoToken-sell(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->15;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amountOfTokens <= tokenBalanceLedger_[_customerAddress])

IRs:
REF_14(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_20(bool) = _amountOfTokens <= REF_14
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_tokens = _amountOfTokens

IRs:
_tokens(uint256) := _amountOfTokens(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_ethereum = tokensToEthereum_(_tokens)

IRs:
TMP_22(uint256) = INTERNAL_CALL, NekoToken.tokensToEthereum_(uint256)(_tokens)
_ethereum(uint256) := TMP_22(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_dividends = SafeMath.div(_ethereum,dividendFee_)

IRs:
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_ethereum', 'dividendFee_'] 
_dividends(uint256) := TMP_23(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_taxedEthereum = SafeMath.sub(_ethereum,_dividends)

IRs:
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereum', '_dividends'] 
_taxedEthereum(uint256) := TMP_24(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tokenSupply_ = SafeMath.sub(tokenSupply_,_tokens)

IRs:
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokenSupply_', '_tokens'] 
tokenSupply_(uint256) := TMP_25(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress],_tokens)

IRs:
REF_18(uint256) -> tokenBalanceLedger_[_customerAddress]
REF_20(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_tokens'] 
REF_18(uint256) (->tokenBalanceLedger_) := TMP_26(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
_updatedPayouts = int256(profitPerShare_ * _tokens + (_taxedEthereum * magnitude))

IRs:
TMP_27(uint256) = profitPerShare_ * _tokens
TMP_28(uint256) = _taxedEthereum * magnitude
TMP_29(uint256) = TMP_27 + TMP_28
TMP_30 = CONVERT TMP_29 to int256
_updatedPayouts(int256) := TMP_30(int256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
payoutsTo_[_customerAddress] -= _updatedPayouts

IRs:
REF_21(int256) -> payoutsTo_[_customerAddress]
REF_21(-> payoutsTo_) = REF_21 - _updatedPayouts"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
tokenSupply_ > 0

IRs:
TMP_31(bool) = tokenSupply_ > 0
CONDITION TMP_31"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
profitPerShare_ = SafeMath.add(profitPerShare_,(_dividends * magnitude) / tokenSupply_)

IRs:
TMP_32(uint256) = _dividends * magnitude
TMP_33(uint256) = TMP_32 / tokenSupply_
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['profitPerShare_', 'TMP_33'] 
profitPerShare_(uint256) := TMP_34(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onTokenSell(_customerAddress,_tokens,_taxedEthereum)

IRs:
Emit onTokenSell(_customerAddress,_tokens,_taxedEthereum)"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
onlyBagholders()

IRs:
MODIFIER_CALL, NekoToken.onlyBagholders()()"];
15->1;
}
// Function: 3125.sol-NekoToken-sellPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
tokenSupply_ == 0

IRs:
TMP_74(bool) = tokenSupply_ == 0
CONDITION TMP_74"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
tokenPriceInitial_ - tokenPriceIncremental_

IRs:
TMP_75(uint256) = tokenPriceInitial_ - tokenPriceIncremental_
RETURN TMP_75"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_ethereum = tokensToEthereum_(1e18)

IRs:
TMP_76(uint256) = INTERNAL_CALL, NekoToken.tokensToEthereum_(uint256)(1000000000000000000)
_ethereum(uint256) := TMP_76(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_dividends = SafeMath.div(_ethereum,dividendFee_)

IRs:
TMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_ethereum', 'dividendFee_'] 
_dividends(uint256) := TMP_77(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_taxedEthereum = SafeMath.sub(_ethereum,_dividends)

IRs:
TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethereum', '_dividends'] 
_taxedEthereum(uint256) := TMP_78(uint256)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
_taxedEthereum

IRs:
RETURN _taxedEthereum"];
}
// Function: 3125.sol-NekoToken-setAdministrator(address,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
administrators[_identifier] = _status

IRs:
REF_36(bool) -> administrators[_identifier]
REF_36(bool) (->administrators) := _status(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, NekoToken.onlyAdministrator()()"];
2->1;
}
// Function: 3125.sol-NekoToken-setJackpotFactor(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
jackpotFactor = _factor

IRs:
jackpotFactor(uint256) := _factor(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, NekoToken.onlyAdministrator()()"];
2->1;
}
// Function: 3125.sol-NekoToken-setName(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, NekoToken.onlyAdministrator()()"];
2->1;
}
// Function: 3125.sol-NekoToken-setStakingRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stakingRequirement = _amountOfTokens

IRs:
stakingRequirement(uint256) := _amountOfTokens(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, NekoToken.onlyAdministrator()()"];
2->1;
}
// Function: 3125.sol-NekoToken-setSymbol(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, NekoToken.onlyAdministrator()()"];
2->1;
}
// Function: 3125.sol-NekoToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
dividendFee_ = 4

IRs:
dividendFee_(uint8) := 4(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
tokenPriceInitial_ = 100000000000

IRs:
tokenPriceInitial_(uint256) := 100000000000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
tokenPriceIncremental_ = 10000000000

IRs:
tokenPriceIncremental_(uint256) := 10000000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
magnitude = 2 ** 64

IRs:
TMP_179(uint256) = 2 ** 64
magnitude(uint256) := TMP_179(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
ambassadorMaxPurchase_ = 5000000000000000000

IRs:
ambassadorMaxPurchase_(uint256) := 5000000000000000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
ambassadorQuota_ = 10000000000000000000

IRs:
ambassadorQuota_(uint256) := 10000000000000000000(uint256)"];
}
// Function: 3125.sol-NekoToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = NEKO TOKEN

IRs:
name(string) := NEKO TOKEN(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = NEKO

IRs:
symbol(string) := NEKO(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
stakingRequirement = 100e18

IRs:
stakingRequirement(uint256) := 100000000000000000000(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
tokenSupply_ = 0

IRs:
tokenSupply_(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
jackpot_ = 0

IRs:
jackpot_(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
onlyAmbassadors = true

IRs:
onlyAmbassadors(bool) := True(bool)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
jackpotFactor = 250

IRs:
jackpotFactor(uint256) := 250(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
jackpotCounter = 0

IRs:
jackpotCounter(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
lastWinner = 0x0000000000000000000000000000000000000000

IRs:
lastWinner(address) := 0(address)"];
}
// Function: 3125.sol-NekoToken-sqrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = (x + 1) / 2

IRs:
TMP_173(uint256) = x + 1
TMP_174(uint256) = TMP_173 / 2
z(uint256) := TMP_174(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
y = x

IRs:
y(uint256) := x(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
z < y

IRs:
TMP_175(bool) = z < y
CONDITION TMP_175"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
y = z

IRs:
y(uint256) := z(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
z = (x / z + z) / 2

IRs:
TMP_176(uint256) = x / z
TMP_177(uint256) = TMP_176 + z
TMP_178(uint256) = TMP_177 / 2
z(uint256) := TMP_178(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
y

IRs:
RETURN y"];
}
// Function: 3125.sol-NekoToken-tokensToEthereum_(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokens_ = (_tokens + 1e18)

IRs:
TMP_158(uint256) = _tokens + 1000000000000000000
tokens_(uint256) := TMP_158(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_tokenSupply = (tokenSupply_ + 1e18)

IRs:
TMP_159(uint256) = tokenSupply_ + 1000000000000000000
_tokenSupply(uint256) := TMP_159(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_etherReceived = (SafeMath.sub((((tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))) - tokenPriceIncremental_) * (tokens_ - 1e18)),(tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2) / 1e18)

IRs:
TMP_160(uint256) = _tokenSupply / 1000000000000000000
TMP_161(uint256) = tokenPriceIncremental_ * TMP_160
TMP_162(uint256) = tokenPriceInitial_ + TMP_161
TMP_163(uint256) = TMP_162 - tokenPriceIncremental_
TMP_164(uint256) = tokens_ - 1000000000000000000
TMP_165(uint256) = TMP_163 * TMP_164
TMP_166(uint256) = tokens_ ** 2
TMP_167(uint256) = TMP_166 - tokens_
TMP_168(uint256) = TMP_167 / 1000000000000000000
TMP_169(uint256) = tokenPriceIncremental_ * TMP_168
TMP_170(uint256) = TMP_169 / 2
TMP_171(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_165', 'TMP_170'] 
TMP_172(uint256) = TMP_171 / 1000000000000000000
_etherReceived(uint256) := TMP_172(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
_etherReceived

IRs:
RETURN _etherReceived"];
}
// Function: 3125.sol-NekoToken-totalEthereumBalance()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
this.balance

IRs:
REF_37(uint256) = SOLIDITY_CALL balance(address)(this)
RETURN REF_37"];
}
// Function: 3125.sol-NekoToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
tokenSupply_

IRs:
RETURN tokenSupply_"];
}
// Function: 3125.sol-NekoToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->17;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress])

IRs:
TMP_37 = UnaryType.BANG onlyAmbassadors 
REF_23(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_38(bool) = _amountOfTokens <= REF_23
TMP_39(bool) = TMP_37 && TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
myDividends(true) > 0

IRs:
TMP_41(uint256) = INTERNAL_CALL, NekoToken.myDividends(bool)(True)
TMP_42(bool) = TMP_41 > 0
CONDITION TMP_42"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
withdraw()

IRs:
INTERNAL_CALL, NekoToken.withdraw()()"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
_tokenFee = SafeMath.div(_amountOfTokens,dividendFee_)

IRs:
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_amountOfTokens', 'dividendFee_'] 
_tokenFee(uint256) := TMP_44(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
_taxedTokens = SafeMath.sub(_amountOfTokens,_tokenFee)

IRs:
TMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_amountOfTokens', '_tokenFee'] 
_taxedTokens(uint256) := TMP_45(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
_dividends = tokensToEthereum_(_tokenFee)

IRs:
TMP_46(uint256) = INTERNAL_CALL, NekoToken.tokensToEthereum_(uint256)(_tokenFee)
_dividends(uint256) := TMP_46(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
tokenSupply_ = SafeMath.sub(tokenSupply_,_tokenFee)

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokenSupply_', '_tokenFee'] 
tokenSupply_(uint256) := TMP_47(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress],_amountOfTokens)

IRs:
REF_27(uint256) -> tokenBalanceLedger_[_customerAddress]
REF_29(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', '_amountOfTokens'] 
REF_27(uint256) (->tokenBalanceLedger_) := TMP_48(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress],_taxedTokens)

IRs:
REF_30(uint256) -> tokenBalanceLedger_[_toAddress]
REF_32(uint256) -> tokenBalanceLedger_[_toAddress]
TMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', '_taxedTokens'] 
REF_30(uint256) (->tokenBalanceLedger_) := TMP_49(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
payoutsTo_[_customerAddress] -= int256(profitPerShare_ * _amountOfTokens)

IRs:
REF_33(int256) -> payoutsTo_[_customerAddress]
TMP_50(uint256) = profitPerShare_ * _amountOfTokens
TMP_51 = CONVERT TMP_50 to int256
REF_33(-> payoutsTo_) = REF_33 - TMP_51"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
payoutsTo_[_toAddress] += int256(profitPerShare_ * _taxedTokens)

IRs:
REF_34(int256) -> payoutsTo_[_toAddress]
TMP_52(uint256) = profitPerShare_ * _taxedTokens
TMP_53 = CONVERT TMP_52 to int256
REF_34(-> payoutsTo_) = REF_34 + TMP_53"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
profitPerShare_ = SafeMath.add(profitPerShare_,(_dividends * magnitude) / tokenSupply_)

IRs:
TMP_54(uint256) = _dividends * magnitude
TMP_55(uint256) = TMP_54 / tokenSupply_
TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['profitPerShare_', 'TMP_55'] 
profitPerShare_(uint256) := TMP_56(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_customerAddress,_toAddress,_taxedTokens)

IRs:
Emit Transfer(_customerAddress,_toAddress,_taxedTokens)"];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
onlyBagholders()

IRs:
MODIFIER_CALL, NekoToken.onlyBagholders()()"];
17->1;
}
// Function: 3125.sol-NekoToken-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_dividends = myDividends(false)

IRs:
TMP_14(uint256) = INTERNAL_CALL, NekoToken.myDividends(bool)(False)
_dividends(uint256) := TMP_14(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
payoutsTo_[_customerAddress] += int256(_dividends * magnitude)

IRs:
REF_10(int256) -> payoutsTo_[_customerAddress]
TMP_15(uint256) = _dividends * magnitude
TMP_16 = CONVERT TMP_15 to int256
REF_10(-> payoutsTo_) = REF_10 + TMP_16"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_dividends += referralBalance_[_customerAddress]

IRs:
REF_11(uint256) -> referralBalance_[_customerAddress]
_dividends(uint256) = _dividends + REF_11"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
referralBalance_[_customerAddress] = 0

IRs:
REF_12(uint256) -> referralBalance_[_customerAddress]
REF_12(uint256) (->referralBalance_) := 0(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_customerAddress.transfer(_dividends)

IRs:
Transfer dest:_customerAddress value:_dividends"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onWithdraw(_customerAddress,_dividends)

IRs:
Emit onWithdraw(_customerAddress,_dividends)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyStronghands()

IRs:
MODIFIER_CALL, NekoToken.onlyStronghands()()"];
8->1;
}
// Function: 3125.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_206(uint256) = a + b
c(uint256) := TMP_206(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_207(bool) = c >= a
TMP_208(None) = SOLIDITY_CALL assert(bool)(TMP_207)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3125.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_202(uint256) = a / b
c(uint256) := TMP_202(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3125.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_197(bool) = a == 0
CONDITION TMP_197"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_198(uint256) = a * b
c(uint256) := TMP_198(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_199(uint256) = c / a
TMP_200(bool) = TMP_199 == b
TMP_201(None) = SOLIDITY_CALL assert(bool)(TMP_200)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 3125.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_203(bool) = b <= a
TMP_204(None) = SOLIDITY_CALL assert(bool)(TMP_203)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_205(uint256) = a - b
RETURN TMP_205"];
}
}
