digraph G {
// Function: 399.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_23(bool) = msg.sender == owner
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 399.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_18 = CONVERT 0 to address
TMP_19(bool) = newOwner != TMP_18
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 399.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 399.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a / b

IRs:
TMP_5(uint256) = a / b
RETURN TMP_5"];
}
// Function: 399.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 399.sol-SafeMath-sqrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = ((add(x,1)) / 2)

IRs:
TMP_12(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(x,1)
TMP_13(uint256) = TMP_12 / 2
z(uint256) := TMP_13(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
y = x

IRs:
y(uint256) := x(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
z < y

IRs:
TMP_14(bool) = z < y
CONDITION TMP_14"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
y = z

IRs:
y(uint256) := z(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
z = ((add((x / z),z)) / 2)

IRs:
TMP_15(uint256) = x / z
TMP_16(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(TMP_15,z)
TMP_17(uint256) = TMP_16 / 2
z(uint256) := TMP_17(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
y

IRs:
RETURN y"];
}
// Function: 399.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 399.sol-Saturn-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
playerOf[_owner].tokenBalance

IRs:
REF_0(Saturn.Player) -> playerOf[_owner]
REF_1(uint256) -> REF_0.tokenBalance
RETURN REF_1"];
}
// Function: 399.sol-Saturn-buy(Saturn.Player,Saturn.InternalBuyEvent,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX)

IRs:
TMP_122(bool) = now < finishTime
TMP_123(bool) = _amount >= BUY_AMOUNT_MIN
TMP_124(bool) = TMP_122 && TMP_123
TMP_125(bool) = _amount <= BUY_AMOUNT_MAX
TMP_126(bool) = TMP_124 && TMP_125
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_day = (now / 86400) * 86400

IRs:
TMP_128(uint256) = now / 86400
TMP_129(uint256) = TMP_128 * 86400
_day(uint256) := TMP_129(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_backEth = 0

IRs:
_backEth(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_eth = _amount

IRs:
_eth(uint256) := _amount(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
totalPot < 200000000000000000000

IRs:
TMP_130(bool) = totalPot < 200000000000000000000
CONDITION TMP_130"];
5->6[label="True"];
5->10[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
_eth >= 5000000000000000000

IRs:
TMP_131(bool) = _eth >= 5000000000000000000
CONDITION TMP_131"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_backEth = _eth.sub(5000000000000000000)

IRs:
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_eth', '5000000000000000000'] 
_backEth(uint256) := TMP_132(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_eth = 5000000000000000000

IRs:
_eth(uint256) := 5000000000000000000(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
txCount = txCount + 1

IRs:
TMP_133(uint64) = txCount + 1
txCount(uint64) := TMP_133(uint64)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_buyEvent.flag1 += txCount * 10

IRs:
REF_85(uint256) -> _buyEvent.flag1
TMP_134(uint64) = txCount * 10
REF_85(-> _buyEvent) = REF_85 + TMP_134"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_player.ethTotal = _player.ethTotal.add(_eth)

IRs:
REF_86(uint256) -> _player.ethTotal
REF_87(uint256) -> _player.ethTotal
TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_87', '_eth'] 
REF_86(uint256) (->_player) := TMP_135(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
totalPot = totalPot.add(_eth)

IRs:
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalPot', '_eth'] 
totalPot(uint256) := TMP_136(uint256)"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
_newTotalSupply = calculateTotalSupply(totalPot)

IRs:
TMP_137(uint256) = INTERNAL_CALL, Saturn.calculateTotalSupply(uint256)(totalPot)
_newTotalSupply(uint256) := TMP_137(uint256)"];
15->16;
16[label="Node Type: NEW VARIABLE 16

EXPRESSION:
_tokenAmount = _newTotalSupply.sub(totalSupply)

IRs:
TMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_newTotalSupply', 'totalSupply'] 
_tokenAmount(uint256) := TMP_138(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
_player.tokenBalance = _player.tokenBalance.add(_tokenAmount)

IRs:
REF_91(uint256) -> _player.tokenBalance
REF_92(uint256) -> _player.tokenBalance
TMP_139(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_92', '_tokenAmount'] 
REF_91(uint256) (->_player) := TMP_139(uint256)"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
_player.tokenDay == _day

IRs:
REF_94(uint256) -> _player.tokenDay
TMP_140(bool) = REF_94 == _day
CONDITION TMP_140"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
_player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount)

IRs:
REF_95(uint256) -> _player.tokenDayBalance
REF_96(uint256) -> _player.tokenDayBalance
TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_96', '_tokenAmount'] 
REF_95(uint256) (->_player) := TMP_141(uint256)"];
19->22;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
_player.tokenDay = _day

IRs:
REF_98(uint256) -> _player.tokenDay
REF_98(uint256) (->_player) := _day(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
_player.tokenDayBalance = _tokenAmount

IRs:
REF_99(uint256) -> _player.tokenDayBalance
REF_99(uint256) (->_player) := _tokenAmount(uint256)"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
updatePrice(_newTotalSupply)

IRs:
INTERNAL_CALL, Saturn.updatePrice(uint256)(_newTotalSupply)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
handlePot(_day,_eth,_newTotalSupply,_tokenAmount,_player,_buyEvent)

IRs:
INTERNAL_CALL, Saturn.handlePot(uint256,uint256,uint256,uint256,Saturn.Player,Saturn.InternalBuyEvent)(_day,_eth,_newTotalSupply,_tokenAmount,_player,_buyEvent)"];
24->25;
25[label="Node Type: IF 25

EXPRESSION:
_backEth > 0

IRs:
TMP_144(bool) = _backEth > 0
CONDITION TMP_144"];
25->26[label="True"];
25->27[label="False"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
_player.ethBalance = _player.ethBalance.add(_backEth)

IRs:
REF_100(uint256) -> _player.ethBalance
REF_101(uint256) -> _player.ethBalance
TMP_145(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_101', '_backEth'] 
REF_100(uint256) (->_player) := TMP_145(uint256)"];
26->27;
27[label="Node Type: END_IF 27
"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
sendFeeIfAvailable()

IRs:
INTERNAL_CALL, Saturn.sendFeeIfAvailable()()"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
emitEndTxEvents(_eth,_tokenAmount,_buyEvent)

IRs:
INTERNAL_CALL, Saturn.emitEndTxEvents(uint256,uint256,Saturn.InternalBuyEvent)(_eth,_tokenAmount,_buyEvent)"];
}
// Function: 399.sol-Saturn-calculateTotalSupply(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_newTotalPot.mul(10000000000000000000000000000).add(193600000000000000000000000000000000000000000000).sqrt().sub(440000000000000000000000)

IRs:
TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_newTotalPot', '10000000000000000000000000000'] 
TMP_313(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_312', '193600000000000000000000000000000000000000000000'] 
TMP_314(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sqrt(uint256), arguments:['TMP_313'] 
TMP_315(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_314', '440000000000000000000000'] 
RETURN TMP_315"];
}
// Function: 399.sol-Saturn-changeFeeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_feeOwner != feeOwner && _feeOwner != address(0))

IRs:
TMP_318(bool) = _feeOwner != feeOwner
TMP_319 = CONVERT 0 to address
TMP_320(bool) = _feeOwner != TMP_319
TMP_321(bool) = TMP_318 && TMP_320
TMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feeOwner = _feeOwner

IRs:
feeOwner(address) := _feeOwner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 399.sol-Saturn-constructor(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTime >= now && _feeOwner != address(0))

IRs:
TMP_30(bool) = _startTime >= now
TMP_31 = CONVERT 0 to address
TMP_32(bool) = _feeOwner != TMP_31
TMP_33(bool) = TMP_30 && TMP_32
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
finishTime = _startTime + TIME_DURATION_MAX

IRs:
TMP_35(uint256) = _startTime + TIME_DURATION_MAX
finishTime(uint256) := TMP_35(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply = 0

IRs:
totalSupply(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
price = 88000000000000

IRs:
price(uint256) := 88000000000000(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
feeOwner = _feeOwner

IRs:
feeOwner(address) := _feeOwner(address)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 399.sol-Saturn-emitEndTxEvents(uint256,uint256,Saturn.InternalBuyEvent)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Transfer(address(this),msg.sender,_tokenAmount)

IRs:
TMP_285 = CONVERT this to address
Emit Transfer(TMP_285,msg.sender,_tokenAmount)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Buy(address(this),msg.sender,_eth,_tokenAmount,totalSupply,totalPot,sharePot,finalPot,luckyPot,price,_buyEvent.flag1)

IRs:
TMP_287 = CONVERT this to address
REF_203(uint256) -> _buyEvent.flag1
Emit Buy(TMP_287,msg.sender,_eth,_tokenAmount,totalSupply,totalPot,sharePot,finalPot,luckyPot,price,REF_203)"];
}
// Function: 399.sol-Saturn-endGame()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
luckyPot > 0

IRs:
TMP_289(bool) = luckyPot > 0
CONDITION TMP_289"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feeAmount = feeAmount.add(luckyPot)

IRs:
TMP_290(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['feeAmount', 'luckyPot'] 
feeAmount(uint256) := TMP_290(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
luckyPot = 0

IRs:
luckyPot(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
winner == address(0) && lastPlayer != address(0)

IRs:
TMP_291 = CONVERT 0 to address
TMP_292(bool) = winner == TMP_291
TMP_293 = CONVERT 0 to address
TMP_294(bool) = lastPlayer != TMP_293
TMP_295(bool) = TMP_292 && TMP_294
CONDITION TMP_295"];
5->6[label="True"];
5->13[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
winner = lastPlayer

IRs:
winner(address) := lastPlayer(address)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
lastPlayer = address(0)

IRs:
TMP_296 = CONVERT 0 to address
lastPlayer(address) := TMP_296(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
winAmount = finalPot

IRs:
winAmount(uint256) := finalPot(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
finalPot = 0

IRs:
finalPot(uint256) := 0(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
_player = playerOf[winner]

IRs:
REF_205(Saturn.Player) -> playerOf[winner]
_player(Saturn.Player) := REF_205(Saturn.Player)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_player.ethBalance = _player.ethBalance.add(winAmount)

IRs:
REF_206(uint256) -> _player.ethBalance
REF_207(uint256) -> _player.ethBalance
TMP_297(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_207', 'winAmount'] 
REF_206(uint256) (->_player) := TMP_297(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Win(address(this),winner,winAmount)

IRs:
TMP_298 = CONVERT this to address
Emit Win(TMP_298,winner,winAmount)"];
12->13;
13[label="Node Type: END_IF 13
"];
}
// Function: 399.sol-Saturn-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->18;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_eth = msg.value

IRs:
_eth(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now < finishTime)

IRs:
TMP_108(bool) = now < finishTime
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_buyEvent = InternalBuyEvent({flag1:0})

IRs:
TMP_110(Saturn.InternalBuyEvent) = new InternalBuyEvent(0)
_buyEvent(Saturn.InternalBuyEvent) := TMP_110(Saturn.InternalBuyEvent)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_player = playerOf[msg.sender]

IRs:
REF_73(Saturn.Player) -> playerOf[msg.sender]
_player(Saturn.Player) := REF_73(Saturn.Player)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
_player.pid == 0

IRs:
REF_74(uint256) -> _player.pid
TMP_111(bool) = REF_74 == 0
CONDITION TMP_111"];
5->6[label="True"];
5->16[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(_eth >= FEE_REGISTER_ACCOUNT)

IRs:
TMP_112(bool) = _eth >= FEE_REGISTER_ACCOUNT
TMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
_fee = FEE_REGISTER_ACCOUNT.sub(BUY_AMOUNT_MIN)

IRs:
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['FEE_REGISTER_ACCOUNT', 'BUY_AMOUNT_MIN'] 
_fee(uint256) := TMP_114(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_eth = _eth.sub(_fee)

IRs:
TMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_eth', '_fee'] 
_eth(uint256) := TMP_115(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
feeAmount = feeAmount.add(_fee)

IRs:
TMP_116(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['feeAmount', '_fee'] 
feeAmount(uint256) := TMP_116(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
playerCount = playerCount.add(1)

IRs:
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['playerCount', '1'] 
playerCount(uint256) := TMP_117(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
_p = Player({pid:playerCount,ethTotal:0,ethBalance:0,ethWithdraw:0,ethShareWithdraw:0,tokenBalance:0,tokenDay:0,tokenDayBalance:0})

IRs:
TMP_118(Saturn.Player) = new Player(playerCount,0,0,0,0,0,0,0)
_p(Saturn.Player) := TMP_118(Saturn.Player)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
playerOf[msg.sender] = _p

IRs:
REF_79(Saturn.Player) -> playerOf[msg.sender]
REF_79(Saturn.Player) (->playerOf) := _p(Saturn.Player)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
playerIdOf[_p.pid] = msg.sender

IRs:
REF_80(uint256) -> _p.pid
REF_81(address) -> playerIdOf[REF_80]
REF_81(address) (->playerIdOf) := msg.sender(address)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_player = playerOf[msg.sender]

IRs:
REF_82(Saturn.Player) -> playerOf[msg.sender]
_player(Saturn.Player) := REF_82(Saturn.Player)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_buyEvent.flag1 += 1

IRs:
REF_83(uint256) -> _buyEvent.flag1
REF_83(-> _buyEvent) = REF_83 + 1"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
buy(_player,_buyEvent,_eth)

IRs:
INTERNAL_CALL, Saturn.buy(Saturn.Player,Saturn.InternalBuyEvent,uint256)(_player,_buyEvent,_eth)"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Saturn.isActivated()()"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
isAccount()

IRs:
MODIFIER_CALL, Saturn.isAccount()()"];
19->1;
}
// Function: 399.sol-Saturn-getDealerAndLuckyInfo(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_day = (now / 86400) * 86400

IRs:
TMP_59(uint256) = now / 86400
TMP_60(uint256) = TMP_59 * 86400
_day(uint256) := TMP_60(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
dealerDay == _day

IRs:
TMP_61(bool) = dealerDay == _day
CONDITION TMP_61"];
2->5[label="True"];
2->14[label="False"];
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->14;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_i = 0

IRs:
_i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
_i < 3

IRs:
TMP_62(bool) = _i < 3
CONDITION TMP_62"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
dealers[_i] != address(0)

IRs:
REF_26(address) -> dealers[_i]
TMP_63 = CONVERT 0 to address
TMP_64(bool) = REF_26 != TMP_63
CONDITION TMP_64"];
7->8[label="True"];
7->12[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
_player = playerOf[dealers[_i]]

IRs:
REF_27(address) -> dealers[_i]
REF_28(Saturn.Player) -> playerOf[REF_27]
_player(Saturn.Player) := REF_28(Saturn.Player)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_dealerPlayers[_i] = dealers[_i]

IRs:
REF_29(address) -> _dealerPlayers[_i]
REF_30(address) -> dealers[_i]
REF_29(address) (->_dealerPlayers) := REF_30(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_dealerDayTokens[_i] = _player.tokenDayBalance

IRs:
REF_31(uint256) -> _dealerDayTokens[_i]
REF_32(uint256) -> _player.tokenDayBalance
REF_31(uint256) (->_dealerDayTokens) := REF_32(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_dealerTotalTokens[_i] = _player.tokenBalance

IRs:
REF_33(uint256) -> _dealerTotalTokens[_i]
REF_34(uint256) -> _player.tokenBalance
REF_33(uint256) (->_dealerTotalTokens) := REF_34(uint256)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
++ _i

IRs:
_i(uint256) = _i + 1"];
13->6;
14[label="Node Type: END_IF 14
"];
14->29;
16[label="Node Type: IF 16

EXPRESSION:
_luckyPlayers.length < _size

IRs:
REF_35 -> LENGTH _luckyPlayers
TMP_65(bool) = REF_35 < _size
CONDITION TMP_65"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
_size = _luckyPlayers.length

IRs:
REF_36 -> LENGTH _luckyPlayers
_size(uint256) := REF_36(uint256)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->21;
19[label="Node Type: BEGIN_LOOP 19
"];
19->22;
20[label="Node Type: END_LOOP 20
"];
20->33;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
_i = 0

IRs:
_i(uint256) := 0(uint256)"];
21->19;
22[label="Node Type: IF_LOOP 22

EXPRESSION:
_i < _size

IRs:
TMP_66(bool) = _i < _size
CONDITION TMP_66"];
22->23[label="True"];
22->20[label="False"];
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
_record = luckyRecords[luckyRecords.length - _luckyOffset - 1 - _i]

IRs:
REF_37 -> LENGTH luckyRecords
TMP_67(uint256) = REF_37 - _luckyOffset
TMP_68(uint256) = TMP_67 - 1
TMP_69(uint256) = TMP_68 - _i
REF_38(Saturn.LuckyRecord) -> luckyRecords[TMP_69]
_record(Saturn.LuckyRecord) := REF_38(Saturn.LuckyRecord)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
_luckyPlayers[_i] = _record.player

IRs:
REF_39(address) -> _luckyPlayers[_i]
REF_40(address) -> _record.player
REF_39(address) (->_luckyPlayers) := REF_40(address)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
_luckyAmounts[_i] = _record.amount

IRs:
REF_41(uint256) -> _luckyAmounts[_i]
REF_42(uint256) -> _record.amount
REF_41(uint256) (->_luckyAmounts) := REF_42(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
_luckyLevels[_i] = _record.level

IRs:
REF_43(uint256) -> _luckyLevels[_i]
REF_44(uint64) -> _record.level
REF_43(uint256) (->_luckyLevels) := REF_44(uint64)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
_luckyTimes[_i] = _record.time

IRs:
REF_45(uint256) -> _luckyTimes[_i]
REF_46(uint64) -> _record.time
REF_45(uint256) (->_luckyTimes) := REF_46(uint64)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
++ _i

IRs:
_i(uint256) = _i + 1"];
28->22;
29[label="Node Type: IF 29

EXPRESSION:
_luckyOffset >= luckyRecords.length

IRs:
REF_47 -> LENGTH luckyRecords
TMP_70(bool) = _luckyOffset >= REF_47
CONDITION TMP_70"];
29->30[label="True"];
29->31[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
_size = 0

IRs:
_size(uint256) := 0(uint256)"];
30->32;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
_size = luckyRecords.length - _luckyOffset

IRs:
REF_48 -> LENGTH luckyRecords
TMP_71(uint256) = REF_48 - _luckyOffset
_size(uint256) := TMP_71(uint256)"];
31->32;
32[label="Node Type: END_IF 32
"];
32->16;
33[label="Node Type: RETURN 33

EXPRESSION:
(_dealerPlayers,_dealerDayTokens,_dealerTotalTokens,_luckyPlayers,_luckyAmounts,_luckyLevels,_luckyTimes)

IRs:
RETURN _dealerPlayers,_dealerDayTokens,_dealerTotalTokens,_luckyPlayers,_luckyAmounts,_luckyLevels,_luckyTimes"];
}
// Function: 399.sol-Saturn-getGameInfo()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_balance = address(this).balance

IRs:
TMP_36 = CONVERT this to address
TMP_37(uint256) = SOLIDITY_CALL balance(address)(TMP_36)
_balance(uint256) := TMP_37(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_totalPot = totalPot

IRs:
_totalPot(uint256) := totalPot(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_sharePot = sharePot

IRs:
_sharePot(uint256) := sharePot(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_finalPot = finalPot

IRs:
_finalPot(uint256) := finalPot(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_luckyPot = luckyPot

IRs:
_luckyPot(uint256) := luckyPot(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_rewardPot = _sharePot

IRs:
_rewardPot(uint256) := _sharePot(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
_withdraw = _sharePot.add(_finalPot).add(_luckyPot)

IRs:
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_sharePot', '_finalPot'] 
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_38', '_luckyPot'] 
_withdraw(uint256) := TMP_39(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
_totalPot > _withdraw

IRs:
TMP_40(bool) = _totalPot > _withdraw
CONDITION TMP_40"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_rewardPot = _rewardPot.add(_totalPot.sub(_withdraw))

IRs:
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_totalPot', '_withdraw'] 
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_rewardPot', 'TMP_41'] 
_rewardPot(uint256) := TMP_42(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_price = price

IRs:
_price(uint256) := price(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_totalSupply = totalSupply

IRs:
_totalSupply(uint256) := totalSupply(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_now = now

IRs:
_now(uint256) := now(uint256)"];
13->21;
15[label="Node Type: IF 15

EXPRESSION:
now < finishTime

IRs:
TMP_43(bool) = now < finishTime
CONDITION TMP_43"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
_timeLeft = finishTime - now

IRs:
TMP_44(uint256) = finishTime - now
_timeLeft(uint256) := TMP_44(uint256)"];
16->20;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
_timeLeft = 0

IRs:
_timeLeft(uint256) := 0(uint256)"];
17->25;
20[label="Node Type: END_IF 20
"];
20->33;
21[label="Node Type: IF 21

EXPRESSION:
feeIndex >= feePercents.length

IRs:
REF_8 -> LENGTH feePercents
TMP_45(bool) = feeIndex >= REF_8
CONDITION TMP_45"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
_feePercent = 0

IRs:
_feePercent(uint8) := 0(uint256)"];
22->24;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
_feePercent = feePercents[feeIndex]

IRs:
REF_9(uint8) -> feePercents[feeIndex]
_feePercent(uint8) := REF_9(uint8)"];
23->24;
24[label="Node Type: END_IF 24
"];
24->15;
25[label="Node Type: IF 25

EXPRESSION:
winner != address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = winner != TMP_46
CONDITION TMP_47"];
25->26[label="True"];
25->27[label="False"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
_winner = winner

IRs:
_winner(address) := winner(address)"];
26->28;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
_winner = lastPlayer

IRs:
_winner(address) := lastPlayer(address)"];
27->28;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: IF 29

EXPRESSION:
winner != address(0)

IRs:
TMP_48 = CONVERT 0 to address
TMP_49(bool) = winner != TMP_48
CONDITION TMP_49"];
29->30[label="True"];
29->31[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
_winAmount = winAmount

IRs:
_winAmount(uint256) := winAmount(uint256)"];
30->32;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
_winAmount = finalPot

IRs:
_winAmount(uint256) := finalPot(uint256)"];
31->32;
32[label="Node Type: END_IF 32
"];
32->20;
33[label="Node Type: RETURN 33

EXPRESSION:
(_balance,_totalPot,_sharePot,_finalPot,_luckyPot,_rewardPot,_price,_totalSupply,_now,_timeLeft,_winner,_winAmount,_feePercent)

IRs:
RETURN _balance,_totalPot,_sharePot,_finalPot,_luckyPot,_rewardPot,_price,_totalSupply,_now,_timeLeft,_winner,_winAmount,_feePercent"];
}
// Function: 399.sol-Saturn-getLuckyPendingSize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
luckyPendings.length

IRs:
REF_2 -> LENGTH luckyPendings
RETURN REF_2"];
}
// Function: 399.sol-Saturn-getLuckyRecordSize()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
luckyRecords.length

IRs:
REF_3 -> LENGTH luckyRecords
RETURN REF_3"];
}
// Function: 399.sol-Saturn-getPlayerInfo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_player = playerOf[_playerAddress]

IRs:
REF_10(Saturn.Player) -> playerOf[_playerAddress]
_player(Saturn.Player) := REF_10(Saturn.Player)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_player.pid > 0

IRs:
REF_11(uint256) -> _player.pid
TMP_50(bool) = REF_11 > 0
CONDITION TMP_50"];
2->3[label="True"];
2->16[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_pid = _player.pid

IRs:
REF_12(uint256) -> _player.pid
_pid(uint256) := REF_12(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_ethTotal = _player.ethTotal

IRs:
REF_13(uint256) -> _player.ethTotal
_ethTotal(uint256) := REF_13(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply)

IRs:
REF_14(uint256) -> _player.tokenBalance
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_14', 'sharePot'] 
TMP_52(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_51', 'totalSupply'] 
_sharePot(uint256) := TMP_52(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_ethBalance = _player.ethBalance

IRs:
REF_17(uint256) -> _player.ethBalance
_ethBalance(uint256) := REF_17(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
_sharePot > _player.ethShareWithdraw

IRs:
REF_18(uint256) -> _player.ethShareWithdraw
TMP_53(bool) = _sharePot > REF_18
CONDITION TMP_53"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_ethBalance = _ethBalance.add(_sharePot.sub(_player.ethShareWithdraw))

IRs:
REF_21(uint256) -> _player.ethShareWithdraw
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_sharePot', 'REF_21'] 
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_ethBalance', 'TMP_54'] 
_ethBalance(uint256) := TMP_55(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_ethWithdraw = _player.ethWithdraw

IRs:
REF_22(uint256) -> _player.ethWithdraw
_ethWithdraw(uint256) := REF_22(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_tokenBalance = _player.tokenBalance

IRs:
REF_23(uint256) -> _player.tokenBalance
_tokenBalance(uint256) := REF_23(uint256)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
_day = (now / 86400) * 86400

IRs:
TMP_56(uint256) = now / 86400
TMP_57(uint256) = TMP_56 * 86400
_day(uint256) := TMP_57(uint256)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
_player.tokenDay == _day

IRs:
REF_24(uint256) -> _player.tokenDay
TMP_58(bool) = REF_24 == _day
CONDITION TMP_58"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_tokenDayBalance = _player.tokenDayBalance

IRs:
REF_25(uint256) -> _player.tokenDayBalance
_tokenDayBalance(uint256) := REF_25(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: RETURN 17

EXPRESSION:
(_pid,_ethTotal,_ethBalance,_ethWithdraw,_tokenBalance,_tokenDayBalance)

IRs:
RETURN _pid,_ethTotal,_ethBalance,_ethWithdraw,_tokenBalance,_tokenDayBalance"];
}
// Function: 399.sol-Saturn-handleDealerPot(uint256,uint256,Saturn.Player,Saturn.InternalBuyEvent)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_potUnit = _dealerPotDelta.div(dealers.length)

IRs:
REF_161 -> LENGTH dealers
TMP_250(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_dealerPotDelta', 'REF_161'] 
_potUnit(uint256) := TMP_250(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
dealerDay != _day || dealers[0] == address(0)

IRs:
TMP_251(bool) = dealerDay != _day
REF_162(address) -> dealers[0]
TMP_252 = CONVERT 0 to address
TMP_253(bool) = REF_162 == TMP_252
TMP_254(bool) = TMP_251 || TMP_253
CONDITION TMP_254"];
2->3[label="True"];
2->11[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
dealerDay = _day

IRs:
dealerDay(uint256) := _day(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
dealers[0] = msg.sender

IRs:
REF_163(address) -> dealers[0]
REF_163(address) (->dealers) := msg.sender(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
dealers[1] = address(0)

IRs:
REF_164(address) -> dealers[1]
TMP_255 = CONVERT 0 to address
REF_164(address) (->dealers) := TMP_255(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
dealers[2] = address(0)

IRs:
REF_165(address) -> dealers[2]
TMP_256 = CONVERT 0 to address
REF_165(address) (->dealers) := TMP_256(address)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_player.ethBalance = _player.ethBalance.add(_potUnit)

IRs:
REF_166(uint256) -> _player.ethBalance
REF_167(uint256) -> _player.ethBalance
TMP_257(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_167', '_potUnit'] 
REF_166(uint256) (->_player) := TMP_257(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
feeAmount = feeAmount.add(_dealerPotDelta.sub(_potUnit))

IRs:
TMP_258(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_dealerPotDelta', '_potUnit'] 
TMP_259(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['feeAmount', 'TMP_258'] 
feeAmount(uint256) := TMP_259(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_buyEvent.flag1 += _player.pid * 100000000000000000000000000000000

IRs:
REF_171(uint256) -> _buyEvent.flag1
REF_172(uint256) -> _player.pid
TMP_260(uint256) = REF_172 * 100000000000000000000000000000000
REF_171(-> _buyEvent) = REF_171 + TMP_260"];
9->10;
10[label="Node Type: RETURN 10
"];
11[label="Node Type: END_IF 11
"];
11->14;
12[label="Node Type: BEGIN_LOOP 12
"];
12->15;
13[label="Node Type: END_LOOP 13
"];
13->37;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
_i = 0

IRs:
_i(uint256) := 0(uint256)"];
14->12;
15[label="Node Type: IF_LOOP 15

EXPRESSION:
_i < dealers.length

IRs:
REF_173 -> LENGTH dealers
TMP_261(bool) = _i < REF_173
CONDITION TMP_261"];
15->16[label="True"];
15->13[label="False"];
16[label="Node Type: IF 16

EXPRESSION:
dealers[_i] == address(0)

IRs:
REF_174(address) -> dealers[_i]
TMP_262 = CONVERT 0 to address
TMP_263(bool) = REF_174 == TMP_262
CONDITION TMP_263"];
16->17[label="True"];
16->19[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
dealers[_i] = msg.sender

IRs:
REF_175(address) -> dealers[_i]
REF_175(address) (->dealers) := msg.sender(address)"];
17->18;
18[label="Node Type: BREAK 18
"];
18->13;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
dealers[_i] == msg.sender

IRs:
REF_176(address) -> dealers[_i]
TMP_264(bool) = REF_176 == msg.sender
CONDITION TMP_264"];
20->21[label="True"];
20->22[label="False"];
21[label="Node Type: BREAK 21
"];
21->13;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
_dealer = playerOf[dealers[_i]]

IRs:
REF_177(address) -> dealers[_i]
REF_178(Saturn.Player) -> playerOf[REF_177]
_dealer(Saturn.Player) := REF_178(Saturn.Player)"];
23->24;
24[label="Node Type: IF 24

EXPRESSION:
_dealer.tokenDayBalance < _player.tokenDayBalance

IRs:
REF_179(uint256) -> _dealer.tokenDayBalance
REF_180(uint256) -> _player.tokenDayBalance
TMP_265(bool) = REF_179 < REF_180
CONDITION TMP_265"];
24->27[label="True"];
24->35[label="False"];
25[label="Node Type: BEGIN_LOOP 25
"];
25->28;
26[label="Node Type: END_LOOP 26
"];
26->33;
27[label="Node Type: NEW VARIABLE 27

EXPRESSION:
_j = dealers.length - 1

IRs:
REF_181 -> LENGTH dealers
TMP_266(uint256) = REF_181 - 1
_j(uint256) := TMP_266(uint256)"];
27->25;
28[label="Node Type: IF_LOOP 28

EXPRESSION:
_j > _i

IRs:
TMP_267(bool) = _j > _i
CONDITION TMP_267"];
28->29[label="True"];
28->26[label="False"];
29[label="Node Type: IF 29

EXPRESSION:
dealers[_j - 1] != msg.sender

IRs:
TMP_268(uint256) = _j - 1
REF_182(address) -> dealers[TMP_268]
TMP_269(bool) = REF_182 != msg.sender
CONDITION TMP_269"];
29->30[label="True"];
29->31[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
dealers[_j] = dealers[_j - 1]

IRs:
REF_183(address) -> dealers[_j]
TMP_270(uint256) = _j - 1
REF_184(address) -> dealers[TMP_270]
REF_183(address) (->dealers) := REF_184(address)"];
30->31;
31[label="Node Type: END_IF 31
"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
-- _j

IRs:
_j(uint256) = _j - 1"];
32->28;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
dealers[_i] = msg.sender

IRs:
REF_185(address) -> dealers[_i]
REF_185(address) (->dealers) := msg.sender(address)"];
33->34;
34[label="Node Type: BREAK 34
"];
34->13;
35[label="Node Type: END_IF 35
"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
++ _i

IRs:
_i(uint256) = _i + 1"];
36->15;
37[label="Node Type: NEW VARIABLE 37

EXPRESSION:
_fee = _dealerPotDelta

IRs:
_fee(uint256) := _dealerPotDelta(uint256)"];
37->40;
38[label="Node Type: BEGIN_LOOP 38
"];
38->41;
39[label="Node Type: END_LOOP 39
"];
39->50;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
_i = 0

IRs:
_i(uint256) := 0(uint256)"];
40->38;
41[label="Node Type: IF_LOOP 41

EXPRESSION:
_i < dealers.length

IRs:
REF_186 -> LENGTH dealers
TMP_271(bool) = _i < REF_186
CONDITION TMP_271"];
41->42[label="True"];
41->39[label="False"];
42[label="Node Type: IF 42

EXPRESSION:
dealers[_i] == address(0)

IRs:
REF_187(address) -> dealers[_i]
TMP_272 = CONVERT 0 to address
TMP_273(bool) = REF_187 == TMP_272
CONDITION TMP_273"];
42->43[label="True"];
42->44[label="False"];
43[label="Node Type: BREAK 43
"];
43->39;
44[label="Node Type: END_IF 44
"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
_dealer = playerOf[dealers[_i]]

IRs:
REF_188(address) -> dealers[_i]
REF_189(Saturn.Player) -> playerOf[REF_188]
_dealer(Saturn.Player) := REF_189(Saturn.Player)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
_dealer.ethBalance = _dealer.ethBalance.add(_potUnit)

IRs:
REF_190(uint256) -> _dealer.ethBalance
REF_191(uint256) -> _dealer.ethBalance
TMP_274(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_191', '_potUnit'] 
REF_190(uint256) (->_dealer) := TMP_274(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
_fee = _fee.sub(_potUnit)

IRs:
TMP_275(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_fee', '_potUnit'] 
_fee(uint256) := TMP_275(uint256)"];
47->53;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
++ _i

IRs:
_i(uint256) = _i + 1"];
49->41;
50[label="Node Type: IF 50

EXPRESSION:
_fee > 0

IRs:
TMP_276(bool) = _fee > 0
CONDITION TMP_276"];
50->51[label="True"];
50->52[label="False"];
51[label="Node Type: EXPRESSION 51

EXPRESSION:
feeAmount = feeAmount.add(_fee)

IRs:
TMP_277(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['feeAmount', '_fee'] 
feeAmount(uint256) := TMP_277(uint256)"];
51->52;
52[label="Node Type: END_IF 52
"];
53[label="Node Type: IF 53

EXPRESSION:
_i == 0

IRs:
TMP_278(bool) = _i == 0
CONDITION TMP_278"];
53->54[label="True"];
53->57[label="False"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
_buyEvent.flag1 += _dealer.pid * 100000000000000000000000000000000

IRs:
REF_195(uint256) -> _buyEvent.flag1
REF_196(uint256) -> _dealer.pid
TMP_279(uint256) = REF_196 * 100000000000000000000000000000000
REF_195(-> _buyEvent) = REF_195 + TMP_279"];
54->56;
56[label="Node Type: END_IF 56
"];
56->49;
57[label="Node Type: IF 57

EXPRESSION:
_i == 1

IRs:
TMP_280(bool) = _i == 1
CONDITION TMP_280"];
57->58[label="True"];
57->61[label="False"];
58[label="Node Type: EXPRESSION 58

EXPRESSION:
_buyEvent.flag1 += _dealer.pid * 100000000000000000000000000000000000000000000000

IRs:
REF_197(uint256) -> _buyEvent.flag1
REF_198(uint256) -> _dealer.pid
TMP_281(uint256) = REF_198 * 100000000000000000000000000000000000000000000000
REF_197(-> _buyEvent) = REF_197 + TMP_281"];
58->60;
60[label="Node Type: END_IF 60
"];
60->56;
61[label="Node Type: IF 61

EXPRESSION:
_i == 2

IRs:
TMP_282(bool) = _i == 2
CONDITION TMP_282"];
61->62[label="True"];
61->63[label="False"];
62[label="Node Type: EXPRESSION 62

EXPRESSION:
_buyEvent.flag1 += _dealer.pid * 100000000000000000000000000000000000000000000000000000000000000

IRs:
REF_199(uint256) -> _buyEvent.flag1
REF_200(uint256) -> _dealer.pid
TMP_283(uint256) = REF_200 * 100000000000000000000000000000000000000000000000000000000000000
REF_199(-> _buyEvent) = REF_199 + TMP_283"];
62->64;
63[label="Node Type: EXPRESSION 63

EXPRESSION:
_buyEvent.flag1 += _dealer.pid * 0

IRs:
REF_201(uint256) -> _buyEvent.flag1
REF_202(uint256) -> _dealer.pid
TMP_284(uint256) = REF_202 * 0
REF_201(-> _buyEvent) = REF_201 + TMP_284"];
63->64;
64[label="Node Type: END_IF 64
"];
64->60;
}
// Function: 399.sol-Saturn-handleLuckyPending(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
luckyPendingIndex < luckyPendings.length - _pendingSkipSize

IRs:
REF_125 -> LENGTH luckyPendings
TMP_198(uint256) = REF_125 - _pendingSkipSize
TMP_199(bool) = luckyPendingIndex < TMP_198
CONDITION TMP_199"];
1->2[label="True"];
1->14[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_pending = luckyPendings[luckyPendingIndex]

IRs:
REF_126(Saturn.LuckyPending) -> luckyPendings[luckyPendingIndex]
_pending(Saturn.LuckyPending) := REF_126(Saturn.LuckyPending)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_pending.block <= block.number

IRs:
REF_127(uint64) -> _pending.block
TMP_200(bool) = REF_127 <= block.number
CONDITION TMP_200"];
3->4[label="True"];
3->13[label="False"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_seed = uint256(keccak256()(abi.encodePacked((block.timestamp).add(block.difficulty).add((uint256(keccak256()(abi.encodePacked(block.coinbase)))) / (now)).add(block.gaslimit).add(block.number))))

IRs:
TMP_201(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['block.timestamp', 'block.difficulty'] 
TMP_202(bytes) = SOLIDITY_CALL abi.encodePacked()(block.coinbase)
TMP_203(bytes32) = SOLIDITY_CALL keccak256()(TMP_202)
TMP_204 = CONVERT TMP_203 to uint256
TMP_205(uint256) = TMP_204 / now
TMP_206(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_201', 'TMP_205'] 
TMP_207(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_206', 'block.gaslimit'] 
TMP_208(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_207', 'block.number'] 
TMP_209(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_208)
TMP_210(bytes32) = SOLIDITY_CALL keccak256()(TMP_209)
TMP_211 = CONVERT TMP_210 to uint256
_seed(uint256) := TMP_211(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_seed = _seed - ((_seed / 1000) * 1000)

IRs:
TMP_212(uint256) = _seed / 1000
TMP_213(uint256) = TMP_212 * 1000
TMP_214(uint256) = _seed - TMP_213
_seed(uint256) := TMP_214(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
handleLucyPendingForOne(_pending,_seed)

IRs:
INTERNAL_CALL, Saturn.handleLucyPendingForOne(Saturn.LuckyPending,uint256)(_pending,_seed)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
luckyPendingIndex < luckyPendings.length - _pendingSkipSize

IRs:
REF_134 -> LENGTH luckyPendings
TMP_216(uint256) = REF_134 - _pendingSkipSize
TMP_217(bool) = luckyPendingIndex < TMP_216
CONDITION TMP_217"];
7->8[label="True"];
7->12[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_pending = luckyPendings[luckyPendingIndex]

IRs:
REF_135(Saturn.LuckyPending) -> luckyPendings[luckyPendingIndex]
_pending(Saturn.LuckyPending) := REF_135(Saturn.LuckyPending)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
_pending.block <= block.number

IRs:
REF_136(uint64) -> _pending.block
TMP_218(bool) = REF_136 <= block.number
CONDITION TMP_218"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
handleLucyPendingForOne(_pending,_seed)

IRs:
INTERNAL_CALL, Saturn.handleLucyPendingForOne(Saturn.LuckyPending,uint256)(_pending,_seed)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: END_IF 14
"];
}
// Function: 399.sol-Saturn-handleLuckyPot(uint256,Saturn.Player)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_seed = uint256(keccak256()(abi.encodePacked((block.timestamp).add(block.difficulty).add((uint256(keccak256()(abi.encodePacked(block.coinbase)))) / (now)).add(block.gaslimit).add((uint256(keccak256()(abi.encodePacked(msg.sender)))) / (now)).add(block.number))))

IRs:
TMP_163(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['block.timestamp', 'block.difficulty'] 
TMP_164(bytes) = SOLIDITY_CALL abi.encodePacked()(block.coinbase)
TMP_165(bytes32) = SOLIDITY_CALL keccak256()(TMP_164)
TMP_166 = CONVERT TMP_165 to uint256
TMP_167(uint256) = TMP_166 / now
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_163', 'TMP_167'] 
TMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_168', 'block.gaslimit'] 
TMP_170(bytes) = SOLIDITY_CALL abi.encodePacked()(msg.sender)
TMP_171(bytes32) = SOLIDITY_CALL keccak256()(TMP_170)
TMP_172 = CONVERT TMP_171 to uint256
TMP_173(uint256) = TMP_172 / now
TMP_174(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_169', 'TMP_173'] 
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_174', 'block.number'] 
TMP_176(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_175)
TMP_177(bytes32) = SOLIDITY_CALL keccak256()(TMP_176)
TMP_178 = CONVERT TMP_177 to uint256
_seed(uint256) := TMP_178(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_seed = _seed - ((_seed / 1000) * 1000)

IRs:
TMP_179(uint256) = _seed / 1000
TMP_180(uint256) = TMP_179 * 1000
TMP_181(uint256) = _seed - TMP_180
_seed(uint256) := TMP_181(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_level = 0

IRs:
_level(uint64) := 0(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_seed < 227

IRs:
TMP_182(bool) = _seed < 227
CONDITION TMP_182"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_level = 1

IRs:
_level(uint64) := 1(uint256)"];
5->19;
6[label="Node Type: IF 6

EXPRESSION:
_seed < 422

IRs:
TMP_183(bool) = _seed < 422
CONDITION TMP_183"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_level = 2

IRs:
_level(uint64) := 2(uint256)"];
7->18;
8[label="Node Type: IF 8

EXPRESSION:
_seed < 519

IRs:
TMP_184(bool) = _seed < 519
CONDITION TMP_184"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_level = 3

IRs:
_level(uint64) := 3(uint256)"];
9->17;
10[label="Node Type: IF 10

EXPRESSION:
_seed < 600

IRs:
TMP_185(bool) = _seed < 600
CONDITION TMP_185"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_level = 4

IRs:
_level(uint64) := 4(uint256)"];
11->16;
12[label="Node Type: IF 12

EXPRESSION:
_seed < 700

IRs:
TMP_186(bool) = _seed < 700
CONDITION TMP_186"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_level = 5

IRs:
_level(uint64) := 5(uint256)"];
13->15;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_level = 6

IRs:
_level(uint64) := 6(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
_level >= 5

IRs:
TMP_187(bool) = _level >= 5
CONDITION TMP_187"];
20->21[label="True"];
20->22[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
handleLuckyReward(txCount,_level,_eth,_player)

IRs:
INTERNAL_CALL, Saturn.handleLuckyReward(uint64,uint64,uint256,Saturn.Player)(txCount,_level,_eth,_player)"];
21->24;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
_pending = LuckyPending({player:msg.sender,amount:_eth,txId:txCount,block:uint64(block.number + 1),level:_level})

IRs:
TMP_189(uint256) = block.number + 1
TMP_190 = CONVERT TMP_189 to uint64
TMP_191(Saturn.LuckyPending) = new LuckyPending(msg.sender,_eth,txCount,TMP_190,_level)
_pending(Saturn.LuckyPending) := TMP_191(Saturn.LuckyPending)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
luckyPendings.push(_pending)

IRs:
REF_123 -> LENGTH luckyPendings
TMP_193(uint256) := REF_123(uint256)
TMP_194(uint256) = TMP_193 + 1
REF_123(uint256) (->luckyPendings) := TMP_194(uint256)
REF_124(Saturn.LuckyPending) -> luckyPendings[TMP_193]
REF_124(Saturn.LuckyPending) (->luckyPendings) := _pending(Saturn.LuckyPending)"];
23->24;
24[label="Node Type: END_IF 24
"];
24->26;
26[label="Node Type: IF 26

EXPRESSION:
_level >= 5

IRs:
TMP_195(bool) = _level >= 5
CONDITION TMP_195"];
26->27[label="True"];
26->28[label="False"];
27[label="Node Type: EXPRESSION 27

EXPRESSION:
handleLuckyPending(0)

IRs:
INTERNAL_CALL, Saturn.handleLuckyPending(uint256)(0)"];
27->29;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
handleLuckyPending(1)

IRs:
INTERNAL_CALL, Saturn.handleLuckyPending(uint256)(1)"];
28->29;
29[label="Node Type: END_IF 29
"];
}
// Function: 399.sol-Saturn-handleLuckyReward(uint64,uint64,uint256,Saturn.Player)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_level == 1

IRs:
TMP_230(bool) = _level == 1
CONDITION TMP_230"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_amount = _eth.mul(7)

IRs:
TMP_231(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', '7'] 
_amount(uint256) := TMP_231(uint256)"];
3->19;
4[label="Node Type: IF 4

EXPRESSION:
_level == 2

IRs:
TMP_232(bool) = _level == 2
CONDITION TMP_232"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_amount = _eth.mul(3)

IRs:
TMP_233(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', '3'] 
_amount(uint256) := TMP_233(uint256)"];
5->18;
6[label="Node Type: IF 6

EXPRESSION:
_level == 3

IRs:
TMP_234(bool) = _level == 3
CONDITION TMP_234"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_amount = _eth

IRs:
_amount(uint256) := _eth(uint256)"];
7->17;
8[label="Node Type: IF 8

EXPRESSION:
_level == 4

IRs:
TMP_235(bool) = _level == 4
CONDITION TMP_235"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_amount = _eth.div(2)

IRs:
TMP_236(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_eth', '2'] 
_amount(uint256) := TMP_236(uint256)"];
9->16;
10[label="Node Type: IF 10

EXPRESSION:
_level == 5

IRs:
TMP_237(bool) = _level == 5
CONDITION TMP_237"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_amount = _eth.div(5)

IRs:
TMP_238(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_eth', '5'] 
_amount(uint256) := TMP_238(uint256)"];
11->15;
12[label="Node Type: IF 12

EXPRESSION:
_level == 6

IRs:
TMP_239(bool) = _level == 6
CONDITION TMP_239"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_amount = _eth.div(10)

IRs:
TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_eth', '10'] 
_amount(uint256) := TMP_240(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: NEW VARIABLE 20

EXPRESSION:
_maxPot = luckyPot.div(2)

IRs:
TMP_241(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['luckyPot', '2'] 
_maxPot(uint256) := TMP_241(uint256)"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
_amount > _maxPot

IRs:
TMP_242(bool) = _amount > _maxPot
CONDITION TMP_242"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
_amount = _maxPot

IRs:
_amount(uint256) := _maxPot(uint256)"];
22->23;
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
luckyPot = luckyPot.sub(_amount)

IRs:
TMP_243(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['luckyPot', '_amount'] 
luckyPot(uint256) := TMP_243(uint256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
_player.ethBalance = _player.ethBalance.add(_amount)

IRs:
REF_154(uint256) -> _player.ethBalance
REF_155(uint256) -> _player.ethBalance
TMP_244(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_155', '_amount'] 
REF_154(uint256) (->_player) := TMP_244(uint256)"];
25->26;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
_record = LuckyRecord({player:msg.sender,amount:_amount,txId:_txId,level:_level,time:uint64(now)})

IRs:
TMP_245 = CONVERT now to uint64
TMP_246(Saturn.LuckyRecord) = new LuckyRecord(msg.sender,_amount,_txId,TMP_245,_level)
_record(Saturn.LuckyRecord) := TMP_246(Saturn.LuckyRecord)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
luckyRecords.push(_record)

IRs:
REF_158 -> LENGTH luckyRecords
TMP_248(uint256) := REF_158(uint256)
TMP_249(uint256) = TMP_248 + 1
REF_158(uint256) (->luckyRecords) := TMP_249(uint256)
REF_159(Saturn.LuckyRecord) -> luckyRecords[TMP_248]
REF_159(Saturn.LuckyRecord) (->luckyRecords) := _record(Saturn.LuckyRecord)"];
}
// Function: 399.sol-Saturn-handleLucyPendingForOne(Saturn.LuckyPending,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
luckyPendingIndex = luckyPendingIndex.add(1)

IRs:
TMP_220(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['luckyPendingIndex', '1'] 
luckyPendingIndex(uint256) := TMP_220(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_reward = false

IRs:
_reward(bool) := False(bool)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_pending.level == 4

IRs:
REF_138(uint64) -> _pending.level
TMP_221(bool) = REF_138 == 4
CONDITION TMP_221"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_reward = _seed < 617

IRs:
TMP_222(bool) = _seed < 617
_reward(bool) := TMP_222(bool)"];
4->14;
5[label="Node Type: IF 5

EXPRESSION:
_pending.level == 3

IRs:
REF_139(uint64) -> _pending.level
TMP_223(bool) = REF_139 == 3
CONDITION TMP_223"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_reward = _seed < 309

IRs:
TMP_224(bool) = _seed < 309
_reward(bool) := TMP_224(bool)"];
6->13;
7[label="Node Type: IF 7

EXPRESSION:
_pending.level == 2

IRs:
REF_140(uint64) -> _pending.level
TMP_225(bool) = REF_140 == 2
CONDITION TMP_225"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_reward = _seed < 102

IRs:
TMP_226(bool) = _seed < 102
_reward(bool) := TMP_226(bool)"];
8->12;
9[label="Node Type: IF 9

EXPRESSION:
_pending.level == 1

IRs:
REF_141(uint64) -> _pending.level
TMP_227(bool) = REF_141 == 1
CONDITION TMP_227"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_reward = _seed < 44

IRs:
TMP_228(bool) = _seed < 44
_reward(bool) := TMP_228(bool)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
_reward

IRs:
CONDITION _reward"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
handleLuckyReward(_pending.txId,_pending.level,_pending.amount,playerOf[_pending.player])

IRs:
REF_142(uint64) -> _pending.txId
REF_143(uint64) -> _pending.level
REF_144(uint256) -> _pending.amount
REF_145(address) -> _pending.player
REF_146(Saturn.Player) -> playerOf[REF_145]
INTERNAL_CALL, Saturn.handleLuckyReward(uint64,uint64,uint256,Saturn.Player)(REF_142,REF_143,REF_144,REF_146)"];
16->17;
17[label="Node Type: END_IF 17
"];
}
// Function: 399.sol-Saturn-handlePot(uint256,uint256,uint256,uint256,Saturn.Player,Saturn.InternalBuyEvent)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_sharePotDelta = _eth.div(2)

IRs:
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_eth', '2'] 
_sharePotDelta(uint256) := TMP_148(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_finalPotDelta = _eth.div(5)

IRs:
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_eth', '5'] 
_finalPotDelta(uint256) := TMP_149(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_luckyPotDelta = _eth.mul(255).div(1000)

IRs:
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', '255'] 
TMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_150', '1000'] 
_luckyPotDelta(uint256) := TMP_151(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_dealerPotDelta = _eth.sub(_sharePotDelta).sub(_finalPotDelta).sub(_luckyPotDelta)

IRs:
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_eth', '_sharePotDelta'] 
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_152', '_finalPotDelta'] 
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_153', '_luckyPotDelta'] 
_dealerPotDelta(uint256) := TMP_154(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
sharePot = sharePot.add(_sharePotDelta)

IRs:
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sharePot', '_sharePotDelta'] 
sharePot(uint256) := TMP_155(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
finalPot = finalPot.add(_finalPotDelta)

IRs:
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['finalPot', '_finalPotDelta'] 
finalPot(uint256) := TMP_156(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
luckyPot = luckyPot.add(_luckyPotDelta)

IRs:
TMP_157(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['luckyPot', '_luckyPotDelta'] 
luckyPot(uint256) := TMP_157(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
totalSupply = _newTotalSupply

IRs:
totalSupply(uint256) := _newTotalSupply(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
handleDealerPot(_day,_dealerPotDelta,_player,_buyEvent)

IRs:
INTERNAL_CALL, Saturn.handleDealerPot(uint256,uint256,Saturn.Player,Saturn.InternalBuyEvent)(_day,_dealerPotDelta,_player,_buyEvent)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
handleLuckyPot(_eth,_player)

IRs:
INTERNAL_CALL, Saturn.handleLuckyPot(uint256,Saturn.Player)(_eth,_player)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
_tokenAmount >= ONE_TOKEN

IRs:
TMP_160(bool) = _tokenAmount >= ONE_TOKEN
CONDITION TMP_160"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
updateFinishTime(_tokenAmount)

IRs:
INTERNAL_CALL, Saturn.updateFinishTime(uint256)(_tokenAmount)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
lastPlayer = msg.sender

IRs:
lastPlayer(address) := msg.sender(address)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_buyEvent.flag1 += finishTime * 1000000000000000000000

IRs:
REF_113(uint256) -> _buyEvent.flag1
TMP_162(uint256) = finishTime * 1000000000000000000000
REF_113(-> _buyEvent) = REF_113 + TMP_162"];
}
// Function: 399.sol-Saturn-isAccount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_address = msg.sender

IRs:
_address(address) := msg.sender(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: INLINE ASM 3
"];
3->4;
4[label="Node Type: END INLINE ASM 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_codeLength == 0 && tx.origin == msg.sender)

IRs:
TMP_340(bool) = _codeLength == 0
TMP_341(bool) = tx.origin == msg.sender
TMP_342(bool) = TMP_340 && TMP_341
TMP_343(None) = SOLIDITY_CALL require(bool)(TMP_342)"];
5->6;
6[label="Node Type: _ 6
"];
}
// Function: 399.sol-Saturn-isActivated()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now >= startTime)

IRs:
TMP_338(bool) = now >= startTime
TMP_339(None) = SOLIDITY_CALL require(bool)(TMP_338)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 399.sol-Saturn-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_336(bool) = msg.sender == owner
TMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 399.sol-Saturn-sendFeeIfAvailable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
feeAmount > 1000000000000000000

IRs:
TMP_316(bool) = feeAmount > 1000000000000000000
CONDITION TMP_316"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feeOwner.transfer(feeAmount)

IRs:
Transfer dest:feeOwner value:feeAmount"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
feeAmount = 0

IRs:
feeAmount(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 399.sol-Saturn-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Saturn

IRs:
name(string) := Saturn(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = SAT

IRs:
symbol(string) := SAT(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
FEE_REGISTER_ACCOUNT = 10000000000000000

IRs:
FEE_REGISTER_ACCOUNT(uint256) := 10000000000000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
BUY_AMOUNT_MIN = 1000000000

IRs:
BUY_AMOUNT_MIN(uint256) := 1000000000(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
BUY_AMOUNT_MAX = 100000000000000000000000

IRs:
BUY_AMOUNT_MAX(uint256) := 100000000000000000000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
TIME_DURATION_INCREASE = 30

IRs:
TIME_DURATION_INCREASE(uint256) := 30(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
TIME_DURATION_MAX = 86400

IRs:
TIME_DURATION_MAX(uint256) := 86400(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
ONE_TOKEN = 1000000000000000000

IRs:
ONE_TOKEN(uint256) := 1000000000000000000(uint256)"];
}
// Function: 399.sol-Saturn-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
feePrices = (uint64(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100)

IRs:
TMP_334 = CONVERT 88000000000000 to uint64
feePrices(uint64[16]) = ['TMP_334(uint64)', '140664279921934(uint256)', '224845905067685(uint256)', '359406674201608(uint256)', '574496375292119(uint256)', '918308169866219(uint256)', '1467876789325690(uint256)', '2346338995279770(uint256)', '3750523695724810(uint256)', '5995053579423660(uint256)', '9582839714125510(uint256)', '15317764181758900(uint256)', '24484798507285300(uint256)', '39137915352965200(uint256)', '62560303190573500(uint256)', '99999999999999100(uint256)']"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
feePercents = (uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0)

IRs:
TMP_335 = CONVERT 150 to uint8
feePercents(uint8[16]) = ['TMP_335(uint8)', '140(uint256)', '130(uint256)', '120(uint256)', '110(uint256)', '100(uint256)', '90(uint256)', '80(uint256)', '70(uint256)', '60(uint256)', '50(uint256)', '40(uint256)', '30(uint256)', '20(uint256)', '10(uint256)', '0(uint256)']"];
}
// Function: 399.sol-Saturn-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->34;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to == address(this))

IRs:
TMP_72 = CONVERT this to address
TMP_73(bool) = _to == TMP_72
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_player = playerOf[msg.sender]

IRs:
REF_49(Saturn.Player) -> playerOf[msg.sender]
_player(Saturn.Player) := REF_49(Saturn.Player)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_player.pid > 0)

IRs:
REF_50(uint256) -> _player.pid
TMP_75(bool) = REF_50 > 0
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
now >= finishTime

IRs:
TMP_77(bool) = now >= finishTime
CONDITION TMP_77"];
4->5[label="True"];
4->9[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
winner == address(0)

IRs:
TMP_78 = CONVERT 0 to address
TMP_79(bool) = winner == TMP_78
CONDITION TMP_79"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
endGame()

IRs:
INTERNAL_CALL, Saturn.endGame()()"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_value = 80000000000000000

IRs:
_value(uint256) := 80000000000000000(uint256)"];
8->10;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(_value == 80000000000000000 || _value == 10000000000000000)

IRs:
TMP_81(bool) = _value == 80000000000000000
TMP_82(bool) = _value == 10000000000000000
TMP_83(bool) = TMP_81 || TMP_82
TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
_sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply)

IRs:
REF_51(uint256) -> _player.tokenBalance
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_51', 'sharePot'] 
TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_85', 'totalSupply'] 
_sharePot(uint256) := TMP_86(uint256)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
_eth = 0

IRs:
_eth(uint256) := 0(uint256)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
_sharePot > _player.ethShareWithdraw

IRs:
REF_54(uint256) -> _player.ethShareWithdraw
TMP_87(bool) = _sharePot > REF_54
CONDITION TMP_87"];
13->14[label="True"];
13->16[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_eth = _sharePot.sub(_player.ethShareWithdraw)

IRs:
REF_56(uint256) -> _player.ethShareWithdraw
TMP_88(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_sharePot', 'REF_56'] 
_eth(uint256) := TMP_88(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_player.ethShareWithdraw = _sharePot

IRs:
REF_57(uint256) -> _player.ethShareWithdraw
REF_57(uint256) (->_player) := _sharePot(uint256)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
_eth = _eth.add(_player.ethBalance)

IRs:
REF_59(uint256) -> _player.ethBalance
TMP_89(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_eth', 'REF_59'] 
_eth(uint256) := TMP_89(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_player.ethBalance = 0

IRs:
REF_60(uint256) -> _player.ethBalance
REF_60(uint256) (->_player) := 0(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
_player.ethWithdraw = _player.ethWithdraw.add(_eth)

IRs:
REF_61(uint256) -> _player.ethWithdraw
REF_62(uint256) -> _player.ethWithdraw
TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_62', '_eth'] 
REF_61(uint256) (->_player) := TMP_90(uint256)"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
_value == 80000000000000000

IRs:
TMP_91(bool) = _value == 80000000000000000
CONDITION TMP_91"];
20->36[label="True"];
20->30[label="False"];
22[label="Node Type: IF 22

EXPRESSION:
_fee > 0

IRs:
TMP_92(bool) = _fee > 0
CONDITION TMP_92"];
22->23[label="True"];
22->25[label="False"];
23[label="Node Type: EXPRESSION 23

EXPRESSION:
feeAmount = feeAmount.add(_fee)

IRs:
TMP_93(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['feeAmount', '_fee'] 
feeAmount(uint256) := TMP_93(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
_eth = _eth.sub(_fee)

IRs:
TMP_94(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_eth', '_fee'] 
_eth(uint256) := TMP_94(uint256)"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
sendFeeIfAvailable()

IRs:
INTERNAL_CALL, Saturn.sendFeeIfAvailable()()"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
msg.sender.transfer(_eth)

IRs:
Transfer dest:msg.sender value:_eth"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
Withdraw(_to,msg.sender,_eth)

IRs:
Emit Withdraw(_to,msg.sender,_eth)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
Transfer(msg.sender,_to,0)

IRs:
Emit Transfer(msg.sender,_to,0)"];
29->32;
30[label="Node Type: NEW VARIABLE 30

EXPRESSION:
_buyEvent = InternalBuyEvent({flag1:0})

IRs:
TMP_99(Saturn.InternalBuyEvent) = new InternalBuyEvent(0)
_buyEvent(Saturn.InternalBuyEvent) := TMP_99(Saturn.InternalBuyEvent)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
buy(_player,_buyEvent,_eth)

IRs:
INTERNAL_CALL, Saturn.buy(Saturn.Player,Saturn.InternalBuyEvent,uint256)(_player,_buyEvent,_eth)"];
31->32;
32[label="Node Type: END_IF 32
"];
32->33;
33[label="Node Type: RETURN 33

EXPRESSION:
true

IRs:
RETURN True"];
34[label="Node Type: EXPRESSION 34

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, Saturn.isActivated()()"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
isAccount()

IRs:
MODIFIER_CALL, Saturn.isAccount()()"];
35->1;
36[label="Node Type: IF 36

EXPRESSION:
feeIndex >= feePercents.length

IRs:
REF_67 -> LENGTH feePercents
TMP_103(bool) = feeIndex >= REF_67
CONDITION TMP_103"];
36->37[label="True"];
36->38[label="False"];
37[label="Node Type: EXPRESSION 37

EXPRESSION:
_fee = _eth.mul(0).div(1000)

IRs:
TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', '0'] 
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_104', '1000'] 
_fee(uint256) := TMP_105(uint256)"];
37->39;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
_fee = _eth.mul(feePercents[feeIndex]).div(1000)

IRs:
REF_71(uint8) -> feePercents[feeIndex]
TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_eth', 'REF_71'] 
TMP_107(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_106', '1000'] 
_fee(uint256) := TMP_107(uint256)"];
38->39;
39[label="Node Type: END_IF 39
"];
39->22;
}
// Function: 399.sol-Saturn-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_25 = CONVERT 0 to address
TMP_26(bool) = newOwner != TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 399.sol-Saturn-updateFinishTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE)

IRs:
TMP_300(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_tokenAmount', 'ONE_TOKEN'] 
TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_300', 'TIME_DURATION_INCREASE'] 
_timeDelta(uint256) := TMP_301(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_finishTime = finishTime.add(_timeDelta)

IRs:
TMP_302(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['finishTime', '_timeDelta'] 
_finishTime(uint256) := TMP_302(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_maxTime = now.add(TIME_DURATION_MAX)

IRs:
TMP_303(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['now', 'TIME_DURATION_MAX'] 
_maxTime(uint256) := TMP_303(uint256)"];
3->5;
5[label="Node Type: IF 5

EXPRESSION:
_finishTime <= _maxTime

IRs:
TMP_304(bool) = _finishTime <= _maxTime
CONDITION TMP_304"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
finishTime = _finishTime

IRs:
finishTime(uint256) := _finishTime(uint256)"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
finishTime = _maxTime

IRs:
finishTime(uint256) := _maxTime(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 399.sol-Saturn-updatePrice(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
price = _newTotalSupply.mul(2).div(10000000000).add(88000000000000)

IRs:
TMP_305(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_newTotalSupply', '2'] 
TMP_306(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_305', '10000000000'] 
TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_306', '88000000000000'] 
price(uint256) := TMP_307(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
_idx = feeIndex + 1

IRs:
TMP_308(uint256) = feeIndex + 1
_idx(uint256) := TMP_308(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
_idx < feePrices.length && price >= feePrices[_idx]

IRs:
REF_216 -> LENGTH feePrices
TMP_309(bool) = _idx < REF_216
REF_217(uint64) -> feePrices[_idx]
TMP_310(bool) = price >= REF_217
TMP_311(bool) = TMP_309 && TMP_310
CONDITION TMP_311"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
feeIndex = _idx

IRs:
feeIndex(uint256) := _idx(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
++ _idx

IRs:
_idx(uint256) = _idx + 1"];
6->4;
7[label="Node Type: END_LOOP 7
"];
}
// Function: 399.sol-Saturn-withdrawFee(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now >= finishTime.add(2592000))

IRs:
TMP_324(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['finishTime', '2592000'] 
TMP_325(bool) = now >= TMP_324
TMP_326(None) = SOLIDITY_CALL require(bool)(TMP_325)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
winner == address(0)

IRs:
TMP_327 = CONVERT 0 to address
TMP_328(bool) = winner == TMP_327
CONDITION TMP_328"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
endGame()

IRs:
INTERNAL_CALL, Saturn.endGame()()"];
3->4;
4[label="Node Type: END_IF 4
"];
4->8;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
feeOwner.transfer(_amount)

IRs:
Transfer dest:feeOwner value:_amount"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->1;
8[label="Node Type: IF 8

EXPRESSION:
feeAmount > _amount

IRs:
TMP_332(bool) = feeAmount > _amount
CONDITION TMP_332"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
feeAmount = feeAmount.sub(_amount)

IRs:
TMP_333(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['feeAmount', '_amount'] 
feeAmount(uint256) := TMP_333(uint256)"];
9->11;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
feeAmount = 0

IRs:
feeAmount(uint256) := 0(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->6;
}
}
