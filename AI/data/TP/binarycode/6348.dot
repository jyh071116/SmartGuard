digraph G {
// Function: 6348.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 6348.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 6348.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = _to != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_15(bool) = _value <= REF_0
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_17(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_18(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6348.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 6348.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_100(uint256) -> balances[msg.sender]
TMP_127(bool) = _value <= REF_100
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_101(uint256) -> balances[burner]
REF_102(uint256) -> balances[burner]
TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_102', '_value'] 
REF_101(uint256) (->balances) := TMP_129(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_130(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
}
// Function: 6348.sol-BurnableToken-totalSupply()
digraph{
}
// Function: 6348.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 6348.sol-DutchAuction-DutchAuction(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_walletAddress != 0x0)

IRs:
TMP_214(bool) = _walletAddress != 0
TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
walletAddress = _walletAddress

IRs:
walletAddress(address) := _walletAddress(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerAddress = msg.sender

IRs:
ownerAddress(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
stage = Stages.AuctionDeployed

IRs:
REF_161(DutchAuction.Stages) -> Stages.AuctionDeployed
stage(DutchAuction.Stages) := REF_161(DutchAuction.Stages)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
changeSettings(_startPrice,_priceDecreaseRate,_endTimeOfBids)

IRs:
INTERNAL_CALL, DutchAuction.changeSettings(uint256,uint256,uint256)(_startPrice,_priceDecreaseRate,_endTimeOfBids)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Deployed(_startPrice,_priceDecreaseRate)

IRs:
Emit Deployed(_startPrice,_priceDecreaseRate)"];
}
// Function: 6348.sol-DutchAuction-atStage(DutchAuction.Stages)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(stage == _stage)

IRs:
TMP_306(bool) = stage == _stage
TMP_307(None) = SOLIDITY_CALL require(bool)(TMP_306)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-DutchAuction-bid()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_256(bool) = msg.value > 0
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(bids[msg.sender] + msg.value >= msg.value)

IRs:
REF_173(uint256) -> bids[msg.sender]
TMP_258(uint256) = REF_173 + msg.value
TMP_259(bool) = TMP_258 >= msg.value
TMP_260(None) = SOLIDITY_CALL assert(bool)(TMP_259)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
missingFunds = missingFundsToEndAuction()

IRs:
TMP_261(uint256) = INTERNAL_CALL, DutchAuction.missingFundsToEndAuction()()
missingFunds(uint256) := TMP_261(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.value <= missingFunds)

IRs:
TMP_262(bool) = msg.value <= missingFunds
TMP_263(None) = SOLIDITY_CALL require(bool)(TMP_262)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bids[msg.sender] += msg.value

IRs:
REF_174(uint256) -> bids[msg.sender]
REF_174(-> bids) = REF_174 + msg.value"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
receivedWei += msg.value

IRs:
receivedWei(uint256) = receivedWei + msg.value"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
walletAddress.transfer(msg.value)

IRs:
Transfer dest:walletAddress value:msg.value"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
BidSubmission(msg.sender,msg.value,missingFunds,block.timestamp)

IRs:
Emit BidSubmission(msg.sender,msg.value,missingFunds,block.timestamp)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
assert(bool)(receivedWei >= msg.value)

IRs:
TMP_266(bool) = receivedWei >= msg.value
TMP_267(None) = SOLIDITY_CALL assert(bool)(TMP_266)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
atStage(Stages.AuctionStarted)

IRs:
REF_176(DutchAuction.Stages) -> Stages.AuctionStarted
MODIFIER_CALL, DutchAuction.atStage(DutchAuction.Stages)(REF_176)"];
10->1;
}
// Function: 6348.sol-DutchAuction-calcTokenPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
stage == Stages.AuctionStarted

IRs:
REF_190(DutchAuction.Stages) -> Stages.AuctionStarted
TMP_302(bool) = stage == REF_190
CONDITION TMP_302"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
currentPrice = startPrice - priceDecreaseRate * (block.number - startBlock)

IRs:
TMP_303(uint256) = block.number - startBlock
TMP_304(uint256) = priceDecreaseRate * TMP_303
TMP_305(uint256) = startPrice - TMP_304
currentPrice(uint256) := TMP_305(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
currentPrice = startPrice

IRs:
currentPrice(uint256) := startPrice(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
currentPrice

IRs:
RETURN currentPrice"];
}
// Function: 6348.sol-DutchAuction-changeSettings(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp)

IRs:
REF_167(DutchAuction.Stages) -> Stages.AuctionDeployed
TMP_231(bool) = stage == REF_167
REF_168(DutchAuction.Stages) -> Stages.AuctionSetUp
TMP_232(bool) = stage == REF_168
TMP_233(bool) = TMP_231 || TMP_232
TMP_234(None) = SOLIDITY_CALL require(bool)(TMP_233)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_startPrice > 0)

IRs:
TMP_235(bool) = _startPrice > 0
TMP_236(None) = SOLIDITY_CALL require(bool)(TMP_235)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_priceDecreaseRate > 0)

IRs:
TMP_237(bool) = _priceDecreaseRate > 0
TMP_238(None) = SOLIDITY_CALL require(bool)(TMP_237)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_endTimeOfBids > now)

IRs:
TMP_239(bool) = _endTimeOfBids > now
TMP_240(None) = SOLIDITY_CALL require(bool)(TMP_239)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
endTimeOfBids = _endTimeOfBids

IRs:
endTimeOfBids(uint256) := _endTimeOfBids(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startPrice = _startPrice

IRs:
startPrice(uint256) := _startPrice(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
priceDecreaseRate = _priceDecreaseRate

IRs:
priceDecreaseRate(uint256) := _priceDecreaseRate(uint256)"];
}
// Function: 6348.sol-DutchAuction-claimTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
proxyClaimTokens(msg.sender)

IRs:
TMP_269(bool) = INTERNAL_CALL, DutchAuction.proxyClaimTokens(address)(msg.sender)
RETURN TMP_269"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
atStage(Stages.AuctionEnded)

IRs:
REF_177(DutchAuction.Stages) -> Stages.AuctionEnded
MODIFIER_CALL, DutchAuction.atStage(DutchAuction.Stages)(REF_177)"];
2->1;
}
// Function: 6348.sol-DutchAuction-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bid()

IRs:
INTERNAL_CALL, DutchAuction.bid()()"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
atStage(Stages.AuctionStarted)

IRs:
REF_162(DutchAuction.Stages) -> Stages.AuctionStarted
MODIFIER_CALL, DutchAuction.atStage(DutchAuction.Stages)(REF_162)"];
2->1;
}
// Function: 6348.sol-DutchAuction-finalizeAuction()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
missingFunds = missingFundsToEndAuction()

IRs:
TMP_244(uint256) = INTERNAL_CALL, DutchAuction.missingFundsToEndAuction()()
missingFunds(uint256) := TMP_244(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(missingFunds == 0 || now > endTimeOfBids)

IRs:
TMP_245(bool) = missingFunds == 0
TMP_246(bool) = now > endTimeOfBids
TMP_247(bool) = TMP_245 || TMP_246
TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
finalPrice = tokenMultiplier * receivedWei / tokensAuctioned

IRs:
TMP_249(uint256) = tokenMultiplier * receivedWei
TMP_250(uint256) = TMP_249 / tokensAuctioned
finalPrice(uint256) := TMP_250(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
finalizedTime = now

IRs:
finalizedTime(uint256) := now(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
stage = Stages.AuctionEnded

IRs:
REF_171(DutchAuction.Stages) -> Stages.AuctionEnded
stage(DutchAuction.Stages) := REF_171(DutchAuction.Stages)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
AuctionEnded(finalPrice)

IRs:
Emit AuctionEnded(finalPrice)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(finalPrice > 0)

IRs:
TMP_252(bool) = finalPrice > 0
TMP_253(None) = SOLIDITY_CALL assert(bool)(TMP_252)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, DutchAuction.isOwner()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
atStage(Stages.AuctionStarted)

IRs:
REF_172(DutchAuction.Stages) -> Stages.AuctionStarted
MODIFIER_CALL, DutchAuction.atStage(DutchAuction.Stages)(REF_172)"];
9->1;
}
// Function: 6348.sol-DutchAuction-isOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == ownerAddress)

IRs:
TMP_308(bool) = msg.sender == ownerAddress
TMP_309(None) = SOLIDITY_CALL require(bool)(TMP_308)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-DutchAuction-missingFundsToEndAuction()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
requiredWei = tokensAuctioned * price() / tokenMultiplier

IRs:
TMP_297(uint256) = INTERNAL_CALL, DutchAuction.price()()
TMP_298(uint256) = tokensAuctioned * TMP_297
TMP_299(uint256) = TMP_298 / tokenMultiplier
requiredWei(uint256) := TMP_299(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
requiredWei <= receivedWei

IRs:
TMP_300(bool) = requiredWei <= receivedWei
CONDITION TMP_300"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
requiredWei - receivedWei

IRs:
TMP_301(uint256) = requiredWei - receivedWei
RETURN TMP_301"];
}
// Function: 6348.sol-DutchAuction-price()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
stage == Stages.AuctionEnded || stage == Stages.TokensDistributed

IRs:
REF_188(DutchAuction.Stages) -> Stages.AuctionEnded
TMP_293(bool) = stage == REF_188
REF_189(DutchAuction.Stages) -> Stages.TokensDistributed
TMP_294(bool) = stage == REF_189
TMP_295(bool) = TMP_293 || TMP_294
CONDITION TMP_295"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
finalPrice

IRs:
RETURN finalPrice"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
calcTokenPrice()

IRs:
TMP_296(uint256) = INTERNAL_CALL, DutchAuction.calcTokenPrice()()
RETURN TMP_296"];
}
// Function: 6348.sol-DutchAuction-proxyClaimTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->22;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > finalizedTime + TOKEN_CLAIM_WAITING_PERIOD)

IRs:
TMP_271(uint256) = finalizedTime + TOKEN_CLAIM_WAITING_PERIOD
TMP_272(bool) = now > TMP_271
TMP_273(None) = SOLIDITY_CALL require(bool)(TMP_272)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(receiverAddress != 0x0)

IRs:
TMP_274(bool) = receiverAddress != 0
TMP_275(None) = SOLIDITY_CALL require(bool)(TMP_274)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
bids[receiverAddress] == 0

IRs:
REF_178(uint256) -> bids[receiverAddress]
TMP_276(bool) = REF_178 == 0
CONDITION TMP_276"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
num = (tokenMultiplier * bids[receiverAddress]) / finalPrice

IRs:
REF_179(uint256) -> bids[receiverAddress]
TMP_277(uint256) = tokenMultiplier * REF_179
TMP_278(uint256) = TMP_277 / finalPrice
num(uint256) := TMP_278(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
auctionTokensBalance = token.balanceOf(address(this))

IRs:
TMP_279 = CONVERT this to address
TMP_280(uint256) = HIGH_LEVEL_CALL, dest:token(LetsbetToken), function:balanceOf, arguments:['TMP_279']  
auctionTokensBalance(uint256) := TMP_280(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
num > auctionTokensBalance

IRs:
TMP_281(bool) = num > auctionTokensBalance
CONDITION TMP_281"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
num = auctionTokensBalance

IRs:
num(uint256) := auctionTokensBalance(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
fundsClaimed += bids[receiverAddress]

IRs:
REF_181(uint256) -> bids[receiverAddress]
fundsClaimed(uint256) = fundsClaimed + REF_181"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
bids[receiverAddress] = 0

IRs:
REF_182(uint256) -> bids[receiverAddress]
REF_182(uint256) (->bids) := 0(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(token.transfer(receiverAddress,num))

IRs:
TMP_282(bool) = HIGH_LEVEL_CALL, dest:token(LetsbetToken), function:transfer, arguments:['receiverAddress', 'num']  
TMP_283(None) = SOLIDITY_CALL require(bool)(TMP_282)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
ClaimedTokens(receiverAddress,num)

IRs:
Emit ClaimedTokens(receiverAddress,num)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
fundsClaimed == receivedWei

IRs:
TMP_285(bool) = fundsClaimed == receivedWei
CONDITION TMP_285"];
15->16[label="True"];
15->18[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
stage = Stages.TokensDistributed

IRs:
REF_184(DutchAuction.Stages) -> Stages.TokensDistributed
stage(DutchAuction.Stages) := REF_184(DutchAuction.Stages)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
TokensDistributed()

IRs:
Emit TokensDistributed()"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
assert(bool)(token.balanceOf(receiverAddress) >= num)

IRs:
TMP_287(uint256) = HIGH_LEVEL_CALL, dest:token(LetsbetToken), function:balanceOf, arguments:['receiverAddress']  
TMP_288(bool) = TMP_287 >= num
TMP_289(None) = SOLIDITY_CALL assert(bool)(TMP_288)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
assert(bool)(bids[receiverAddress] == 0)

IRs:
REF_186(uint256) -> bids[receiverAddress]
TMP_290(bool) = REF_186 == 0
TMP_291(None) = SOLIDITY_CALL assert(bool)(TMP_290)"];
20->21;
21[label="Node Type: RETURN 21

EXPRESSION:
true

IRs:
RETURN True"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
atStage(Stages.AuctionEnded)

IRs:
REF_187(DutchAuction.Stages) -> Stages.AuctionEnded
MODIFIER_CALL, DutchAuction.atStage(DutchAuction.Stages)(REF_187)"];
22->1;
}
// Function: 6348.sol-DutchAuction-setup(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_tokenAddress != 0x0)

IRs:
TMP_220(bool) = _tokenAddress != 0
TMP_221(None) = SOLIDITY_CALL require(bool)(TMP_220)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token = LetsbetToken(_tokenAddress)

IRs:
TMP_222 = CONVERT _tokenAddress to LetsbetToken
token(LetsbetToken) := TMP_222(LetsbetToken)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokensAuctioned = token.balanceOf(address(this))

IRs:
TMP_223 = CONVERT this to address
TMP_224(uint256) = HIGH_LEVEL_CALL, dest:token(LetsbetToken), function:balanceOf, arguments:['TMP_223']  
tokensAuctioned(uint256) := TMP_224(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokenMultiplier = 10 ** uint256(token.decimals())

IRs:
TMP_225(uint8) = HIGH_LEVEL_CALL, dest:token(LetsbetToken), function:decimals, arguments:[]  
TMP_226 = CONVERT TMP_225 to uint256
TMP_227(uint256) = 10 ** TMP_226
tokenMultiplier(uint256) := TMP_227(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
stage = Stages.AuctionSetUp

IRs:
REF_165(DutchAuction.Stages) -> Stages.AuctionSetUp
stage(DutchAuction.Stages) := REF_165(DutchAuction.Stages)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Setup()

IRs:
Emit Setup()"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, DutchAuction.isOwner()()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
atStage(Stages.AuctionDeployed)

IRs:
REF_166(DutchAuction.Stages) -> Stages.AuctionDeployed
MODIFIER_CALL, DutchAuction.atStage(DutchAuction.Stages)(REF_166)"];
8->1;
}
// Function: 6348.sol-DutchAuction-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
TOKEN_CLAIM_WAITING_PERIOD = 604800

IRs:
TOKEN_CLAIM_WAITING_PERIOD(uint256) := 604800(uint256)"];
}
// Function: 6348.sol-DutchAuction-startAuction()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
stage = Stages.AuctionStarted

IRs:
REF_169(DutchAuction.Stages) -> Stages.AuctionStarted
stage(DutchAuction.Stages) := REF_169(DutchAuction.Stages)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
startTime = now

IRs:
startTime(uint256) := now(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
startBlock = block.number

IRs:
startBlock(uint256) := block.number(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
AuctionStarted(startTime,startBlock)

IRs:
Emit AuctionStarted(startTime,startBlock)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, DutchAuction.isOwner()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
atStage(Stages.AuctionSetUp)

IRs:
REF_170(DutchAuction.Stages) -> Stages.AuctionSetUp
MODIFIER_CALL, DutchAuction.atStage(DutchAuction.Stages)(REF_170)"];
6->1;
}
// Function: 6348.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 6348.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 6348.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 6348.sol-ERC20-totalSupply()
digraph{
}
// Function: 6348.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 6348.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 6348.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 6348.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 6348.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 6348.sol-LetsbetToken-LetsbetToken(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(auctionAddress != 0x0)

IRs:
TMP_183(bool) = auctionAddress != 0
TMP_184(None) = SOLIDITY_CALL require(bool)(TMP_183)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(walletAddress != 0x0)

IRs:
TMP_185(bool) = walletAddress != 0
TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bountyAddress != 0x0)

IRs:
TMP_187(bool) = bountyAddress != 0
TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = INITIAL_SUPPLY

IRs:
totalSupply_(uint256) := INITIAL_SUPPLY(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[auctionAddress] = AUCTION_TOKENS

IRs:
REF_152(uint256) -> balances[auctionAddress]
REF_152(uint256) (->balances) := AUCTION_TOKENS(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[walletAddress] = TEAM_TOKENS

IRs:
REF_153(uint256) -> balances[walletAddress]
REF_153(uint256) (->balances) := TEAM_TOKENS(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balances[bountyAddress] = BOUNTY_TOKENS

IRs:
REF_154(uint256) -> balances[bountyAddress]
REF_154(uint256) (->balances) := BOUNTY_TOKENS(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(0x0,auctionAddress,balances[auctionAddress])

IRs:
REF_155(uint256) -> balances[auctionAddress]
Emit Transfer(0,auctionAddress,REF_155)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(0x0,walletAddress,balances[walletAddress])

IRs:
REF_156(uint256) -> balances[walletAddress]
Emit Transfer(0,walletAddress,REF_156)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Transfer(0x0,bountyAddress,balances[bountyAddress])

IRs:
REF_157(uint256) -> balances[bountyAddress]
Emit Transfer(0,bountyAddress,REF_157)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Deployed(totalSupply_)

IRs:
Emit Deployed(totalSupply_)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
assert(bool)(totalSupply_ == balances[auctionAddress] + balances[walletAddress] + balances[bountyAddress])

IRs:
REF_158(uint256) -> balances[auctionAddress]
REF_159(uint256) -> balances[walletAddress]
TMP_193(uint256) = REF_158 + REF_159
REF_160(uint256) -> balances[bountyAddress]
TMP_194(uint256) = TMP_193 + REF_160
TMP_195(bool) = totalSupply_ == TMP_194
TMP_196(None) = SOLIDITY_CALL assert(bool)(TMP_195)"];
}
// Function: 6348.sol-LetsbetToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 6348.sol-LetsbetToken-allowance(address,address)
digraph{
}
// Function: 6348.sol-LetsbetToken-approve(address,uint256)
digraph{
}
// Function: 6348.sol-LetsbetToken-balanceOf(address)
digraph{
}
// Function: 6348.sol-LetsbetToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_105(uint256) -> balances[msg.sender]
TMP_132(bool) = _value <= REF_105
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_106(uint256) -> balances[burner]
REF_107(uint256) -> balances[burner]
TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_107', '_value'] 
REF_106(uint256) (->balances) := TMP_134(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_135(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
}
// Function: 6348.sol-LetsbetToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_143(mapping(address => uint256)) -> allowed[msg.sender]
REF_144(uint256) -> REF_143[_spender]
oldValue(uint256) := REF_144(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_180(bool) = _subtractedValue > oldValue
CONDITION TMP_180"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_145(mapping(address => uint256)) -> allowed[msg.sender]
REF_146(uint256) -> REF_145[_spender]
REF_146(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_147(mapping(address => uint256)) -> allowed[msg.sender]
REF_148(uint256) -> REF_147[_spender]
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_148(uint256) (->allowed) := TMP_181(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_150(mapping(address => uint256)) -> allowed[msg.sender]
REF_151(uint256) -> REF_150[_spender]
Emit Approval(msg.sender,_spender,REF_151)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6348.sol-LetsbetToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_136(mapping(address => uint256)) -> allowed[msg.sender]
REF_137(uint256) -> REF_136[_spender]
REF_138(mapping(address => uint256)) -> allowed[msg.sender]
REF_139(uint256) -> REF_138[_spender]
TMP_178(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_139', '_addedValue'] 
REF_137(uint256) (->allowed) := TMP_178(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_141(mapping(address => uint256)) -> allowed[msg.sender]
REF_142(uint256) -> REF_141[_spender]
Emit Approval(msg.sender,_spender,REF_142)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6348.sol-LetsbetToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_212(bool) = msg.sender == owner
TMP_213(None) = SOLIDITY_CALL require(bool)(TMP_212)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-LetsbetToken-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 6348.sol-LetsbetToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Letsbet Token

IRs:
name(string) := Letsbet Token(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = XBET

IRs:
symbol(string) := XBET(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
INITIAL_SUPPLY = 100000000 * 10 ** uint256(decimals)

IRs:
TMP_197 = CONVERT decimals to uint256
TMP_198(uint256) = 10 ** TMP_197
TMP_199(uint256) = 100000000 * TMP_198
INITIAL_SUPPLY(uint256) := TMP_199(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
TEAM_TOKENS = 18000000 * 10 ** uint256(decimals)

IRs:
TMP_200 = CONVERT decimals to uint256
TMP_201(uint256) = 10 ** TMP_200
TMP_202(uint256) = 18000000 * TMP_201
TEAM_TOKENS(uint256) := TMP_202(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
BOUNTY_TOKENS = 5000000 * 10 ** uint256(decimals)

IRs:
TMP_203 = CONVERT decimals to uint256
TMP_204(uint256) = 10 ** TMP_203
TMP_205(uint256) = 5000000 * TMP_204
BOUNTY_TOKENS(uint256) := TMP_205(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
AUCTION_TOKENS = 77000000 * 10 ** uint256(decimals)

IRs:
TMP_206 = CONVERT decimals to uint256
TMP_207(uint256) = 10 ** TMP_206
TMP_208(uint256) = 77000000 * TMP_207
AUCTION_TOKENS(uint256) := TMP_208(uint256)"];
}
// Function: 6348.sol-LetsbetToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 6348.sol-LetsbetToken-totalSupply()
digraph{
}
// Function: 6348.sol-LetsbetToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_145(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)
RETURN TMP_145"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 6348.sol-LetsbetToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 6348.sol-LetsbetToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_161 = CONVERT 0 to address
TMP_162(bool) = newOwner != TMP_161
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 6348.sol-LetsbetToken-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 6348.sol-LetsbetToken-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_209 = UnaryType.BANG paused 
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-LetsbetToken-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_211(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 6348.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_50(bool) = msg.sender == owner
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_45 = CONVERT 0 to address
TMP_46(bool) = newOwner != TMP_45
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 6348.sol-Pausable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 6348.sol-Pausable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_63(bool) = msg.sender == owner
TMP_64(None) = SOLIDITY_CALL require(bool)(TMP_63)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-Pausable-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 6348.sol-Pausable-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 6348.sol-Pausable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_52 = CONVERT 0 to address
TMP_53(bool) = newOwner != TMP_52
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 6348.sol-Pausable-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 6348.sol-Pausable-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_65 = UnaryType.BANG paused 
TMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-Pausable-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_67(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-PausableToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 6348.sol-PausableToken-allowance(address,address)
digraph{
}
// Function: 6348.sol-PausableToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.approve(_spender,_value)

IRs:
TMP_108(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
RETURN TMP_108"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 6348.sol-PausableToken-balanceOf(address)
digraph{
}
// Function: 6348.sol-PausableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.decreaseApproval(_spender,_subtractedValue)

IRs:
TMP_112(bool) = INTERNAL_CALL, StandardToken.decreaseApproval(address,uint256)(_spender,_subtractedValue)
RETURN TMP_112"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 6348.sol-PausableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.increaseApproval(_spender,_addedValue)

IRs:
TMP_110(bool) = INTERNAL_CALL, StandardToken.increaseApproval(address,uint256)(_spender,_addedValue)
RETURN TMP_110"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 6348.sol-PausableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_117(bool) = msg.sender == owner
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-PausableToken-pause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = true

IRs:
paused(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Pause()

IRs:
Emit Pause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
4->1;
}
// Function: 6348.sol-PausableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
}
// Function: 6348.sol-PausableToken-totalSupply()
digraph{
}
// Function: 6348.sol-PausableToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_104(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)
RETURN TMP_104"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 6348.sol-PausableToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_106(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_106"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()"];
2->1;
}
// Function: 6348.sol-PausableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_74 = CONVERT 0 to address
TMP_75(bool) = newOwner != TMP_74
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 6348.sol-PausableToken-unpause()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
paused = false

IRs:
paused(bool) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Unpause()

IRs:
Emit Unpause()"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, Pausable.whenPaused()()"];
4->1;
}
// Function: 6348.sol-PausableToken-whenNotPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! paused)

IRs:
TMP_114 = UnaryType.BANG paused 
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-PausableToken-whenPaused()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(paused)

IRs:
TMP_116(None) = SOLIDITY_CALL require(bool)(paused)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6348.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 6348.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_5(uint256) = a / b
c(uint256) := TMP_5(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 6348.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 6348.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 6348.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 6348.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6348.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 6348.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_42(bool) = _subtractedValue > oldValue
CONDITION TMP_42"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_43(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6348.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_40(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6348.sol-StandardToken-totalSupply()
digraph{
}
// Function: 6348.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 6348.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_28 = CONVERT 0 to address
TMP_29(bool) = _to != TMP_28
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_31(bool) = _value <= REF_16
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_33(bool) = _value <= REF_18
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_35(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_36(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_37(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
}
