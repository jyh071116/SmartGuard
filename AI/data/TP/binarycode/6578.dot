digraph G {
// Function: 6578.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
}
// Function: 6578.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 6578.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_23 = CONVERT 0 to address
TMP_24(bool) = _to != TMP_23
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_26(bool) = _value <= REF_0
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_28(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_29(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6578.sol-CryptualProjectToken-_getCrowdsaleTokenAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
uncountedWeiRaised = crowdsaleWeiRaised

IRs:
uncountedWeiRaised(uint256) := crowdsaleWeiRaised(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
uncountedWeiAmount = _weiAmount

IRs:
uncountedWeiAmount(uint256) := _weiAmount(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokenAmount = 0

IRs:
tokenAmount(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->24;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < crowdsaleWeiAvailableLevels.length

IRs:
REF_113 -> LENGTH crowdsaleWeiAvailableLevels
TMP_141(bool) = i < REF_113
CONDITION TMP_141"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
weiAvailable = crowdsaleWeiAvailableLevels[i]

IRs:
REF_114(uint256) -> crowdsaleWeiAvailableLevels[i]
weiAvailable(uint256) := REF_114(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
rate = crowdsaleRates[i]

IRs:
REF_115(uint256) -> crowdsaleRates[i]
rate(uint256) := REF_115(uint256)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
uncountedWeiRaised < weiAvailable

IRs:
TMP_142(bool) = uncountedWeiRaised < weiAvailable
CONDITION TMP_142"];
10->11[label="True"];
10->21[label="False"];
11[label="Node Type: IF 11

EXPRESSION:
uncountedWeiRaised > 0

IRs:
TMP_143(bool) = uncountedWeiRaised > 0
CONDITION TMP_143"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
weiAvailable = weiAvailable.sub(uncountedWeiRaised)

IRs:
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['weiAvailable', 'uncountedWeiRaised'] 
weiAvailable(uint256) := TMP_144(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
uncountedWeiRaised = 0

IRs:
uncountedWeiRaised(uint256) := 0(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
uncountedWeiAmount <= weiAvailable

IRs:
TMP_145(bool) = uncountedWeiAmount <= weiAvailable
CONDITION TMP_145"];
15->16[label="True"];
15->18[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
tokenAmount = tokenAmount.add(uncountedWeiAmount.mul(rate))

IRs:
TMP_146(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['uncountedWeiAmount', 'rate'] 
TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenAmount', 'TMP_146'] 
tokenAmount(uint256) := TMP_147(uint256)"];
16->17;
17[label="Node Type: BREAK 17
"];
17->5;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
uncountedWeiAmount = uncountedWeiAmount.sub(weiAvailable)

IRs:
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['uncountedWeiAmount', 'weiAvailable'] 
uncountedWeiAmount(uint256) := TMP_148(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
tokenAmount = tokenAmount.add(weiAvailable.mul(rate))

IRs:
TMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAvailable', 'rate'] 
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenAmount', 'TMP_149'] 
tokenAmount(uint256) := TMP_150(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->22;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
uncountedWeiRaised = uncountedWeiRaised.sub(weiAvailable)

IRs:
TMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['uncountedWeiRaised', 'weiAvailable'] 
uncountedWeiRaised(uint256) := TMP_151(uint256)"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
i ++

IRs:
TMP_152(uint256) := i(uint256)
i(uint256) = i + 1"];
23->7;
24[label="Node Type: RETURN 24

EXPRESSION:
tokenAmount.div(1000000000000000000)

IRs:
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['tokenAmount', '1000000000000000000'] 
RETURN TMP_153"];
}
// Function: 6578.sol-CryptualProjectToken-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply_ = totalSupply_.add(_tokenAmount)

IRs:
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_tokenAmount'] 
totalSupply_(uint256) := TMP_154(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount)

IRs:
REF_125(uint256) -> balances[_beneficiary]
REF_126(uint256) -> balances[_beneficiary]
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_126', '_tokenAmount'] 
REF_125(uint256) (->balances) := TMP_155(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0x0,_beneficiary,_tokenAmount)

IRs:
Emit Transfer(0,_beneficiary,_tokenAmount)"];
}
// Function: 6578.sol-CryptualProjectToken-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_61 = CONVERT 0 to address
TMP_62(bool) = _newOwner != TMP_61
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 6578.sol-CryptualProjectToken-addManyToPresaleWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_129 -> LENGTH _beneficiaries
TMP_158(bool) = i < REF_129
CONDITION TMP_158"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
whitelist[_beneficiaries[i]] = true

IRs:
REF_130(address) -> _beneficiaries[i]
REF_131(bool) -> whitelist[REF_130]
REF_131(bool) (->whitelist) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_159(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->3;
}
// Function: 6578.sol-CryptualProjectToken-addToPresaleWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = true

IRs:
REF_128(bool) -> whitelist[_beneficiary]
REF_128(bool) (->whitelist) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 6578.sol-CryptualProjectToken-allowance(address,address)
digraph{
}
// Function: 6578.sol-CryptualProjectToken-approve(address,uint256)
digraph{
}
// Function: 6578.sol-CryptualProjectToken-balanceOf(address)
digraph{
}
// Function: 6578.sol-CryptualProjectToken-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = _beneficiary != TMP_95
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(weiAmount != 0)

IRs:
TMP_98(bool) = weiAmount != 0
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME

IRs:
TMP_100(bool) = block.timestamp >= PRESALE_OPENING_TIME
TMP_101(bool) = block.timestamp <= PRESALE_CLOSING_TIME
TMP_102(bool) = TMP_100 && TMP_101
isPresale(bool) := TMP_102(bool)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME

IRs:
TMP_103(bool) = block.timestamp >= CROWDSALE_OPENING_TIME
TMP_104(bool) = block.timestamp <= CROWDSALE_CLOSING_TIME
TMP_105(bool) = TMP_103 && TMP_104
isCrowdsale(bool) := TMP_105(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(isPresale || isCrowdsale)

IRs:
TMP_106(bool) = isPresale || isCrowdsale
TMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
isCrowdsale

IRs:
CONDITION isCrowdsale"];
8->9[label="True"];
8->14[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP)

IRs:
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['crowdsaleWeiRaised', 'weiAmount'] 
TMP_109(bool) = TMP_108 <= CROWDSALE_WEI_CAP
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap())

IRs:
REF_94(uint256) -> crowdsaleContributions[_beneficiary]
TMP_111(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_94', 'weiAmount'] 
TMP_112(uint256) = INTERNAL_CALL, CryptualProjectToken.getCrowdsaleUserCap()()
TMP_113(bool) = TMP_111 <= TMP_112
TMP_114(None) = SOLIDITY_CALL require(bool)(TMP_113)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tokens = _getCrowdsaleTokenAmount(weiAmount)

IRs:
TMP_115(uint256) = INTERNAL_CALL, CryptualProjectToken._getCrowdsaleTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_115(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(tokens != 0)

IRs:
TMP_116(bool) = tokens != 0
TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
crowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount)

IRs:
TMP_118(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['crowdsaleWeiRaised', 'weiAmount'] 
crowdsaleWeiRaised(uint256) := TMP_118(uint256)"];
13->21;
14[label="Node Type: IF 14

EXPRESSION:
isPresale

IRs:
CONDITION isPresale"];
14->15[label="True"];
14->20[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP)

IRs:
TMP_119(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presaleWeiRaised', 'weiAmount'] 
TMP_120(bool) = TMP_119 <= PRESALE_WEI_CAP
TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
require(bool)(whitelist[_beneficiary])

IRs:
REF_98(bool) -> whitelist[_beneficiary]
TMP_122(None) = SOLIDITY_CALL require(bool)(REF_98)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
tokens = weiAmount.mul(PRESALE_RATE).div(1000000000000000000)

IRs:
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'PRESALE_RATE'] 
TMP_124(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_123', '1000000000000000000'] 
tokens(uint256) := TMP_124(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(tokens != 0)

IRs:
TMP_125(bool) = tokens != 0
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
presaleWeiRaised = presaleWeiRaised.add(weiAmount)

IRs:
TMP_127(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presaleWeiRaised', 'weiAmount'] 
presaleWeiRaised(uint256) := TMP_127(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, CryptualProjectToken._processPurchase(address,uint256)(_beneficiary,tokens)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)"];
23->24;
24[label="Node Type: IF 24

EXPRESSION:
isCrowdsale

IRs:
CONDITION isCrowdsale"];
24->25[label="True"];
24->26[label="False"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount)

IRs:
REF_102(uint256) -> crowdsaleContributions[_beneficiary]
REF_103(uint256) -> crowdsaleContributions[_beneficiary]
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_103', 'weiAmount'] 
REF_102(uint256) (->crowdsaleContributions) := TMP_130(uint256)"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
deposited[_beneficiary] = deposited[_beneficiary].add(msg.value)

IRs:
REF_105(uint256) -> deposited[_beneficiary]
REF_106(uint256) -> deposited[_beneficiary]
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_106', 'msg.value'] 
REF_105(uint256) (->deposited) := TMP_131(uint256)"];
}
// Function: 6578.sol-CryptualProjectToken-claimRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isCrowdsaleFinalized)

IRs:
TMP_176(None) = SOLIDITY_CALL require(bool)(isCrowdsaleFinalized)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! combinedGoalReached())

IRs:
TMP_177(bool) = INTERNAL_CALL, CryptualProjectToken.combinedGoalReached()()
TMP_178 = UnaryType.BANG TMP_177 
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(deposited[msg.sender] > 0)

IRs:
REF_134(uint256) -> deposited[msg.sender]
TMP_180(bool) = REF_134 > 0
TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
depositedValue = deposited[msg.sender]

IRs:
REF_135(uint256) -> deposited[msg.sender]
depositedValue(uint256) := REF_135(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
deposited[msg.sender] = 0

IRs:
REF_136(uint256) -> deposited[msg.sender]
REF_136(uint256) (->deposited) := 0(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(depositedValue)

IRs:
Transfer dest:msg.sender value:depositedValue"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Refunded(msg.sender,depositedValue)

IRs:
Emit Refunded(msg.sender,depositedValue)"];
}
// Function: 6578.sol-CryptualProjectToken-combinedGoalReached()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
presaleWeiRaised.add(crowdsaleWeiRaised) >= COMBINED_WEI_GOAL

IRs:
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presaleWeiRaised', 'crowdsaleWeiRaised'] 
TMP_185(bool) = TMP_184 >= COMBINED_WEI_GOAL
RETURN TMP_185"];
}
// Function: 6578.sol-CryptualProjectToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 6578.sol-CryptualProjectToken-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_90 = CONVERT 0 to address
TMP_91(bool) = _wallet != TMP_90
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = INITIAL_SUPPLY

IRs:
totalSupply_(uint256) := INITIAL_SUPPLY(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = INITIAL_SUPPLY

IRs:
REF_92(uint256) -> balances[msg.sender]
REF_92(uint256) (->balances) := INITIAL_SUPPLY(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(0x0,msg.sender,INITIAL_SUPPLY)

IRs:
Emit Transfer(0,msg.sender,INITIAL_SUPPLY)"];
}
// Function: 6578.sol-CryptualProjectToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
oldValue(uint256) := REF_76(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_79(bool) = _subtractedValue > oldValue
CONDITION TMP_79"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
REF_78(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_80(uint256) (->allowed) := TMP_80(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
Emit Approval(msg.sender,_spender,REF_83)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6578.sol-CryptualProjectToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, CryptualProjectToken.buyTokens(address)(msg.sender)"];
}
// Function: 6578.sol-CryptualProjectToken-finalizeCrowdsale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isCrowdsaleFinalized)

IRs:
TMP_162 = UnaryType.BANG isCrowdsaleFinalized 
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL))

IRs:
TMP_164(bool) = block.timestamp > CROWDSALE_CLOSING_TIME
TMP_165(bool) = block.timestamp > PRESALE_CLOSING_TIME
TMP_166(bool) = presaleWeiRaised < PRESALE_WEI_GOAL
TMP_167(bool) = TMP_165 && TMP_166
TMP_168(bool) = TMP_164 || TMP_167
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
combinedGoalReached()

IRs:
TMP_170(bool) = INTERNAL_CALL, CryptualProjectToken.combinedGoalReached()()
CONDITION TMP_170"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(address(this).balance)

IRs:
TMP_171 = CONVERT this to address
TMP_172(uint256) = SOLIDITY_CALL balance(address)(TMP_171)
Transfer dest:wallet value:TMP_172"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
RefundsEnabled()

IRs:
Emit RefundsEnabled()"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
CrowdsaleFinalized()

IRs:
Emit CrowdsaleFinalized()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isCrowdsaleFinalized = true

IRs:
isCrowdsaleFinalized(bool) := True(bool)"];
}
// Function: 6578.sol-CryptualProjectToken-getCrowdsaleUserCap()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME)

IRs:
TMP_132(bool) = block.timestamp >= CROWDSALE_OPENING_TIME
TMP_133(bool) = block.timestamp <= CROWDSALE_CLOSING_TIME
TMP_134(bool) = TMP_132 && TMP_133
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME)

IRs:
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.timestamp', 'CROWDSALE_OPENING_TIME'] 
elapsedTime(uint256) := TMP_136(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
currentMinElapsedTime = 0

IRs:
currentMinElapsedTime(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
currentCap = 0

IRs:
currentCap(uint256) := 0(uint256)"];
4->7;
5[label="Node Type: BEGIN_LOOP 5
"];
5->8;
6[label="Node Type: END_LOOP 6
"];
6->17;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
7->5;
8[label="Node Type: IF_LOOP 8

EXPRESSION:
i < crowdsaleUserCaps.length

IRs:
REF_109 -> LENGTH crowdsaleUserCaps
TMP_137(bool) = i < REF_109
CONDITION TMP_137"];
8->9[label="True"];
8->6[label="False"];
9[label="Node Type: IF 9

EXPRESSION:
elapsedTime < crowdsaleMinElapsedTimeLevels[i]

IRs:
REF_110(uint256) -> crowdsaleMinElapsedTimeLevels[i]
TMP_138(bool) = elapsedTime < REF_110
CONDITION TMP_138"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: CONTINUE 10
"];
10->16;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime

IRs:
REF_111(uint256) -> crowdsaleMinElapsedTimeLevels[i]
TMP_139(bool) = REF_111 < currentMinElapsedTime
CONDITION TMP_139"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: CONTINUE 13
"];
13->16;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
currentCap = crowdsaleUserCaps[i]

IRs:
REF_112(uint256) -> crowdsaleUserCaps[i]
currentCap(uint256) := REF_112(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_140(uint256) := i(uint256)
i(uint256) = i + 1"];
16->8;
17[label="Node Type: RETURN 17

EXPRESSION:
currentCap

IRs:
RETURN currentCap"];
}
// Function: 6578.sol-CryptualProjectToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
TMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] 
REF_69(uint256) (->allowed) := TMP_77(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_73(mapping(address => uint256)) -> allowed[msg.sender]
REF_74(uint256) -> REF_73[_spender]
Emit Approval(msg.sender,_spender,REF_74)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6578.sol-CryptualProjectToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_190(bool) = msg.sender == owner
TMP_191(None) = SOLIDITY_CALL require(bool)(TMP_190)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6578.sol-CryptualProjectToken-removeFromPresaleWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = false

IRs:
REF_132(bool) -> whitelist[_beneficiary]
REF_132(bool) (->whitelist) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 6578.sol-CryptualProjectToken-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_57 = CONVERT 0 to address
owner(address) := TMP_57(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 6578.sol-CryptualProjectToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Cryptual Project Token

IRs:
name(string) := Cryptual Project Token(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = CPT

IRs:
symbol(string) := CPT(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 0

IRs:
decimals(uint8) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
INITIAL_SUPPLY = 283000000

IRs:
INITIAL_SUPPLY(uint256) := 283000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
PRESALE_OPENING_TIME = 1531998000

IRs:
PRESALE_OPENING_TIME(uint256) := 1531998000(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
PRESALE_CLOSING_TIME = 1532563200

IRs:
PRESALE_CLOSING_TIME(uint256) := 1532563200(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
PRESALE_RATE = 150000

IRs:
PRESALE_RATE(uint256) := 150000(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
PRESALE_WEI_CAP = 500000000000000000000

IRs:
PRESALE_WEI_CAP(uint256) := 500000000000000000000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
PRESALE_WEI_GOAL = 50000000000000000000

IRs:
PRESALE_WEI_GOAL(uint256) := 50000000000000000000(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
CROWDSALE_OPENING_TIME = 1532602800

IRs:
CROWDSALE_OPENING_TIME(uint256) := 1532602800(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
CROWDSALE_CLOSING_TIME = 1535328000

IRs:
CROWDSALE_CLOSING_TIME(uint256) := 1535328000(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
CROWDSALE_WEI_CAP = 5000000000000000000000

IRs:
CROWDSALE_WEI_CAP(uint256) := 5000000000000000000000(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
COMBINED_WEI_GOAL = 750000000000000000000

IRs:
COMBINED_WEI_GOAL(uint256) := 750000000000000000000(uint256)"];
}
// Function: 6578.sol-CryptualProjectToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
crowdsaleWeiAvailableLevels = (1000000000000000000000,1500000000000000000000,2000000000000000000000)

IRs:
crowdsaleWeiAvailableLevels(uint256[]) = ['1000000000000000000000(uint256)', '1500000000000000000000(uint256)', '2000000000000000000000(uint256)']"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
crowdsaleRates = (135000,120000,100000)

IRs:
crowdsaleRates(uint256[]) = ['135000(uint256)', '120000(uint256)', '100000(uint256)']"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
crowdsaleMinElapsedTimeLevels = (0,12 * 3600,18 * 3600,21 * 3600,22 * 3600)

IRs:
TMP_186(uint256) = 12 * 3600
TMP_187(uint256) = 18 * 3600
TMP_188(uint256) = 21 * 3600
TMP_189(uint256) = 22 * 3600
crowdsaleMinElapsedTimeLevels(uint256[]) = ['0(uint256)', 'TMP_186(uint256)', 'TMP_187(uint256)', 'TMP_188(uint256)', 'TMP_189(uint256)']"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
crowdsaleUserCaps = (1000000000000000000,2000000000000000000,4000000000000000000,8000000000000000000,CROWDSALE_WEI_CAP)

IRs:
crowdsaleUserCaps(uint256[]) = ['1000000000000000000(uint256)', '2000000000000000000(uint256)', '4000000000000000000(uint256)', '8000000000000000000(uint256)', 'CROWDSALE_WEI_CAP(uint256)']"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
isCrowdsaleFinalized = false

IRs:
isCrowdsaleFinalized(bool) := False(bool)"];
}
// Function: 6578.sol-CryptualProjectToken-totalSupply()
digraph{
}
// Function: 6578.sol-CryptualProjectToken-transfer(address,uint256)
digraph{
}
// Function: 6578.sol-CryptualProjectToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 6578.sol-CryptualProjectToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 6578.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 6578.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 6578.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 6578.sol-ERC20-totalSupply()
digraph{
}
// Function: 6578.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 6578.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 6578.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 6578.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 6578.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 6578.sol-Ownable-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_17 = CONVERT 0 to address
TMP_18(bool) = _newOwner != TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 6578.sol-Ownable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 6578.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_21(bool) = msg.sender == owner
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 6578.sol-Ownable-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_13 = CONVERT 0 to address
owner(address) := TMP_13(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 6578.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 6578.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 6578.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a / b

IRs:
TMP_5(uint256) = a / b
RETURN TMP_5"];
}
// Function: 6578.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 6578.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 6578.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 6578.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6578.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 6578.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_53(bool) = _subtractedValue > oldValue
CONDITION TMP_53"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_54(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6578.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_51(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 6578.sol-StandardToken-totalSupply()
digraph{
}
// Function: 6578.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 6578.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_39 = CONVERT 0 to address
TMP_40(bool) = _to != TMP_39
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_42(bool) = _value <= REF_16
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_44(bool) = _value <= REF_18
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_46(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_47(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_48(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
}
