digraph G {
// Function: 7627.sol-Cosigner-claim(address,uint256,bytes)
digraph{
}
// Function: 7627.sol-Cosigner-cost(address,uint256,bytes,bytes)
digraph{
}
// Function: 7627.sol-Cosigner-requestCosign(Engine,uint256,bytes,bytes)
digraph{
}
// Function: 7627.sol-Cosigner-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = 2

IRs:
VERSION(uint256) := 2(uint256)"];
}
// Function: 7627.sol-Cosigner-url()
digraph{
}
// Function: 7627.sol-ERC721-approve(address,uint256)
digraph{
}
// Function: 7627.sol-ERC721-balanceOf(address)
digraph{
}
// Function: 7627.sol-ERC721-getApproved(uint256)
digraph{
}
// Function: 7627.sol-ERC721-isApprovedForAll(address,address)
digraph{
}
// Function: 7627.sol-ERC721-name()
digraph{
}
// Function: 7627.sol-ERC721-ownerOf(uint256)
digraph{
}
// Function: 7627.sol-ERC721-setApprovalForAll(address,bool)
digraph{
}
// Function: 7627.sol-ERC721-symbol()
digraph{
}
// Function: 7627.sol-ERC721-takeOwnership(uint256)
digraph{
}
// Function: 7627.sol-ERC721-tokenMetadata(uint256)
digraph{
}
// Function: 7627.sol-ERC721-totalSupply()
digraph{
}
// Function: 7627.sol-ERC721-transfer(address,uint256)
digraph{
}
// Function: 7627.sol-Engine-approveLoan(uint256)
digraph{
}
// Function: 7627.sol-Engine-cosign(uint256,uint256)
digraph{
}
// Function: 7627.sol-Engine-getAmount(uint256)
digraph{
}
// Function: 7627.sol-Engine-getApprobation(uint256,address)
digraph{
}
// Function: 7627.sol-Engine-getBorrower(uint256)
digraph{
}
// Function: 7627.sol-Engine-getCosigner(uint256)
digraph{
}
// Function: 7627.sol-Engine-getCreator(uint256)
digraph{
}
// Function: 7627.sol-Engine-getCurrency(uint256)
digraph{
}
// Function: 7627.sol-Engine-getDueTime(uint256)
digraph{
}
// Function: 7627.sol-Engine-getOracle(uint256)
digraph{
}
// Function: 7627.sol-Engine-getPaid(uint256)
digraph{
}
// Function: 7627.sol-Engine-getPendingAmount(uint256)
digraph{
}
// Function: 7627.sol-Engine-getStatus(uint256)
digraph{
}
// Function: 7627.sol-Engine-getTotalLoans()
digraph{
}
// Function: 7627.sol-Engine-isApproved(uint256)
digraph{
}
// Function: 7627.sol-Engine-ownerOf(uint256)
digraph{
}
// Function: 7627.sol-Engine-takeOwnership(uint256)
digraph{
}
// Function: 7627.sol-Engine-transfer(address,uint256)
digraph{
}
// Function: 7627.sol-Engine-withdrawal(uint256,address,uint256)
digraph{
}
// Function: 7627.sol-NanoLoanEngine-NanoLoanEngine(Token)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
rcn = _rcn

IRs:
rcn(Token) := _rcn(Token)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
loans.length ++

IRs:
REF_31 -> LENGTH loans
TMP_110(uint256) := REF_31(uint256)
REF_31(-> loans) = REF_31 + 1"];
}
// Function: 7627.sol-NanoLoanEngine-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7627.sol-NanoLoanEngine-addInterest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_207(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_207(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(loan.status == Status.lent)

IRs:
REF_208(Engine.Status) -> loan.status
REF_209(Engine.Status) -> Status.lent
TMP_261(bool) = REF_208 == REF_209
TMP_262(None) = SOLIDITY_CALL require(bool)(TMP_261)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
internalAddInterest(loan,block.timestamp)

IRs:
INTERNAL_CALL, NanoLoanEngine.internalAddInterest(NanoLoanEngine.Loan,uint256)(loan,block.timestamp)"];
}
// Function: 7627.sol-NanoLoanEngine-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_174(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_174(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == loan.lender)

IRs:
REF_175(address) -> loan.lender
TMP_225(bool) = msg.sender == REF_175
TMP_226(None) = SOLIDITY_CALL require(bool)(TMP_225)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
loan.approvedTransfer = to

IRs:
REF_176(address) -> loan.approvedTransfer
REF_176(address) (->loan) := to(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Approval(msg.sender,to,index)

IRs:
Emit Approval(msg.sender,to,index)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-approveLoan(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_98(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_98(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(loan.status == Status.initial)

IRs:
REF_99(Engine.Status) -> loan.status
REF_100(Engine.Status) -> Status.initial
TMP_144(bool) = REF_99 == REF_100
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
loan.approbations[msg.sender] = true

IRs:
REF_101(mapping(address => bool)) -> loan.approbations
REF_102(bool) -> REF_101[msg.sender]
REF_102(bool) (->loan) := True(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ApprovedBy(index,msg.sender)

IRs:
Emit ApprovedBy(index,msg.sender)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-approveLoanIdentifier(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
index = identifierToIndex[identifier]

IRs:
REF_103(uint256) -> identifierToIndex[identifier]
index(uint256) := REF_103(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(index != 0)

IRs:
TMP_147(bool) = index != 0
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
approveLoan(index)

IRs:
TMP_149(bool) = INTERNAL_CALL, NanoLoanEngine.approveLoan(uint256)(index)
RETURN TMP_149"];
}
// Function: 7627.sol-NanoLoanEngine-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_balance = lendersBalance[_owner]

IRs:
REF_17(uint256) -> lendersBalance[_owner]
_balance(uint256) := REF_17(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_balance

IRs:
RETURN _balance"];
}
// Function: 7627.sol-NanoLoanEngine-buildIdentifier(Oracle,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
keccak256()(this,oracle,borrower,creator,currency,amount,interestRate,interestRatePunitory,duesIn,cancelableAt,expirationRequest,metadata)

IRs:
TMP_143(bytes32) = SOLIDITY_CALL keccak256()(this,oracle,borrower,creator,currency,amount,interestRate,interestRatePunitory,duesIn,cancelableAt,expirationRequest,metadata)
RETURN TMP_143"];
}
// Function: 7627.sol-NanoLoanEngine-calculateInterest(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
amount == 0

IRs:
TMP_234(bool) = amount == 0
CONDITION TMP_234"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
interest = 0

IRs:
interest(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
realDelta = timeDelta

IRs:
realDelta(uint256) := timeDelta(uint256)"];
3->6;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
interest = safeMult(safeMult(100000,amount),timeDelta) / interestRate

IRs:
TMP_235(uint256) = INTERNAL_CALL, RpSafeMath.safeMult(uint256,uint256)(100000,amount)
TMP_236(uint256) = INTERNAL_CALL, RpSafeMath.safeMult(uint256,uint256)(TMP_235,timeDelta)
TMP_237(uint256) = TMP_236 / interestRate
interest(uint256) := TMP_237(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
realDelta = safeMult(interest,interestRate) / (amount * 100000)

IRs:
TMP_238(uint256) = INTERNAL_CALL, RpSafeMath.safeMult(uint256,uint256)(interest,interestRate)
TMP_239(uint256) = amount * 100000
TMP_240(uint256) = TMP_238 / TMP_239
realDelta(uint256) := TMP_240(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(realDelta,interest)

IRs:
RETURN realDelta,interest"];
}
// Function: 7627.sol-NanoLoanEngine-convertRate(Oracle,bytes32,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
oracle == address(0)

IRs:
TMP_284 = CONVERT 0 to address
TMP_285(bool) = oracle == TMP_284
CONDITION TMP_285"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
amount

IRs:
RETURN amount"];
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
(rate,decimals) = oracle.getRate(currency,data)

IRs:
TUPLE_2(uint256,uint256) = HIGH_LEVEL_CALL, dest:oracle(Oracle), function:getRate, arguments:['currency', 'data']  
rate(uint256)= UNPACK TUPLE_2 index: 0 
decimals(uint256)= UNPACK TUPLE_2 index: 1 "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(decimals <= RCN_DECIMALS)

IRs:
TMP_286(bool) = decimals <= RCN_DECIMALS
TMP_287(None) = SOLIDITY_CALL require(bool)(TMP_286)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(safeMult(safeMult(amount,rate),(10 ** (RCN_DECIMALS - decimals)))) / PRECISION

IRs:
TMP_288(uint256) = INTERNAL_CALL, RpSafeMath.safeMult(uint256,uint256)(amount,rate)
TMP_289(uint256) = RCN_DECIMALS - decimals
TMP_290(uint256) = 10 ** TMP_289
TMP_291(uint256) = INTERNAL_CALL, RpSafeMath.safeMult(uint256,uint256)(TMP_288,TMP_290)
TMP_292(uint256) = TMP_291 / PRECISION
RETURN TMP_292"];
}
// Function: 7627.sol-NanoLoanEngine-cosign(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_135(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_135(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp)

IRs:
REF_136(Engine.Status) -> loan.status
REF_137(Engine.Status) -> Status.lent
TMP_182(bool) = REF_136 == REF_137
REF_138(uint256) -> loan.dueTime
REF_139(uint256) -> loan.duesIn
TMP_183(uint256) = REF_138 - REF_139
TMP_184(bool) = TMP_183 == block.timestamp
TMP_185(bool) = TMP_182 && TMP_184
TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(loan.cosigner != address(0))

IRs:
REF_140(address) -> loan.cosigner
TMP_187 = CONVERT 0 to address
TMP_188(bool) = REF_140 != TMP_187
TMP_189(None) = SOLIDITY_CALL require(bool)(TMP_188)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(loan.cosigner == address(uint256(msg.sender) + 2))

IRs:
REF_141(address) -> loan.cosigner
TMP_190 = CONVERT msg.sender to uint256
TMP_191(uint256) = TMP_190 + 2
TMP_192 = CONVERT TMP_191 to address
TMP_193(bool) = REF_141 == TMP_192
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
loan.cosigner = msg.sender

IRs:
REF_142(address) -> loan.cosigner
REF_142(address) (->loan) := msg.sender(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(rcn.transferFrom(loan.lender,msg.sender,cost))

IRs:
REF_144(address) -> loan.lender
TMP_195(bool) = HIGH_LEVEL_CALL, dest:rcn(Token), function:transferFrom, arguments:['REF_144', 'msg.sender', 'cost']  
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-createLoan(Oracle,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! deprecated)

IRs:
TMP_111 = UnaryType.BANG deprecated 
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_cancelableAt <= _duesIn)

IRs:
TMP_113(bool) = _cancelableAt <= _duesIn
TMP_114(None) = SOLIDITY_CALL require(bool)(TMP_113)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_oracleContract != address(0) || _currency == 0x0)

IRs:
TMP_115 = CONVERT 0 to address
TMP_116(bool) = _oracleContract != TMP_115
TMP_117(bool) = _currency == 0
TMP_118(bool) = TMP_116 || TMP_117
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_borrower != address(0))

IRs:
TMP_120 = CONVERT 0 to address
TMP_121(bool) = _borrower != TMP_120
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_amount != 0)

IRs:
TMP_123(bool) = _amount != 0
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(_interestRatePunitory != 0)

IRs:
TMP_125(bool) = _interestRatePunitory != 0
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(_interestRate != 0)

IRs:
TMP_127(bool) = _interestRate != 0
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(_expirationRequest > block.timestamp)

IRs:
TMP_129(bool) = _expirationRequest > block.timestamp
TMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
loan = Loan(Status.initial,_oracleContract,_borrower,0x0,msg.sender,0x0,_amount,0,0,0,0,_interestRate,_interestRatePunitory,0,_duesIn,_currency,_cancelableAt,0,0x0,_expirationRequest,_metadata)

IRs:
REF_32(Engine.Status) -> Status.initial
TMP_131(NanoLoanEngine.Loan) = new Loan(REF_32,_oracleContract,_borrower,0,msg.sender,0,_amount,0,0,0,0,_interestRate,_interestRatePunitory,0,_duesIn,_currency,_cancelableAt,0,0,_expirationRequest,_metadata)
loan(NanoLoanEngine.Loan) := TMP_131(NanoLoanEngine.Loan)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
index = loans.push(loan) - 1

IRs:
REF_34 -> LENGTH loans
TMP_134(uint256) := REF_34(uint256)
TMP_135(uint256) = TMP_134 + 1
REF_34(uint256) (->loans) := TMP_135(uint256)
REF_35(NanoLoanEngine.Loan) -> loans[TMP_134]
REF_35(NanoLoanEngine.Loan) (->loans) := loan(NanoLoanEngine.Loan)
TMP_133(None) = TMP_132 - 1
index(uint256) := TMP_133(None)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
CreatedLoan(index,_borrower,msg.sender)

IRs:
Emit CreatedLoan(index,_borrower,msg.sender)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
identifier = getIdentifier(index)

IRs:
TMP_137(bytes32) = INTERNAL_CALL, NanoLoanEngine.getIdentifier(uint256)(index)
identifier(bytes32) := TMP_137(bytes32)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(identifierToIndex[identifier] == 0)

IRs:
REF_36(uint256) -> identifierToIndex[identifier]
TMP_138(bool) = REF_36 == 0
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
identifierToIndex[identifier] = index

IRs:
REF_37(uint256) -> identifierToIndex[identifier]
REF_37(uint256) (->identifierToIndex) := index(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
msg.sender == _borrower

IRs:
TMP_140(bool) = msg.sender == _borrower
CONDITION TMP_140"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
approveLoan(index)

IRs:
TMP_141(bool) = INTERNAL_CALL, NanoLoanEngine.approveLoan(uint256)(index)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
index

IRs:
RETURN index"];
}
// Function: 7627.sol-NanoLoanEngine-destroy(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_145(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_145(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(loan.status != Status.destroyed)

IRs:
REF_146(Engine.Status) -> loan.status
REF_147(Engine.Status) -> Status.destroyed
TMP_197(bool) = REF_146 != REF_147
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial))

IRs:
REF_148(address) -> loan.lender
TMP_199(bool) = msg.sender == REF_148
REF_149(address) -> loan.borrower
TMP_200(bool) = msg.sender == REF_149
REF_150(Engine.Status) -> loan.status
REF_151(Engine.Status) -> Status.initial
TMP_201(bool) = REF_150 == REF_151
TMP_202(bool) = TMP_200 && TMP_201
TMP_203(bool) = TMP_199 || TMP_202
TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
DestroyedBy(index,msg.sender)

IRs:
Emit DestroyedBy(index,msg.sender)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
loan.status != Status.initial

IRs:
REF_152(Engine.Status) -> loan.status
REF_153(Engine.Status) -> Status.initial
TMP_206(bool) = REF_152 != REF_153
CONDITION TMP_206"];
5->6[label="True"];
5->9[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
lendersBalance[loan.lender] -= 1

IRs:
REF_154(address) -> loan.lender
REF_155(uint256) -> lendersBalance[REF_154]
REF_155(-> lendersBalance) = REF_155 - 1"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
activeLoans -= 1

IRs:
activeLoans(uint256) = activeLoans - 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(loan.lender,0x0,index)

IRs:
REF_156(address) -> loan.lender
Emit Transfer(REF_156,0,index)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
loan.status = Status.destroyed

IRs:
REF_157(Engine.Status) -> loan.status
REF_158(Engine.Status) -> Status.destroyed
REF_157(Engine.Status) (->loan) := REF_158(Engine.Status)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-destroyIdentifier(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
index = identifierToIndex[identifier]

IRs:
REF_159(uint256) -> identifierToIndex[identifier]
index(uint256) := REF_159(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(index != 0)

IRs:
TMP_208(bool) = index != 0
TMP_209(None) = SOLIDITY_CALL require(bool)(TMP_208)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
destroy(index)

IRs:
TMP_210(bool) = INTERNAL_CALL, NanoLoanEngine.destroy(uint256)(index)
RETURN TMP_210"];
}
// Function: 7627.sol-NanoLoanEngine-getAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].amount

IRs:
REF_49(NanoLoanEngine.Loan) -> loans[index]
REF_50(uint256) -> REF_49.amount
RETURN REF_50"];
}
// Function: 7627.sol-NanoLoanEngine-getApprobation(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].approbations[_address]

IRs:
REF_67(NanoLoanEngine.Loan) -> loans[index]
REF_68(mapping(address => bool)) -> REF_67.approbations
REF_69(bool) -> REF_68[_address]
RETURN REF_69"];
}
// Function: 7627.sol-NanoLoanEngine-getApproved(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].approvedTransfer

IRs:
REF_74(NanoLoanEngine.Loan) -> loans[index]
REF_75(address) -> REF_74.approvedTransfer
RETURN REF_75"];
}
// Function: 7627.sol-NanoLoanEngine-getBorrower(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].borrower

IRs:
REF_43(NanoLoanEngine.Loan) -> loans[index]
REF_44(address) -> REF_43.borrower
RETURN REF_44"];
}
// Function: 7627.sol-NanoLoanEngine-getCancelableAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].cancelableAt

IRs:
REF_65(NanoLoanEngine.Loan) -> loans[index]
REF_66(uint256) -> REF_65.cancelableAt
RETURN REF_66"];
}
// Function: 7627.sol-NanoLoanEngine-getCosigner(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].cosigner

IRs:
REF_45(NanoLoanEngine.Loan) -> loans[index]
REF_46(address) -> REF_45.cosigner
RETURN REF_46"];
}
// Function: 7627.sol-NanoLoanEngine-getCreator(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].creator

IRs:
REF_47(NanoLoanEngine.Loan) -> loans[index]
REF_48(address) -> REF_47.creator
RETURN REF_48"];
}
// Function: 7627.sol-NanoLoanEngine-getCurrency(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].currency

IRs:
REF_76(NanoLoanEngine.Loan) -> loans[index]
REF_77(bytes32) -> REF_76.currency
RETURN REF_77"];
}
// Function: 7627.sol-NanoLoanEngine-getDueTime(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].dueTime

IRs:
REF_61(NanoLoanEngine.Loan) -> loans[index]
REF_62(uint256) -> REF_61.dueTime
RETURN REF_62"];
}
// Function: 7627.sol-NanoLoanEngine-getDuesIn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].duesIn

IRs:
REF_63(NanoLoanEngine.Loan) -> loans[index]
REF_64(uint256) -> REF_63.duesIn
RETURN REF_64"];
}
// Function: 7627.sol-NanoLoanEngine-getExpirationRequest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].expirationRequest

IRs:
REF_78(NanoLoanEngine.Loan) -> loans[index]
REF_79(uint256) -> REF_78.expirationRequest
RETURN REF_79"];
}
// Function: 7627.sol-NanoLoanEngine-getIdentifier(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_82(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_82(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
buildIdentifier(loan.oracle,loan.borrower,loan.creator,loan.currency,loan.amount,loan.interestRate,loan.interestRatePunitory,loan.duesIn,loan.cancelableAt,loan.expirationRequest,loan.metadata)

IRs:
REF_83(Oracle) -> loan.oracle
REF_84(address) -> loan.borrower
REF_85(address) -> loan.creator
REF_86(bytes32) -> loan.currency
REF_87(uint256) -> loan.amount
REF_88(uint256) -> loan.interestRate
REF_89(uint256) -> loan.interestRatePunitory
REF_90(uint256) -> loan.duesIn
REF_91(uint256) -> loan.cancelableAt
REF_92(uint256) -> loan.expirationRequest
REF_93(string) -> loan.metadata
TMP_142(bytes32) = INTERNAL_CALL, NanoLoanEngine.buildIdentifier(Oracle,address,address,bytes32,uint256,uint256,uint256,uint256,uint256,uint256,string)(REF_83,REF_84,REF_85,REF_86,REF_87,REF_88,REF_89,REF_90,REF_91,REF_92,REF_93)
RETURN TMP_142"];
}
// Function: 7627.sol-NanoLoanEngine-getInterest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].interest

IRs:
REF_80(NanoLoanEngine.Loan) -> loans[index]
REF_81(uint256) -> REF_80.interest
RETURN REF_81"];
}
// Function: 7627.sol-NanoLoanEngine-getInterestRate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].interestRate

IRs:
REF_57(NanoLoanEngine.Loan) -> loans[index]
REF_58(uint256) -> REF_57.interestRate
RETURN REF_58"];
}
// Function: 7627.sol-NanoLoanEngine-getInterestRatePunitory(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].interestRatePunitory

IRs:
REF_59(NanoLoanEngine.Loan) -> loans[index]
REF_60(uint256) -> REF_59.interestRatePunitory
RETURN REF_60"];
}
// Function: 7627.sol-NanoLoanEngine-getInterestTimestamp(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].interestTimestamp

IRs:
REF_53(NanoLoanEngine.Loan) -> loans[index]
REF_54(uint256) -> REF_53.interestTimestamp
RETURN REF_54"];
}
// Function: 7627.sol-NanoLoanEngine-getLenderBalance(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].lenderBalance

IRs:
REF_72(NanoLoanEngine.Loan) -> loans[index]
REF_73(uint256) -> REF_72.lenderBalance
RETURN REF_73"];
}
// Function: 7627.sol-NanoLoanEngine-getOracle(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].oracle

IRs:
REF_41(NanoLoanEngine.Loan) -> loans[index]
REF_42(Oracle) -> REF_41.oracle
RETURN REF_42"];
}
// Function: 7627.sol-NanoLoanEngine-getPaid(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].paid

IRs:
REF_55(NanoLoanEngine.Loan) -> loans[index]
REF_56(uint256) -> REF_55.paid
RETURN REF_56"];
}
// Function: 7627.sol-NanoLoanEngine-getPendingAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
addInterest(index)

IRs:
TMP_229(bool) = INTERNAL_CALL, NanoLoanEngine.addInterest(uint256)(index)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
getRawPendingAmount(index)

IRs:
TMP_230(uint256) = INTERNAL_CALL, NanoLoanEngine.getRawPendingAmount(uint256)(index)
RETURN TMP_230"];
}
// Function: 7627.sol-NanoLoanEngine-getPunitoryInterest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].punitoryInterest

IRs:
REF_51(NanoLoanEngine.Loan) -> loans[index]
REF_52(uint256) -> REF_51.punitoryInterest
RETURN REF_52"];
}
// Function: 7627.sol-NanoLoanEngine-getRawPendingAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_179(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_179(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
safeSubtract(safeAdd(safeAdd(loan.amount,loan.interest),loan.punitoryInterest),loan.paid)

IRs:
REF_180(uint256) -> loan.amount
REF_181(uint256) -> loan.interest
TMP_231(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(REF_180,REF_181)
REF_182(uint256) -> loan.punitoryInterest
TMP_232(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(TMP_231,REF_182)
REF_183(uint256) -> loan.paid
TMP_233(uint256) = INTERNAL_CALL, RpSafeMath.safeSubtract(uint256,uint256)(TMP_232,REF_183)
RETURN TMP_233"];
}
// Function: 7627.sol-NanoLoanEngine-getStatus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].status

IRs:
REF_70(NanoLoanEngine.Loan) -> loans[index]
REF_71(Engine.Status) -> REF_70.status
RETURN REF_71"];
}
// Function: 7627.sol-NanoLoanEngine-getTotalLoans()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans.length

IRs:
REF_40 -> LENGTH loans
RETURN REF_40"];
}
// Function: 7627.sol-NanoLoanEngine-internalAddInterest(NanoLoanEngine.Loan,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
timestamp > loan.interestTimestamp

IRs:
REF_184(uint256) -> loan.interestTimestamp
TMP_241(bool) = timestamp > REF_184
CONDITION TMP_241"];
1->2[label="True"];
1->34[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
newInterest = loan.interest

IRs:
REF_185(uint256) -> loan.interest
newInterest(uint256) := REF_185(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
newPunitoryInterest = loan.punitoryInterest

IRs:
REF_186(uint256) -> loan.punitoryInterest
newPunitoryInterest(uint256) := REF_186(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6
"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
endNonPunitory = min(timestamp,loan.dueTime)

IRs:
REF_187(uint256) -> loan.dueTime
TMP_242(uint256) = INTERNAL_CALL, RpSafeMath.min(uint256,uint256)(timestamp,REF_187)
endNonPunitory(uint256) := TMP_242(uint256)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
endNonPunitory > loan.interestTimestamp

IRs:
REF_188(uint256) -> loan.interestTimestamp
TMP_243(bool) = endNonPunitory > REF_188
CONDITION TMP_243"];
10->11[label="True"];
10->19[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
deltaTime = endNonPunitory - loan.interestTimestamp

IRs:
REF_189(uint256) -> loan.interestTimestamp
TMP_244(uint256) = endNonPunitory - REF_189
deltaTime(uint256) := TMP_244(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
loan.paid < loan.amount

IRs:
REF_190(uint256) -> loan.paid
REF_191(uint256) -> loan.amount
TMP_245(bool) = REF_190 < REF_191
CONDITION TMP_245"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
pending = loan.amount - loan.paid

IRs:
REF_192(uint256) -> loan.amount
REF_193(uint256) -> loan.paid
TMP_246(uint256) = REF_192 - REF_193
pending(uint256) := TMP_246(uint256)"];
13->15;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
pending = 0

IRs:
pending(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
(realDelta,calculatedInterest) = calculateInterest(deltaTime,loan.interestRate,pending)

IRs:
REF_194(uint256) -> loan.interestRate
TUPLE_0(uint256,uint256) = INTERNAL_CALL, NanoLoanEngine.calculateInterest(uint256,uint256,uint256)(deltaTime,REF_194,pending)
realDelta(uint256)= UNPACK TUPLE_0 index: 0 
calculatedInterest(uint256)= UNPACK TUPLE_0 index: 1 "];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
newInterest = safeAdd(calculatedInterest,newInterest)

IRs:
TMP_247(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(calculatedInterest,newInterest)
newInterest(uint256) := TMP_247(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
newTimestamp = loan.interestTimestamp + realDelta

IRs:
REF_195(uint256) -> loan.interestTimestamp
TMP_248(uint256) = REF_195 + realDelta
newTimestamp(uint256) := TMP_248(uint256)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
timestamp > loan.dueTime

IRs:
REF_196(uint256) -> loan.dueTime
TMP_249(bool) = timestamp > REF_196
CONDITION TMP_249"];
20->21[label="True"];
20->28[label="False"];
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
startPunitory = max(loan.dueTime,loan.interestTimestamp)

IRs:
REF_197(uint256) -> loan.dueTime
REF_198(uint256) -> loan.interestTimestamp
TMP_250(uint256) = INTERNAL_CALL, RpSafeMath.max(uint256,uint256)(REF_197,REF_198)
startPunitory(uint256) := TMP_250(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
deltaTime = timestamp - startPunitory

IRs:
TMP_251(uint256) = timestamp - startPunitory
deltaTime(uint256) := TMP_251(uint256)"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
debt = safeAdd(loan.amount,newInterest)

IRs:
REF_199(uint256) -> loan.amount
TMP_252(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(REF_199,newInterest)
debt(uint256) := TMP_252(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
pending = min(debt,safeSubtract(safeAdd(debt,newPunitoryInterest),loan.paid))

IRs:
TMP_253(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(debt,newPunitoryInterest)
REF_200(uint256) -> loan.paid
TMP_254(uint256) = INTERNAL_CALL, RpSafeMath.safeSubtract(uint256,uint256)(TMP_253,REF_200)
TMP_255(uint256) = INTERNAL_CALL, RpSafeMath.min(uint256,uint256)(debt,TMP_254)
pending(uint256) := TMP_255(uint256)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
(realDelta,calculatedInterest) = calculateInterest(deltaTime,loan.interestRatePunitory,pending)

IRs:
REF_201(uint256) -> loan.interestRatePunitory
TUPLE_1(uint256,uint256) = INTERNAL_CALL, NanoLoanEngine.calculateInterest(uint256,uint256,uint256)(deltaTime,REF_201,pending)
realDelta(uint256)= UNPACK TUPLE_1 index: 0 
calculatedInterest(uint256)= UNPACK TUPLE_1 index: 1 "];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
newPunitoryInterest = safeAdd(newPunitoryInterest,calculatedInterest)

IRs:
TMP_256(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(newPunitoryInterest,calculatedInterest)
newPunitoryInterest(uint256) := TMP_256(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
newTimestamp = startPunitory + realDelta

IRs:
TMP_257(uint256) = startPunitory + realDelta
newTimestamp(uint256) := TMP_257(uint256)"];
27->28;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: IF 29

EXPRESSION:
newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest

IRs:
REF_202(uint256) -> loan.interest
TMP_258(bool) = newInterest != REF_202
REF_203(uint256) -> loan.punitoryInterest
TMP_259(bool) = newPunitoryInterest != REF_203
TMP_260(bool) = TMP_258 || TMP_259
CONDITION TMP_260"];
29->30[label="True"];
29->33[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
loan.interestTimestamp = newTimestamp

IRs:
REF_204(uint256) -> loan.interestTimestamp
REF_204(uint256) (->loan) := newTimestamp(uint256)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
loan.interest = newInterest

IRs:
REF_205(uint256) -> loan.interest
REF_205(uint256) (->loan) := newInterest(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
loan.punitoryInterest = newPunitoryInterest

IRs:
REF_206(uint256) -> loan.punitoryInterest
REF_206(uint256) (->loan) := newPunitoryInterest(uint256)"];
32->33;
33[label="Node Type: END_IF 33
"];
33->34;
34[label="Node Type: END_IF 34
"];
}
// Function: 7627.sol-NanoLoanEngine-isApproved(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_94(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_94(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
loan.approbations[loan.borrower]

IRs:
REF_95(mapping(address => bool)) -> loan.approbations
REF_96(address) -> loan.borrower
REF_97(bool) -> REF_95[REF_96]
RETURN REF_97"];
}
// Function: 7627.sol-NanoLoanEngine-isApprovedForAll(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
operators[_owner][_operator]

IRs:
REF_25(mapping(address => bool)) -> operators[_owner]
REF_26(bool) -> REF_25[_operator]
RETURN REF_26"];
}
// Function: 7627.sol-NanoLoanEngine-lend(uint256,bytes,Cosigner,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_111(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_111(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(loan.status == Status.initial)

IRs:
REF_112(Engine.Status) -> loan.status
REF_113(Engine.Status) -> Status.initial
TMP_157(bool) = REF_112 == REF_113
TMP_158(None) = SOLIDITY_CALL require(bool)(TMP_157)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(isApproved(index))

IRs:
TMP_159(bool) = INTERNAL_CALL, NanoLoanEngine.isApproved(uint256)(index)
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(block.timestamp <= loan.expirationRequest)

IRs:
REF_114(uint256) -> loan.expirationRequest
TMP_161(bool) = block.timestamp <= REF_114
TMP_162(None) = SOLIDITY_CALL require(bool)(TMP_161)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
loan.lender = msg.sender

IRs:
REF_115(address) -> loan.lender
REF_115(address) (->loan) := msg.sender(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
loan.dueTime = safeAdd(block.timestamp,loan.duesIn)

IRs:
REF_116(uint256) -> loan.dueTime
REF_117(uint256) -> loan.duesIn
TMP_163(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(block.timestamp,REF_117)
REF_116(uint256) (->loan) := TMP_163(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
loan.interestTimestamp = block.timestamp

IRs:
REF_118(uint256) -> loan.interestTimestamp
REF_118(uint256) (->loan) := block.timestamp(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
loan.status = Status.lent

IRs:
REF_119(Engine.Status) -> loan.status
REF_120(Engine.Status) -> Status.lent
REF_119(Engine.Status) (->loan) := REF_120(Engine.Status)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(0x0,loan.lender,index)

IRs:
REF_121(address) -> loan.lender
Emit Transfer(0,REF_121,index)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
activeLoans += 1

IRs:
activeLoans(uint256) = activeLoans + 1"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
lendersBalance[loan.lender] += 1

IRs:
REF_122(address) -> loan.lender
REF_123(uint256) -> lendersBalance[REF_122]
REF_123(-> lendersBalance) = REF_123 + 1"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
loan.cancelableAt > 0

IRs:
REF_124(uint256) -> loan.cancelableAt
TMP_165(bool) = REF_124 > 0
CONDITION TMP_165"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
internalAddInterest(loan,safeAdd(block.timestamp,loan.cancelableAt))

IRs:
REF_125(uint256) -> loan.cancelableAt
TMP_166(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(block.timestamp,REF_125)
INTERNAL_CALL, NanoLoanEngine.internalAddInterest(NanoLoanEngine.Loan,uint256)(loan,TMP_166)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
transferValue = convertRate(loan.oracle,loan.currency,oracleData,loan.amount)

IRs:
REF_126(Oracle) -> loan.oracle
REF_127(bytes32) -> loan.currency
REF_128(uint256) -> loan.amount
TMP_168(uint256) = INTERNAL_CALL, NanoLoanEngine.convertRate(Oracle,bytes32,bytes,uint256)(REF_126,REF_127,oracleData,REF_128)
transferValue(uint256) := TMP_168(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
require(bool)(rcn.transferFrom(msg.sender,loan.borrower,transferValue))

IRs:
REF_130(address) -> loan.borrower
TMP_169(bool) = HIGH_LEVEL_CALL, dest:rcn(Token), function:transferFrom, arguments:['msg.sender', 'REF_130', 'transferValue']  
TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169)"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
cosigner != address(0)

IRs:
TMP_171 = CONVERT 0 to address
TMP_172(bool) = cosigner != TMP_171
CONDITION TMP_172"];
17->18[label="True"];
17->21[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
loan.cosigner = address(uint256(cosigner) + 2)

IRs:
REF_131(address) -> loan.cosigner
TMP_173 = CONVERT cosigner to uint256
TMP_174(uint256) = TMP_173 + 2
TMP_175 = CONVERT TMP_174 to address
REF_131(address) (->loan) := TMP_175(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
require(bool)(cosigner.requestCosign(this,index,cosignerData,oracleData))

IRs:
TMP_176(bool) = HIGH_LEVEL_CALL, dest:cosigner(Cosigner), function:requestCosign, arguments:['this', 'index', 'cosignerData', 'oracleData']  
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
require(bool)(loan.cosigner == address(cosigner))

IRs:
REF_133(address) -> loan.cosigner
TMP_178 = CONVERT cosigner to address
TMP_179(bool) = REF_133 == TMP_178
TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
Lent(index,loan.lender,cosigner)

IRs:
REF_134(address) -> loan.lender
Emit Lent(index,REF_134,cosigner)"];
22->23;
23[label="Node Type: RETURN 23

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-lockTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
lockedTokens[token] = safeAdd(lockedTokens[token],amount)

IRs:
REF_10(uint256) -> lockedTokens[token]
REF_11(uint256) -> lockedTokens[token]
TMP_65(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(REF_11,amount)
REF_10(uint256) (->lockedTokens) := TMP_65(uint256)"];
}
// Function: 7627.sol-NanoLoanEngine-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a > b

IRs:
TMP_95(bool) = a > b
CONDITION TMP_95"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
a

IRs:
RETURN a"];
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 7627.sol-NanoLoanEngine-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a < b

IRs:
TMP_94(bool) = a < b
CONDITION TMP_94"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
a

IRs:
RETURN a"];
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 7627.sol-NanoLoanEngine-name()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_name = RCN - Nano loan engine - Basalt 233

IRs:
_name(string) := RCN - Nano loan engine - Basalt 233(string)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_name

IRs:
RETURN _name"];
}
// Function: 7627.sol-NanoLoanEngine-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_307(bool) = msg.sender == owner
TMP_308(None) = SOLIDITY_CALL require(bool)(TMP_307)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7627.sol-NanoLoanEngine-ownerOf(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = loans[index].lender

IRs:
REF_38(NanoLoanEngine.Loan) -> loans[index]
REF_39(address) -> REF_38.lender
owner(address) := REF_39(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
owner

IRs:
RETURN owner"];
}
// Function: 7627.sol-NanoLoanEngine-pay(uint256,uint256,address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_210(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_210(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(loan.status == Status.lent)

IRs:
REF_211(Engine.Status) -> loan.status
REF_212(Engine.Status) -> Status.lent
TMP_264(bool) = REF_211 == REF_212
TMP_265(None) = SOLIDITY_CALL require(bool)(TMP_264)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
addInterest(index)

IRs:
TMP_266(bool) = INTERNAL_CALL, NanoLoanEngine.addInterest(uint256)(index)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
toPay = min(getPendingAmount(index),_amount)

IRs:
TMP_267(uint256) = INTERNAL_CALL, NanoLoanEngine.getPendingAmount(uint256)(index)
TMP_268(uint256) = INTERNAL_CALL, RpSafeMath.min(uint256,uint256)(TMP_267,_amount)
toPay(uint256) := TMP_268(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
PartialPayment(index,msg.sender,_from,toPay)

IRs:
Emit PartialPayment(index,msg.sender,_from,toPay)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
loan.paid = safeAdd(loan.paid,toPay)

IRs:
REF_213(uint256) -> loan.paid
REF_214(uint256) -> loan.paid
TMP_270(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(REF_214,toPay)
REF_213(uint256) (->loan) := TMP_270(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
getRawPendingAmount(index) == 0

IRs:
TMP_271(uint256) = INTERNAL_CALL, NanoLoanEngine.getRawPendingAmount(uint256)(index)
TMP_272(bool) = TMP_271 == 0
CONDITION TMP_272"];
7->8[label="True"];
7->13[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
TotalPayment(index)

IRs:
Emit TotalPayment(index)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
loan.status = Status.paid

IRs:
REF_215(Engine.Status) -> loan.status
REF_216(Engine.Status) -> Status.paid
REF_215(Engine.Status) (->loan) := REF_216(Engine.Status)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
lendersBalance[loan.lender] -= 1

IRs:
REF_217(address) -> loan.lender
REF_218(uint256) -> lendersBalance[REF_217]
REF_218(-> lendersBalance) = REF_218 - 1"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
activeLoans -= 1

IRs:
activeLoans(uint256) = activeLoans - 1"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(loan.lender,0x0,index)

IRs:
REF_219(address) -> loan.lender
Emit Transfer(REF_219,0,index)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
transferValue = convertRate(loan.oracle,loan.currency,oracleData,toPay)

IRs:
REF_220(Oracle) -> loan.oracle
REF_221(bytes32) -> loan.currency
TMP_275(uint256) = INTERNAL_CALL, NanoLoanEngine.convertRate(Oracle,bytes32,bytes,uint256)(REF_220,REF_221,oracleData,toPay)
transferValue(uint256) := TMP_275(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(transferValue > 0 || toPay < _amount)

IRs:
TMP_276(bool) = transferValue > 0
TMP_277(bool) = toPay < _amount
TMP_278(bool) = TMP_276 || TMP_277
TMP_279(None) = SOLIDITY_CALL require(bool)(TMP_278)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
lockTokens(rcn,transferValue)

IRs:
INTERNAL_CALL, TokenLockable.lockTokens(address,uint256)(rcn,transferValue)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(rcn.transferFrom(msg.sender,this,transferValue))

IRs:
TMP_281(bool) = HIGH_LEVEL_CALL, dest:rcn(Token), function:transferFrom, arguments:['msg.sender', 'this', 'transferValue']  
TMP_282(None) = SOLIDITY_CALL require(bool)(TMP_281)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
loan.lenderBalance = safeAdd(transferValue,loan.lenderBalance)

IRs:
REF_223(uint256) -> loan.lenderBalance
REF_224(uint256) -> loan.lenderBalance
TMP_283(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(transferValue,REF_224)
REF_223(uint256) (->loan) := TMP_283(uint256)"];
18->19;
19[label="Node Type: RETURN 19

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-registerApprove(bytes32,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
index = identifierToIndex[identifier]

IRs:
REF_104(uint256) -> identifierToIndex[identifier]
index(uint256) := REF_104(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(index != 0)

IRs:
TMP_150(bool) = index != 0
TMP_151(None) = SOLIDITY_CALL require(bool)(TMP_150)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
loan = loans[index]

IRs:
REF_105(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_105(NanoLoanEngine.Loan)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(loan.borrower == ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(Ethereum Signed Message:
32,identifier),v,r,s))

IRs:
REF_106(address) -> loan.borrower
TMP_152(bytes32) = SOLIDITY_CALL keccak256()(Ethereum Signed Message:
32,identifier)
TMP_153(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_152,v,r,s)
TMP_154(bool) = REF_106 == TMP_153
TMP_155(None) = SOLIDITY_CALL require(bool)(TMP_154)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
loan.approbations[loan.borrower] = true

IRs:
REF_107(mapping(address => bool)) -> loan.approbations
REF_108(address) -> loan.borrower
REF_109(bool) -> REF_107[REF_108]
REF_109(bool) (->loan) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ApprovedBy(index,loan.borrower)

IRs:
REF_110(address) -> loan.borrower
Emit ApprovedBy(index,REF_110)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_80(uint256) = x + y
z(uint256) := TMP_80(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((z >= x) && (z >= y))

IRs:
TMP_81(bool) = z >= x
TMP_82(bool) = z >= y
TMP_83(bool) = TMP_81 && TMP_82
TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-NanoLoanEngine-safeMult(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x * y

IRs:
TMP_88(uint256) = x * y
z(uint256) := TMP_88(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((x == 0) || (z / x == y))

IRs:
TMP_89(bool) = x == 0
TMP_90(uint256) = z / x
TMP_91(bool) = TMP_90 == y
TMP_92(bool) = TMP_89 || TMP_91
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-NanoLoanEngine-safeSubtract(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(x >= y)

IRs:
TMP_85(bool) = x >= y
TMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
z = x - y

IRs:
TMP_87(uint256) = x - y
z(uint256) := TMP_87(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-NanoLoanEngine-setApprovalForAll(address,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
operators[msg.sender][_operator] = _approved

IRs:
REF_177(mapping(address => bool)) -> operators[msg.sender]
REF_178(bool) -> REF_177[_operator]
REF_178(bool) (->operators) := _approved(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ApprovalForAll(msg.sender,_operator,_approved)

IRs:
Emit ApprovalForAll(msg.sender,_operator,_approved)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-setDeprecated(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
deprecated = _deprecated

IRs:
deprecated(bool) := _deprecated(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 7627.sol-NanoLoanEngine-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = 233

IRs:
VERSION(uint256) := 233(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
VERSION_NAME = Basalt

IRs:
VERSION_NAME(string) := Basalt(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
PRECISION = (10 ** 18)

IRs:
TMP_306(uint256) = 10 ** 18
PRECISION(uint256) := TMP_306(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
RCN_DECIMALS = 18

IRs:
RCN_DECIMALS(uint256) := 18(uint256)"];
}
// Function: 7627.sol-NanoLoanEngine-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
activeLoans = 0

IRs:
activeLoans(uint256) := 0(uint256)"];
}
// Function: 7627.sol-NanoLoanEngine-symbol()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_symbol = RCN-NLE-233

IRs:
_symbol(string) := RCN-NLE-233(string)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_symbol

IRs:
RETURN _symbol"];
}
// Function: 7627.sol-NanoLoanEngine-takeOwnership(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
transfer(msg.sender,_index)

IRs:
TMP_221(bool) = INTERNAL_CALL, NanoLoanEngine.transfer(address,uint256)(msg.sender,_index)
RETURN TMP_221"];
}
// Function: 7627.sol-NanoLoanEngine-tokenMetadata(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
loans[index].metadata

IRs:
REF_27(NanoLoanEngine.Loan) -> loans[index]
REF_28(string) -> REF_27.metadata
RETURN REF_28"];
}
// Function: 7627.sol-NanoLoanEngine-tokenMetadataHash(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
keccak256()(loans[index].metadata)

IRs:
REF_29(NanoLoanEngine.Loan) -> loans[index]
REF_30(string) -> REF_29.metadata
TMP_109(bytes32) = SOLIDITY_CALL keccak256()(REF_30)
RETURN TMP_109"];
}
// Function: 7627.sol-NanoLoanEngine-tokensOfOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tokenCount = balanceOf(_owner)

IRs:
TMP_96(uint256) = INTERNAL_CALL, NanoLoanEngine.balanceOf(address)(_owner)
tokenCount(uint256) := TMP_96(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
tokenCount == 0

IRs:
TMP_97(bool) = tokenCount == 0
CONDITION TMP_97"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
new uint256[](0)

IRs:
TMP_99(uint256[])  = new uint256[](0)
RETURN TMP_99"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
result = new uint256[](tokenCount)

IRs:
TMP_101(uint256[])  = new uint256[](tokenCount)
result(uint256[]) = ['TMP_101(uint256[])']"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
totalLoans = loans.length - 1

IRs:
REF_18 -> LENGTH loans
TMP_102(uint256) = REF_18 - 1
totalLoans(uint256) := TMP_102(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
resultIndex = 0

IRs:
resultIndex(uint256) := 0(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->10;
8[label="Node Type: BEGIN_LOOP 8
"];
8->11;
9[label="Node Type: END_LOOP 9
"];
9->17;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
loanId = 0

IRs:
loanId(uint256) := 0(uint256)"];
10->8;
11[label="Node Type: IF_LOOP 11

EXPRESSION:
loanId <= totalLoans

IRs:
TMP_103(bool) = loanId <= totalLoans
CONDITION TMP_103"];
11->12[label="True"];
11->9[label="False"];
12[label="Node Type: IF 12

EXPRESSION:
loans[loanId].lender == _owner && loans[loanId].status == Status.lent

IRs:
REF_19(NanoLoanEngine.Loan) -> loans[loanId]
REF_20(address) -> REF_19.lender
TMP_104(bool) = REF_20 == _owner
REF_21(NanoLoanEngine.Loan) -> loans[loanId]
REF_22(Engine.Status) -> REF_21.status
REF_23(Engine.Status) -> Status.lent
TMP_105(bool) = REF_22 == REF_23
TMP_106(bool) = TMP_104 && TMP_105
CONDITION TMP_106"];
12->13[label="True"];
12->15[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
result[resultIndex] = loanId

IRs:
REF_24(uint256) -> result[resultIndex]
REF_24(uint256) (->result) := loanId(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
resultIndex ++

IRs:
TMP_107(uint256) := resultIndex(uint256)
resultIndex(uint256) = resultIndex + 1"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
loanId ++

IRs:
TMP_108(uint256) := loanId(uint256)
loanId(uint256) = loanId + 1"];
16->11;
17[label="Node Type: RETURN 17

EXPRESSION:
result

IRs:
RETURN result"];
19[label="Node Type: RETURN 19

EXPRESSION:
ownerTokens

IRs:
RETURN ownerTokens"];
}
// Function: 7627.sol-NanoLoanEngine-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_totalSupply = activeLoans

IRs:
_totalSupply(uint256) := activeLoans(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply"];
}
// Function: 7627.sol-NanoLoanEngine-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_160(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_160(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == loan.lender || msg.sender == loan.approvedTransfer || operators[loan.lender][msg.sender])

IRs:
REF_161(address) -> loan.lender
TMP_211(bool) = msg.sender == REF_161
REF_162(address) -> loan.approvedTransfer
TMP_212(bool) = msg.sender == REF_162
TMP_213(bool) = TMP_211 || TMP_212
REF_163(address) -> loan.lender
REF_164(mapping(address => bool)) -> operators[REF_163]
REF_165(bool) -> REF_164[msg.sender]
TMP_214(bool) = TMP_213 || REF_165
TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_216 = CONVERT 0 to address
TMP_217(bool) = to != TMP_216
TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
lendersBalance[loan.lender] -= 1

IRs:
REF_166(address) -> loan.lender
REF_167(uint256) -> lendersBalance[REF_166]
REF_167(-> lendersBalance) = REF_167 - 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
lendersBalance[to] += 1

IRs:
REF_168(uint256) -> lendersBalance[to]
REF_168(-> lendersBalance) = REF_168 + 1"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(loan.lender,to,index)

IRs:
REF_169(address) -> loan.lender
Emit Transfer(REF_169,to,index)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
loan.lender = to

IRs:
REF_170(address) -> loan.lender
REF_170(address) (->loan) := to(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
loan.approvedTransfer = address(0)

IRs:
REF_171(address) -> loan.approvedTransfer
TMP_220 = CONVERT 0 to address
REF_171(address) (->loan) := TMP_220(address)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(loans[index].lender == from)

IRs:
REF_172(NanoLoanEngine.Loan) -> loans[index]
REF_173(address) -> REF_172.lender
TMP_222(bool) = REF_173 == from
TMP_223(None) = SOLIDITY_CALL require(bool)(TMP_222)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
transfer(to,index)

IRs:
TMP_224(bool) = INTERNAL_CALL, NanoLoanEngine.transfer(address,uint256)(to,index)
RETURN TMP_224"];
}
// Function: 7627.sol-NanoLoanEngine-transferTo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_76 = CONVERT 0 to address
TMP_77(bool) = _to != TMP_76
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = _to

IRs:
owner(address) := _to(address)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7627.sol-NanoLoanEngine-unlockTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
lockedTokens[token] = safeSubtract(lockedTokens[token],amount)

IRs:
REF_12(uint256) -> lockedTokens[token]
REF_13(uint256) -> lockedTokens[token]
TMP_66(uint256) = INTERNAL_CALL, RpSafeMath.safeSubtract(uint256,uint256)(REF_13,amount)
REF_12(uint256) (->lockedTokens) := TMP_66(uint256)"];
}
// Function: 7627.sol-NanoLoanEngine-withdrawTokens(Token,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(safeSubtract(token.balanceOf(this),lockedTokens[token]) >= amount)

IRs:
TMP_67(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
REF_15(uint256) -> lockedTokens[token]
TMP_68(uint256) = INTERNAL_CALL, RpSafeMath.safeSubtract(uint256,uint256)(TMP_67,REF_15)
TMP_69(bool) = TMP_68 >= amount
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_71 = CONVERT 0 to address
TMP_72(bool) = to != TMP_71
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
token.transfer(to,amount)

IRs:
TMP_74(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['to', 'amount']  
RETURN TMP_74"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7627.sol-NanoLoanEngine-withdrawal(uint256,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
loan = loans[index]

IRs:
REF_226(NanoLoanEngine.Loan) -> loans[index]
loan(NanoLoanEngine.Loan) := REF_226(NanoLoanEngine.Loan)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == loan.lender)

IRs:
REF_227(address) -> loan.lender
TMP_293(bool) = msg.sender == REF_227
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
loan.lenderBalance = safeSubtract(loan.lenderBalance,amount)

IRs:
REF_228(uint256) -> loan.lenderBalance
REF_229(uint256) -> loan.lenderBalance
TMP_295(uint256) = INTERNAL_CALL, RpSafeMath.safeSubtract(uint256,uint256)(REF_229,amount)
REF_228(uint256) (->loan) := TMP_295(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(rcn.transfer(to,amount))

IRs:
TMP_296(bool) = HIGH_LEVEL_CALL, dest:rcn(Token), function:transfer, arguments:['to', 'amount']  
TMP_297(None) = SOLIDITY_CALL require(bool)(TMP_296)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
unlockTokens(rcn,amount)

IRs:
INTERNAL_CALL, TokenLockable.unlockTokens(address,uint256)(rcn,amount)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7627.sol-NanoLoanEngine-withdrawalList(uint256[],address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
totalWithdraw = 0

IRs:
totalWithdraw(uint256) := 0(uint256)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->13;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
inputId = 0

IRs:
inputId(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
inputId < loanIds.length

IRs:
REF_231 -> LENGTH loanIds
TMP_299(bool) = inputId < REF_231
CONDITION TMP_299"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
loan = loans[loanIds[inputId]]

IRs:
REF_232(uint256) -> loanIds[inputId]
REF_233(NanoLoanEngine.Loan) -> loans[REF_232]
loan(NanoLoanEngine.Loan) := REF_233(NanoLoanEngine.Loan)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
loan.lender == msg.sender

IRs:
REF_234(address) -> loan.lender
TMP_300(bool) = REF_234 == msg.sender
CONDITION TMP_300"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalWithdraw += loan.lenderBalance

IRs:
REF_235(uint256) -> loan.lenderBalance
totalWithdraw(uint256) = totalWithdraw + REF_235"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
loan.lenderBalance = 0

IRs:
REF_236(uint256) -> loan.lenderBalance
REF_236(uint256) (->loan) := 0(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
inputId ++

IRs:
TMP_301(uint256) := inputId(uint256)
inputId(uint256) = inputId + 1"];
12->6;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(rcn.transfer(to,totalWithdraw))

IRs:
TMP_302(bool) = HIGH_LEVEL_CALL, dest:rcn(Token), function:transfer, arguments:['to', 'totalWithdraw']  
TMP_303(None) = SOLIDITY_CALL require(bool)(TMP_302)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
unlockTokens(rcn,totalWithdraw)

IRs:
INTERNAL_CALL, TokenLockable.unlockTokens(address,uint256)(rcn,totalWithdraw)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
totalWithdraw

IRs:
RETURN totalWithdraw"];
}
// Function: 7627.sol-Oracle-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7627.sol-Oracle-addCurrency(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
NewSymbol(currency,ticker)

IRs:
Emit NewSymbol(currency,ticker)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
currency = keccak256()(ticker)

IRs:
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(ticker)
currency(bytes32) := TMP_11(bytes32)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
currencies[currency] = Symbol(ticker,true)

IRs:
REF_0(Oracle.Symbol) -> currencies[currency]
TMP_12(Oracle.Symbol) = new Symbol(ticker,True)
REF_0(Oracle.Symbol) (->currencies) := TMP_12(Oracle.Symbol)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
currency

IRs:
RETURN currency"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 7627.sol-Oracle-getRate(bytes32,bytes)
digraph{
}
// Function: 7627.sol-Oracle-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_14(bool) = msg.sender == owner
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7627.sol-Oracle-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
VERSION = 3

IRs:
VERSION(uint256) := 3(uint256)"];
}
// Function: 7627.sol-Oracle-supported(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
currencies[symbol].supported

IRs:
REF_1(Oracle.Symbol) -> currencies[symbol]
REF_2(bool) -> REF_1.supported
RETURN REF_2"];
}
// Function: 7627.sol-Oracle-transferTo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_6 = CONVERT 0 to address
TMP_7(bool) = _to != TMP_6
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = _to

IRs:
owner(address) := _to(address)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7627.sol-Oracle-url()
digraph{
}
// Function: 7627.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7627.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_4(bool) = msg.sender == owner
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7627.sol-Ownable-transferTo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_0 = CONVERT 0 to address
TMP_1(bool) = _to != TMP_0
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = _to

IRs:
owner(address) := _to(address)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7627.sol-RpSafeMath-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a > b

IRs:
TMP_31(bool) = a > b
CONDITION TMP_31"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
a

IRs:
RETURN a"];
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 7627.sol-RpSafeMath-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a < b

IRs:
TMP_30(bool) = a < b
CONDITION TMP_30"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
a

IRs:
RETURN a"];
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 7627.sol-RpSafeMath-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_16(uint256) = x + y
z(uint256) := TMP_16(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((z >= x) && (z >= y))

IRs:
TMP_17(bool) = z >= x
TMP_18(bool) = z >= y
TMP_19(bool) = TMP_17 && TMP_18
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-RpSafeMath-safeMult(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x * y

IRs:
TMP_24(uint256) = x * y
z(uint256) := TMP_24(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((x == 0) || (z / x == y))

IRs:
TMP_25(bool) = x == 0
TMP_26(uint256) = z / x
TMP_27(bool) = TMP_26 == y
TMP_28(bool) = TMP_25 || TMP_27
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-RpSafeMath-safeSubtract(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(x >= y)

IRs:
TMP_21(bool) = x >= y
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
z = x - y

IRs:
TMP_23(uint256) = x - y
z(uint256) := TMP_23(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-Token-allowance(address,address)
digraph{
}
// Function: 7627.sol-Token-approve(address,uint256)
digraph{
}
// Function: 7627.sol-Token-balanceOf(address)
digraph{
}
// Function: 7627.sol-Token-increaseApproval(address,uint256)
digraph{
}
// Function: 7627.sol-Token-transfer(address,uint256)
digraph{
}
// Function: 7627.sol-Token-transferFrom(address,address,uint256)
digraph{
}
// Function: 7627.sol-TokenLockable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7627.sol-TokenLockable-lockTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
lockedTokens[token] = safeAdd(lockedTokens[token],amount)

IRs:
REF_3(uint256) -> lockedTokens[token]
REF_4(uint256) -> lockedTokens[token]
TMP_52(uint256) = INTERNAL_CALL, RpSafeMath.safeAdd(uint256,uint256)(REF_4,amount)
REF_3(uint256) (->lockedTokens) := TMP_52(uint256)"];
}
// Function: 7627.sol-TokenLockable-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a > b

IRs:
TMP_51(bool) = a > b
CONDITION TMP_51"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
a

IRs:
RETURN a"];
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 7627.sol-TokenLockable-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a < b

IRs:
TMP_50(bool) = a < b
CONDITION TMP_50"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
a

IRs:
RETURN a"];
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 7627.sol-TokenLockable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_63(bool) = msg.sender == owner
TMP_64(None) = SOLIDITY_CALL require(bool)(TMP_63)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7627.sol-TokenLockable-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x + y

IRs:
TMP_36(uint256) = x + y
z(uint256) := TMP_36(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((z >= x) && (z >= y))

IRs:
TMP_37(bool) = z >= x
TMP_38(bool) = z >= y
TMP_39(bool) = TMP_37 && TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-TokenLockable-safeMult(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = x * y

IRs:
TMP_44(uint256) = x * y
z(uint256) := TMP_44(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((x == 0) || (z / x == y))

IRs:
TMP_45(bool) = x == 0
TMP_46(uint256) = z / x
TMP_47(bool) = TMP_46 == y
TMP_48(bool) = TMP_45 || TMP_47
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-TokenLockable-safeSubtract(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(x >= y)

IRs:
TMP_41(bool) = x >= y
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
z = x - y

IRs:
TMP_43(uint256) = x - y
z(uint256) := TMP_43(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 7627.sol-TokenLockable-transferTo(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_32 = CONVERT 0 to address
TMP_33(bool) = _to != TMP_32
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = _to

IRs:
owner(address) := _to(address)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7627.sol-TokenLockable-unlockTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
lockedTokens[token] = safeSubtract(lockedTokens[token],amount)

IRs:
REF_5(uint256) -> lockedTokens[token]
REF_6(uint256) -> lockedTokens[token]
TMP_53(uint256) = INTERNAL_CALL, RpSafeMath.safeSubtract(uint256,uint256)(REF_6,amount)
REF_5(uint256) (->lockedTokens) := TMP_53(uint256)"];
}
// Function: 7627.sol-TokenLockable-withdrawTokens(Token,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(safeSubtract(token.balanceOf(this),lockedTokens[token]) >= amount)

IRs:
TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
REF_8(uint256) -> lockedTokens[token]
TMP_55(uint256) = INTERNAL_CALL, RpSafeMath.safeSubtract(uint256,uint256)(TMP_54,REF_8)
TMP_56(bool) = TMP_55 >= amount
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_58 = CONVERT 0 to address
TMP_59(bool) = to != TMP_58
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
token.transfer(to,amount)

IRs:
TMP_61(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['to', 'amount']  
RETURN TMP_61"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
}
