digraph G {
// Function: 7696.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)
digraph{
}
// Function: 7696.sol-ERC20Interface-allowance(address,address)
digraph{
}
// Function: 7696.sol-ERC20Interface-approve(address,uint256)
digraph{
}
// Function: 7696.sol-ERC20Interface-balanceOf(address)
digraph{
}
// Function: 7696.sol-ERC20Interface-totalSupply()
digraph{
}
// Function: 7696.sol-ERC20Interface-transfer(address,uint256)
digraph{
}
// Function: 7696.sol-ERC20Interface-transferFrom(address,address,uint256)
digraph{
}
// Function: 7696.sol-Owned-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = msg.sender

IRs:
admin(address) := msg.sender(address)"];
}
// Function: 7696.sol-Owned-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_19(bool) = msg.sender == newOwner
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_22 = CONVERT 0 to address
newOwner(address) := TMP_22(address)"];
}
// Function: 7696.sol-Owned-onlyAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == admin || msg.sender == owner)

IRs:
TMP_25(bool) = msg.sender == admin
TMP_26(bool) = msg.sender == owner
TMP_27(bool) = TMP_25 || TMP_26
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7696.sol-Owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_23(bool) = msg.sender == owner
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7696.sol-Owned-setAdmin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
AdminChanged(admin,newAdmin)

IRs:
Emit AdminChanged(admin,newAdmin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = newAdmin

IRs:
admin(address) := newAdmin(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 7696.sol-Owned-showAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_admin = admin

IRs:
_admin(address) := admin(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_admin

IRs:
RETURN _admin"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
_admin

IRs:
RETURN _admin"];
}
// Function: 7696.sol-Owned-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 7696.sol-Redenom-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = msg.sender

IRs:
admin(address) := msg.sender(address)"];
}
// Function: 7696.sol-Redenom-Redenom()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
symbol = NOMT

IRs:
symbol(string) := NOMT(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = Redenom_test

IRs:
name(string) := Redenom_test(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply = 0

IRs:
_totalSupply(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
total_fund = 1000000 * 10 ** decimals

IRs:
TMP_37(uint256) = 10 ** decimals
TMP_38(uint256) = 1000000 * TMP_37
total_fund(uint256) := TMP_38(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
epoch_fund = 100000 * 10 ** decimals

IRs:
TMP_39(uint256) = 10 ** decimals
TMP_40(uint256) = 100000 * TMP_39
epoch_fund(uint256) := TMP_40(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
total_fund = total_fund.sub(epoch_fund)

IRs:
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['total_fund', 'epoch_fund'] 
total_fund(uint256) := TMP_41(uint256)"];
}
// Function: 7696.sol-Redenom-StartNewEpoch()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_42(bool) = frozen == False
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round == 9)

IRs:
TMP_44(bool) = round == 9
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(epoch < 10)

IRs:
TMP_46(bool) = epoch < 10
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(votingActive == false)

IRs:
TMP_48(bool) = votingActive == False
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
dec = (0,0,0,0,0,0,0,0)

IRs:
dec(uint256[8]) = ['0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
round = 1

IRs:
round(uint256) := 1(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
epoch ++

IRs:
TMP_50(uint256) := epoch(uint256)
epoch(uint256) = epoch + 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
epoch_fund = 100000 * 10 ** decimals

IRs:
TMP_51(uint256) = 10 ** decimals
TMP_52(uint256) = 100000 * TMP_51
epoch_fund(uint256) := TMP_52(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
total_fund = total_fund.sub(epoch_fund)

IRs:
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['total_fund', 'epoch_fund'] 
total_fund(uint256) := TMP_53(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Epoch(epoch)

IRs:
Emit Epoch(epoch)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
12->1;
13[label="Node Type: RETURN 13

EXPRESSION:
succ

IRs:
RETURN succ"];
}
// Function: 7696.sol-Redenom-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_33(bool) = msg.sender == newOwner
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_36 = CONVERT 0 to address
newOwner(address) := TMP_36(address)"];
}
// Function: 7696.sol-Redenom-addProject(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
projects.push(Project({id:_id,votesWeight:0,active:true}))

IRs:
TMP_63(Redenom.Project) = new Project(_id,0,True)
REF_11 -> LENGTH projects
TMP_65(uint256) := REF_11(uint256)
TMP_66(uint256) = TMP_65 + 1
REF_11(uint256) (->projects) := TMP_66(uint256)
REF_12(Redenom.Project) -> projects[TMP_65]
REF_12(Redenom.Project) (->projects) := TMP_63(Redenom.Project)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
2->1;
}
// Function: 7696.sol-Redenom-addWinner(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
winners.push(Winner({id:curentBallotId,projId:projId}))

IRs:
TMP_56(Redenom.Winner) = new Winner(curentBallotId,projId)
REF_3 -> LENGTH winners
TMP_58(uint256) := REF_3(uint256)
TMP_59(uint256) = TMP_58 + 1
REF_3(uint256) (->winners) := TMP_59(uint256)
REF_4(Redenom.Winner) -> winners[TMP_58]
REF_4(Redenom.Winner) (->winners) := TMP_56(Redenom.Winner)"];
}
// Function: 7696.sol-Redenom-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[tokenOwner][spender]

IRs:
REF_178(mapping(address => uint256)) -> allowed[tokenOwner]
REF_179(uint256) -> REF_178[spender]
RETURN REF_179"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 7696.sol-Redenom-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_358(bool) = frozen == False
TMP_359(None) = SOLIDITY_CALL require(bool)(TMP_358)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(msg.sender,1024) == false)

IRs:
TMP_360(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,1024)
TMP_361(bool) = TMP_360 == False
TMP_362(None) = SOLIDITY_CALL require(bool)(TMP_361)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_198(mapping(address => uint256)) -> allowed[msg.sender]
REF_199(uint256) -> REF_198[spender]
REF_199(uint256) (->allowed) := tokens(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_379(bool) = frozen == False
TMP_380(None) = SOLIDITY_CALL require(bool)(TMP_379)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(msg.sender,1024) == false)

IRs:
TMP_381(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,1024)
TMP_382(bool) = TMP_381 == False
TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_223(mapping(address => uint256)) -> allowed[msg.sender]
REF_224(uint256) -> REF_223[spender]
REF_224(uint256) (->allowed) := tokens(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_385 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_385(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  "];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[tokenOwner].balance

IRs:
REF_176(Redenom.Account) -> accounts[tokenOwner]
REF_177(uint256) -> REF_176.balance
RETURN REF_177"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 7696.sol-Redenom-ban_user(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bitmask_add(user,1024)

IRs:
TMP_215(bool) = INTERNAL_CALL, Redenom.bitmask_add(address,uint256)(user,1024)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-bitmask_add(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(user,_bit) == false)

IRs:
TMP_205(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(user,_bit)
TMP_206(bool) = TMP_205 == False
TMP_207(None) = SOLIDITY_CALL require(bool)(TMP_206)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[user].bitmask = accounts[user].bitmask.add(_bit)

IRs:
REF_88(Redenom.Account) -> accounts[user]
REF_89(uint256) -> REF_88.bitmask
REF_90(Redenom.Account) -> accounts[user]
REF_91(uint256) -> REF_90.bitmask
TMP_208(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_91', '_bit'] 
REF_89(uint256) (->accounts) := TMP_208(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-bitmask_check(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->4;
3[label="Node Type: RETURN 3

EXPRESSION:
flag

IRs:
RETURN flag"];
4[label="Node Type: IF 4

EXPRESSION:
accounts[user].bitmask & _bit == 0

IRs:
REF_98(Redenom.Account) -> accounts[user]
REF_99(uint256) -> REF_98.bitmask
TMP_213(uint256) = REF_99 & _bit
TMP_214(bool) = TMP_213 == 0
CONDITION TMP_214"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
flag = false

IRs:
flag(bool) := False(bool)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
flag = true

IRs:
flag(bool) := True(bool)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->3;
8[label="Node Type: RETURN 8

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 7696.sol-Redenom-bitmask_rm(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(user,_bit) == true)

IRs:
TMP_209(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(user,_bit)
TMP_210(bool) = TMP_209 == True
TMP_211(None) = SOLIDITY_CALL require(bool)(TMP_210)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[user].bitmask = accounts[user].bitmask.sub(_bit)

IRs:
REF_93(Redenom.Account) -> accounts[user]
REF_94(uint256) -> REF_93.bitmask
REF_95(Redenom.Account) -> accounts[user]
REF_96(uint256) -> REF_95.bitmask
TMP_212(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_96', '_bit'] 
REF_94(uint256) (->accounts) := TMP_212(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-current_mul()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mul[round - 1]

IRs:
TMP_331(uint256) = round - 1
REF_175(uint256) -> mul[TMP_331]
RETURN REF_175"];
2[label="Node Type: RETURN 2

EXPRESSION:
_current_mul

IRs:
RETURN _current_mul"];
}
// Function: 7696.sol-Redenom-disableVoting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(votingActive == true)

IRs:
TMP_101(bool) = votingActive == True
TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_103(bool) = frozen == False
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
votingActive = false

IRs:
votingActive(bool) := False(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
curentWinner = winningProject()

IRs:
TMP_105(uint256) = INTERNAL_CALL, Redenom.winningProject()()
curentWinner(uint256) := TMP_105(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
addWinner(curentWinner)

IRs:
INTERNAL_CALL, Redenom.addWinner(uint256)(curentWinner)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
VotingOff(curentWinner)

IRs:
Emit VotingOff(curentWinner)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
curentWinner

IRs:
RETURN curentWinner"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
winner

IRs:
RETURN winner"];
}
// Function: 7696.sol-Redenom-enableVoting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(votingActive == false)

IRs:
TMP_94(bool) = votingActive == False
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_96(bool) = frozen == False
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
curentBallotId ++

IRs:
TMP_98(uint256) := curentBallotId(uint256)
curentBallotId(uint256) = curentBallotId + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
votingActive = true

IRs:
votingActive(bool) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
delete projects

IRs:
projects = delete projects "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
VotingOn(curentBallotId)

IRs:
Emit VotingOn(curentBallotId)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
curentBallotId

IRs:
RETURN curentBallotId"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
8->1;
9[label="Node Type: RETURN 9

EXPRESSION:
ballotId

IRs:
RETURN ballotId"];
}
// Function: 7696.sol-Redenom-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_387(None) = SOLIDITY_CALL revert()()"];
}
// Function: 7696.sol-Redenom-findWinner(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < winners.length

IRs:
REF_5 -> LENGTH winners
TMP_60(bool) = p < REF_5
CONDITION TMP_60"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
winners[p].id == _ballotId

IRs:
REF_6(Redenom.Winner) -> winners[p]
REF_7(uint256) -> REF_6.id
TMP_61(bool) = REF_7 == _ballotId
CONDITION TMP_61"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
winners[p].projId

IRs:
REF_8(Redenom.Winner) -> winners[p]
REF_9(uint256) -> REF_8.projId
RETURN REF_9"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
p ++

IRs:
TMP_62(uint256) := p(uint256)
p(uint256) = p + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
winner

IRs:
RETURN winner"];
}
// Function: 7696.sol-Redenom-fix_amount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(amount / current_mul()) * current_mul()

IRs:
TMP_332(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_333(uint256) = amount / TMP_332
TMP_334(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_335(uint256) = TMP_333 * TMP_334
RETURN TMP_335"];
2[label="Node Type: RETURN 2

EXPRESSION:
fixed_amount

IRs:
RETURN fixed_amount"];
}
// Function: 7696.sol-Redenom-freeze_contract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_178(bool) = frozen == False
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-get_rest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
amount % current_mul()

IRs:
TMP_336(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_337(uint256) = amount % TMP_336
RETURN TMP_337"];
2[label="Node Type: RETURN 2

EXPRESSION:
fixed_amount

IRs:
RETURN fixed_amount"];
}
// Function: 7696.sol-Redenom-is_banned(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
bitmask_check(user,1024)

IRs:
TMP_219(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(user,1024)
RETURN TMP_219"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 7696.sol-Redenom-onlyAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == admin || msg.sender == owner)

IRs:
TMP_397(bool) = msg.sender == admin
TMP_398(bool) = msg.sender == owner
TMP_399(bool) = TMP_397 || TMP_398
TMP_400(None) = SOLIDITY_CALL require(bool)(TMP_399)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7696.sol-Redenom-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_395(bool) = msg.sender == owner
TMP_396(None) = SOLIDITY_CALL require(bool)(TMP_395)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7696.sol-Redenom-onlyVoter()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(votingActive == true)

IRs:
TMP_401(bool) = votingActive == True
TMP_402(None) = SOLIDITY_CALL require(bool)(TMP_401)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(msg.sender,4) == true)

IRs:
TMP_403(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,4)
TMP_404(bool) = TMP_403 == True
TMP_405(None) = SOLIDITY_CALL require(bool)(TMP_404)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bitmask_check(msg.sender,1024) == false)

IRs:
TMP_406(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,1024)
TMP_407(bool) = TMP_406 == False
TMP_408(None) = SOLIDITY_CALL require(bool)(TMP_407)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)((accounts[msg.sender].lastVotedBallotId < curentBallotId))

IRs:
REF_227(Redenom.Account) -> accounts[msg.sender]
REF_228(uint256) -> REF_227.lastVotedBallotId
TMP_409(bool) = REF_228 < curentBallotId
TMP_410(None) = SOLIDITY_CALL require(bool)(TMP_409)"];
4->5;
5[label="Node Type: _ 5
"];
}
// Function: 7696.sol-Redenom-pay055(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(to,2) == false)

IRs:
TMP_121(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,2)
TMP_122(bool) = TMP_121 == False
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
new_amount = 55566600 + (block.timestamp % 100)

IRs:
TMP_124(uint256) = block.timestamp % 100
TMP_125(uint256) = 55566600 + TMP_124
new_amount(uint256) := TMP_125(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
payout(to,new_amount)

IRs:
TMP_126(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,new_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bitmask_add(to,2)

IRs:
TMP_127(bool) = INTERNAL_CALL, Redenom.bitmask_add(address,uint256)(to,2)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-pay055loyal(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(epoch > 1)

IRs:
TMP_129(bool) = epoch > 1
TMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(to,4) == true)

IRs:
TMP_131(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,4)
TMP_132(bool) = TMP_131 == True
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
new_amount = 55566600 + (block.timestamp % 100)

IRs:
TMP_134(uint256) = block.timestamp % 100
TMP_135(uint256) = 55566600 + TMP_134
new_amount(uint256) := TMP_135(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payout(to,new_amount)

IRs:
TMP_136(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,new_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-pay1(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(to,4) == false)

IRs:
TMP_115(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,4)
TMP_116(bool) = TMP_115 == False
TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
new_amount = 100000000

IRs:
new_amount(uint256) := 100000000(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
payout(to,new_amount)

IRs:
TMP_118(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,new_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bitmask_add(to,4)

IRs:
TMP_119(bool) = INTERNAL_CALL, Redenom.bitmask_add(address,uint256)(to,4)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-payCustom(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
payout(to,amount)

IRs:
TMP_138(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,amount)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-payout(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_140 = CONVERT 0 to address
TMP_141(bool) = to != TMP_140
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount >= current_mul())

IRs:
TMP_143(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_144(bool) = amount >= TMP_143
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bitmask_check(to,1024) == false)

IRs:
TMP_146(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,1024)
TMP_147(bool) = TMP_146 == False
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_149(bool) = frozen == False
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateAccount(to)

IRs:
TMP_151(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(to)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
fixedAmount = fix_amount(amount)

IRs:
TMP_152(uint256) = INTERNAL_CALL, Redenom.fix_amount(uint256)(amount)
fixedAmount(uint256) := TMP_152(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
renewDec(accounts[to].balance,accounts[to].balance.add(fixedAmount))

IRs:
REF_54(Redenom.Account) -> accounts[to]
REF_55(uint256) -> REF_54.balance
REF_56(Redenom.Account) -> accounts[to]
REF_57(uint256) -> REF_56.balance
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_57', 'fixedAmount'] 
TMP_154(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(REF_55,TMP_153)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
team_part = (fixedAmount / 100) * 10

IRs:
TMP_155(uint256) = fixedAmount / 100
TMP_156(uint256) = TMP_155 * 10
team_part(uint256) := TMP_156(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
dao_part = (fixedAmount / 100) * 30

IRs:
TMP_157(uint256) = fixedAmount / 100
TMP_158(uint256) = TMP_157 * 30
dao_part(uint256) := TMP_158(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
total = fixedAmount.add(team_part).add(dao_part)

IRs:
TMP_159(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['fixedAmount', 'team_part'] 
TMP_160(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_159', 'dao_part'] 
total(uint256) := TMP_160(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
epoch_fund = epoch_fund.sub(total)

IRs:
TMP_161(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['epoch_fund', 'total'] 
epoch_fund(uint256) := TMP_161(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
team_fund = team_fund.add(team_part)

IRs:
TMP_162(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['team_fund', 'team_part'] 
team_fund(uint256) := TMP_162(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
redenom_dao_fund = redenom_dao_fund.add(dao_part)

IRs:
TMP_163(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['redenom_dao_fund', 'dao_part'] 
redenom_dao_fund(uint256) := TMP_163(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(fixedAmount)

IRs:
REF_64(Redenom.Account) -> accounts[to]
REF_65(uint256) -> REF_64.balance
REF_66(Redenom.Account) -> accounts[to]
REF_67(uint256) -> REF_66.balance
TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_67', 'fixedAmount'] 
REF_65(uint256) (->accounts) := TMP_164(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_totalSupply = _totalSupply.add(total)

IRs:
TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', 'total'] 
_totalSupply(uint256) := TMP_165(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Transfer(address(0),to,fixedAmount)

IRs:
TMP_166 = CONVERT 0 to address
Emit Transfer(TMP_166,to,fixedAmount)"];
16->17;
17[label="Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True"];
18[label="Node Type: RETURN 18

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-projectActive(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < projects.length

IRs:
REF_27 -> LENGTH projects
TMP_76(bool) = p < REF_27
CONDITION TMP_76"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
projects[p].id == _id

IRs:
REF_28(Redenom.Project) -> projects[p]
REF_29(uint256) -> REF_28.id
TMP_77(bool) = REF_29 == _id
CONDITION TMP_77"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
projects[p].active

IRs:
REF_30(Redenom.Project) -> projects[p]
REF_31(bool) -> REF_30.active
RETURN REF_31"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
p ++

IRs:
TMP_78(uint256) := p(uint256)
p(uint256) = p + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
PA

IRs:
RETURN PA"];
}
// Function: 7696.sol-Redenom-projectWeight(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < projects.length

IRs:
REF_22 -> LENGTH projects
TMP_73(bool) = p < REF_22
CONDITION TMP_73"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
projects[p].id == _id

IRs:
REF_23(Redenom.Project) -> projects[p]
REF_24(uint256) -> REF_23.id
TMP_74(bool) = REF_24 == _id
CONDITION TMP_74"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
projects[p].votesWeight

IRs:
REF_25(Redenom.Project) -> projects[p]
REF_26(uint256) -> REF_25.votesWeight
RETURN REF_26"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
p ++

IRs:
TMP_75(uint256) := p(uint256)
p(uint256) = p + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
PW

IRs:
RETURN PW"];
}
// Function: 7696.sol-Redenom-redenominate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->53;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_221(bool) = frozen == False
TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round < 9)

IRs:
TMP_223(bool) = round < 9
TMP_224(None) = SOLIDITY_CALL require(bool)(TMP_223)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply = _totalSupply.sub(team_fund % mul[round]).sub(redenom_dao_fund % mul[round]).sub(dec[8 - round] * mul[round - 1])

IRs:
REF_101(uint256) -> mul[round]
TMP_225(uint256) = team_fund % REF_101
TMP_226(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_totalSupply', 'TMP_225'] 
REF_103(uint256) -> mul[round]
TMP_227(uint256) = redenom_dao_fund % REF_103
TMP_228(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_226', 'TMP_227'] 
TMP_229(uint256) = 8 - round
REF_105(uint256) -> dec[TMP_229]
TMP_230(uint256) = round - 1
REF_106(uint256) -> mul[TMP_230]
TMP_231(uint256) = REF_105 * REF_106
TMP_232(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_228', 'TMP_231'] 
_totalSupply(uint256) := TMP_232(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_totalSupply = (_totalSupply / mul[round]) * mul[round]

IRs:
REF_107(uint256) -> mul[round]
TMP_233(uint256) = _totalSupply / REF_107
REF_108(uint256) -> mul[round]
TMP_234(uint256) = TMP_233 * REF_108
_totalSupply(uint256) := TMP_234(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
team_fund = (team_fund / mul[round]) * mul[round]

IRs:
REF_109(uint256) -> mul[round]
TMP_235(uint256) = team_fund / REF_109
REF_110(uint256) -> mul[round]
TMP_236(uint256) = TMP_235 * REF_110
team_fund(uint256) := TMP_236(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
redenom_dao_fund = (redenom_dao_fund / mul[round]) * mul[round]

IRs:
REF_111(uint256) -> mul[round]
TMP_237(uint256) = redenom_dao_fund / REF_111
REF_112(uint256) -> mul[round]
TMP_238(uint256) = TMP_237 * REF_112
redenom_dao_fund(uint256) := TMP_238(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
round > 1

IRs:
TMP_239(bool) = round > 1
CONDITION TMP_239"];
7->8[label="True"];
7->11[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
superold = dec[(8 - round) + 1]

IRs:
TMP_240(uint256) = 8 - round
TMP_241(uint256) = TMP_240 + 1
REF_113(uint256) -> dec[TMP_241]
superold(uint256) := REF_113(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
epoch_fund = epoch_fund.add(superold * mul[round - 2])

IRs:
TMP_242(uint256) = round - 2
REF_115(uint256) -> mul[TMP_242]
TMP_243(uint256) = superold * REF_115
TMP_244(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['epoch_fund', 'TMP_243'] 
epoch_fund(uint256) := TMP_244(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
dec[(8 - round) + 1] = 0

IRs:
TMP_245(uint256) = 8 - round
TMP_246(uint256) = TMP_245 + 1
REF_116(uint256) -> dec[TMP_246]
REF_116(uint256) (->dec) := 0(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
round < 8

IRs:
TMP_247(bool) = round < 8
CONDITION TMP_247"];
12->13[label="True"];
12->45[label="False"];
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
unclimed = dec[8 - round]

IRs:
TMP_248(uint256) = 8 - round
REF_117(uint256) -> dec[TMP_248]
unclimed(uint256) := REF_117(uint256)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
total_current = dec[8 - 1 - round]

IRs:
TMP_249(uint256) = 8 - 1
TMP_250(uint256) = TMP_249 - round
REF_118(uint256) -> dec[TMP_250]
total_current(uint256) := REF_118(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
total_current == 0

IRs:
TMP_251(bool) = total_current == 0
CONDITION TMP_251"];
15->16[label="True"];
15->19[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
current_toadd = (0,0,0,0,0,0,0,0,0)

IRs:
current_toadd(uint256[9]) = ['0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
round ++

IRs:
TMP_252(uint256) := round(uint256)
round(uint256) = round + 1"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
round

IRs:
RETURN round"];
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: NEW VARIABLE 20

EXPRESSION:
numbers = (uint256(1),2,3,4,5,6,7,8,9)

IRs:
TMP_253 = CONVERT 1 to uint256
numbers(uint256[9]) = ['TMP_253(uint256)', '2(uint256)', '3(uint256)', '4(uint256)', '5(uint256)', '6(uint256)', '7(uint256)', '8(uint256)', '9(uint256)']"];
20->21;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
ke9 = (uint256(0),0,0,0,0,0,0,0,0)

IRs:
TMP_254 = CONVERT 0 to uint256
ke9(uint256[9]) = ['TMP_254(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
21->22;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
k2e9 = (uint256(0),0,0,0,0,0,0,0,0)

IRs:
TMP_255 = CONVERT 0 to uint256
k2e9(uint256[9]) = ['TMP_255(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
k05summ = 0

IRs:
k05summ(uint256) := 0(uint256)"];
23->26;
24[label="Node Type: BEGIN_LOOP 24
"];
24->27;
25[label="Node Type: END_LOOP 25
"];
25->35;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
k = 0

IRs:
k(uint256) := 0(uint256)"];
26->24;
27[label="Node Type: IF_LOOP 27

EXPRESSION:
k < ke9.length

IRs:
REF_119 -> LENGTH ke9
TMP_256(bool) = k < REF_119
CONDITION TMP_256"];
27->28[label="True"];
27->25[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
ke9[k] = numbers[k] * 1e9 / total_current

IRs:
REF_120(uint256) -> ke9[k]
REF_121(uint256) -> numbers[k]
TMP_257(uint256) = REF_121 * 1000000000
TMP_258(uint256) = TMP_257 / total_current
REF_120(uint256) (->ke9) := TMP_258(uint256)"];
28->29;
29[label="Node Type: IF 29

EXPRESSION:
k < 5

IRs:
TMP_259(bool) = k < 5
CONDITION TMP_259"];
29->30[label="True"];
29->31[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
k05summ += ke9[k]

IRs:
REF_122(uint256) -> ke9[k]
k05summ(uint256) = k05summ + REF_122"];
30->31;
31[label="Node Type: END_IF 31
"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
k ++

IRs:
TMP_260(uint256) := k(uint256)
k(uint256) = k + 1"];
32->27;
33[label="Node Type: BEGIN_LOOP 33
"];
33->36;
34[label="Node Type: END_LOOP 34
"];
34->41;
35[label="Node Type: NEW VARIABLE 35

EXPRESSION:
k2 = 5

IRs:
k2(uint256) := 5(uint256)"];
35->33;
36[label="Node Type: IF_LOOP 36

EXPRESSION:
k2 < k2e9.length

IRs:
REF_123 -> LENGTH k2e9
TMP_261(bool) = k2 < REF_123
CONDITION TMP_261"];
36->37[label="True"];
36->34[label="False"];
37[label="Node Type: EXPRESSION 37

EXPRESSION:
k2e9[k2] = uint256(ke9[k2]) + uint256(k05summ) * uint256(weight[k2]) / uint256(100)

IRs:
REF_124(uint256) -> k2e9[k2]
REF_125(uint256) -> ke9[k2]
TMP_262 = CONVERT REF_125 to uint256
TMP_263 = CONVERT k05summ to uint256
REF_126(uint256) -> weight[k2]
TMP_264 = CONVERT REF_126 to uint256
TMP_265(uint256) = TMP_263 * TMP_264
TMP_266 = CONVERT 100 to uint256
TMP_267(uint256) = TMP_265 / TMP_266
TMP_268(uint256) = TMP_262 + TMP_267
REF_124(uint256) (->k2e9) := TMP_268(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
k2 ++

IRs:
TMP_269(uint256) := k2(uint256)
k2(uint256) = k2 + 1"];
38->36;
39[label="Node Type: BEGIN_LOOP 39
"];
39->42;
40[label="Node Type: END_LOOP 40
"];
40->49;
41[label="Node Type: NEW VARIABLE 41

EXPRESSION:
n = 5

IRs:
n(uint256) := 5(uint256)"];
41->39;
42[label="Node Type: IF_LOOP 42

EXPRESSION:
n < current_toadd.length

IRs:
REF_127 -> LENGTH current_toadd
TMP_270(bool) = n < REF_127
CONDITION TMP_270"];
42->43[label="True"];
42->40[label="False"];
43[label="Node Type: EXPRESSION 43

EXPRESSION:
current_toadd[n] = k2e9[n] * unclimed / 10 / 1e9

IRs:
REF_128(uint256) -> current_toadd[n]
REF_129(uint256) -> k2e9[n]
TMP_271(uint256) = REF_129 * unclimed
TMP_272(uint256) = TMP_271 / 10
TMP_273(uint256) = TMP_272 / 1000000000
REF_128(uint256) (->current_toadd) := TMP_273(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
n ++

IRs:
TMP_274(uint256) := n(uint256)
n(uint256) = n + 1"];
44->42;
45[label="Node Type: IF 45

EXPRESSION:
round == 8

IRs:
TMP_275(bool) = round == 8
CONDITION TMP_275"];
45->46[label="True"];
45->48[label="False"];
46[label="Node Type: EXPRESSION 46

EXPRESSION:
epoch_fund = epoch_fund.add(dec[0] * 10000000)

IRs:
REF_131(uint256) -> dec[0]
TMP_276(uint256) = REF_131 * 10000000
TMP_277(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['epoch_fund', 'TMP_276'] 
epoch_fund(uint256) := TMP_277(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
dec[0] = 0

IRs:
REF_132(uint256) -> dec[0]
REF_132(uint256) (->dec) := 0(uint256)"];
47->48;
48[label="Node Type: END_IF 48
"];
48->49;
49[label="Node Type: END_IF 49
"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
round ++

IRs:
TMP_278(uint256) := round(uint256)
round(uint256) = round + 1"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
Redenomination(round)

IRs:
Emit Redenomination(round)"];
51->52;
52[label="Node Type: RETURN 52

EXPRESSION:
round

IRs:
RETURN round"];
53[label="Node Type: EXPRESSION 53

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
53->1;
54[label="Node Type: RETURN 54

EXPRESSION:
current_round

IRs:
RETURN current_round"];
}
// Function: 7696.sol-Redenom-renewDec(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
round < 9

IRs:
TMP_184(bool) = round < 9
CONDITION TMP_184"];
1->2[label="True"];
1->19[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tempInitSum = initSum

IRs:
tempInitSum(uint256) := initSum(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tempNewSum = newSum

IRs:
tempNewSum(uint256) := newSum(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cnt = 1

IRs:
cnt(uint256) := 1(uint256)"];
4->5;
5[label="Node Type: BEGIN_LOOP 5
"];
5->6;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
(tempNewSum > 0 || tempInitSum > 0) && cnt <= decimals

IRs:
TMP_185(bool) = tempNewSum > 0
TMP_186(bool) = tempInitSum > 0
TMP_187(bool) = TMP_185 || TMP_186
TMP_188(bool) = cnt <= decimals
TMP_189(bool) = TMP_187 && TMP_188
CONDITION TMP_189"];
6->7[label="True"];
6->18[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
lastInitSum = tempInitSum % 10

IRs:
TMP_190(uint256) = tempInitSum % 10
lastInitSum(uint256) := TMP_190(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
tempInitSum = tempInitSum / 10

IRs:
TMP_191(uint256) = tempInitSum / 10
tempInitSum(uint256) := TMP_191(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
lastNewSum = tempNewSum % 10

IRs:
TMP_192(uint256) = tempNewSum % 10
lastNewSum(uint256) := TMP_192(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
tempNewSum = tempNewSum / 10

IRs:
TMP_193(uint256) = tempNewSum / 10
tempNewSum(uint256) := TMP_193(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
cnt >= round

IRs:
TMP_194(bool) = cnt >= round
CONDITION TMP_194"];
11->12[label="True"];
11->16[label="False"];
12[label="Node Type: IF 12

EXPRESSION:
lastNewSum >= lastInitSum

IRs:
TMP_195(bool) = lastNewSum >= lastInitSum
CONDITION TMP_195"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
dec[decimals - cnt] = dec[decimals - cnt].add(lastNewSum - lastInitSum)

IRs:
TMP_196(uint256) = decimals - cnt
REF_82(uint256) -> dec[TMP_196]
TMP_197(uint256) = decimals - cnt
REF_83(uint256) -> dec[TMP_197]
TMP_198(uint256) = lastNewSum - lastInitSum
TMP_199(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_83', 'TMP_198'] 
REF_82(uint256) (->dec) := TMP_199(uint256)"];
13->15;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
dec[decimals - cnt] = dec[decimals - cnt].sub(lastInitSum - lastNewSum)

IRs:
TMP_200(uint256) = decimals - cnt
REF_85(uint256) -> dec[TMP_200]
TMP_201(uint256) = decimals - cnt
REF_86(uint256) -> dec[TMP_201]
TMP_202(uint256) = lastInitSum - lastNewSum
TMP_203(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_86', 'TMP_202'] 
REF_85(uint256) (->dec) := TMP_203(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
cnt = cnt + 1

IRs:
TMP_204(uint256) = cnt + 1
cnt(uint256) := TMP_204(uint256)"];
17->6;
18[label="Node Type: END_LOOP 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
true

IRs:
RETURN True"];
21[label="Node Type: RETURN 21

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-setAdmin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
AdminChanged(admin,newAdmin)

IRs:
Emit AdminChanged(admin,newAdmin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = newAdmin

IRs:
admin(address) := newAdmin(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 7696.sol-Redenom-showAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_admin = admin

IRs:
_admin(address) := admin(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_admin

IRs:
RETURN _admin"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
_admin

IRs:
RETURN _admin"];
}
// Function: 7696.sol-Redenom-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 8

IRs:
decimals(uint256) := 8(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
round = 1

IRs:
round(uint256) := 1(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
epoch = 1

IRs:
epoch(uint256) := 1(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
dec = (0,0,0,0,0,0,0,0)

IRs:
dec(uint256[8]) = ['0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
mul = (1,10,100,1000,10000,100000,1000000,10000000,100000000)

IRs:
mul(uint256[9]) = ['1(uint256)', '10(uint256)', '100(uint256)', '1000(uint256)', '10000(uint256)', '100000(uint256)', '1000000(uint256)', '10000000(uint256)', '100000000(uint256)']"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
weight = (uint256(0),0,0,0,0,5,10,30,55)

IRs:
TMP_393 = CONVERT 0 to uint256
weight(uint256[9]) = ['TMP_393(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '5(uint256)', '10(uint256)', '30(uint256)', '55(uint256)']"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
current_toadd = (uint256(0),0,0,0,0,0,0,0,0)

IRs:
TMP_394 = CONVERT 0 to uint256
current_toadd(uint256[9]) = ['TMP_394(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
votingActive = false

IRs:
votingActive(bool) := False(bool)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
curentBallotId = 0

IRs:
curentBallotId(uint256) := 0(uint256)"];
}
// Function: 7696.sol-Redenom-sqrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = (x + 1) / 2

IRs:
TMP_109(uint256) = x + 1
TMP_110(uint256) = TMP_109 / 2
z(uint256) := TMP_110(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
y = x

IRs:
y(uint256) := x(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
z < y

IRs:
TMP_111(bool) = z < y
CONDITION TMP_111"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
y = z

IRs:
y(uint256) := z(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
z = (x / z + z) / 2

IRs:
TMP_112(uint256) = x / z
TMP_113(uint256) = TMP_112 + z
TMP_114(uint256) = TMP_113 / 2
z(uint256) := TMP_114(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
y

IRs:
RETURN y"];
}
// Function: 7696.sol-Redenom-swapProject(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < projects.length

IRs:
REF_13 -> LENGTH projects
TMP_68(bool) = p < REF_13
CONDITION TMP_68"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
projects[p].id == _id

IRs:
REF_14(Redenom.Project) -> projects[p]
REF_15(uint256) -> REF_14.id
TMP_69(bool) = REF_15 == _id
CONDITION TMP_69"];
5->6[label="True"];
5->10[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
projects[p].active == true

IRs:
REF_16(Redenom.Project) -> projects[p]
REF_17(bool) -> REF_16.active
TMP_70(bool) = REF_17 == True
CONDITION TMP_70"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
projects[p].active = false

IRs:
REF_18(Redenom.Project) -> projects[p]
REF_19(bool) -> REF_18.active
REF_19(bool) (->projects) := False(bool)"];
7->9;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
projects[p].active = true

IRs:
REF_20(Redenom.Project) -> projects[p]
REF_21(bool) -> REF_20.active
REF_21(bool) (->projects) := True(bool)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
p ++

IRs:
TMP_71(uint256) := p(uint256)
p(uint256) = p + 1"];
11->4;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
12->3;
}
// Function: 7696.sol-Redenom-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply"];
}
// Function: 7696.sol-Redenom-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_338(bool) = frozen == False
TMP_339(None) = SOLIDITY_CALL require(bool)(TMP_338)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_340 = CONVERT 0 to address
TMP_341(bool) = to != TMP_340
TMP_342(None) = SOLIDITY_CALL require(bool)(TMP_341)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bitmask_check(to,1024) == false)

IRs:
TMP_343(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,1024)
TMP_344(bool) = TMP_343 == False
TMP_345(None) = SOLIDITY_CALL require(bool)(TMP_344)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokens = fix_amount(tokens)

IRs:
TMP_346(uint256) = INTERNAL_CALL, Redenom.fix_amount(uint256)(tokens)
tokens(uint256) := TMP_346(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(tokens > 0)

IRs:
TMP_347(bool) = tokens > 0
TMP_348(None) = SOLIDITY_CALL require(bool)(TMP_347)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateAccount(to)

IRs:
TMP_349(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(to)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updateAccount(msg.sender)

IRs:
TMP_350(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(msg.sender)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
fromOldBal = accounts[msg.sender].balance

IRs:
REF_180(Redenom.Account) -> accounts[msg.sender]
REF_181(uint256) -> REF_180.balance
fromOldBal(uint256) := REF_181(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
toOldBal = accounts[to].balance

IRs:
REF_182(Redenom.Account) -> accounts[to]
REF_183(uint256) -> REF_182.balance
toOldBal(uint256) := REF_183(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens)

IRs:
REF_184(Redenom.Account) -> accounts[msg.sender]
REF_185(uint256) -> REF_184.balance
REF_186(Redenom.Account) -> accounts[msg.sender]
REF_187(uint256) -> REF_186.balance
TMP_351(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_187', 'tokens'] 
REF_185(uint256) (->accounts) := TMP_351(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(tokens)

IRs:
REF_189(Redenom.Account) -> accounts[to]
REF_190(uint256) -> REF_189.balance
REF_191(Redenom.Account) -> accounts[to]
REF_192(uint256) -> REF_191.balance
TMP_352(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_192', 'tokens'] 
REF_190(uint256) (->accounts) := TMP_352(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(renewDec(fromOldBal,accounts[msg.sender].balance))

IRs:
REF_194(Redenom.Account) -> accounts[msg.sender]
REF_195(uint256) -> REF_194.balance
TMP_353(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(fromOldBal,REF_195)
TMP_354(None) = SOLIDITY_CALL require(bool)(TMP_353)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(renewDec(toOldBal,accounts[to].balance))

IRs:
REF_196(Redenom.Account) -> accounts[to]
REF_197(uint256) -> REF_196.balance
TMP_355(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(toOldBal,REF_197)
TMP_356(None) = SOLIDITY_CALL require(bool)(TMP_355)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(msg.sender,to,tokens)

IRs:
Emit Transfer(msg.sender,to,tokens)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
true

IRs:
RETURN True"];
16[label="Node Type: RETURN 16

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-transferAnyERC20Token(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_388(bool) = frozen == False
TMP_389(None) = SOLIDITY_CALL require(bool)(TMP_388)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
ERC20Interface(tokenAddress).transfer(owner,tokens)

IRs:
TMP_390 = CONVERT tokenAddress to ERC20Interface
TMP_391(bool) = HIGH_LEVEL_CALL, dest:TMP_390(ERC20Interface), function:transfer, arguments:['owner', 'tokens']  
RETURN TMP_391"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_364(bool) = frozen == False
TMP_365(None) = SOLIDITY_CALL require(bool)(TMP_364)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(to,1024) == false)

IRs:
TMP_366(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,1024)
TMP_367(bool) = TMP_366 == False
TMP_368(None) = SOLIDITY_CALL require(bool)(TMP_367)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
updateAccount(from)

IRs:
TMP_369(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(from)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
updateAccount(to)

IRs:
TMP_370(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(to)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
fromOldBal = accounts[from].balance

IRs:
REF_200(Redenom.Account) -> accounts[from]
REF_201(uint256) -> REF_200.balance
fromOldBal(uint256) := REF_201(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
toOldBal = accounts[to].balance

IRs:
REF_202(Redenom.Account) -> accounts[to]
REF_203(uint256) -> REF_202.balance
toOldBal(uint256) := REF_203(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
accounts[from].balance = accounts[from].balance.sub(tokens)

IRs:
REF_204(Redenom.Account) -> accounts[from]
REF_205(uint256) -> REF_204.balance
REF_206(Redenom.Account) -> accounts[from]
REF_207(uint256) -> REF_206.balance
TMP_371(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_207', 'tokens'] 
REF_205(uint256) (->accounts) := TMP_371(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens)

IRs:
REF_209(mapping(address => uint256)) -> allowed[from]
REF_210(uint256) -> REF_209[msg.sender]
REF_211(mapping(address => uint256)) -> allowed[from]
REF_212(uint256) -> REF_211[msg.sender]
TMP_372(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_212', 'tokens'] 
REF_210(uint256) (->allowed) := TMP_372(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(tokens)

IRs:
REF_214(Redenom.Account) -> accounts[to]
REF_215(uint256) -> REF_214.balance
REF_216(Redenom.Account) -> accounts[to]
REF_217(uint256) -> REF_216.balance
TMP_373(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_217', 'tokens'] 
REF_215(uint256) (->accounts) := TMP_373(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(renewDec(fromOldBal,accounts[from].balance))

IRs:
REF_219(Redenom.Account) -> accounts[from]
REF_220(uint256) -> REF_219.balance
TMP_374(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(fromOldBal,REF_220)
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(renewDec(toOldBal,accounts[to].balance))

IRs:
REF_221(Redenom.Account) -> accounts[to]
REF_222(uint256) -> REF_221.balance
TMP_376(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(toOldBal,REF_222)
TMP_377(None) = SOLIDITY_CALL require(bool)(TMP_376)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(from,to,tokens)

IRs:
Emit Transfer(from,to,tokens)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True"];
14[label="Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 7696.sol-Redenom-unban_user(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bitmask_rm(user,1024)

IRs:
TMP_217(bool) = INTERNAL_CALL, Redenom.bitmask_rm(address,uint256)(user,1024)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-unfreeze_contract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == true)

IRs:
TMP_181(bool) = frozen == True
TMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-updateAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_281(bool) = frozen == False
TMP_282(None) = SOLIDITY_CALL require(bool)(TMP_281)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round <= 9)

IRs:
TMP_283(bool) = round <= 9
TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bitmask_check(account,1024) == false)

IRs:
TMP_285(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(account,1024)
TMP_286(bool) = TMP_285 == False
TMP_287(None) = SOLIDITY_CALL require(bool)(TMP_286)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
round > accounts[account].lastRound

IRs:
REF_133(Redenom.Account) -> accounts[account]
REF_134(uint256) -> REF_133.lastRound
TMP_288(bool) = round > REF_134
CONDITION TMP_288"];
4->5[label="True"];
4->39[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
round > 1 && round <= 8

IRs:
TMP_289(bool) = round > 1
TMP_290(bool) = round <= 8
TMP_291(bool) = TMP_289 && TMP_290
CONDITION TMP_291"];
5->6[label="True"];
5->27[label="False"];
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
tempDividedBalance = accounts[account].balance / current_mul()

IRs:
REF_135(Redenom.Account) -> accounts[account]
REF_136(uint256) -> REF_135.balance
TMP_292(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_293(uint256) = REF_136 / TMP_292
tempDividedBalance(uint256) := TMP_293(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
newFixedBalance = tempDividedBalance * current_mul()

IRs:
TMP_294(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_295(uint256) = tempDividedBalance * TMP_294
newFixedBalance(uint256) := TMP_295(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
lastActiveDigit = tempDividedBalance % 10

IRs:
TMP_296(uint256) = tempDividedBalance % 10
lastActiveDigit(uint256) := TMP_296(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
diff = accounts[account].balance - newFixedBalance

IRs:
REF_137(Redenom.Account) -> accounts[account]
REF_138(uint256) -> REF_137.balance
TMP_297(uint256) = REF_138 - newFixedBalance
diff(uint256) := TMP_297(uint256)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
diff > 0

IRs:
TMP_298(bool) = diff > 0
CONDITION TMP_298"];
10->11[label="True"];
10->13[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
accounts[account].balance = newFixedBalance

IRs:
REF_139(Redenom.Account) -> accounts[account]
REF_140(uint256) -> REF_139.balance
REF_140(uint256) (->accounts) := newFixedBalance(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(account,address(0),diff)

IRs:
TMP_299 = CONVERT 0 to address
Emit Transfer(account,TMP_299,diff)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
toBalance = 0

IRs:
toBalance(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
lastActiveDigit > 0 && current_toadd[lastActiveDigit - 1] > 0

IRs:
TMP_301(bool) = lastActiveDigit > 0
TMP_302(uint256) = lastActiveDigit - 1
REF_141(uint256) -> current_toadd[TMP_302]
TMP_303(bool) = REF_141 > 0
TMP_304(bool) = TMP_301 && TMP_303
CONDITION TMP_304"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
toBalance = current_toadd[lastActiveDigit - 1] * current_mul()

IRs:
TMP_305(uint256) = lastActiveDigit - 1
REF_142(uint256) -> current_toadd[TMP_305]
TMP_306(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_307(uint256) = REF_142 * TMP_306
toBalance(uint256) := TMP_307(uint256)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
toBalance > 0 && toBalance < dec[8 - round + 1]

IRs:
TMP_308(bool) = toBalance > 0
TMP_309(uint256) = 8 - round
TMP_310(uint256) = TMP_309 + 1
REF_143(uint256) -> dec[TMP_310]
TMP_311(bool) = toBalance < REF_143
TMP_312(bool) = TMP_308 && TMP_311
CONDITION TMP_312"];
18->19[label="True"];
18->24[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
renewDec(accounts[account].balance,accounts[account].balance.add(toBalance))

IRs:
REF_144(Redenom.Account) -> accounts[account]
REF_145(uint256) -> REF_144.balance
REF_146(Redenom.Account) -> accounts[account]
REF_147(uint256) -> REF_146.balance
TMP_313(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_147', 'toBalance'] 
TMP_314(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(REF_145,TMP_313)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
Transfer(address(0),account,toBalance)

IRs:
TMP_315 = CONVERT 0 to address
Emit Transfer(TMP_315,account,toBalance)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
accounts[account].balance = accounts[account].balance.add(toBalance)

IRs:
REF_149(Redenom.Account) -> accounts[account]
REF_150(uint256) -> REF_149.balance
REF_151(Redenom.Account) -> accounts[account]
REF_152(uint256) -> REF_151.balance
TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_152', 'toBalance'] 
REF_150(uint256) (->accounts) := TMP_317(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
dec[8 - round + 1] = dec[8 - round + 1].sub(toBalance)

IRs:
TMP_318(uint256) = 8 - round
TMP_319(uint256) = TMP_318 + 1
REF_154(uint256) -> dec[TMP_319]
TMP_320(uint256) = 8 - round
TMP_321(uint256) = TMP_320 + 1
REF_155(uint256) -> dec[TMP_321]
TMP_322(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_155', 'toBalance'] 
REF_154(uint256) (->dec) := TMP_322(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
_totalSupply = _totalSupply.add(toBalance)

IRs:
TMP_323(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', 'toBalance'] 
_totalSupply(uint256) := TMP_323(uint256)"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
accounts[account].lastRound = round

IRs:
REF_158(Redenom.Account) -> accounts[account]
REF_159(uint256) -> REF_158.lastRound
REF_159(uint256) (->accounts) := round(uint256)"];
25->26;
26[label="Node Type: RETURN 26

EXPRESSION:
accounts[account].balance

IRs:
REF_160(Redenom.Account) -> accounts[account]
REF_161(uint256) -> REF_160.balance
RETURN REF_161"];
27[label="Node Type: IF 27

EXPRESSION:
round == 9

IRs:
TMP_324(bool) = round == 9
CONDITION TMP_324"];
27->28[label="True"];
27->37[label="False"];
28[label="Node Type: NEW VARIABLE 28

EXPRESSION:
newBalance = fix_amount(accounts[account].balance)

IRs:
REF_162(Redenom.Account) -> accounts[account]
REF_163(uint256) -> REF_162.balance
TMP_325(uint256) = INTERNAL_CALL, Redenom.fix_amount(uint256)(REF_163)
newBalance(uint256) := TMP_325(uint256)"];
28->29;
29[label="Node Type: NEW VARIABLE 29

EXPRESSION:
_diff = accounts[account].balance.sub(newBalance)

IRs:
REF_164(Redenom.Account) -> accounts[account]
REF_165(uint256) -> REF_164.balance
TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_165', 'newBalance'] 
_diff(uint256) := TMP_326(uint256)"];
29->30;
30[label="Node Type: IF 30

EXPRESSION:
_diff > 0

IRs:
TMP_327(bool) = _diff > 0
CONDITION TMP_327"];
30->31[label="True"];
30->34[label="False"];
31[label="Node Type: EXPRESSION 31

EXPRESSION:
renewDec(accounts[account].balance,newBalance)

IRs:
REF_167(Redenom.Account) -> accounts[account]
REF_168(uint256) -> REF_167.balance
TMP_328(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(REF_168,newBalance)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
accounts[account].balance = newBalance

IRs:
REF_169(Redenom.Account) -> accounts[account]
REF_170(uint256) -> REF_169.balance
REF_170(uint256) (->accounts) := newBalance(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
Transfer(account,address(0),_diff)

IRs:
TMP_329 = CONVERT 0 to address
Emit Transfer(account,TMP_329,_diff)"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
accounts[account].lastRound = round

IRs:
REF_171(Redenom.Account) -> accounts[account]
REF_172(uint256) -> REF_171.lastRound
REF_172(uint256) (->accounts) := round(uint256)"];
35->36;
36[label="Node Type: RETURN 36

EXPRESSION:
accounts[account].balance

IRs:
REF_173(Redenom.Account) -> accounts[account]
REF_174(uint256) -> REF_173.balance
RETURN REF_174"];
37[label="Node Type: END_IF 37
"];
37->38;
38[label="Node Type: END_IF 38
"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: RETURN 40

EXPRESSION:
new_balance

IRs:
RETURN new_balance"];
}
// Function: 7696.sol-Redenom-vote(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_79(bool) = frozen == False
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
p < projects.length

IRs:
REF_32 -> LENGTH projects
TMP_81(bool) = p < REF_32
CONDITION TMP_81"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
projects[p].id == _id && projects[p].active == true

IRs:
REF_33(Redenom.Project) -> projects[p]
REF_34(uint256) -> REF_33.id
TMP_82(bool) = REF_34 == _id
REF_35(Redenom.Project) -> projects[p]
REF_36(bool) -> REF_35.active
TMP_83(bool) = REF_36 == True
TMP_84(bool) = TMP_82 && TMP_83
CONDITION TMP_84"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
projects[p].votesWeight += sqrt(accounts[msg.sender].balance)

IRs:
REF_37(Redenom.Project) -> projects[p]
REF_38(uint256) -> REF_37.votesWeight
REF_39(Redenom.Account) -> accounts[msg.sender]
REF_40(uint256) -> REF_39.balance
TMP_85(uint256) = INTERNAL_CALL, Redenom.sqrt(uint256)(REF_40)
REF_38(-> projects) = REF_38 + TMP_85"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
accounts[msg.sender].lastVotedBallotId = curentBallotId

IRs:
REF_41(Redenom.Account) -> accounts[msg.sender]
REF_42(uint256) -> REF_41.lastVotedBallotId
REF_42(uint256) (->accounts) := curentBallotId(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
p ++

IRs:
TMP_86(uint256) := p(uint256)
p(uint256) = p + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Vote(msg.sender,_id,accounts[msg.sender].balance,curentBallotId)

IRs:
REF_43(Redenom.Account) -> accounts[msg.sender]
REF_44(uint256) -> REF_43.balance
Emit Vote(msg.sender,_id,REF_44,curentBallotId)"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyVoter()

IRs:
MODIFIER_CALL, Redenom.onlyVoter()()"];
13->1;
14[label="Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-winningProject()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
winningVoteWeight = 0

IRs:
winningVoteWeight(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
p < projects.length

IRs:
REF_45 -> LENGTH projects
TMP_89(bool) = p < REF_45
CONDITION TMP_89"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
projects[p].votesWeight > winningVoteWeight && projects[p].active == true

IRs:
REF_46(Redenom.Project) -> projects[p]
REF_47(uint256) -> REF_46.votesWeight
TMP_90(bool) = REF_47 > winningVoteWeight
REF_48(Redenom.Project) -> projects[p]
REF_49(bool) -> REF_48.active
TMP_91(bool) = REF_49 == True
TMP_92(bool) = TMP_90 && TMP_91
CONDITION TMP_92"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
winningVoteWeight = projects[p].votesWeight

IRs:
REF_50(Redenom.Project) -> projects[p]
REF_51(uint256) -> REF_50.votesWeight
winningVoteWeight(uint256) := REF_51(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_winningProject = projects[p].id

IRs:
REF_52(Redenom.Project) -> projects[p]
REF_53(uint256) -> REF_52.id
_winningProject(uint256) := REF_53(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
p ++

IRs:
TMP_93(uint256) := p(uint256)
p(uint256) = p + 1"];
10->5;
11[label="Node Type: RETURN 11

EXPRESSION:
_winningProject

IRs:
RETURN _winningProject"];
}
// Function: 7696.sol-Redenom-withdraw_dao_fund(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount <= redenom_dao_fund)

IRs:
TMP_173(bool) = amount <= redenom_dao_fund
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(amount)

IRs:
REF_76(Redenom.Account) -> accounts[to]
REF_77(uint256) -> REF_76.balance
REF_78(Redenom.Account) -> accounts[to]
REF_79(uint256) -> REF_78.balance
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_79', 'amount'] 
REF_77(uint256) (->accounts) := TMP_175(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
redenom_dao_fund = redenom_dao_fund.sub(amount)

IRs:
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['redenom_dao_fund', 'amount'] 
redenom_dao_fund(uint256) := TMP_176(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-Redenom-withdraw_team_fund(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount <= team_fund)

IRs:
TMP_168(bool) = amount <= team_fund
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(amount)

IRs:
REF_70(Redenom.Account) -> accounts[to]
REF_71(uint256) -> REF_70.balance
REF_72(Redenom.Account) -> accounts[to]
REF_73(uint256) -> REF_72.balance
TMP_170(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_73', 'amount'] 
REF_71(uint256) (->accounts) := TMP_170(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
team_fund = team_fund.sub(amount)

IRs:
TMP_171(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['team_fund', 'amount'] 
team_fund(uint256) := TMP_171(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 7696.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_0(uint256) = a + b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(c >= a)

IRs:
TMP_1(bool) = c >= a
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 7696.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b > 0)

IRs:
TMP_12(bool) = b > 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a / b

IRs:
TMP_14(uint256) = a / b
c(uint256) := TMP_14(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 7696.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_6(uint256) = a * b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(a == 0 || c / a == b)

IRs:
TMP_7(bool) = a == 0
TMP_8(uint256) = c / a
TMP_9(bool) = TMP_8 == b
TMP_10(bool) = TMP_7 || TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 7696.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b <= a)

IRs:
TMP_3(bool) = b <= a
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_5(uint256) = a - b
c(uint256) := TMP_5(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
}
