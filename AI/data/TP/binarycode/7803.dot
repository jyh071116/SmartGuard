digraph G {
// Function: 7803.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
}
// Function: 7803.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 7803.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_0 = CONVERT 0 to address
TMP_1(bool) = _to != TMP_0
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_3(bool) = _value <= REF_0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_5(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_5(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_6(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_6(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-BurnableToken-_burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_who])

IRs:
REF_151(uint256) -> balances[_who]
TMP_145(bool) = _value <= REF_151
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_who] = balances[_who].sub(_value)

IRs:
REF_152(uint256) -> balances[_who]
REF_153(uint256) -> balances[_who]
TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_153', '_value'] 
REF_152(uint256) (->balances) := TMP_147(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_148(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(_who,_value)

IRs:
Emit Burn(_who,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_who,address(0),_value)

IRs:
TMP_150 = CONVERT 0 to address
Emit Transfer(_who,TMP_150,_value)"];
}
// Function: 7803.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 7803.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_burn(msg.sender,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(msg.sender,_value)"];
}
// Function: 7803.sol-BurnableToken-totalSupply()
digraph{
}
// Function: 7803.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 7803.sol-CappedToken-CappedToken(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_cap > 0)

IRs:
TMP_124(bool) = _cap > 0
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
cap = _cap

IRs:
cap(uint256) := _cap(uint256)"];
}
// Function: 7803.sol-CappedToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7803.sol-CappedToken-allowance(address,address)
digraph{
}
// Function: 7803.sol-CappedToken-approve(address,uint256)
digraph{
}
// Function: 7803.sol-CappedToken-balanceOf(address)
digraph{
}
// Function: 7803.sol-CappedToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_132 = UnaryType.BANG mintingFinished 
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-CappedToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_125(mapping(address => uint256)) -> allowed[msg.sender]
REF_126(uint256) -> REF_125[_spender]
oldValue(uint256) := REF_126(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_113(bool) = _subtractedValue > oldValue
CONDITION TMP_113"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_127(mapping(address => uint256)) -> allowed[msg.sender]
REF_128(uint256) -> REF_127[_spender]
REF_128(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_129(mapping(address => uint256)) -> allowed[msg.sender]
REF_130(uint256) -> REF_129[_spender]
TMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_130(uint256) (->allowed) := TMP_114(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_132(mapping(address => uint256)) -> allowed[msg.sender]
REF_133(uint256) -> REF_132[_spender]
Emit Approval(msg.sender,_spender,REF_133)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-CappedToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 7803.sol-CappedToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_118(mapping(address => uint256)) -> allowed[msg.sender]
REF_119(uint256) -> REF_118[_spender]
REF_120(mapping(address => uint256)) -> allowed[msg.sender]
REF_121(uint256) -> REF_120[_spender]
TMP_111(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_121', '_addedValue'] 
REF_119(uint256) (->allowed) := TMP_111(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_123(mapping(address => uint256)) -> allowed[msg.sender]
REF_124(uint256) -> REF_123[_spender]
Emit Approval(msg.sender,_spender,REF_124)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-CappedToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(totalSupply_.add(_amount) <= cap)

IRs:
TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
TMP_127(bool) = TMP_126 <= cap
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.mint(_to,_amount)

IRs:
TMP_129(bool) = INTERNAL_CALL, MintableToken.mint(address,uint256)(_to,_amount)
RETURN TMP_129"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
4->1;
}
// Function: 7803.sol-CappedToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_134(bool) = msg.sender == owner
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-CappedToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
}
// Function: 7803.sol-CappedToken-totalSupply()
digraph{
}
// Function: 7803.sol-CappedToken-transfer(address,uint256)
digraph{
}
// Function: 7803.sol-CappedToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 7803.sol-CappedToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_94 = CONVERT 0 to address
TMP_95(bool) = newOwner != TMP_94
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7803.sol-CareerChainPrivateSale-CareerChainPrivateSale(uint256,uint256,uint256,address,uint256[6],uint256,uint256,CareerChainToken)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_lockupEndTime[0] >= block.timestamp)

IRs:
REF_235(uint256) -> _lockupEndTime[0]
TMP_375(bool) = REF_235 >= block.timestamp
TMP_376(None) = SOLIDITY_CALL require(bool)(TMP_375)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_lockupEndTime[1] >= _lockupEndTime[0])

IRs:
REF_236(uint256) -> _lockupEndTime[1]
REF_237(uint256) -> _lockupEndTime[0]
TMP_377(bool) = REF_236 >= REF_237
TMP_378(None) = SOLIDITY_CALL require(bool)(TMP_377)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_lockupEndTime[2] >= _lockupEndTime[1])

IRs:
REF_238(uint256) -> _lockupEndTime[2]
REF_239(uint256) -> _lockupEndTime[1]
TMP_379(bool) = REF_238 >= REF_239
TMP_380(None) = SOLIDITY_CALL require(bool)(TMP_379)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_lockupEndTime[3] >= _lockupEndTime[2])

IRs:
REF_240(uint256) -> _lockupEndTime[3]
REF_241(uint256) -> _lockupEndTime[2]
TMP_381(bool) = REF_240 >= REF_241
TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_lockupEndTime[4] >= _lockupEndTime[3])

IRs:
REF_242(uint256) -> _lockupEndTime[4]
REF_243(uint256) -> _lockupEndTime[3]
TMP_383(bool) = REF_242 >= REF_243
TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(_lockupEndTime[5] >= _lockupEndTime[4])

IRs:
REF_244(uint256) -> _lockupEndTime[5]
REF_245(uint256) -> _lockupEndTime[4]
TMP_385(bool) = REF_244 >= REF_245
TMP_386(None) = SOLIDITY_CALL require(bool)(TMP_385)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
lockupEndTime = _lockupEndTime

IRs:
lockupEndTime(uint256[6]) := _lockupEndTime(uint256[6])"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
firstVestedLockUpAmount = _firstVestedLockUpAmount

IRs:
firstVestedLockUpAmount(uint256) := _firstVestedLockUpAmount(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
stagedVestedLockUpAmounts = _stagedVestedLockUpAmounts

IRs:
stagedVestedLockUpAmounts(uint256) := _stagedVestedLockUpAmounts(uint256)"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Crowdsale(_rate,_wallet,_token)

IRs:
INTERNAL_CALL, Crowdsale.Crowdsale(uint256,address,ERC20)(_rate,_wallet,_token)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
TimedCrowdsale(_openingTime,_closingTime)

IRs:
INTERNAL_CALL, TimedCrowdsale.TimedCrowdsale(uint256,uint256)(_openingTime,_closingTime)"];
11->1;
}
// Function: 7803.sol-CareerChainPrivateSale-Crowdsale(uint256,address,ERC20)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_342(bool) = _rate > 0
TMP_343(None) = SOLIDITY_CALL require(bool)(TMP_342)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_344 = CONVERT 0 to address
TMP_345(bool) = _wallet != TMP_344
TMP_346(None) = SOLIDITY_CALL require(bool)(TMP_345)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_347 = CONVERT 0 to address
TMP_348(bool) = _token != TMP_347
TMP_349(None) = SOLIDITY_CALL require(bool)(TMP_348)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token = _token

IRs:
token(ERC20) := _token(ERC20)"];
}
// Function: 7803.sol-CareerChainPrivateSale-IssueTokensToInvestors(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_402 = CONVERT 0 to address
TMP_403(bool) = _beneficiary != TMP_402
TMP_404(None) = SOLIDITY_CALL require(bool)(TMP_403)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_processPurchase(_beneficiary,_amount)

IRs:
INTERNAL_CALL, CareerChainPrivateSale._processPurchase(address,uint256)(_beneficiary,_amount)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyWhileOpen()

IRs:
MODIFIER_CALL, TimedCrowdsale.onlyWhileOpen()()"];
4->1;
}
// Function: 7803.sol-CareerChainPrivateSale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7803.sol-CareerChainPrivateSale-TimedCrowdsale(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_openingTime >= block.timestamp)

IRs:
TMP_368(bool) = _openingTime >= block.timestamp
TMP_369(None) = SOLIDITY_CALL require(bool)(TMP_368)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_closingTime >= _openingTime)

IRs:
TMP_370(bool) = _closingTime >= _openingTime
TMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
openingTime = _openingTime

IRs:
openingTime(uint256) := _openingTime(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
closingTime = _closingTime

IRs:
closingTime(uint256) := _closingTime(uint256)"];
}
// Function: 7803.sol-CareerChainPrivateSale-TransferUnsoldTokensBackToTokenContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(hasClosed())

IRs:
TMP_395(bool) = INTERNAL_CALL, TimedCrowdsale.hasClosed()()
TMP_396(None) = SOLIDITY_CALL require(bool)(TMP_395)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
unSoldTokens = token.balanceOf(address(this)).sub(tokensStillInLockup)

IRs:
TMP_397 = CONVERT this to address
TMP_398(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_397']  
TMP_399(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_398', 'tokensStillInLockup'] 
unSoldTokens(uint256) := TMP_399(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
token.transfer(_beneficiary,unSoldTokens)

IRs:
TMP_400(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_beneficiary', 'unSoldTokens']  "];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7803.sol-CareerChainPrivateSale-_changeRate(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_408(bool) = _rate > 0
TMP_409(None) = SOLIDITY_CALL require(bool)(TMP_408)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 7803.sol-CareerChainPrivateSale-_deliverTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.transfer(_beneficiary,_tokenAmount)

IRs:
TMP_364(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_beneficiary', '_tokenAmount']  "];
}
// Function: 7803.sol-CareerChainPrivateSale-_forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 7803.sol-CareerChainPrivateSale-_getTokenAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_weiAmount.mul(rate)

IRs:
TMP_366(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_weiAmount', 'rate'] 
RETURN TMP_366"];
}
// Function: 7803.sol-CareerChainPrivateSale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-CareerChainPrivateSale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super._preValidatePurchase(_beneficiary,_weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,_weiAmount)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyWhileOpen()

IRs:
MODIFIER_CALL, TimedCrowdsale.onlyWhileOpen()()"];
2->1;
}
// Function: 7803.sol-CareerChainPrivateSale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
newTokensSold = tokensStillInLockup.add(_tokenAmount)

IRs:
TMP_389(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensStillInLockup', '_tokenAmount'] 
newTokensSold(uint256) := TMP_389(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(newTokensSold <= token.balanceOf(address(this)))

IRs:
TMP_390 = CONVERT this to address
TMP_391(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_390']  
TMP_392(bool) = newTokensSold <= TMP_391
TMP_393(None) = SOLIDITY_CALL require(bool)(TMP_392)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokensStillInLockup = newTokensSold

IRs:
tokensStillInLockup(uint256) := newTokensSold(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount)

IRs:
REF_248(uint256) -> balances[_beneficiary]
REF_249(uint256) -> balances[_beneficiary]
TMP_394(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_249', '_tokenAmount'] 
REF_248(uint256) (->balances) := TMP_394(uint256)"];
}
// Function: 7803.sol-CareerChainPrivateSale-_updatePurchasingState(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-CareerChainPrivateSale-addManyToWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_227 -> LENGTH _beneficiaries
TMP_331(bool) = i < REF_227
CONDITION TMP_331"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
whitelist[_beneficiaries[i]] = true

IRs:
REF_228(address) -> _beneficiaries[i]
REF_229(bool) -> whitelist[REF_228]
REF_229(bool) (->whitelist) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_332(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->3;
}
// Function: 7803.sol-CareerChainPrivateSale-addToWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = true

IRs:
REF_226(bool) -> whitelist[_beneficiary]
REF_226(bool) (->whitelist) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 7803.sol-CareerChainPrivateSale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, WhitelistedCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_352(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_352(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_353(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_353(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, CareerChainPrivateSale._processPurchase(address,uint256)(_beneficiary,tokens)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
}
// Function: 7803.sol-CareerChainPrivateSale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 7803.sol-CareerChainPrivateSale-hasClosed()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
block.timestamp > closingTime

IRs:
TMP_372(bool) = block.timestamp > closingTime
RETURN TMP_372"];
}
// Function: 7803.sol-CareerChainPrivateSale-isWhitelisted(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(whitelist[_beneficiary])

IRs:
REF_274(bool) -> whitelist[_beneficiary]
TMP_433(None) = SOLIDITY_CALL require(bool)(REF_274)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-CareerChainPrivateSale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_434(bool) = msg.sender == owner
TMP_435(None) = SOLIDITY_CALL require(bool)(TMP_434)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-CareerChainPrivateSale-onlyWhileOpen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp >= openingTime && block.timestamp <= closingTime)

IRs:
TMP_436(bool) = block.timestamp >= openingTime
TMP_437(bool) = block.timestamp <= closingTime
TMP_438(bool) = TMP_436 && TMP_437
TMP_439(None) = SOLIDITY_CALL require(bool)(TMP_438)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-CareerChainPrivateSale-releasableAmount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
vestedAmount().sub(released[msg.sender])

IRs:
TMP_411(uint256) = INTERNAL_CALL, CareerChainPrivateSale.vestedAmount()()
REF_255(uint256) -> released[msg.sender]
TMP_412(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_411', 'REF_255'] 
RETURN TMP_412"];
}
// Function: 7803.sol-CareerChainPrivateSale-removeFromWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = false

IRs:
REF_230(bool) -> whitelist[_beneficiary]
REF_230(bool) (->whitelist) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 7803.sol-CareerChainPrivateSale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_337 = CONVERT 0 to address
TMP_338(bool) = newOwner != TMP_337
TMP_339(None) = SOLIDITY_CALL require(bool)(TMP_338)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7803.sol-CareerChainPrivateSale-vestedAmount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
lockupStage = 0

IRs:
lockupStage(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
releasable = 0

IRs:
releasable(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: BEGIN_LOOP 4
"];
4->5;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < lockupEndTime.length && lockupEndTime[i] <= now

IRs:
REF_256 -> LENGTH lockupEndTime
TMP_413(bool) = i < REF_256
REF_257(uint256) -> lockupEndTime[i]
TMP_414(bool) = REF_257 <= now
TMP_415(bool) = TMP_413 && TMP_414
CONDITION TMP_415"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
lockupStage = lockupStage.add(1)

IRs:
TMP_416(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['lockupStage', '1'] 
lockupStage(uint256) := TMP_416(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i = i.add(1)

IRs:
TMP_417(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['i', '1'] 
i(uint256) := TMP_417(uint256)"];
7->5;
8[label="Node Type: END_LOOP 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
lockupStage > 0

IRs:
TMP_418(bool) = lockupStage > 0
CONDITION TMP_418"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
releasable = (lockupStage.sub(1).mul(stagedVestedLockUpAmounts)).add(firstVestedLockUpAmount)

IRs:
TMP_419(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['lockupStage', '1'] 
TMP_420(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_419', 'stagedVestedLockUpAmounts'] 
TMP_421(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_420', 'firstVestedLockUpAmount'] 
releasable(uint256) := TMP_421(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
releasable

IRs:
RETURN releasable"];
}
// Function: 7803.sol-CareerChainPrivateSale-withdrawTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tobeReleased = 0

IRs:
tobeReleased(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
unreleased = releasableAmount()

IRs:
TMP_422(uint256) = INTERNAL_CALL, CareerChainPrivateSale.releasableAmount()()
unreleased(uint256) := TMP_422(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
balances[msg.sender] >= unreleased && lockupEndTime[lockupEndTime.length - 1] > now

IRs:
REF_263(uint256) -> balances[msg.sender]
TMP_423(bool) = REF_263 >= unreleased
REF_264 -> LENGTH lockupEndTime
TMP_424(uint256) = REF_264 - 1
REF_265(uint256) -> lockupEndTime[TMP_424]
TMP_425(bool) = REF_265 > now
TMP_426(bool) = TMP_423 && TMP_425
CONDITION TMP_426"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tobeReleased = unreleased

IRs:
tobeReleased(uint256) := unreleased(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tobeReleased = balances[msg.sender]

IRs:
REF_266(uint256) -> balances[msg.sender]
tobeReleased(uint256) := REF_266(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(tobeReleased > 0)

IRs:
TMP_427(bool) = tobeReleased > 0
TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(tobeReleased)

IRs:
REF_267(uint256) -> balances[msg.sender]
REF_268(uint256) -> balances[msg.sender]
TMP_429(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_268', 'tobeReleased'] 
REF_267(uint256) (->balances) := TMP_429(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
tokensStillInLockup = tokensStillInLockup.sub(tobeReleased)

IRs:
TMP_430(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensStillInLockup', 'tobeReleased'] 
tokensStillInLockup(uint256) := TMP_430(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
released[msg.sender] = released[msg.sender].add(tobeReleased)

IRs:
REF_271(uint256) -> released[msg.sender]
REF_272(uint256) -> released[msg.sender]
TMP_431(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_272', 'tobeReleased'] 
REF_271(uint256) (->released) := TMP_431(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_deliverTokens(msg.sender,tobeReleased)

IRs:
INTERNAL_CALL, Crowdsale._deliverTokens(address,uint256)(msg.sender,tobeReleased)"];
}
// Function: 7803.sol-CareerChainToken-CappedToken(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_cap > 0)

IRs:
TMP_168(bool) = _cap > 0
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
cap = _cap

IRs:
cap(uint256) := _cap(uint256)"];
}
// Function: 7803.sol-CareerChainToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7803.sol-CareerChainToken-_burn(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_who])

IRs:
REF_156(uint256) -> balances[_who]
TMP_153(bool) = _value <= REF_156
TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_who] = balances[_who].sub(_value)

IRs:
REF_157(uint256) -> balances[_who]
REF_158(uint256) -> balances[_who]
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_158', '_value'] 
REF_157(uint256) (->balances) := TMP_155(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_156(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Burn(_who,_value)

IRs:
Emit Burn(_who,_value)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_who,address(0),_value)

IRs:
TMP_158 = CONVERT 0 to address
Emit Transfer(_who,TMP_158,_value)"];
}
// Function: 7803.sol-CareerChainToken-allowance(address,address)
digraph{
}
// Function: 7803.sol-CareerChainToken-approve(address,uint256)
digraph{
}
// Function: 7803.sol-CareerChainToken-balanceOf(address)
digraph{
}
// Function: 7803.sol-CareerChainToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_burn(msg.sender,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(msg.sender,_value)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 7803.sol-CareerChainToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_210 = UnaryType.BANG mintingFinished 
TMP_211(None) = SOLIDITY_CALL require(bool)(TMP_210)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-CareerChainToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_199(mapping(address => uint256)) -> allowed[msg.sender]
REF_200(uint256) -> REF_199[_spender]
oldValue(uint256) := REF_200(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_205(bool) = _subtractedValue > oldValue
CONDITION TMP_205"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_201(mapping(address => uint256)) -> allowed[msg.sender]
REF_202(uint256) -> REF_201[_spender]
REF_202(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_203(mapping(address => uint256)) -> allowed[msg.sender]
REF_204(uint256) -> REF_203[_spender]
TMP_206(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_204(uint256) (->allowed) := TMP_206(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_206(mapping(address => uint256)) -> allowed[msg.sender]
REF_207(uint256) -> REF_206[_spender]
Emit Approval(msg.sender,_spender,REF_207)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-CareerChainToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 7803.sol-CareerChainToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_192(mapping(address => uint256)) -> allowed[msg.sender]
REF_193(uint256) -> REF_192[_spender]
REF_194(mapping(address => uint256)) -> allowed[msg.sender]
REF_195(uint256) -> REF_194[_spender]
TMP_203(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_195', '_addedValue'] 
REF_193(uint256) (->allowed) := TMP_203(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_197(mapping(address => uint256)) -> allowed[msg.sender]
REF_198(uint256) -> REF_197[_spender]
Emit Approval(msg.sender,_spender,REF_198)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-CareerChainToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply_ = totalSupply_.add(_amount)

IRs:
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
totalSupply_(uint256) := TMP_176(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_171(uint256) -> balances[_to]
REF_172(uint256) -> balances[_to]
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_172', '_amount'] 
REF_171(uint256) (->balances) := TMP_177(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_179 = CONVERT 0 to address
Emit Transfer(TMP_179,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 7803.sol-CareerChainToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_212(bool) = msg.sender == owner
TMP_213(None) = SOLIDITY_CALL require(bool)(TMP_212)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-CareerChainToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
name = CareerChain Token

IRs:
name(string) := CareerChain Token(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
symbol = CCH

IRs:
symbol(string) := CCH(string)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
}
// Function: 7803.sol-CareerChainToken-totalSupply()
digraph{
}
// Function: 7803.sol-CareerChainToken-transfer(address,uint256)
digraph{
}
// Function: 7803.sol-CareerChainToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 7803.sol-CareerChainToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_186 = CONVERT 0 to address
TMP_187(bool) = newOwner != TMP_186
TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7803.sol-Crowdsale-Crowdsale(uint256,address,ERC20)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_226(bool) = _rate > 0
TMP_227(None) = SOLIDITY_CALL require(bool)(TMP_226)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_228 = CONVERT 0 to address
TMP_229(bool) = _wallet != TMP_228
TMP_230(None) = SOLIDITY_CALL require(bool)(TMP_229)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_231 = CONVERT 0 to address
TMP_232(bool) = _token != TMP_231
TMP_233(None) = SOLIDITY_CALL require(bool)(TMP_232)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token = _token

IRs:
token(ERC20) := _token(ERC20)"];
}
// Function: 7803.sol-Crowdsale-_deliverTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.transfer(_beneficiary,_tokenAmount)

IRs:
TMP_248(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_beneficiary', '_tokenAmount']  "];
}
// Function: 7803.sol-Crowdsale-_forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 7803.sol-Crowdsale-_getTokenAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_weiAmount.mul(rate)

IRs:
TMP_250(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_weiAmount', 'rate'] 
RETURN TMP_250"];
}
// Function: 7803.sol-Crowdsale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-Crowdsale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_243 = CONVERT 0 to address
TMP_244(bool) = _beneficiary != TMP_243
TMP_245(None) = SOLIDITY_CALL require(bool)(TMP_244)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_weiAmount != 0)

IRs:
TMP_246(bool) = _weiAmount != 0
TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246)"];
}
// Function: 7803.sol-Crowdsale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_deliverTokens(_beneficiary,_tokenAmount)

IRs:
INTERNAL_CALL, Crowdsale._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)"];
}
// Function: 7803.sol-Crowdsale-_updatePurchasingState(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-Crowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_236(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_236(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_237(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_237(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
}
// Function: 7803.sol-Crowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 7803.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 7803.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 7803.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 7803.sol-ERC20-totalSupply()
digraph{
}
// Function: 7803.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 7803.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 7803.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 7803.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 7803.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 7803.sol-MintableToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7803.sol-MintableToken-allowance(address,address)
digraph{
}
// Function: 7803.sol-MintableToken-approve(address,uint256)
digraph{
}
// Function: 7803.sol-MintableToken-balanceOf(address)
digraph{
}
// Function: 7803.sol-MintableToken-canMint()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_82 = UnaryType.BANG mintingFinished 
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-MintableToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_75(mapping(address => uint256)) -> allowed[msg.sender]
REF_76(uint256) -> REF_75[_spender]
oldValue(uint256) := REF_76(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_59(bool) = _subtractedValue > oldValue
CONDITION TMP_59"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_77(mapping(address => uint256)) -> allowed[msg.sender]
REF_78(uint256) -> REF_77[_spender]
REF_78(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
TMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_80(uint256) (->allowed) := TMP_60(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
Emit Approval(msg.sender,_spender,REF_83)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-MintableToken-finishMinting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MintFinished()

IRs:
Emit MintFinished()"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
5->1;
}
// Function: 7803.sol-MintableToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] 
REF_69(uint256) (->allowed) := TMP_57(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_73(mapping(address => uint256)) -> allowed[msg.sender]
REF_74(uint256) -> REF_73[_spender]
Emit Approval(msg.sender,_spender,REF_74)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-MintableToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply_ = totalSupply_.add(_amount)

IRs:
TMP_70(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
totalSupply_(uint256) := TMP_70(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_93(uint256) -> balances[_to]
REF_94(uint256) -> balances[_to]
TMP_71(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_94', '_amount'] 
REF_93(uint256) (->balances) := TMP_71(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_73 = CONVERT 0 to address
Emit Transfer(TMP_73,_to,_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()"];
7->1;
}
// Function: 7803.sol-MintableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_80(bool) = msg.sender == owner
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-MintableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
mintingFinished = false

IRs:
mintingFinished(bool) := False(bool)"];
}
// Function: 7803.sol-MintableToken-totalSupply()
digraph{
}
// Function: 7803.sol-MintableToken-transfer(address,uint256)
digraph{
}
// Function: 7803.sol-MintableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 7803.sol-MintableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_40 = CONVERT 0 to address
TMP_41(bool) = newOwner != TMP_40
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7803.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7803.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_13(bool) = msg.sender == owner
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_8 = CONVERT 0 to address
TMP_9(bool) = newOwner != TMP_8
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 7803.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_223(uint256) = a + b
c(uint256) := TMP_223(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_224(bool) = c >= a
TMP_225(None) = SOLIDITY_CALL assert(bool)(TMP_224)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 7803.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a / b

IRs:
TMP_219(uint256) = a / b
RETURN TMP_219"];
}
// Function: 7803.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_214(bool) = a == 0
CONDITION TMP_214"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_215(uint256) = a * b
c(uint256) := TMP_215(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_216(uint256) = c / a
TMP_217(bool) = TMP_216 == b
TMP_218(None) = SOLIDITY_CALL assert(bool)(TMP_217)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 7803.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_220(bool) = b <= a
TMP_221(None) = SOLIDITY_CALL assert(bool)(TMP_220)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_222(uint256) = a - b
RETURN TMP_222"];
}
// Function: 7803.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 7803.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 7803.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_37(bool) = _subtractedValue > oldValue
CONDITION TMP_37"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_38(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_35(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-StandardToken-totalSupply()
digraph{
}
// Function: 7803.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 7803.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_23 = CONVERT 0 to address
TMP_24(bool) = _to != TMP_23
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_26(bool) = _value <= REF_16
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_28(bool) = _value <= REF_18
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_30(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_31(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_32(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7803.sol-TimedCrowdsale-Crowdsale(uint256,address,ERC20)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_293(bool) = _rate > 0
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_295 = CONVERT 0 to address
TMP_296(bool) = _wallet != TMP_295
TMP_297(None) = SOLIDITY_CALL require(bool)(TMP_296)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_298 = CONVERT 0 to address
TMP_299(bool) = _token != TMP_298
TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token = _token

IRs:
token(ERC20) := _token(ERC20)"];
}
// Function: 7803.sol-TimedCrowdsale-TimedCrowdsale(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_openingTime >= block.timestamp)

IRs:
TMP_319(bool) = _openingTime >= block.timestamp
TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_closingTime >= _openingTime)

IRs:
TMP_321(bool) = _closingTime >= _openingTime
TMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
openingTime = _openingTime

IRs:
openingTime(uint256) := _openingTime(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
closingTime = _closingTime

IRs:
closingTime(uint256) := _closingTime(uint256)"];
}
// Function: 7803.sol-TimedCrowdsale-_deliverTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.transfer(_beneficiary,_tokenAmount)

IRs:
TMP_315(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_beneficiary', '_tokenAmount']  "];
}
// Function: 7803.sol-TimedCrowdsale-_forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 7803.sol-TimedCrowdsale-_getTokenAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_weiAmount.mul(rate)

IRs:
TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_weiAmount', 'rate'] 
RETURN TMP_317"];
}
// Function: 7803.sol-TimedCrowdsale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-TimedCrowdsale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super._preValidatePurchase(_beneficiary,_weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,_weiAmount)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyWhileOpen()

IRs:
MODIFIER_CALL, TimedCrowdsale.onlyWhileOpen()()"];
2->1;
}
// Function: 7803.sol-TimedCrowdsale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_deliverTokens(_beneficiary,_tokenAmount)

IRs:
INTERNAL_CALL, Crowdsale._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)"];
}
// Function: 7803.sol-TimedCrowdsale-_updatePurchasingState(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-TimedCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, TimedCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_303(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_303(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_304(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_304(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
}
// Function: 7803.sol-TimedCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 7803.sol-TimedCrowdsale-hasClosed()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
block.timestamp > closingTime

IRs:
TMP_323(bool) = block.timestamp > closingTime
RETURN TMP_323"];
}
// Function: 7803.sol-TimedCrowdsale-onlyWhileOpen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp >= openingTime && block.timestamp <= closingTime)

IRs:
TMP_326(bool) = block.timestamp >= openingTime
TMP_327(bool) = block.timestamp <= closingTime
TMP_328(bool) = TMP_326 && TMP_327
TMP_329(None) = SOLIDITY_CALL require(bool)(TMP_328)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-WhitelistedCrowdsale-Crowdsale(uint256,address,ERC20)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_rate > 0)

IRs:
TMP_257(bool) = _rate > 0
TMP_258(None) = SOLIDITY_CALL require(bool)(TMP_257)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_259 = CONVERT 0 to address
TMP_260(bool) = _wallet != TMP_259
TMP_261(None) = SOLIDITY_CALL require(bool)(TMP_260)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_262 = CONVERT 0 to address
TMP_263(bool) = _token != TMP_262
TMP_264(None) = SOLIDITY_CALL require(bool)(TMP_263)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rate = _rate

IRs:
rate(uint256) := _rate(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
token = _token

IRs:
token(ERC20) := _token(ERC20)"];
}
// Function: 7803.sol-WhitelistedCrowdsale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 7803.sol-WhitelistedCrowdsale-_deliverTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token.transfer(_beneficiary,_tokenAmount)

IRs:
TMP_279(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_beneficiary', '_tokenAmount']  "];
}
// Function: 7803.sol-WhitelistedCrowdsale-_forwardFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value"];
}
// Function: 7803.sol-WhitelistedCrowdsale-_getTokenAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_weiAmount.mul(rate)

IRs:
TMP_281(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_weiAmount', 'rate'] 
RETURN TMP_281"];
}
// Function: 7803.sol-WhitelistedCrowdsale-_postValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-WhitelistedCrowdsale-_preValidatePurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super._preValidatePurchase(_beneficiary,_weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,_weiAmount)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isWhitelisted(_beneficiary)

IRs:
MODIFIER_CALL, WhitelistedCrowdsale.isWhitelisted(address)(_beneficiary)"];
2->1;
}
// Function: 7803.sol-WhitelistedCrowdsale-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_deliverTokens(_beneficiary,_tokenAmount)

IRs:
INTERNAL_CALL, Crowdsale._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)"];
}
// Function: 7803.sol-WhitelistedCrowdsale-_updatePurchasingState(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 7803.sol-WhitelistedCrowdsale-addManyToWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_217 -> LENGTH _beneficiaries
TMP_284(bool) = i < REF_217
CONDITION TMP_284"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
whitelist[_beneficiaries[i]] = true

IRs:
REF_218(address) -> _beneficiaries[i]
REF_219(bool) -> whitelist[REF_218]
REF_219(bool) (->whitelist) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_285(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->3;
}
// Function: 7803.sol-WhitelistedCrowdsale-addToWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = true

IRs:
REF_216(bool) -> whitelist[_beneficiary]
REF_216(bool) (->whitelist) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 7803.sol-WhitelistedCrowdsale-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, WhitelistedCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_267(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_267(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_268(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_268(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)"];
}
// Function: 7803.sol-WhitelistedCrowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, Crowdsale.buyTokens(address)(msg.sender)"];
}
// Function: 7803.sol-WhitelistedCrowdsale-isWhitelisted(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(whitelist[_beneficiary])

IRs:
REF_221(bool) -> whitelist[_beneficiary]
TMP_292(None) = SOLIDITY_CALL require(bool)(REF_221)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-WhitelistedCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_290(bool) = msg.sender == owner
TMP_291(None) = SOLIDITY_CALL require(bool)(TMP_290)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7803.sol-WhitelistedCrowdsale-removeFromWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = false

IRs:
REF_220(bool) -> whitelist[_beneficiary]
REF_220(bool) (->whitelist) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 7803.sol-WhitelistedCrowdsale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_252 = CONVERT 0 to address
TMP_253(bool) = newOwner != TMP_252
TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
}
