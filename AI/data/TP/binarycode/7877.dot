digraph G {
// Function: 7877.sol-AddressExtension-isAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: INLINE ASM 1
"];
1->2;
2[label="Node Type: END INLINE ASM 2
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 7877.sol-AddressExtension-isValid(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
0 != _address

IRs:
TMP_0(bool) = 0 != _address
RETURN TMP_0"];
}
// Function: 7877.sol-AddressExtension-toBytes(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: INLINE ASM 1
"];
1->2;
2[label="Node Type: END INLINE ASM 2
"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
b

IRs:
RETURN b"];
}
// Function: 7877.sol-Authorizable-constructor(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
fstkAuthority = _fstkAuthority

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)"];
}
// Function: 7877.sol-Authorizable-onlyFsTKApproved(bytes32,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isApproved(hash,approveTime,approveToken))

IRs:
TMP_49(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isApproved, arguments:['hash', 'approveTime', 'approveToken']  
TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-Authorizable-onlyFsTKAuthorized()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isAuthorized(msg.sender,this,msg.data))

IRs:
TMP_47(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isAuthorized, arguments:['msg.sender', 'this', 'msg.data']  
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-Authorizable-setFsTKAuthority(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_fstkAuthority.validate() == _fstkAuthority.validate.selector)

IRs:
TMP_42(bytes4) = HIGH_LEVEL_CALL, dest:_fstkAuthority(FsTKAuthority), function:validate, arguments:[]  
REF_17(bytes4) (->None) := 1761736296(uint256)
TMP_43(bool) = TMP_42 == REF_17
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetFsTKAuthority(fstkAuthority = _fstkAuthority)

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)
Emit SetFsTKAuthority(fstkAuthority)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
3->1;
}
// Function: 7877.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 7877.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 7877.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 7877.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 7877.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 7877.sol-ERC20Like-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[owner].instruments[spender].allowance

IRs:
REF_22(FsTKToken.Account) -> accounts[owner]
REF_23(mapping(address => FsTKToken.Instrument)) -> REF_22.instruments
REF_24(FsTKToken.Instrument) -> REF_23[spender]
REF_25(uint256) -> REF_24.allowance
RETURN REF_25"];
}
// Function: 7877.sol-ERC20Like-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_43(FsTKToken.Account) -> accounts[msg.sender]
REF_44(mapping(address => FsTKToken.Instrument)) -> REF_43.instruments
REF_45(FsTKToken.Instrument) -> REF_44[spender]
spenderInstrument(FsTKToken.Instrument) := REF_45(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
erc20ApproveChecking

IRs:
CONDITION erc20ApproveChecking"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)((value == 0) || (spenderInstrument.allowance == 0))

IRs:
TMP_64(bool) = value == 0
REF_46(uint256) -> spenderInstrument.allowance
TMP_65(bool) = REF_46 == 0
TMP_66(bool) = TMP_64 || TMP_65
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = value)

IRs:
REF_47(uint256) -> spenderInstrument.allowance
REF_47(uint256) (->spenderInstrument) := value(uint256)
Emit Approval(msg.sender,spender,REF_47)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7877.sol-ERC20Like-approve(address,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_48(FsTKToken.Account) -> accounts[msg.sender]
REF_49(mapping(address => FsTKToken.Instrument)) -> REF_48.instruments
REF_50(FsTKToken.Instrument) -> REF_49[spender]
spenderInstrument(FsTKToken.Instrument) := REF_50(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(spenderInstrument.allowance == expectedValue)

IRs:
REF_51(uint256) -> spenderInstrument.allowance
TMP_70(bool) = REF_51 == expectedValue
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = newValue)

IRs:
REF_52(uint256) -> spenderInstrument.allowance
REF_52(uint256) (->spenderInstrument) := newValue(uint256)
Emit Approval(msg.sender,spender,REF_52)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7877.sol-ERC20Like-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[owner].balance

IRs:
REF_20(FsTKToken.Account) -> accounts[owner]
REF_21(uint256) -> REF_20.balance
RETURN REF_21"];
}
// Function: 7877.sol-ERC20Like-canDelegate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDelegateEnable)

IRs:
TMP_159(None) = SOLIDITY_CALL require(bool)(isDelegateEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-ERC20Like-canUseDirectDebit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDirectDebitEnable)

IRs:
TMP_158(None) = SOLIDITY_CALL require(bool)(isDirectDebitEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-ERC20Like-constructor(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
metadata = _metadata

IRs:
metadata(string) := _metadata(string)"];
}
// Function: 7877.sol-ERC20Like-decreaseAllowance(address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_59(FsTKToken.Account) -> accounts[msg.sender]
REF_60(mapping(address => FsTKToken.Instrument)) -> REF_59.instruments
REF_61(FsTKToken.Instrument) -> REF_60[spender]
spenderInstrument(FsTKToken.Instrument) := REF_61(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
currentValue = spenderInstrument.allowance

IRs:
REF_62(uint256) -> spenderInstrument.allowance
currentValue(uint256) := REF_62(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
strict

IRs:
CONDITION strict"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
newValue = currentValue.sub(value)

IRs:
TMP_75(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['currentValue', 'value'] 
newValue(uint256) := TMP_75(uint256)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
value < currentValue

IRs:
TMP_76(bool) = value < currentValue
CONDITION TMP_76"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
newValue = currentValue - value

IRs:
TMP_77(uint256) = currentValue - value
newValue(uint256) := TMP_77(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = newValue)

IRs:
REF_64(uint256) -> spenderInstrument.allowance
REF_64(uint256) (->spenderInstrument) := newValue(uint256)
Emit Approval(msg.sender,spender,REF_64)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7877.sol-ERC20Like-delegateTransferAndCall(uint256,uint256,address,uint256,bytes,address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->17;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
signer = ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(abi.encodePacked(nonce,fee,to,value,data,delegator)),v,r,s)

IRs:
TMP_103(bytes) = SOLIDITY_CALL abi.encodePacked()(nonce,fee,to,value,data,delegator)
TMP_104(bytes32) = SOLIDITY_CALL keccak256()(TMP_103)
TMP_105(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_104,v,r,s)
signer(address) := TMP_105(address)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
signerAccount = accounts[signer]

IRs:
REF_89(FsTKToken.Account) -> accounts[signer]
signerAccount(FsTKToken.Account) := REF_89(FsTKToken.Account)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(nonce == signerAccount.nonce && (delegator == address(0) || delegator == msg.sender))

IRs:
REF_90(uint256) -> signerAccount.nonce
TMP_106(bool) = nonce == REF_90
TMP_107 = CONVERT 0 to address
TMP_108(bool) = delegator == TMP_107
TMP_109(bool) = delegator == msg.sender
TMP_110(bool) = TMP_108 || TMP_109
TMP_111(bool) = TMP_106 && TMP_110
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
IncreaseNonce(signer,signerAccount.nonce += 1)

IRs:
REF_91(uint256) -> signerAccount.nonce
REF_91(-> signerAccount) = REF_91 + 1
Emit IncreaseNonce(signer,REF_91)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
signerAccount.balance = signerAccount.balance.sub(value.add(fee))

IRs:
REF_92(uint256) -> signerAccount.balance
REF_93(uint256) -> signerAccount.balance
TMP_114(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['value', 'fee'] 
TMP_115(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_93', 'TMP_114'] 
REF_92(uint256) (->signerAccount) := TMP_115(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
accounts[to].balance += value

IRs:
REF_96(FsTKToken.Account) -> accounts[to]
REF_97(uint256) -> REF_96.balance
REF_97(-> accounts) = REF_97 + value"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(signer,to,value)

IRs:
Emit Transfer(signer,to,value)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
accounts[msg.sender].balance += fee

IRs:
REF_98(FsTKToken.Account) -> accounts[msg.sender]
REF_99(uint256) -> REF_98.balance
REF_99(-> accounts) = REF_99 + fee"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(signer,msg.sender,fee)

IRs:
Emit Transfer(signer,msg.sender,fee)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
! to.isAccount()

IRs:
TMP_118(bool) = LIBRARY_CALL, dest:AddressExtension, function:AddressExtension.isAccount(address), arguments:['to'] 
TMP_119 = UnaryType.BANG TMP_118 
CONDITION TMP_119"];
10->11[label="True"];
10->15[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(data.length >= 68)

IRs:
REF_101 -> LENGTH data
TMP_120(bool) = REF_101 >= 68
TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)"];
11->12;
12[label="Node Type: INLINE ASM 12
"];
12->13;
13[label="Node Type: END INLINE ASM 13
"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(to.call(data))

IRs:
TMP_122(bool) = LOW_LEVEL_CALL, dest:to, function:call, arguments:['data']  
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
canDelegate()

IRs:
MODIFIER_CALL, ERC20Like.canDelegate()()"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
notThis(to)

IRs:
MODIFIER_CALL, ERC20Like.notThis(address)(to)"];
19->1;
}
// Function: 7877.sol-ERC20Like-directDebit(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[debtor].instruments[receiver].directDebit

IRs:
REF_103(FsTKToken.Account) -> accounts[debtor]
REF_104(mapping(address => FsTKToken.Instrument)) -> REF_103.instruments
REF_105(FsTKToken.Instrument) -> REF_104[receiver]
REF_106(FsTKToken.DirectDebit) -> REF_105.directDebit
RETURN REF_106"];
}
// Function: 7877.sol-ERC20Like-increaseAllowance(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
spenderInstrument = accounts[msg.sender].instruments[spender]

IRs:
REF_53(FsTKToken.Account) -> accounts[msg.sender]
REF_54(mapping(address => FsTKToken.Instrument)) -> REF_53.instruments
REF_55(FsTKToken.Instrument) -> REF_54[spender]
spenderInstrument(FsTKToken.Instrument) := REF_55(FsTKToken.Instrument)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,spenderInstrument.allowance = spenderInstrument.allowance.add(value))

IRs:
REF_56(uint256) -> spenderInstrument.allowance
REF_57(uint256) -> spenderInstrument.allowance
TMP_73(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['REF_57', 'value'] 
REF_56(uint256) (->spenderInstrument) := TMP_73(uint256)
Emit Approval(msg.sender,spender,REF_56)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7877.sol-ERC20Like-increaseNonce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
IncreaseNonce(msg.sender,accounts[msg.sender].nonce += 1)

IRs:
REF_86(FsTKToken.Account) -> accounts[msg.sender]
REF_87(uint256) -> REF_86.nonce
REF_87(-> accounts) = REF_87 + 1
Emit IncreaseNonce(msg.sender,REF_87)"];
}
// Function: 7877.sol-ERC20Like-liquid()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLiquid)

IRs:
TMP_157(None) = SOLIDITY_CALL require(bool)(isLiquid)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-ERC20Like-nonceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[owner].nonce

IRs:
REF_84(FsTKToken.Account) -> accounts[owner]
REF_85(uint256) -> REF_84.nonce
RETURN REF_85"];
}
// Function: 7877.sol-ERC20Like-notThis(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != address(this))

IRs:
TMP_160 = CONVERT this to address
TMP_161(bool) = _address != TMP_160
TMP_162(None) = SOLIDITY_CALL require(bool)(TMP_161)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-ERC20Like-setDelegate(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetDelegate(isDelegateEnable = delegate)

IRs:
isDelegateEnable(bool) := delegate(bool)
Emit SetDelegate(isDelegateEnable)"];
}
// Function: 7877.sol-ERC20Like-setDirectDebit(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetDirectDebit(isDirectDebitEnable = directDebit)

IRs:
isDirectDebitEnable(bool) := directDebit(bool)
Emit SetDirectDebit(isDirectDebitEnable)"];
}
// Function: 7877.sol-ERC20Like-setERC20ApproveChecking(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetERC20ApproveChecking(erc20ApproveChecking = approveChecking)

IRs:
erc20ApproveChecking(bool) := approveChecking(bool)
Emit SetERC20ApproveChecking(erc20ApproveChecking)"];
}
// Function: 7877.sol-ERC20Like-setLiquid0(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetLiquid(isLiquid = liquidity)

IRs:
isLiquid(bool) := liquidity(bool)
Emit SetLiquid(isLiquid)"];
}
// Function: 7877.sol-ERC20Like-setMetadata0(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetMetadata(metadata = _metadata)

IRs:
metadata(string) := _metadata(string)
Emit SetMetadata(metadata)"];
}
// Function: 7877.sol-ERC20Like-setupDirectDebit(address,FsTKToken.DirectDebitInfo)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({info:info,epoch:0})

IRs:
REF_107(FsTKToken.Account) -> accounts[msg.sender]
REF_108(mapping(address => FsTKToken.Instrument)) -> REF_107.instruments
REF_109(FsTKToken.Instrument) -> REF_108[receiver]
REF_110(FsTKToken.DirectDebit) -> REF_109.directDebit
TMP_127(FsTKToken.DirectDebit) = new DirectDebit(info,0)
REF_110(FsTKToken.DirectDebit) (->accounts) := TMP_127(FsTKToken.DirectDebit)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetupDirectDebit(msg.sender,receiver,info)

IRs:
Emit SetupDirectDebit(msg.sender,receiver,info)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7877.sol-ERC20Like-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isLiquid = true

IRs:
isLiquid(bool) := True(bool)"];
}
// Function: 7877.sol-ERC20Like-spendableAllowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
ownerAccount = accounts[owner]

IRs:
REF_65(FsTKToken.Account) -> accounts[owner]
ownerAccount(FsTKToken.Account) := REF_65(FsTKToken.Account)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
Math.min(ownerAccount.instruments[spender].allowance,ownerAccount.balance)

IRs:
REF_67(mapping(address => FsTKToken.Instrument)) -> ownerAccount.instruments
REF_68(FsTKToken.Instrument) -> REF_67[spender]
REF_69(uint256) -> REF_68.allowance
REF_70(uint256) -> ownerAccount.balance
TMP_83(uint256) = LIBRARY_CALL, dest:Math, function:Math.min(uint256,uint256), arguments:['REF_69', 'REF_70'] 
RETURN TMP_83"];
}
// Function: 7877.sol-ERC20Like-terminateDirectDebit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
delete accounts[msg.sender].instruments[receiver].directDebit

IRs:
REF_111(FsTKToken.Account) -> accounts[msg.sender]
REF_112(mapping(address => FsTKToken.Instrument)) -> REF_111.instruments
REF_113(FsTKToken.Instrument) -> REF_112[receiver]
REF_114(FsTKToken.DirectDebit) -> REF_113.directDebit
REF_113 = delete REF_114 "];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
TerminateDirectDebit(msg.sender,receiver)

IRs:
Emit TerminateDirectDebit(msg.sender,receiver)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 7877.sol-ERC20Like-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
senderAccount = accounts[msg.sender]

IRs:
REF_26(FsTKToken.Account) -> accounts[msg.sender]
senderAccount(FsTKToken.Account) := REF_26(FsTKToken.Account)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
senderAccount.balance = senderAccount.balance.sub(value)

IRs:
REF_27(uint256) -> senderAccount.balance
REF_28(uint256) -> senderAccount.balance
TMP_57(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_28', 'value'] 
REF_27(uint256) (->senderAccount) := TMP_57(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
accounts[to].balance += value

IRs:
REF_30(FsTKToken.Account) -> accounts[to]
REF_31(uint256) -> REF_30.balance
REF_31(-> accounts) = REF_31 + value"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
6->1;
}
// Function: 7877.sol-ERC20Like-transfer(uint256[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->15;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
senderAccount = accounts[msg.sender]

IRs:
REF_71(FsTKToken.Account) -> accounts[msg.sender]
senderAccount(FsTKToken.Account) := REF_71(FsTKToken.Account)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->13;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < data.length

IRs:
REF_72 -> LENGTH data
TMP_84(bool) = i < REF_72
CONDITION TMP_84"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
receiver = address(data[i] >> 96)

IRs:
REF_73(uint256) -> data[i]
TMP_85(uint256) = REF_73 >> 96
TMP_86 = CONVERT TMP_85 to address
receiver(address) := TMP_86(address)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
value = data[i] & 0xffffffffffffffffffffffff

IRs:
REF_74(uint256) -> data[i]
TMP_87(uint256) = REF_74 & 79228162514264337593543950335
value(uint256) := TMP_87(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
totalValue = totalValue.add(value)

IRs:
TMP_88(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['totalValue', 'value'] 
totalValue(uint256) := TMP_88(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
accounts[receiver].balance += value

IRs:
REF_76(FsTKToken.Account) -> accounts[receiver]
REF_77(uint256) -> REF_76.balance
REF_77(-> accounts) = REF_77 + value"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Transfer(msg.sender,receiver,value)

IRs:
Emit Transfer(msg.sender,receiver,value)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_90(uint256) := i(uint256)
i(uint256) = i + 1"];
12->6;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
senderAccount.balance = senderAccount.balance.sub(totalValue)

IRs:
REF_78(uint256) -> senderAccount.balance
REF_79(uint256) -> senderAccount.balance
TMP_91(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_79', 'totalValue'] 
REF_78(uint256) (->senderAccount) := TMP_91(uint256)"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
true

IRs:
RETURN True"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
15->1;
}
// Function: 7877.sol-ERC20Like-transferAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(transfer(to,value) && data.length >= 68)

IRs:
TMP_93(bool) = INTERNAL_CALL, ERC20Like.transfer(address,uint256)(to,value)
REF_81 -> LENGTH data
TMP_94(bool) = REF_81 >= 68
TMP_95(bool) = TMP_93 && TMP_94
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(to.call.value(msg.value)(data))

IRs:
TMP_98(bool) = LOW_LEVEL_CALL, dest:to, function:call, arguments:['data'] value:msg.value 
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notThis(to)

IRs:
MODIFIER_CALL, ERC20Like.notThis(address)(to)"];
7->1;
}
// Function: 7877.sol-ERC20Like-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
fromAccount = accounts[from]

IRs:
REF_32(FsTKToken.Account) -> accounts[from]
fromAccount(FsTKToken.Account) := REF_32(FsTKToken.Account)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
senderInstrument = fromAccount.instruments[msg.sender]

IRs:
REF_33(mapping(address => FsTKToken.Instrument)) -> fromAccount.instruments
REF_34(FsTKToken.Instrument) -> REF_33[msg.sender]
senderInstrument(FsTKToken.Instrument) := REF_34(FsTKToken.Instrument)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
fromAccount.balance = fromAccount.balance.sub(value)

IRs:
REF_35(uint256) -> fromAccount.balance
REF_36(uint256) -> fromAccount.balance
TMP_60(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_36', 'value'] 
REF_35(uint256) (->fromAccount) := TMP_60(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
senderInstrument.allowance = senderInstrument.allowance.sub(value)

IRs:
REF_38(uint256) -> senderInstrument.allowance
REF_39(uint256) -> senderInstrument.allowance
TMP_61(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_39', 'value'] 
REF_38(uint256) (->senderInstrument) := TMP_61(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
accounts[to].balance += value

IRs:
REF_41(FsTKToken.Account) -> accounts[to]
REF_42(uint256) -> REF_41.balance
REF_42(-> accounts) = REF_42 + value"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
8->1;
}
// Function: 7877.sol-ERC20Like-withdrawDirectDebit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
debtorAccount = accounts[debtor]

IRs:
REF_115(FsTKToken.Account) -> accounts[debtor]
debtorAccount(FsTKToken.Account) := REF_115(FsTKToken.Account)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
debit = debtorAccount.instruments[msg.sender].directDebit

IRs:
REF_116(mapping(address => FsTKToken.Instrument)) -> debtorAccount.instruments
REF_117(FsTKToken.Instrument) -> REF_116[msg.sender]
REF_118(FsTKToken.DirectDebit) -> REF_117.directDebit
debit(FsTKToken.DirectDebit) := REF_118(FsTKToken.DirectDebit)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1)

IRs:
REF_120(FsTKToken.DirectDebitInfo) -> debit.info
REF_121(uint256) -> REF_120.startTime
TMP_130(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['block.timestamp', 'REF_121'] 
REF_122(FsTKToken.DirectDebitInfo) -> debit.info
REF_123(uint256) -> REF_122.interval
TMP_131(uint256) = TMP_130 / REF_123
TMP_132(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_131', '1'] 
epoch(uint256) := TMP_132(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
amount = epoch.sub(debit.epoch).mul(debit.info.amount)

IRs:
REF_126(uint256) -> debit.epoch
TMP_133(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['epoch', 'REF_126'] 
REF_128(FsTKToken.DirectDebitInfo) -> debit.info
REF_129(uint256) -> REF_128.amount
TMP_134(uint256) = LIBRARY_CALL, dest:Math, function:Math.mul(uint256,uint256), arguments:['TMP_133', 'REF_129'] 
amount(uint256) := TMP_134(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_135(bool) = amount > 0
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
debtorAccount.balance = debtorAccount.balance.sub(amount)

IRs:
REF_130(uint256) -> debtorAccount.balance
REF_131(uint256) -> debtorAccount.balance
TMP_137(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['REF_131', 'amount'] 
REF_130(uint256) (->debtorAccount) := TMP_137(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
accounts[msg.sender].balance += amount

IRs:
REF_133(FsTKToken.Account) -> accounts[msg.sender]
REF_134(uint256) -> REF_133.balance
REF_134(-> accounts) = REF_134 + amount"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
debit.epoch = epoch

IRs:
REF_135(uint256) -> debit.epoch
REF_135(uint256) (->debit) := epoch(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
Transfer(debtor,msg.sender,amount)

IRs:
Emit Transfer(debtor,msg.sender,amount)"];
9->10;
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
canUseDirectDebit()

IRs:
MODIFIER_CALL, ERC20Like.canUseDirectDebit()()"];
12->1;
}
// Function: 7877.sol-ERC20Like-withdrawDirectDebit(address[],bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->28;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
receiverAccount = accounts[msg.sender]

IRs:
REF_136(FsTKToken.Account) -> accounts[msg.sender]
receiverAccount(FsTKToken.Account) := REF_136(FsTKToken.Account)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
result = true

IRs:
result(bool) := True(bool)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->27;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < debtors.length

IRs:
REF_137 -> LENGTH debtors
TMP_141(bool) = i < REF_137
CONDITION TMP_141"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
debtor = debtors[i]

IRs:
REF_138(address) -> debtors[i]
debtor(address) := REF_138(address)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
debtorAccount = accounts[debtor]

IRs:
REF_139(FsTKToken.Account) -> accounts[debtor]
debtorAccount(FsTKToken.Account) := REF_139(FsTKToken.Account)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
debit = debtorAccount.instruments[msg.sender].directDebit

IRs:
REF_140(mapping(address => FsTKToken.Instrument)) -> debtorAccount.instruments
REF_141(FsTKToken.Instrument) -> REF_140[msg.sender]
REF_142(FsTKToken.DirectDebit) -> REF_141.directDebit
debit(FsTKToken.DirectDebit) := REF_142(FsTKToken.DirectDebit)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1)

IRs:
REF_144(FsTKToken.DirectDebitInfo) -> debit.info
REF_145(uint256) -> REF_144.startTime
TMP_142(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['block.timestamp', 'REF_145'] 
REF_146(FsTKToken.DirectDebitInfo) -> debit.info
REF_147(uint256) -> REF_146.interval
TMP_143(uint256) = TMP_142 / REF_147
TMP_144(uint256) = LIBRARY_CALL, dest:Math, function:Math.add(uint256,uint256), arguments:['TMP_143', '1'] 
epoch(uint256) := TMP_144(uint256)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
amount = epoch.sub(debit.epoch).mul(debit.info.amount)

IRs:
REF_150(uint256) -> debit.epoch
TMP_145(uint256) = LIBRARY_CALL, dest:Math, function:Math.sub(uint256,uint256), arguments:['epoch', 'REF_150'] 
REF_152(FsTKToken.DirectDebitInfo) -> debit.info
REF_153(uint256) -> REF_152.amount
TMP_146(uint256) = LIBRARY_CALL, dest:Math, function:Math.mul(uint256,uint256), arguments:['TMP_145', 'REF_153'] 
amount(uint256) := TMP_146(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_147(bool) = amount > 0
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
debtorBalance = debtorAccount.balance

IRs:
REF_154(uint256) -> debtorAccount.balance
debtorBalance(uint256) := REF_154(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
amount > debtorBalance

IRs:
TMP_149(bool) = amount > debtorBalance
CONDITION TMP_149"];
15->16[label="True"];
15->21[label="False"];
16[label="Node Type: IF 16

EXPRESSION:
strict

IRs:
CONDITION strict"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
revert()()

IRs:
TMP_150(None) = SOLIDITY_CALL revert()()"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
result = false

IRs:
result(bool) := False(bool)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
WithdrawDirectDebitFailure(debtor,msg.sender)

IRs:
Emit WithdrawDirectDebitFailure(debtor,msg.sender)"];
20->25;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
debtorAccount.balance = debtorBalance - amount

IRs:
REF_155(uint256) -> debtorAccount.balance
TMP_152(uint256) = debtorBalance - amount
REF_155(uint256) (->debtorAccount) := TMP_152(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
total += amount

IRs:
total(uint256) = total + amount"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
debit.epoch = epoch

IRs:
REF_156(uint256) -> debit.epoch
REF_156(uint256) (->debit) := epoch(uint256)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
Transfer(debtor,msg.sender,amount)

IRs:
Emit Transfer(debtor,msg.sender,amount)"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
i ++

IRs:
TMP_154(uint256) := i(uint256)
i(uint256) = i + 1"];
26->7;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
receiverAccount.balance += total

IRs:
REF_157(uint256) -> receiverAccount.balance
REF_157(-> receiverAccount) = REF_157 + total"];
27->30;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
liquid()

IRs:
MODIFIER_CALL, ERC20Like.liquid()()"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
canUseDirectDebit()

IRs:
MODIFIER_CALL, ERC20Like.canUseDirectDebit()()"];
29->1;
30[label="Node Type: RETURN 30

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 7877.sol-FsTKAuthority-isApproved(bytes32,uint256,bytes)
digraph{
}
// Function: 7877.sol-FsTKAuthority-isAuthorized(address,address,bytes)
digraph{
}
// Function: 7877.sol-FsTKAuthority-validate()
digraph{
}
// Function: 7877.sol-FsTKToken-delegateTransferAndCall(uint256,uint256,address,uint256,bytes,address,uint8,bytes32,bytes32)
digraph{
}
// Function: 7877.sol-FsTKToken-directDebit(address,address)
digraph{
}
// Function: 7877.sol-FsTKToken-increaseNonce()
digraph{
}
// Function: 7877.sol-FsTKToken-nonceOf(address)
digraph{
}
// Function: 7877.sol-FsTKToken-setupDirectDebit(address,FsTKToken.DirectDebitInfo)
digraph{
}
// Function: 7877.sol-FsTKToken-spendableAllowance(address,address)
digraph{
}
// Function: 7877.sol-FsTKToken-terminateDirectDebit(address)
digraph{
}
// Function: 7877.sol-FsTKToken-transfer(uint256[])
digraph{
}
// Function: 7877.sol-FsTKToken-transferAndCall(address,uint256,bytes)
digraph{
}
// Function: 7877.sol-FsTKToken-withdrawDirectDebit(address)
digraph{
}
// Function: 7877.sol-FsTKToken-withdrawDirectDebit(address[],bool)
digraph{
}
// Function: 7877.sol-IssuerContract-confirmSetIssuer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newIssuer == msg.sender)

IRs:
TMP_52(bool) = newIssuer == msg.sender
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetIssuer(issuer = newIssuer)

IRs:
issuer(address) := newIssuer(address)
Emit SetIssuer(issuer)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete newIssuer

IRs:
newIssuer = delete newIssuer "];
}
// Function: 7877.sol-IssuerContract-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
issuer = _issuer

IRs:
issuer(address) := _issuer(address)"];
}
// Function: 7877.sol-IssuerContract-onlyIssuer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(issuer == msg.sender)

IRs:
TMP_55(bool) = issuer == msg.sender
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-IssuerContract-setIssuer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newIssuer = _address

IRs:
newIssuer(address) := _address(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyIssuer()

IRs:
MODIFIER_CALL, IssuerContract.onlyIssuer()()"];
2->1;
}
// Function: 7877.sol-Math-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((r = a + b) >= a)

IRs:
TMP_14(uint256) = a + b
r(uint256) := TMP_14(uint256)
TMP_15(bool) = r >= a
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-Math-div(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDiv(x,f.denominator,f.numerator)

IRs:
REF_6(uint256) -> f.denominator
REF_7(uint256) -> f.numerator
TMP_37(uint256) = INTERNAL_CALL, Math.mulDiv(uint256,uint256,uint256)(x,REF_6,REF_7)
RETURN TMP_37"];
}
// Function: 7877.sol-Math-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = a / b

IRs:
TMP_10(uint256) = a / b
r(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-Math-divCeil(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDivCeil(x,f.denominator,f.numerator)

IRs:
REF_8(uint256) -> f.denominator
REF_9(uint256) -> f.numerator
TMP_38(uint256) = INTERNAL_CALL, Math.mulDivCeil(uint256,uint256,uint256)(x,REF_8,REF_9)
RETURN TMP_38"];
}
// Function: 7877.sol-Math-isPositive(Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
fraction.numerator > 0 && fraction.denominator > 0

IRs:
REF_0(uint256) -> fraction.numerator
TMP_1(bool) = REF_0 > 0
REF_1(uint256) -> fraction.denominator
TMP_2(bool) = REF_1 > 0
TMP_3(bool) = TMP_1 && TMP_2
RETURN TMP_3"];
}
// Function: 7877.sol-Math-max(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_18(bool) = x >= y
CONDITION TMP_18"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-Math-min(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_17(bool) = x <= y
CONDITION TMP_17"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-Math-mul(Math.Fraction,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
Math.Fraction({numerator:mul(x.numerator,y.numerator),denominator:mul(x.denominator,y.denominator)})

IRs:
REF_11(uint256) -> x.numerator
REF_12(uint256) -> y.numerator
TMP_39(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(REF_11,REF_12)
REF_13(uint256) -> x.denominator
REF_14(uint256) -> y.denominator
TMP_40(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(REF_13,REF_14)
TMP_41(Math.Fraction) = new Fraction(TMP_39,TMP_40)
RETURN TMP_41"];
}
// Function: 7877.sol-Math-mul(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDiv(x,f.numerator,f.denominator)

IRs:
REF_2(uint256) -> f.numerator
REF_3(uint256) -> f.denominator
TMP_35(uint256) = INTERNAL_CALL, Math.mulDiv(uint256,uint256,uint256)(x,REF_2,REF_3)
RETURN TMP_35"];
}
// Function: 7877.sol-Math-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = a * b

IRs:
TMP_4(uint256) = a * b
r(uint256) := TMP_4(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)((a == 0) || (r / a == b))

IRs:
TMP_5(bool) = a == 0
TMP_6(uint256) = r / a
TMP_7(bool) = TMP_6 == b
TMP_8(bool) = TMP_5 || TMP_7
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-Math-mulCeil(uint256,Math.Fraction)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mulDivCeil(x,f.numerator,f.denominator)

IRs:
REF_4(uint256) -> f.numerator
REF_5(uint256) -> f.denominator
TMP_36(uint256) = INTERNAL_CALL, Math.mulDivCeil(uint256,uint256,uint256)(x,REF_4,REF_5)
RETURN TMP_36"];
}
// Function: 7877.sol-Math-mulDiv(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = value * m

IRs:
TMP_19(uint256) = value * m
r(uint256) := TMP_19(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
r / value == m

IRs:
TMP_20(uint256) = r / value
TMP_21(bool) = TMP_20 == m
CONDITION TMP_21"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
r /= d

IRs:
r(uint256) = r / d"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
r = mul(value / d,m)

IRs:
TMP_22(uint256) = value / d
TMP_23(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(TMP_22,m)
r(uint256) := TMP_23(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-Math-mulDivCeil(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
r = value * m

IRs:
TMP_24(uint256) = value * m
r(uint256) := TMP_24(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
r / value == m

IRs:
TMP_25(uint256) = r / value
TMP_26(bool) = TMP_25 == m
CONDITION TMP_26"];
2->3[label="True"];
2->7[label="False"];
3[label="Node Type: IF 3

EXPRESSION:
r % d == 0

IRs:
TMP_27(uint256) = r % d
TMP_28(bool) = TMP_27 == 0
CONDITION TMP_28"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
r /= d

IRs:
r(uint256) = r / d"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
r = (r / d) + 1

IRs:
TMP_29(uint256) = r / d
TMP_30(uint256) = TMP_29 + 1
r(uint256) := TMP_30(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->11;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
r = mul(value / d,m)

IRs:
TMP_31(uint256) = value / d
TMP_32(uint256) = INTERNAL_CALL, Math.mul(uint256,uint256)(TMP_31,m)
r(uint256) := TMP_32(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
value % d != 0

IRs:
TMP_33(uint256) = value % d
TMP_34(bool) = TMP_33 != 0
CONDITION TMP_34"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
r += 1

IRs:
r(uint256) = r + 1"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-Math-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((r = a - b) <= a)

IRs:
TMP_11(uint256) = a - b
r(uint256) := TMP_11(uint256)
TMP_12(bool) = r <= a
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r"];
}
// Function: 7877.sol-SecureERC20-allowance(address,address)
digraph{
}
// Function: 7877.sol-SecureERC20-approve(address,uint256)
digraph{
}
// Function: 7877.sol-SecureERC20-approve(address,uint256,uint256)
digraph{
}
// Function: 7877.sol-SecureERC20-balanceOf(address)
digraph{
}
// Function: 7877.sol-SecureERC20-decreaseAllowance(address,uint256,bool)
digraph{
}
// Function: 7877.sol-SecureERC20-increaseAllowance(address,uint256)
digraph{
}
// Function: 7877.sol-SecureERC20-setERC20ApproveChecking(bool)
digraph{
}
// Function: 7877.sol-SecureERC20-transfer(address,uint256)
digraph{
}
// Function: 7877.sol-SecureERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 7877.sol-SmartToken-allowance(address,address)
digraph{
}
// Function: 7877.sol-SmartToken-approve(address,uint256)
digraph{
}
// Function: 7877.sol-SmartToken-approve(address,uint256,uint256)
digraph{
}
// Function: 7877.sol-SmartToken-balanceOf(address)
digraph{
}
// Function: 7877.sol-SmartToken-canDelegate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDelegateEnable)

IRs:
TMP_295(None) = SOLIDITY_CALL require(bool)(isDelegateEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-SmartToken-canUseDirectDebit()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isDirectDebitEnable)

IRs:
TMP_294(None) = SOLIDITY_CALL require(bool)(isDirectDebitEnable)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-SmartToken-confirmSetIssuer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newIssuer == msg.sender)

IRs:
TMP_264(bool) = newIssuer == msg.sender
TMP_265(None) = SOLIDITY_CALL require(bool)(TMP_264)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetIssuer(issuer = newIssuer)

IRs:
issuer(address) := newIssuer(address)
Emit SetIssuer(issuer)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete newIssuer

IRs:
newIssuer = delete newIssuer "];
}
// Function: 7877.sol-SmartToken-constructor(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
fstkAuthority = _fstkAuthority

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)"];
}
// Function: 7877.sol-SmartToken-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
issuer = _issuer

IRs:
issuer(address) := _issuer(address)"];
}
// Function: 7877.sol-SmartToken-constructor(address,FsTKAuthority,string,string,uint256,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply = _totalSupply

IRs:
totalSupply(uint256) := _totalSupply(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
accounts[_issuer].balance = _totalSupply

IRs:
REF_299(FsTKToken.Account) -> accounts[_issuer]
REF_300(uint256) -> REF_299.balance
REF_300(uint256) (->accounts) := _totalSupply(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(address(0),_issuer,_totalSupply)

IRs:
TMP_272 = CONVERT 0 to address
Emit Transfer(TMP_272,_issuer,_totalSupply)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Authorizable(_fstkAuthority)

IRs:
INTERNAL_CALL, Authorizable.constructor(FsTKAuthority)(_fstkAuthority)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
IssuerContract(_issuer)

IRs:
INTERNAL_CALL, IssuerContract.constructor(address)(_issuer)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
ERC20Like(_metadata)

IRs:
INTERNAL_CALL, ERC20Like.constructor(string)(_metadata)"];
8->1;
}
// Function: 7877.sol-SmartToken-constructor(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
metadata = _metadata

IRs:
metadata(string) := _metadata(string)"];
}
// Function: 7877.sol-SmartToken-decreaseAllowance(address,uint256,bool)
digraph{
}
// Function: 7877.sol-SmartToken-delegateTransferAndCall(uint256,uint256,address,uint256,bytes,address,uint8,bytes32,bytes32)
digraph{
}
// Function: 7877.sol-SmartToken-directDebit(address,address)
digraph{
}
// Function: 7877.sol-SmartToken-increaseAllowance(address,uint256)
digraph{
}
// Function: 7877.sol-SmartToken-increaseNonce()
digraph{
}
// Function: 7877.sol-SmartToken-liquid()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLiquid)

IRs:
TMP_293(None) = SOLIDITY_CALL require(bool)(isLiquid)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-SmartToken-nonceOf(address)
digraph{
}
// Function: 7877.sol-SmartToken-notThis(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != address(this))

IRs:
TMP_296 = CONVERT this to address
TMP_297(bool) = _address != TMP_296
TMP_298(None) = SOLIDITY_CALL require(bool)(TMP_297)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-SmartToken-onlyFsTKApproved(bytes32,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isApproved(hash,approveTime,approveToken))

IRs:
TMP_303(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isApproved, arguments:['hash', 'approveTime', 'approveToken']  
TMP_304(None) = SOLIDITY_CALL require(bool)(TMP_303)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-SmartToken-onlyFsTKAuthorized()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fstkAuthority.isAuthorized(msg.sender,this,msg.data))

IRs:
TMP_301(bool) = HIGH_LEVEL_CALL, dest:fstkAuthority(FsTKAuthority), function:isAuthorized, arguments:['msg.sender', 'this', 'msg.data']  
TMP_302(None) = SOLIDITY_CALL require(bool)(TMP_301)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-SmartToken-onlyIssuer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(issuer == msg.sender)

IRs:
TMP_299(bool) = issuer == msg.sender
TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 7877.sol-SmartToken-setDelegate(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.setDelegate(delegate)

IRs:
INTERNAL_CALL, ERC20Like.setDelegate(bool)(delegate)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyIssuer()

IRs:
MODIFIER_CALL, IssuerContract.onlyIssuer()()"];
2->1;
}
// Function: 7877.sol-SmartToken-setDirectDebit(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.setDirectDebit(directDebit)

IRs:
INTERNAL_CALL, ERC20Like.setDirectDebit(bool)(directDebit)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyIssuer()

IRs:
MODIFIER_CALL, IssuerContract.onlyIssuer()()"];
2->1;
}
// Function: 7877.sol-SmartToken-setERC20ApproveChecking(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
super.setERC20ApproveChecking(approveChecking)

IRs:
INTERNAL_CALL, ERC20Like.setERC20ApproveChecking(bool)(approveChecking)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyIssuer()

IRs:
MODIFIER_CALL, IssuerContract.onlyIssuer()()"];
2->1;
}
// Function: 7877.sol-SmartToken-setFsTKAuthority(FsTKAuthority)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_fstkAuthority.validate() == _fstkAuthority.validate.selector)

IRs:
TMP_267(bytes4) = HIGH_LEVEL_CALL, dest:_fstkAuthority(FsTKAuthority), function:validate, arguments:[]  
REF_298(bytes4) (->None) := 1761736296(uint256)
TMP_268(bool) = TMP_267 == REF_298
TMP_269(None) = SOLIDITY_CALL require(bool)(TMP_268)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
SetFsTKAuthority(fstkAuthority = _fstkAuthority)

IRs:
fstkAuthority(FsTKAuthority) := _fstkAuthority(FsTKAuthority)
Emit SetFsTKAuthority(fstkAuthority)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyFsTKAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyFsTKAuthorized()()"];
3->1;
}
// Function: 7877.sol-SmartToken-setIssuer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newIssuer = _address

IRs:
newIssuer(address) := _address(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyIssuer()

IRs:
MODIFIER_CALL, IssuerContract.onlyIssuer()()"];
2->1;
}
// Function: 7877.sol-SmartToken-setLiquid(bool,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
setLiquid0(liquidity)

IRs:
INTERNAL_CALL, ERC20Like.setLiquid0(bool)(liquidity)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyIssuer()

IRs:
MODIFIER_CALL, IssuerContract.onlyIssuer()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyFsTKApproved(keccak256()(abi.encodePacked(approveTime,this,msg.sig,liquidity)),approveTime,approveToken)

IRs:
TMP_290(bytes) = SOLIDITY_CALL abi.encodePacked()(approveTime,this,msg.sig,liquidity)
TMP_291(bytes32) = SOLIDITY_CALL keccak256()(TMP_290)
MODIFIER_CALL, Authorizable.onlyFsTKApproved(bytes32,uint256,bytes)(TMP_291,approveTime,approveToken)"];
3->1;
}
// Function: 7877.sol-SmartToken-setLiquid0(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetLiquid(isLiquid = liquidity)

IRs:
isLiquid(bool) := liquidity(bool)
Emit SetLiquid(isLiquid)"];
}
// Function: 7877.sol-SmartToken-setMetadata(string,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
setMetadata0(infoUrl)

IRs:
INTERNAL_CALL, ERC20Like.setMetadata0(string)(infoUrl)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyIssuer()

IRs:
MODIFIER_CALL, IssuerContract.onlyIssuer()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyFsTKApproved(keccak256()(abi.encodePacked(approveTime,this,msg.sig,infoUrl)),approveTime,approveToken)

IRs:
TMP_285(bytes) = SOLIDITY_CALL abi.encodePacked()(approveTime,this,msg.sig,infoUrl)
TMP_286(bytes32) = SOLIDITY_CALL keccak256()(TMP_285)
MODIFIER_CALL, Authorizable.onlyFsTKApproved(bytes32,uint256,bytes)(TMP_286,approveTime,approveToken)"];
3->1;
}
// Function: 7877.sol-SmartToken-setMetadata0(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
SetMetadata(metadata = _metadata)

IRs:
metadata(string) := _metadata(string)
Emit SetMetadata(metadata)"];
}
// Function: 7877.sol-SmartToken-setupDirectDebit(address,FsTKToken.DirectDebitInfo)
digraph{
}
// Function: 7877.sol-SmartToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
}
// Function: 7877.sol-SmartToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
isLiquid = true

IRs:
isLiquid(bool) := True(bool)"];
}
// Function: 7877.sol-SmartToken-spendableAllowance(address,address)
digraph{
}
// Function: 7877.sol-SmartToken-terminateDirectDebit(address)
digraph{
}
// Function: 7877.sol-SmartToken-transfer(address,uint256)
digraph{
}
// Function: 7877.sol-SmartToken-transfer(uint256[])
digraph{
}
// Function: 7877.sol-SmartToken-transferAndCall(address,uint256,bytes)
digraph{
}
// Function: 7877.sol-SmartToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 7877.sol-SmartToken-withdrawDirectDebit(address)
digraph{
}
// Function: 7877.sol-SmartToken-withdrawDirectDebit(address[],bool)
digraph{
}
}
