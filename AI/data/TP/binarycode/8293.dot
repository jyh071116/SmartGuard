digraph G {
// Function: 8293.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)
digraph{
}
// Function: 8293.sol-ERC20Interface-allowance(address,address)
digraph{
}
// Function: 8293.sol-ERC20Interface-approve(address,uint256)
digraph{
}
// Function: 8293.sol-ERC20Interface-balanceOf(address)
digraph{
}
// Function: 8293.sol-ERC20Interface-totalSupply()
digraph{
}
// Function: 8293.sol-ERC20Interface-transfer(address,uint256)
digraph{
}
// Function: 8293.sol-ERC20Interface-transferFrom(address,address,uint256)
digraph{
}
// Function: 8293.sol-Owned-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = msg.sender

IRs:
admin(address) := msg.sender(address)"];
}
// Function: 8293.sol-Owned-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_19(bool) = msg.sender == newOwner
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_22 = CONVERT 0 to address
newOwner(address) := TMP_22(address)"];
}
// Function: 8293.sol-Owned-onlyAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == admin || msg.sender == owner)

IRs:
TMP_25(bool) = msg.sender == admin
TMP_26(bool) = msg.sender == owner
TMP_27(bool) = TMP_25 || TMP_26
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8293.sol-Owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_23(bool) = msg.sender == owner
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8293.sol-Owned-setAdmin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
AdminChanged(admin,newAdmin)

IRs:
Emit AdminChanged(admin,newAdmin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = newAdmin

IRs:
admin(address) := newAdmin(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 8293.sol-Owned-showAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_admin = admin

IRs:
_admin(address) := admin(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_admin

IRs:
RETURN _admin"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
_admin

IRs:
RETURN _admin"];
}
// Function: 8293.sol-Owned-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 8293.sol-Redenom-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = msg.sender

IRs:
admin(address) := msg.sender(address)"];
}
// Function: 8293.sol-Redenom-Redenom()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
symbol = NOMT

IRs:
symbol(string) := NOMT(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
name = Redenom_test

IRs:
name(string) := Redenom_test(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply = 0

IRs:
_totalSupply(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
total_fund = 1000000 * 10 ** decimals

IRs:
TMP_37(uint256) = 10 ** decimals
TMP_38(uint256) = 1000000 * TMP_37
total_fund(uint256) := TMP_38(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
epoch_fund = 100000 * 10 ** decimals

IRs:
TMP_39(uint256) = 10 ** decimals
TMP_40(uint256) = 100000 * TMP_39
epoch_fund(uint256) := TMP_40(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
total_fund = total_fund.sub(epoch_fund)

IRs:
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['total_fund', 'epoch_fund'] 
total_fund(uint256) := TMP_41(uint256)"];
}
// Function: 8293.sol-Redenom-StartNewEpoch()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_42(bool) = frozen == False
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round == 9)

IRs:
TMP_44(bool) = round == 9
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(epoch < 10)

IRs:
TMP_46(bool) = epoch < 10
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(votingActive == false)

IRs:
TMP_48(bool) = votingActive == False
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
dec = (0,0,0,0,0,0,0,0)

IRs:
dec(uint256[8]) = ['0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
round = 1

IRs:
round(uint256) := 1(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
epoch ++

IRs:
TMP_50(uint256) := epoch(uint256)
epoch(uint256) = epoch + 1"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
epoch_fund = 100000 * 10 ** decimals

IRs:
TMP_51(uint256) = 10 ** decimals
TMP_52(uint256) = 100000 * TMP_51
epoch_fund(uint256) := TMP_52(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
total_fund = total_fund.sub(epoch_fund)

IRs:
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['total_fund', 'epoch_fund'] 
total_fund(uint256) := TMP_53(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
delete projects

IRs:
projects = delete projects "];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Epoch(epoch)

IRs:
Emit Epoch(epoch)"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
13->1;
14[label="Node Type: RETURN 14

EXPRESSION:
succ

IRs:
RETURN succ"];
}
// Function: 8293.sol-Redenom-acceptOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == newOwner)

IRs:
TMP_33(bool) = msg.sender == newOwner
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
newOwner = address(0)

IRs:
TMP_36 = CONVERT 0 to address
newOwner(address) := TMP_36(address)"];
}
// Function: 8293.sol-Redenom-addProject(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
projects.push(Project({id:_id,votesWeight:0,active:true}))

IRs:
TMP_56(Redenom.Project) = new Project(_id,0,True)
REF_3 -> LENGTH projects
TMP_58(uint256) := REF_3(uint256)
TMP_59(uint256) = TMP_58 + 1
REF_3(uint256) (->projects) := TMP_59(uint256)
REF_4(Redenom.Project) -> projects[TMP_58]
REF_4(Redenom.Project) (->projects) := TMP_56(Redenom.Project)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
2->1;
}
// Function: 8293.sol-Redenom-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[tokenOwner][spender]

IRs:
REF_170(mapping(address => uint256)) -> allowed[tokenOwner]
REF_171(uint256) -> REF_170[spender]
RETURN REF_171"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 8293.sol-Redenom-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_350(bool) = frozen == False
TMP_351(None) = SOLIDITY_CALL require(bool)(TMP_350)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(msg.sender,1024) == false)

IRs:
TMP_352(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,1024)
TMP_353(bool) = TMP_352 == False
TMP_354(None) = SOLIDITY_CALL require(bool)(TMP_353)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_190(mapping(address => uint256)) -> allowed[msg.sender]
REF_191(uint256) -> REF_190[spender]
REF_191(uint256) (->allowed) := tokens(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_371(bool) = frozen == False
TMP_372(None) = SOLIDITY_CALL require(bool)(TMP_371)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(msg.sender,1024) == false)

IRs:
TMP_373(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,1024)
TMP_374(bool) = TMP_373 == False
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_215(mapping(address => uint256)) -> allowed[msg.sender]
REF_216(uint256) -> REF_215[spender]
REF_216(uint256) (->allowed) := tokens(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_377 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_377(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  "];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
accounts[tokenOwner].balance

IRs:
REF_168(Redenom.Account) -> accounts[tokenOwner]
REF_169(uint256) -> REF_168.balance
RETURN REF_169"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 8293.sol-Redenom-ban_user(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bitmask_add(user,1024)

IRs:
TMP_207(bool) = INTERNAL_CALL, Redenom.bitmask_add(address,uint256)(user,1024)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-bitmask_add(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(user,_bit) == false)

IRs:
TMP_197(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(user,_bit)
TMP_198(bool) = TMP_197 == False
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[user].bitmask = accounts[user].bitmask.add(_bit)

IRs:
REF_80(Redenom.Account) -> accounts[user]
REF_81(uint256) -> REF_80.bitmask
REF_82(Redenom.Account) -> accounts[user]
REF_83(uint256) -> REF_82.bitmask
TMP_200(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_83', '_bit'] 
REF_81(uint256) (->accounts) := TMP_200(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-bitmask_check(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->4;
3[label="Node Type: RETURN 3

EXPRESSION:
flag

IRs:
RETURN flag"];
4[label="Node Type: IF 4

EXPRESSION:
accounts[user].bitmask & _bit == 0

IRs:
REF_90(Redenom.Account) -> accounts[user]
REF_91(uint256) -> REF_90.bitmask
TMP_205(uint256) = REF_91 & _bit
TMP_206(bool) = TMP_205 == 0
CONDITION TMP_206"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
flag = false

IRs:
flag(bool) := False(bool)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
flag = true

IRs:
flag(bool) := True(bool)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->3;
8[label="Node Type: RETURN 8

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 8293.sol-Redenom-bitmask_rm(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(user,_bit) == true)

IRs:
TMP_201(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(user,_bit)
TMP_202(bool) = TMP_201 == True
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[user].bitmask = accounts[user].bitmask.sub(_bit)

IRs:
REF_85(Redenom.Account) -> accounts[user]
REF_86(uint256) -> REF_85.bitmask
REF_87(Redenom.Account) -> accounts[user]
REF_88(uint256) -> REF_87.bitmask
TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_88', '_bit'] 
REF_86(uint256) (->accounts) := TMP_204(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-current_mul()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
mul[round - 1]

IRs:
TMP_323(uint256) = round - 1
REF_167(uint256) -> mul[TMP_323]
RETURN REF_167"];
2[label="Node Type: RETURN 2

EXPRESSION:
_current_mul

IRs:
RETURN _current_mul"];
}
// Function: 8293.sol-Redenom-disableVoting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(votingActive == true)

IRs:
TMP_95(bool) = votingActive == True
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_97(bool) = frozen == False
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
votingActive = false

IRs:
votingActive(bool) := False(bool)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
VotingOff(msg.sender)

IRs:
Emit VotingOff(msg.sender)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
succ

IRs:
RETURN succ"];
}
// Function: 8293.sol-Redenom-enableVoting()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(votingActive == false)

IRs:
TMP_87(bool) = votingActive == False
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_89(bool) = frozen == False
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(round == 9)

IRs:
TMP_91(bool) = round == 9
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
votingActive = true

IRs:
votingActive(bool) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
VotingOn(msg.sender)

IRs:
Emit VotingOn(msg.sender)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
succ

IRs:
RETURN succ"];
}
// Function: 8293.sol-Redenom-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_379(None) = SOLIDITY_CALL revert()()"];
}
// Function: 8293.sol-Redenom-fix_amount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
(amount / current_mul()) * current_mul()

IRs:
TMP_324(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_325(uint256) = amount / TMP_324
TMP_326(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_327(uint256) = TMP_325 * TMP_326
RETURN TMP_327"];
2[label="Node Type: RETURN 2

EXPRESSION:
fixed_amount

IRs:
RETURN fixed_amount"];
}
// Function: 8293.sol-Redenom-freeze_contract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_170(bool) = frozen == False
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-get_rest(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
amount % current_mul()

IRs:
TMP_328(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_329(uint256) = amount % TMP_328
RETURN TMP_329"];
2[label="Node Type: RETURN 2

EXPRESSION:
fixed_amount

IRs:
RETURN fixed_amount"];
}
// Function: 8293.sol-Redenom-is_banned(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
bitmask_check(user,1024)

IRs:
TMP_211(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(user,1024)
RETURN TMP_211"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
result

IRs:
RETURN result"];
}
// Function: 8293.sol-Redenom-onlyAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == admin || msg.sender == owner)

IRs:
TMP_389(bool) = msg.sender == admin
TMP_390(bool) = msg.sender == owner
TMP_391(bool) = TMP_389 || TMP_390
TMP_392(None) = SOLIDITY_CALL require(bool)(TMP_391)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8293.sol-Redenom-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_387(bool) = msg.sender == owner
TMP_388(None) = SOLIDITY_CALL require(bool)(TMP_387)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8293.sol-Redenom-onlyVoter()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(votingActive == true)

IRs:
TMP_393(bool) = votingActive == True
TMP_394(None) = SOLIDITY_CALL require(bool)(TMP_393)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(msg.sender,4) == true)

IRs:
TMP_395(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,4)
TMP_396(bool) = TMP_395 == True
TMP_397(None) = SOLIDITY_CALL require(bool)(TMP_396)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)((accounts[msg.sender].lastVotedEpoch < epoch))

IRs:
REF_219(Redenom.Account) -> accounts[msg.sender]
REF_220(uint256) -> REF_219.lastVotedEpoch
TMP_398(bool) = REF_220 < epoch
TMP_399(None) = SOLIDITY_CALL require(bool)(TMP_398)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(bitmask_check(msg.sender,1024) == false)

IRs:
TMP_400(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(msg.sender,1024)
TMP_401(bool) = TMP_400 == False
TMP_402(None) = SOLIDITY_CALL require(bool)(TMP_401)"];
4->5;
5[label="Node Type: _ 5
"];
}
// Function: 8293.sol-Redenom-pay055(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(to,2) == false)

IRs:
TMP_113(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,2)
TMP_114(bool) = TMP_113 == False
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
new_amount = 55566600 + (block.timestamp % 100)

IRs:
TMP_116(uint256) = block.timestamp % 100
TMP_117(uint256) = 55566600 + TMP_116
new_amount(uint256) := TMP_117(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
payout(to,new_amount)

IRs:
TMP_118(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,new_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bitmask_add(to,2)

IRs:
TMP_119(bool) = INTERNAL_CALL, Redenom.bitmask_add(address,uint256)(to,2)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-pay055loyal(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(epoch > 1)

IRs:
TMP_121(bool) = epoch > 1
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(to,4) == true)

IRs:
TMP_123(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,4)
TMP_124(bool) = TMP_123 == True
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
new_amount = 55566600 + (block.timestamp % 100)

IRs:
TMP_126(uint256) = block.timestamp % 100
TMP_127(uint256) = 55566600 + TMP_126
new_amount(uint256) := TMP_127(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payout(to,new_amount)

IRs:
TMP_128(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,new_amount)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-pay1(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bitmask_check(to,4) == false)

IRs:
TMP_107(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,4)
TMP_108(bool) = TMP_107 == False
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
new_amount = 100000000

IRs:
new_amount(uint256) := 100000000(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
payout(to,new_amount)

IRs:
TMP_110(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,new_amount)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
bitmask_add(to,4)

IRs:
TMP_111(bool) = INTERNAL_CALL, Redenom.bitmask_add(address,uint256)(to,4)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-payCustom(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
payout(to,amount)

IRs:
TMP_130(bool) = INTERNAL_CALL, Redenom.payout(address,uint256)(to,amount)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-payout(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_132 = CONVERT 0 to address
TMP_133(bool) = to != TMP_132
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount >= current_mul())

IRs:
TMP_135(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_136(bool) = amount >= TMP_135
TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bitmask_check(to,1024) == false)

IRs:
TMP_138(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,1024)
TMP_139(bool) = TMP_138 == False
TMP_140(None) = SOLIDITY_CALL require(bool)(TMP_139)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_141(bool) = frozen == False
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
updateAccount(to)

IRs:
TMP_143(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(to)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
fixedAmount = fix_amount(amount)

IRs:
TMP_144(uint256) = INTERNAL_CALL, Redenom.fix_amount(uint256)(amount)
fixedAmount(uint256) := TMP_144(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
renewDec(accounts[to].balance,accounts[to].balance.add(fixedAmount))

IRs:
REF_46(Redenom.Account) -> accounts[to]
REF_47(uint256) -> REF_46.balance
REF_48(Redenom.Account) -> accounts[to]
REF_49(uint256) -> REF_48.balance
TMP_145(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_49', 'fixedAmount'] 
TMP_146(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(REF_47,TMP_145)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
team_part = (fixedAmount / 100) * 10

IRs:
TMP_147(uint256) = fixedAmount / 100
TMP_148(uint256) = TMP_147 * 10
team_part(uint256) := TMP_148(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
dao_part = (fixedAmount / 100) * 30

IRs:
TMP_149(uint256) = fixedAmount / 100
TMP_150(uint256) = TMP_149 * 30
dao_part(uint256) := TMP_150(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
total = fixedAmount.add(team_part).add(dao_part)

IRs:
TMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['fixedAmount', 'team_part'] 
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_151', 'dao_part'] 
total(uint256) := TMP_152(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
epoch_fund = epoch_fund.sub(total)

IRs:
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['epoch_fund', 'total'] 
epoch_fund(uint256) := TMP_153(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
team_fund = team_fund.add(team_part)

IRs:
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['team_fund', 'team_part'] 
team_fund(uint256) := TMP_154(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
redenom_dao_fund = redenom_dao_fund.add(dao_part)

IRs:
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['redenom_dao_fund', 'dao_part'] 
redenom_dao_fund(uint256) := TMP_155(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(fixedAmount)

IRs:
REF_56(Redenom.Account) -> accounts[to]
REF_57(uint256) -> REF_56.balance
REF_58(Redenom.Account) -> accounts[to]
REF_59(uint256) -> REF_58.balance
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_59', 'fixedAmount'] 
REF_57(uint256) (->accounts) := TMP_156(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_totalSupply = _totalSupply.add(total)

IRs:
TMP_157(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', 'total'] 
_totalSupply(uint256) := TMP_157(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
Transfer(address(0),to,fixedAmount)

IRs:
TMP_158 = CONVERT 0 to address
Emit Transfer(TMP_158,to,fixedAmount)"];
16->17;
17[label="Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True"];
18[label="Node Type: RETURN 18

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-projectActive(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < projects.length

IRs:
REF_19 -> LENGTH projects
TMP_69(bool) = p < REF_19
CONDITION TMP_69"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
projects[p].id == _id

IRs:
REF_20(Redenom.Project) -> projects[p]
REF_21(uint256) -> REF_20.id
TMP_70(bool) = REF_21 == _id
CONDITION TMP_70"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
projects[p].active

IRs:
REF_22(Redenom.Project) -> projects[p]
REF_23(bool) -> REF_22.active
RETURN REF_23"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
p ++

IRs:
TMP_71(uint256) := p(uint256)
p(uint256) = p + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
PA

IRs:
RETURN PA"];
}
// Function: 8293.sol-Redenom-projectWeight(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < projects.length

IRs:
REF_14 -> LENGTH projects
TMP_66(bool) = p < REF_14
CONDITION TMP_66"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
projects[p].id == _id

IRs:
REF_15(Redenom.Project) -> projects[p]
REF_16(uint256) -> REF_15.id
TMP_67(bool) = REF_16 == _id
CONDITION TMP_67"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
projects[p].votesWeight

IRs:
REF_17(Redenom.Project) -> projects[p]
REF_18(uint256) -> REF_17.votesWeight
RETURN REF_18"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
p ++

IRs:
TMP_68(uint256) := p(uint256)
p(uint256) = p + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
PW

IRs:
RETURN PW"];
}
// Function: 8293.sol-Redenom-redenominate()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->53;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_213(bool) = frozen == False
TMP_214(None) = SOLIDITY_CALL require(bool)(TMP_213)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round < 9)

IRs:
TMP_215(bool) = round < 9
TMP_216(None) = SOLIDITY_CALL require(bool)(TMP_215)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply = _totalSupply.sub(team_fund % mul[round]).sub(redenom_dao_fund % mul[round]).sub(dec[8 - round] * mul[round - 1])

IRs:
REF_93(uint256) -> mul[round]
TMP_217(uint256) = team_fund % REF_93
TMP_218(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_totalSupply', 'TMP_217'] 
REF_95(uint256) -> mul[round]
TMP_219(uint256) = redenom_dao_fund % REF_95
TMP_220(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_218', 'TMP_219'] 
TMP_221(uint256) = 8 - round
REF_97(uint256) -> dec[TMP_221]
TMP_222(uint256) = round - 1
REF_98(uint256) -> mul[TMP_222]
TMP_223(uint256) = REF_97 * REF_98
TMP_224(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_220', 'TMP_223'] 
_totalSupply(uint256) := TMP_224(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_totalSupply = (_totalSupply / mul[round]) * mul[round]

IRs:
REF_99(uint256) -> mul[round]
TMP_225(uint256) = _totalSupply / REF_99
REF_100(uint256) -> mul[round]
TMP_226(uint256) = TMP_225 * REF_100
_totalSupply(uint256) := TMP_226(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
team_fund = (team_fund / mul[round]) * mul[round]

IRs:
REF_101(uint256) -> mul[round]
TMP_227(uint256) = team_fund / REF_101
REF_102(uint256) -> mul[round]
TMP_228(uint256) = TMP_227 * REF_102
team_fund(uint256) := TMP_228(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
redenom_dao_fund = (redenom_dao_fund / mul[round]) * mul[round]

IRs:
REF_103(uint256) -> mul[round]
TMP_229(uint256) = redenom_dao_fund / REF_103
REF_104(uint256) -> mul[round]
TMP_230(uint256) = TMP_229 * REF_104
redenom_dao_fund(uint256) := TMP_230(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
round > 1

IRs:
TMP_231(bool) = round > 1
CONDITION TMP_231"];
7->8[label="True"];
7->11[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
superold = dec[(8 - round) + 1]

IRs:
TMP_232(uint256) = 8 - round
TMP_233(uint256) = TMP_232 + 1
REF_105(uint256) -> dec[TMP_233]
superold(uint256) := REF_105(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
epoch_fund = epoch_fund.add(superold * mul[round - 2])

IRs:
TMP_234(uint256) = round - 2
REF_107(uint256) -> mul[TMP_234]
TMP_235(uint256) = superold * REF_107
TMP_236(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['epoch_fund', 'TMP_235'] 
epoch_fund(uint256) := TMP_236(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
dec[(8 - round) + 1] = 0

IRs:
TMP_237(uint256) = 8 - round
TMP_238(uint256) = TMP_237 + 1
REF_108(uint256) -> dec[TMP_238]
REF_108(uint256) (->dec) := 0(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
round < 8

IRs:
TMP_239(bool) = round < 8
CONDITION TMP_239"];
12->13[label="True"];
12->45[label="False"];
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
unclimed = dec[8 - round]

IRs:
TMP_240(uint256) = 8 - round
REF_109(uint256) -> dec[TMP_240]
unclimed(uint256) := REF_109(uint256)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
total_current = dec[8 - 1 - round]

IRs:
TMP_241(uint256) = 8 - 1
TMP_242(uint256) = TMP_241 - round
REF_110(uint256) -> dec[TMP_242]
total_current(uint256) := REF_110(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
total_current == 0

IRs:
TMP_243(bool) = total_current == 0
CONDITION TMP_243"];
15->16[label="True"];
15->19[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
current_toadd = (0,0,0,0,0,0,0,0,0)

IRs:
current_toadd(uint256[9]) = ['0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
round ++

IRs:
TMP_244(uint256) := round(uint256)
round(uint256) = round + 1"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
round

IRs:
RETURN round"];
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: NEW VARIABLE 20

EXPRESSION:
numbers = (uint256(1),2,3,4,5,6,7,8,9)

IRs:
TMP_245 = CONVERT 1 to uint256
numbers(uint256[9]) = ['TMP_245(uint256)', '2(uint256)', '3(uint256)', '4(uint256)', '5(uint256)', '6(uint256)', '7(uint256)', '8(uint256)', '9(uint256)']"];
20->21;
21[label="Node Type: NEW VARIABLE 21

EXPRESSION:
ke9 = (uint256(0),0,0,0,0,0,0,0,0)

IRs:
TMP_246 = CONVERT 0 to uint256
ke9(uint256[9]) = ['TMP_246(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
21->22;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
k2e9 = (uint256(0),0,0,0,0,0,0,0,0)

IRs:
TMP_247 = CONVERT 0 to uint256
k2e9(uint256[9]) = ['TMP_247(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
22->23;
23[label="Node Type: NEW VARIABLE 23

EXPRESSION:
k05summ = 0

IRs:
k05summ(uint256) := 0(uint256)"];
23->26;
24[label="Node Type: BEGIN_LOOP 24
"];
24->27;
25[label="Node Type: END_LOOP 25
"];
25->35;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
k = 0

IRs:
k(uint256) := 0(uint256)"];
26->24;
27[label="Node Type: IF_LOOP 27

EXPRESSION:
k < ke9.length

IRs:
REF_111 -> LENGTH ke9
TMP_248(bool) = k < REF_111
CONDITION TMP_248"];
27->28[label="True"];
27->25[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
ke9[k] = numbers[k] * 1e9 / total_current

IRs:
REF_112(uint256) -> ke9[k]
REF_113(uint256) -> numbers[k]
TMP_249(uint256) = REF_113 * 1000000000
TMP_250(uint256) = TMP_249 / total_current
REF_112(uint256) (->ke9) := TMP_250(uint256)"];
28->29;
29[label="Node Type: IF 29

EXPRESSION:
k < 5

IRs:
TMP_251(bool) = k < 5
CONDITION TMP_251"];
29->30[label="True"];
29->31[label="False"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
k05summ += ke9[k]

IRs:
REF_114(uint256) -> ke9[k]
k05summ(uint256) = k05summ + REF_114"];
30->31;
31[label="Node Type: END_IF 31
"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
k ++

IRs:
TMP_252(uint256) := k(uint256)
k(uint256) = k + 1"];
32->27;
33[label="Node Type: BEGIN_LOOP 33
"];
33->36;
34[label="Node Type: END_LOOP 34
"];
34->41;
35[label="Node Type: NEW VARIABLE 35

EXPRESSION:
k2 = 5

IRs:
k2(uint256) := 5(uint256)"];
35->33;
36[label="Node Type: IF_LOOP 36

EXPRESSION:
k2 < k2e9.length

IRs:
REF_115 -> LENGTH k2e9
TMP_253(bool) = k2 < REF_115
CONDITION TMP_253"];
36->37[label="True"];
36->34[label="False"];
37[label="Node Type: EXPRESSION 37

EXPRESSION:
k2e9[k2] = uint256(ke9[k2]) + uint256(k05summ) * uint256(weight[k2]) / uint256(100)

IRs:
REF_116(uint256) -> k2e9[k2]
REF_117(uint256) -> ke9[k2]
TMP_254 = CONVERT REF_117 to uint256
TMP_255 = CONVERT k05summ to uint256
REF_118(uint256) -> weight[k2]
TMP_256 = CONVERT REF_118 to uint256
TMP_257(uint256) = TMP_255 * TMP_256
TMP_258 = CONVERT 100 to uint256
TMP_259(uint256) = TMP_257 / TMP_258
TMP_260(uint256) = TMP_254 + TMP_259
REF_116(uint256) (->k2e9) := TMP_260(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
k2 ++

IRs:
TMP_261(uint256) := k2(uint256)
k2(uint256) = k2 + 1"];
38->36;
39[label="Node Type: BEGIN_LOOP 39
"];
39->42;
40[label="Node Type: END_LOOP 40
"];
40->49;
41[label="Node Type: NEW VARIABLE 41

EXPRESSION:
n = 5

IRs:
n(uint256) := 5(uint256)"];
41->39;
42[label="Node Type: IF_LOOP 42

EXPRESSION:
n < current_toadd.length

IRs:
REF_119 -> LENGTH current_toadd
TMP_262(bool) = n < REF_119
CONDITION TMP_262"];
42->43[label="True"];
42->40[label="False"];
43[label="Node Type: EXPRESSION 43

EXPRESSION:
current_toadd[n] = k2e9[n] * unclimed / 10 / 1e9

IRs:
REF_120(uint256) -> current_toadd[n]
REF_121(uint256) -> k2e9[n]
TMP_263(uint256) = REF_121 * unclimed
TMP_264(uint256) = TMP_263 / 10
TMP_265(uint256) = TMP_264 / 1000000000
REF_120(uint256) (->current_toadd) := TMP_265(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
n ++

IRs:
TMP_266(uint256) := n(uint256)
n(uint256) = n + 1"];
44->42;
45[label="Node Type: IF 45

EXPRESSION:
round == 8

IRs:
TMP_267(bool) = round == 8
CONDITION TMP_267"];
45->46[label="True"];
45->48[label="False"];
46[label="Node Type: EXPRESSION 46

EXPRESSION:
epoch_fund = epoch_fund.add(dec[0] * 10000000)

IRs:
REF_123(uint256) -> dec[0]
TMP_268(uint256) = REF_123 * 10000000
TMP_269(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['epoch_fund', 'TMP_268'] 
epoch_fund(uint256) := TMP_269(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
dec[0] = 0

IRs:
REF_124(uint256) -> dec[0]
REF_124(uint256) (->dec) := 0(uint256)"];
47->48;
48[label="Node Type: END_IF 48
"];
48->49;
49[label="Node Type: END_IF 49
"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
round ++

IRs:
TMP_270(uint256) := round(uint256)
round(uint256) = round + 1"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
Redenomination(round)

IRs:
Emit Redenomination(round)"];
51->52;
52[label="Node Type: RETURN 52

EXPRESSION:
round

IRs:
RETURN round"];
53[label="Node Type: EXPRESSION 53

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
53->1;
54[label="Node Type: RETURN 54

EXPRESSION:
current_round

IRs:
RETURN current_round"];
}
// Function: 8293.sol-Redenom-renewDec(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
round < 9

IRs:
TMP_176(bool) = round < 9
CONDITION TMP_176"];
1->2[label="True"];
1->19[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tempInitSum = initSum

IRs:
tempInitSum(uint256) := initSum(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tempNewSum = newSum

IRs:
tempNewSum(uint256) := newSum(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
cnt = 1

IRs:
cnt(uint256) := 1(uint256)"];
4->5;
5[label="Node Type: BEGIN_LOOP 5
"];
5->6;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
(tempNewSum > 0 || tempInitSum > 0) && cnt <= decimals

IRs:
TMP_177(bool) = tempNewSum > 0
TMP_178(bool) = tempInitSum > 0
TMP_179(bool) = TMP_177 || TMP_178
TMP_180(bool) = cnt <= decimals
TMP_181(bool) = TMP_179 && TMP_180
CONDITION TMP_181"];
6->7[label="True"];
6->18[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
lastInitSum = tempInitSum % 10

IRs:
TMP_182(uint256) = tempInitSum % 10
lastInitSum(uint256) := TMP_182(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
tempInitSum = tempInitSum / 10

IRs:
TMP_183(uint256) = tempInitSum / 10
tempInitSum(uint256) := TMP_183(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
lastNewSum = tempNewSum % 10

IRs:
TMP_184(uint256) = tempNewSum % 10
lastNewSum(uint256) := TMP_184(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
tempNewSum = tempNewSum / 10

IRs:
TMP_185(uint256) = tempNewSum / 10
tempNewSum(uint256) := TMP_185(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
cnt >= round

IRs:
TMP_186(bool) = cnt >= round
CONDITION TMP_186"];
11->12[label="True"];
11->16[label="False"];
12[label="Node Type: IF 12

EXPRESSION:
lastNewSum >= lastInitSum

IRs:
TMP_187(bool) = lastNewSum >= lastInitSum
CONDITION TMP_187"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
dec[decimals - cnt] = dec[decimals - cnt].add(lastNewSum - lastInitSum)

IRs:
TMP_188(uint256) = decimals - cnt
REF_74(uint256) -> dec[TMP_188]
TMP_189(uint256) = decimals - cnt
REF_75(uint256) -> dec[TMP_189]
TMP_190(uint256) = lastNewSum - lastInitSum
TMP_191(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_75', 'TMP_190'] 
REF_74(uint256) (->dec) := TMP_191(uint256)"];
13->15;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
dec[decimals - cnt] = dec[decimals - cnt].sub(lastInitSum - lastNewSum)

IRs:
TMP_192(uint256) = decimals - cnt
REF_77(uint256) -> dec[TMP_192]
TMP_193(uint256) = decimals - cnt
REF_78(uint256) -> dec[TMP_193]
TMP_194(uint256) = lastInitSum - lastNewSum
TMP_195(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_78', 'TMP_194'] 
REF_77(uint256) (->dec) := TMP_195(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
cnt = cnt + 1

IRs:
TMP_196(uint256) = cnt + 1
cnt(uint256) := TMP_196(uint256)"];
17->6;
18[label="Node Type: END_LOOP 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
true

IRs:
RETURN True"];
21[label="Node Type: RETURN 21

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-setAdmin(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
AdminChanged(admin,newAdmin)

IRs:
Emit AdminChanged(admin,newAdmin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
admin = newAdmin

IRs:
admin(address) := newAdmin(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 8293.sol-Redenom-showAdmin()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_admin = admin

IRs:
_admin(address) := admin(address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_admin

IRs:
RETURN _admin"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
_admin

IRs:
RETURN _admin"];
}
// Function: 8293.sol-Redenom-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 8

IRs:
decimals(uint256) := 8(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
round = 1

IRs:
round(uint256) := 1(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
epoch = 1

IRs:
epoch(uint256) := 1(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
dec = (0,0,0,0,0,0,0,0)

IRs:
dec(uint256[8]) = ['0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
mul = (1,10,100,1000,10000,100000,1000000,10000000,100000000)

IRs:
mul(uint256[9]) = ['1(uint256)', '10(uint256)', '100(uint256)', '1000(uint256)', '10000(uint256)', '100000(uint256)', '1000000(uint256)', '10000000(uint256)', '100000000(uint256)']"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
weight = (uint256(0),0,0,0,0,5,10,30,55)

IRs:
TMP_385 = CONVERT 0 to uint256
weight(uint256[9]) = ['TMP_385(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '5(uint256)', '10(uint256)', '30(uint256)', '55(uint256)']"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
current_toadd = (uint256(0),0,0,0,0,0,0,0,0)

IRs:
TMP_386 = CONVERT 0 to uint256
current_toadd(uint256[9]) = ['TMP_386(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)', '0(uint256)']"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
votingActive = false

IRs:
votingActive(bool) := False(bool)"];
}
// Function: 8293.sol-Redenom-sqrt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
z = (x + 1) / 2

IRs:
TMP_101(uint256) = x + 1
TMP_102(uint256) = TMP_101 / 2
z(uint256) := TMP_102(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
y = x

IRs:
y(uint256) := x(uint256)"];
2->3;
3[label="Node Type: BEGIN_LOOP 3
"];
3->4;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
z < y

IRs:
TMP_103(bool) = z < y
CONDITION TMP_103"];
4->5[label="True"];
4->7[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
y = z

IRs:
y(uint256) := z(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
z = (x / z + z) / 2

IRs:
TMP_104(uint256) = x / z
TMP_105(uint256) = TMP_104 + z
TMP_106(uint256) = TMP_105 / 2
z(uint256) := TMP_106(uint256)"];
6->4;
7[label="Node Type: END_LOOP 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
y

IRs:
RETURN y"];
}
// Function: 8293.sol-Redenom-swapProject(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
p < projects.length

IRs:
REF_5 -> LENGTH projects
TMP_61(bool) = p < REF_5
CONDITION TMP_61"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
projects[p].id == _id

IRs:
REF_6(Redenom.Project) -> projects[p]
REF_7(uint256) -> REF_6.id
TMP_62(bool) = REF_7 == _id
CONDITION TMP_62"];
5->6[label="True"];
5->10[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
projects[p].active == true

IRs:
REF_8(Redenom.Project) -> projects[p]
REF_9(bool) -> REF_8.active
TMP_63(bool) = REF_9 == True
CONDITION TMP_63"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
projects[p].active = false

IRs:
REF_10(Redenom.Project) -> projects[p]
REF_11(bool) -> REF_10.active
REF_11(bool) (->projects) := False(bool)"];
7->9;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
projects[p].active = true

IRs:
REF_12(Redenom.Project) -> projects[p]
REF_13(bool) -> REF_12.active
REF_13(bool) (->projects) := True(bool)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
p ++

IRs:
TMP_64(uint256) := p(uint256)
p(uint256) = p + 1"];
11->4;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
12->3;
}
// Function: 8293.sol-Redenom-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply"];
}
// Function: 8293.sol-Redenom-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_330(bool) = frozen == False
TMP_331(None) = SOLIDITY_CALL require(bool)(TMP_330)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_332 = CONVERT 0 to address
TMP_333(bool) = to != TMP_332
TMP_334(None) = SOLIDITY_CALL require(bool)(TMP_333)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bitmask_check(to,1024) == false)

IRs:
TMP_335(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,1024)
TMP_336(bool) = TMP_335 == False
TMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokens = fix_amount(tokens)

IRs:
TMP_338(uint256) = INTERNAL_CALL, Redenom.fix_amount(uint256)(tokens)
tokens(uint256) := TMP_338(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(tokens > 0)

IRs:
TMP_339(bool) = tokens > 0
TMP_340(None) = SOLIDITY_CALL require(bool)(TMP_339)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateAccount(to)

IRs:
TMP_341(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(to)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updateAccount(msg.sender)

IRs:
TMP_342(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(msg.sender)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
fromOldBal = accounts[msg.sender].balance

IRs:
REF_172(Redenom.Account) -> accounts[msg.sender]
REF_173(uint256) -> REF_172.balance
fromOldBal(uint256) := REF_173(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
toOldBal = accounts[to].balance

IRs:
REF_174(Redenom.Account) -> accounts[to]
REF_175(uint256) -> REF_174.balance
toOldBal(uint256) := REF_175(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens)

IRs:
REF_176(Redenom.Account) -> accounts[msg.sender]
REF_177(uint256) -> REF_176.balance
REF_178(Redenom.Account) -> accounts[msg.sender]
REF_179(uint256) -> REF_178.balance
TMP_343(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_179', 'tokens'] 
REF_177(uint256) (->accounts) := TMP_343(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(tokens)

IRs:
REF_181(Redenom.Account) -> accounts[to]
REF_182(uint256) -> REF_181.balance
REF_183(Redenom.Account) -> accounts[to]
REF_184(uint256) -> REF_183.balance
TMP_344(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_184', 'tokens'] 
REF_182(uint256) (->accounts) := TMP_344(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(renewDec(fromOldBal,accounts[msg.sender].balance))

IRs:
REF_186(Redenom.Account) -> accounts[msg.sender]
REF_187(uint256) -> REF_186.balance
TMP_345(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(fromOldBal,REF_187)
TMP_346(None) = SOLIDITY_CALL require(bool)(TMP_345)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(renewDec(toOldBal,accounts[to].balance))

IRs:
REF_188(Redenom.Account) -> accounts[to]
REF_189(uint256) -> REF_188.balance
TMP_347(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(toOldBal,REF_189)
TMP_348(None) = SOLIDITY_CALL require(bool)(TMP_347)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(msg.sender,to,tokens)

IRs:
Emit Transfer(msg.sender,to,tokens)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
true

IRs:
RETURN True"];
16[label="Node Type: RETURN 16

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-transferAnyERC20Token(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_380(bool) = frozen == False
TMP_381(None) = SOLIDITY_CALL require(bool)(TMP_380)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
ERC20Interface(tokenAddress).transfer(owner,tokens)

IRs:
TMP_382 = CONVERT tokenAddress to ERC20Interface
TMP_383(bool) = HIGH_LEVEL_CALL, dest:TMP_382(ERC20Interface), function:transfer, arguments:['owner', 'tokens']  
RETURN TMP_383"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_356(bool) = frozen == False
TMP_357(None) = SOLIDITY_CALL require(bool)(TMP_356)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bitmask_check(to,1024) == false)

IRs:
TMP_358(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(to,1024)
TMP_359(bool) = TMP_358 == False
TMP_360(None) = SOLIDITY_CALL require(bool)(TMP_359)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
updateAccount(from)

IRs:
TMP_361(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(from)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
updateAccount(to)

IRs:
TMP_362(uint256) = INTERNAL_CALL, Redenom.updateAccount(address)(to)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
fromOldBal = accounts[from].balance

IRs:
REF_192(Redenom.Account) -> accounts[from]
REF_193(uint256) -> REF_192.balance
fromOldBal(uint256) := REF_193(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
toOldBal = accounts[to].balance

IRs:
REF_194(Redenom.Account) -> accounts[to]
REF_195(uint256) -> REF_194.balance
toOldBal(uint256) := REF_195(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
accounts[from].balance = accounts[from].balance.sub(tokens)

IRs:
REF_196(Redenom.Account) -> accounts[from]
REF_197(uint256) -> REF_196.balance
REF_198(Redenom.Account) -> accounts[from]
REF_199(uint256) -> REF_198.balance
TMP_363(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_199', 'tokens'] 
REF_197(uint256) (->accounts) := TMP_363(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens)

IRs:
REF_201(mapping(address => uint256)) -> allowed[from]
REF_202(uint256) -> REF_201[msg.sender]
REF_203(mapping(address => uint256)) -> allowed[from]
REF_204(uint256) -> REF_203[msg.sender]
TMP_364(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_204', 'tokens'] 
REF_202(uint256) (->allowed) := TMP_364(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(tokens)

IRs:
REF_206(Redenom.Account) -> accounts[to]
REF_207(uint256) -> REF_206.balance
REF_208(Redenom.Account) -> accounts[to]
REF_209(uint256) -> REF_208.balance
TMP_365(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_209', 'tokens'] 
REF_207(uint256) (->accounts) := TMP_365(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(renewDec(fromOldBal,accounts[from].balance))

IRs:
REF_211(Redenom.Account) -> accounts[from]
REF_212(uint256) -> REF_211.balance
TMP_366(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(fromOldBal,REF_212)
TMP_367(None) = SOLIDITY_CALL require(bool)(TMP_366)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(renewDec(toOldBal,accounts[to].balance))

IRs:
REF_213(Redenom.Account) -> accounts[to]
REF_214(uint256) -> REF_213.balance
TMP_368(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(toOldBal,REF_214)
TMP_369(None) = SOLIDITY_CALL require(bool)(TMP_368)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(from,to,tokens)

IRs:
Emit Transfer(from,to,tokens)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True"];
14[label="Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
newOwner = _newOwner

IRs:
newOwner(address) := _newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 8293.sol-Redenom-unban_user(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
bitmask_rm(user,1024)

IRs:
TMP_209(bool) = INTERNAL_CALL, Redenom.bitmask_rm(address,uint256)(user,1024)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-unfreeze_contract()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == true)

IRs:
TMP_173(bool) = frozen == True
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-updateAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_273(bool) = frozen == False
TMP_274(None) = SOLIDITY_CALL require(bool)(TMP_273)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(round <= 9)

IRs:
TMP_275(bool) = round <= 9
TMP_276(None) = SOLIDITY_CALL require(bool)(TMP_275)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bitmask_check(account,1024) == false)

IRs:
TMP_277(bool) = INTERNAL_CALL, Redenom.bitmask_check(address,uint256)(account,1024)
TMP_278(bool) = TMP_277 == False
TMP_279(None) = SOLIDITY_CALL require(bool)(TMP_278)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
round > accounts[account].lastRound

IRs:
REF_125(Redenom.Account) -> accounts[account]
REF_126(uint256) -> REF_125.lastRound
TMP_280(bool) = round > REF_126
CONDITION TMP_280"];
4->5[label="True"];
4->39[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
round > 1 && round <= 8

IRs:
TMP_281(bool) = round > 1
TMP_282(bool) = round <= 8
TMP_283(bool) = TMP_281 && TMP_282
CONDITION TMP_283"];
5->6[label="True"];
5->27[label="False"];
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
tempDividedBalance = accounts[account].balance / current_mul()

IRs:
REF_127(Redenom.Account) -> accounts[account]
REF_128(uint256) -> REF_127.balance
TMP_284(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_285(uint256) = REF_128 / TMP_284
tempDividedBalance(uint256) := TMP_285(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
newFixedBalance = tempDividedBalance * current_mul()

IRs:
TMP_286(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_287(uint256) = tempDividedBalance * TMP_286
newFixedBalance(uint256) := TMP_287(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
lastActiveDigit = tempDividedBalance % 10

IRs:
TMP_288(uint256) = tempDividedBalance % 10
lastActiveDigit(uint256) := TMP_288(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
diff = accounts[account].balance - newFixedBalance

IRs:
REF_129(Redenom.Account) -> accounts[account]
REF_130(uint256) -> REF_129.balance
TMP_289(uint256) = REF_130 - newFixedBalance
diff(uint256) := TMP_289(uint256)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
diff > 0

IRs:
TMP_290(bool) = diff > 0
CONDITION TMP_290"];
10->11[label="True"];
10->13[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
accounts[account].balance = newFixedBalance

IRs:
REF_131(Redenom.Account) -> accounts[account]
REF_132(uint256) -> REF_131.balance
REF_132(uint256) (->accounts) := newFixedBalance(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(account,address(0),diff)

IRs:
TMP_291 = CONVERT 0 to address
Emit Transfer(account,TMP_291,diff)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
toBalance = 0

IRs:
toBalance(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
lastActiveDigit > 0 && current_toadd[lastActiveDigit - 1] > 0

IRs:
TMP_293(bool) = lastActiveDigit > 0
TMP_294(uint256) = lastActiveDigit - 1
REF_133(uint256) -> current_toadd[TMP_294]
TMP_295(bool) = REF_133 > 0
TMP_296(bool) = TMP_293 && TMP_295
CONDITION TMP_296"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
toBalance = current_toadd[lastActiveDigit - 1] * current_mul()

IRs:
TMP_297(uint256) = lastActiveDigit - 1
REF_134(uint256) -> current_toadd[TMP_297]
TMP_298(uint256) = INTERNAL_CALL, Redenom.current_mul()()
TMP_299(uint256) = REF_134 * TMP_298
toBalance(uint256) := TMP_299(uint256)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
toBalance > 0 && toBalance < dec[8 - round + 1]

IRs:
TMP_300(bool) = toBalance > 0
TMP_301(uint256) = 8 - round
TMP_302(uint256) = TMP_301 + 1
REF_135(uint256) -> dec[TMP_302]
TMP_303(bool) = toBalance < REF_135
TMP_304(bool) = TMP_300 && TMP_303
CONDITION TMP_304"];
18->19[label="True"];
18->24[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
renewDec(accounts[account].balance,accounts[account].balance.add(toBalance))

IRs:
REF_136(Redenom.Account) -> accounts[account]
REF_137(uint256) -> REF_136.balance
REF_138(Redenom.Account) -> accounts[account]
REF_139(uint256) -> REF_138.balance
TMP_305(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_139', 'toBalance'] 
TMP_306(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(REF_137,TMP_305)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
Transfer(address(0),account,toBalance)

IRs:
TMP_307 = CONVERT 0 to address
Emit Transfer(TMP_307,account,toBalance)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
accounts[account].balance = accounts[account].balance.add(toBalance)

IRs:
REF_141(Redenom.Account) -> accounts[account]
REF_142(uint256) -> REF_141.balance
REF_143(Redenom.Account) -> accounts[account]
REF_144(uint256) -> REF_143.balance
TMP_309(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_144', 'toBalance'] 
REF_142(uint256) (->accounts) := TMP_309(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
dec[8 - round + 1] = dec[8 - round + 1].sub(toBalance)

IRs:
TMP_310(uint256) = 8 - round
TMP_311(uint256) = TMP_310 + 1
REF_146(uint256) -> dec[TMP_311]
TMP_312(uint256) = 8 - round
TMP_313(uint256) = TMP_312 + 1
REF_147(uint256) -> dec[TMP_313]
TMP_314(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_147', 'toBalance'] 
REF_146(uint256) (->dec) := TMP_314(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
_totalSupply = _totalSupply.add(toBalance)

IRs:
TMP_315(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', 'toBalance'] 
_totalSupply(uint256) := TMP_315(uint256)"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
accounts[account].lastRound = round

IRs:
REF_150(Redenom.Account) -> accounts[account]
REF_151(uint256) -> REF_150.lastRound
REF_151(uint256) (->accounts) := round(uint256)"];
25->26;
26[label="Node Type: RETURN 26

EXPRESSION:
accounts[account].balance

IRs:
REF_152(Redenom.Account) -> accounts[account]
REF_153(uint256) -> REF_152.balance
RETURN REF_153"];
27[label="Node Type: IF 27

EXPRESSION:
round == 9

IRs:
TMP_316(bool) = round == 9
CONDITION TMP_316"];
27->28[label="True"];
27->37[label="False"];
28[label="Node Type: NEW VARIABLE 28

EXPRESSION:
newBalance = fix_amount(accounts[account].balance)

IRs:
REF_154(Redenom.Account) -> accounts[account]
REF_155(uint256) -> REF_154.balance
TMP_317(uint256) = INTERNAL_CALL, Redenom.fix_amount(uint256)(REF_155)
newBalance(uint256) := TMP_317(uint256)"];
28->29;
29[label="Node Type: NEW VARIABLE 29

EXPRESSION:
_diff = accounts[account].balance.sub(newBalance)

IRs:
REF_156(Redenom.Account) -> accounts[account]
REF_157(uint256) -> REF_156.balance
TMP_318(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_157', 'newBalance'] 
_diff(uint256) := TMP_318(uint256)"];
29->30;
30[label="Node Type: IF 30

EXPRESSION:
_diff > 0

IRs:
TMP_319(bool) = _diff > 0
CONDITION TMP_319"];
30->31[label="True"];
30->34[label="False"];
31[label="Node Type: EXPRESSION 31

EXPRESSION:
renewDec(accounts[account].balance,newBalance)

IRs:
REF_159(Redenom.Account) -> accounts[account]
REF_160(uint256) -> REF_159.balance
TMP_320(bool) = INTERNAL_CALL, Redenom.renewDec(uint256,uint256)(REF_160,newBalance)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
accounts[account].balance = newBalance

IRs:
REF_161(Redenom.Account) -> accounts[account]
REF_162(uint256) -> REF_161.balance
REF_162(uint256) (->accounts) := newBalance(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
Transfer(account,address(0),_diff)

IRs:
TMP_321 = CONVERT 0 to address
Emit Transfer(account,TMP_321,_diff)"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
accounts[account].lastRound = round

IRs:
REF_163(Redenom.Account) -> accounts[account]
REF_164(uint256) -> REF_163.lastRound
REF_164(uint256) (->accounts) := round(uint256)"];
35->36;
36[label="Node Type: RETURN 36

EXPRESSION:
accounts[account].balance

IRs:
REF_165(Redenom.Account) -> accounts[account]
REF_166(uint256) -> REF_165.balance
RETURN REF_166"];
37[label="Node Type: END_IF 37
"];
37->38;
38[label="Node Type: END_IF 38
"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: RETURN 40

EXPRESSION:
new_balance

IRs:
RETURN new_balance"];
}
// Function: 8293.sol-Redenom-vote(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(frozen == false)

IRs:
TMP_72(bool) = frozen == False
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
p < projects.length

IRs:
REF_24 -> LENGTH projects
TMP_74(bool) = p < REF_24
CONDITION TMP_74"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
projects[p].id == _id && projects[p].active == true

IRs:
REF_25(Redenom.Project) -> projects[p]
REF_26(uint256) -> REF_25.id
TMP_75(bool) = REF_26 == _id
REF_27(Redenom.Project) -> projects[p]
REF_28(bool) -> REF_27.active
TMP_76(bool) = REF_28 == True
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
projects[p].votesWeight += sqrt(accounts[msg.sender].balance)

IRs:
REF_29(Redenom.Project) -> projects[p]
REF_30(uint256) -> REF_29.votesWeight
REF_31(Redenom.Account) -> accounts[msg.sender]
REF_32(uint256) -> REF_31.balance
TMP_78(uint256) = INTERNAL_CALL, Redenom.sqrt(uint256)(REF_32)
REF_30(-> projects) = REF_30 + TMP_78"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
accounts[msg.sender].lastVotedEpoch = epoch

IRs:
REF_33(Redenom.Account) -> accounts[msg.sender]
REF_34(uint256) -> REF_33.lastVotedEpoch
REF_34(uint256) (->accounts) := epoch(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
p ++

IRs:
TMP_79(uint256) := p(uint256)
p(uint256) = p + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Vote(msg.sender,_id,accounts[msg.sender].balance,epoch)

IRs:
REF_35(Redenom.Account) -> accounts[msg.sender]
REF_36(uint256) -> REF_35.balance
Emit Vote(msg.sender,_id,REF_36,epoch)"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyVoter()

IRs:
MODIFIER_CALL, Redenom.onlyVoter()()"];
13->1;
14[label="Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-winningProject()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
winningVoteWeight = 0

IRs:
winningVoteWeight(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
p = 0

IRs:
p(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
p < projects.length

IRs:
REF_37 -> LENGTH projects
TMP_82(bool) = p < REF_37
CONDITION TMP_82"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
projects[p].votesWeight > winningVoteWeight && projects[p].active == true

IRs:
REF_38(Redenom.Project) -> projects[p]
REF_39(uint256) -> REF_38.votesWeight
TMP_83(bool) = REF_39 > winningVoteWeight
REF_40(Redenom.Project) -> projects[p]
REF_41(bool) -> REF_40.active
TMP_84(bool) = REF_41 == True
TMP_85(bool) = TMP_83 && TMP_84
CONDITION TMP_85"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
winningVoteWeight = projects[p].votesWeight

IRs:
REF_42(Redenom.Project) -> projects[p]
REF_43(uint256) -> REF_42.votesWeight
winningVoteWeight(uint256) := REF_43(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_winningProject = projects[p].id

IRs:
REF_44(Redenom.Project) -> projects[p]
REF_45(uint256) -> REF_44.id
_winningProject(uint256) := REF_45(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
p ++

IRs:
TMP_86(uint256) := p(uint256)
p(uint256) = p + 1"];
10->5;
11[label="Node Type: RETURN 11

EXPRESSION:
_winningProject

IRs:
RETURN _winningProject"];
}
// Function: 8293.sol-Redenom-withdraw_dao_fund(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount <= redenom_dao_fund)

IRs:
TMP_165(bool) = amount <= redenom_dao_fund
TMP_166(None) = SOLIDITY_CALL require(bool)(TMP_165)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(amount)

IRs:
REF_68(Redenom.Account) -> accounts[to]
REF_69(uint256) -> REF_68.balance
REF_70(Redenom.Account) -> accounts[to]
REF_71(uint256) -> REF_70.balance
TMP_167(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', 'amount'] 
REF_69(uint256) (->accounts) := TMP_167(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
redenom_dao_fund = redenom_dao_fund.sub(amount)

IRs:
TMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['redenom_dao_fund', 'amount'] 
redenom_dao_fund(uint256) := TMP_168(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-Redenom-withdraw_team_fund(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount <= team_fund)

IRs:
TMP_160(bool) = amount <= team_fund
TMP_161(None) = SOLIDITY_CALL require(bool)(TMP_160)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
accounts[to].balance = accounts[to].balance.add(amount)

IRs:
REF_62(Redenom.Account) -> accounts[to]
REF_63(uint256) -> REF_62.balance
REF_64(Redenom.Account) -> accounts[to]
REF_65(uint256) -> REF_64.balance
TMP_162(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_65', 'amount'] 
REF_63(uint256) (->accounts) := TMP_162(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
team_fund = team_fund.sub(amount)

IRs:
TMP_163(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['team_fund', 'amount'] 
team_fund(uint256) := TMP_163(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8293.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_0(uint256) = a + b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(c >= a)

IRs:
TMP_1(bool) = c >= a
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 8293.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b > 0)

IRs:
TMP_12(bool) = b > 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a / b

IRs:
TMP_14(uint256) = a / b
c(uint256) := TMP_14(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 8293.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_6(uint256) = a * b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(a == 0 || c / a == b)

IRs:
TMP_7(bool) = a == 0
TMP_8(uint256) = c / a
TMP_9(bool) = TMP_8 == b
TMP_10(bool) = TMP_7 || TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 8293.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b <= a)

IRs:
TMP_3(bool) = b <= a
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_5(uint256) = a - b
c(uint256) := TMP_5(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
}
