digraph G {
// Function: 8305.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 8305.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 8305.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_7 = CONVERT 0 to address
TMP_8(bool) = _to != TMP_7
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_10(bool) = _value <= REF_0
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_12(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_12(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_13(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-CrowdSale-CrowdSale(address,address,uint256,uint256,uint256,uint256[2],uint256[2],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
softCap = 250000000000

IRs:
softCap(uint256) := 250000000000(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
hardCap = 3578912800000

IRs:
hardCap(uint256) := 3578912800000(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
price = _price

IRs:
price(uint256) := _price(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
preICOStats.maxTokenSupply = _maxPreICOTokenSupply

IRs:
REF_254(uint256) -> preICOStats.maxTokenSupply
REF_254(uint256) (->preICOStats) := _maxPreICOTokenSupply(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
tiers.push(Tier(uint256(65),_preIcoDuration[0],_preIcoDuration[0].add(3600)))

IRs:
TMP_523 = CONVERT 65 to uint256
REF_256(uint256) -> _preIcoDuration[0]
REF_257(uint256) -> _preIcoDuration[0]
TMP_524(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_257', '3600'] 
TMP_525(SellableToken.Tier) = new Tier(TMP_523,REF_256,TMP_524)
REF_259 -> LENGTH tiers
TMP_527(uint256) := REF_259(uint256)
TMP_528(uint256) = TMP_527 + 1
REF_259(uint256) (->tiers) := TMP_528(uint256)
REF_260(SellableToken.Tier) -> tiers[TMP_527]
REF_260(SellableToken.Tier) (->tiers) := TMP_525(SellableToken.Tier)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tiers.push(Tier(uint256(60),_preIcoDuration[0].add(3600),_preIcoDuration[0].add(86400)))

IRs:
TMP_529 = CONVERT 60 to uint256
REF_262(uint256) -> _preIcoDuration[0]
TMP_530(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_262', '3600'] 
REF_264(uint256) -> _preIcoDuration[0]
TMP_531(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_264', '86400'] 
TMP_532(SellableToken.Tier) = new Tier(TMP_529,TMP_530,TMP_531)
REF_266 -> LENGTH tiers
TMP_534(uint256) := REF_266(uint256)
TMP_535(uint256) = TMP_534 + 1
REF_266(uint256) (->tiers) := TMP_535(uint256)
REF_267(SellableToken.Tier) -> tiers[TMP_534]
REF_267(SellableToken.Tier) (->tiers) := TMP_532(SellableToken.Tier)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tiers.push(Tier(uint256(57),_preIcoDuration[0].add(86400),_preIcoDuration[0].add(172800)))

IRs:
TMP_536 = CONVERT 57 to uint256
REF_269(uint256) -> _preIcoDuration[0]
TMP_537(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_269', '86400'] 
REF_271(uint256) -> _preIcoDuration[0]
TMP_538(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_271', '172800'] 
TMP_539(SellableToken.Tier) = new Tier(TMP_536,TMP_537,TMP_538)
REF_273 -> LENGTH tiers
TMP_541(uint256) := REF_273(uint256)
TMP_542(uint256) = TMP_541 + 1
REF_273(uint256) (->tiers) := TMP_542(uint256)
REF_274(SellableToken.Tier) -> tiers[TMP_541]
REF_274(SellableToken.Tier) (->tiers) := TMP_539(SellableToken.Tier)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
tiers.push(Tier(uint256(55),_preIcoDuration[0].add(172800),_preIcoDuration[0].add(259200)))

IRs:
TMP_543 = CONVERT 55 to uint256
REF_276(uint256) -> _preIcoDuration[0]
TMP_544(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_276', '172800'] 
REF_278(uint256) -> _preIcoDuration[0]
TMP_545(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_278', '259200'] 
TMP_546(SellableToken.Tier) = new Tier(TMP_543,TMP_544,TMP_545)
REF_280 -> LENGTH tiers
TMP_548(uint256) := REF_280(uint256)
TMP_549(uint256) = TMP_548 + 1
REF_280(uint256) (->tiers) := TMP_549(uint256)
REF_281(SellableToken.Tier) -> tiers[TMP_548]
REF_281(SellableToken.Tier) (->tiers) := TMP_546(SellableToken.Tier)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
tiers.push(Tier(uint256(50),_preIcoDuration[0].add(259200),_preIcoDuration[1]))

IRs:
TMP_550 = CONVERT 50 to uint256
REF_283(uint256) -> _preIcoDuration[0]
TMP_551(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_283', '259200'] 
REF_285(uint256) -> _preIcoDuration[1]
TMP_552(SellableToken.Tier) = new Tier(TMP_550,TMP_551,REF_285)
REF_286 -> LENGTH tiers
TMP_554(uint256) := REF_286(uint256)
TMP_555(uint256) = TMP_554 + 1
REF_286(uint256) (->tiers) := TMP_555(uint256)
REF_287(SellableToken.Tier) -> tiers[TMP_554]
REF_287(SellableToken.Tier) (->tiers) := TMP_552(SellableToken.Tier)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
tiers.push(Tier(uint256(25),_icoDuration[0],_icoDuration[0].add(604800)))

IRs:
TMP_556 = CONVERT 25 to uint256
REF_289(uint256) -> _icoDuration[0]
REF_290(uint256) -> _icoDuration[0]
TMP_557(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_290', '604800'] 
TMP_558(SellableToken.Tier) = new Tier(TMP_556,REF_289,TMP_557)
REF_292 -> LENGTH tiers
TMP_560(uint256) := REF_292(uint256)
TMP_561(uint256) = TMP_560 + 1
REF_292(uint256) (->tiers) := TMP_561(uint256)
REF_293(SellableToken.Tier) -> tiers[TMP_560]
REF_293(SellableToken.Tier) (->tiers) := TMP_558(SellableToken.Tier)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tiers.push(Tier(uint256(15),_icoDuration[0].add(604800),_icoDuration[0].add(1209600)))

IRs:
TMP_562 = CONVERT 15 to uint256
REF_295(uint256) -> _icoDuration[0]
TMP_563(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_295', '604800'] 
REF_297(uint256) -> _icoDuration[0]
TMP_564(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_297', '1209600'] 
TMP_565(SellableToken.Tier) = new Tier(TMP_562,TMP_563,TMP_564)
REF_299 -> LENGTH tiers
TMP_567(uint256) := REF_299(uint256)
TMP_568(uint256) = TMP_567 + 1
REF_299(uint256) (->tiers) := TMP_568(uint256)
REF_300(SellableToken.Tier) -> tiers[TMP_567]
REF_300(SellableToken.Tier) (->tiers) := TMP_565(SellableToken.Tier)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
tiers.push(Tier(uint256(10),_icoDuration[0].add(1209600),_icoDuration[0].add(1814400)))

IRs:
TMP_569 = CONVERT 10 to uint256
REF_302(uint256) -> _icoDuration[0]
TMP_570(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_302', '1209600'] 
REF_304(uint256) -> _icoDuration[0]
TMP_571(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_304', '1814400'] 
TMP_572(SellableToken.Tier) = new Tier(TMP_569,TMP_570,TMP_571)
REF_306 -> LENGTH tiers
TMP_574(uint256) := REF_306(uint256)
TMP_575(uint256) = TMP_574 + 1
REF_306(uint256) (->tiers) := TMP_575(uint256)
REF_307(SellableToken.Tier) -> tiers[TMP_574]
REF_307(SellableToken.Tier) (->tiers) := TMP_572(SellableToken.Tier)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
tiers.push(Tier(uint256(5),_icoDuration[0].add(1814400),_icoDuration[1]))

IRs:
TMP_576 = CONVERT 5 to uint256
REF_309(uint256) -> _icoDuration[0]
TMP_577(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_309', '1814400'] 
REF_311(uint256) -> _icoDuration[1]
TMP_578(SellableToken.Tier) = new Tier(TMP_576,TMP_577,REF_311)
REF_312 -> LENGTH tiers
TMP_580(uint256) := REF_312(uint256)
TMP_581(uint256) = TMP_580 + 1
REF_312(uint256) (->tiers) := TMP_581(uint256)
REF_313(SellableToken.Tier) -> tiers[TMP_580]
REF_313(SellableToken.Tier) (->tiers) := TMP_578(SellableToken.Tier)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
SellableToken(_token,_etherHolder,_preIcoDuration[0],_icoDuration[1],_maxPreICOTokenSupply.add(_maxICOTokenSupply),_etherPriceInUSD)

IRs:
REF_314(uint256) -> _preIcoDuration[0]
REF_315(uint256) -> _icoDuration[1]
TMP_582(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_maxPreICOTokenSupply', '_maxICOTokenSupply'] 
INTERNAL_CALL, SellableToken.SellableToken(address,address,uint256,uint256,uint256,uint256)(_token,_etherHolder,REF_314,REF_315,TMP_582,_etherPriceInUSD)"];
14->1;
}
// Function: 8305.sol-CrowdSale-Multivest()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 8305.sol-CrowdSale-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 8305.sol-CrowdSale-SellableToken(address,address,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0) && _etherHolder != address(0))

IRs:
TMP_431 = CONVERT 0 to address
TMP_432(bool) = _token != TMP_431
TMP_433 = CONVERT 0 to address
TMP_434(bool) = _etherHolder != TMP_433
TMP_435(bool) = TMP_432 && TMP_434
TMP_436(None) = SOLIDITY_CALL require(bool)(TMP_435)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token = GigToken(_token)

IRs:
TMP_437 = CONVERT _token to GigToken
token(GigToken) := TMP_437(GigToken)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_startTime < _endTime)

IRs:
TMP_438(bool) = _startTime < _endTime
TMP_439(None) = SOLIDITY_CALL require(bool)(TMP_438)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
etherHolder = _etherHolder

IRs:
etherHolder(address) := _etherHolder(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)((_maxTokenSupply == uint256(0)) || (_maxTokenSupply <= token.maxSupply()))

IRs:
TMP_440 = CONVERT 0 to uint256
TMP_441(bool) = _maxTokenSupply == TMP_440
TMP_442(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:maxSupply, arguments:[]  
TMP_443(bool) = _maxTokenSupply <= TMP_442
TMP_444(bool) = TMP_441 || TMP_443
TMP_445(None) = SOLIDITY_CALL require(bool)(TMP_444)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
maxTokenSupply = _maxTokenSupply

IRs:
maxTokenSupply(uint256) := _maxTokenSupply(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
etherPriceInUSD = _etherPriceInUSD

IRs:
etherPriceInUSD(uint256) := _etherPriceInUSD(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
priceUpdateAt = block.timestamp

IRs:
priceUpdateAt(uint256) := block.timestamp(uint256)"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Multivest()

IRs:
INTERNAL_CALL, Multivest.Multivest()()"];
11->1;
}
// Function: 8305.sol-CrowdSale-burnUnsoldTokens()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
block.timestamp >= endTime && maxTokenSupply > soldTokens

IRs:
TMP_647(bool) = block.timestamp >= endTime
TMP_648(bool) = maxTokenSupply > soldTokens
TMP_649(bool) = TMP_647 && TMP_648
CONDITION TMP_649"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token.burnUnsoldTokens(maxTokenSupply.sub(soldTokens))

IRs:
TMP_650(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['maxTokenSupply', 'soldTokens'] 
HIGH_LEVEL_CALL, dest:token(GigToken), function:burnUnsoldTokens, arguments:['TMP_650']  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
maxTokenSupply = soldTokens

IRs:
maxTokenSupply(uint256) := soldTokens(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 8305.sol-CrowdSale-buy(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_value == 0 || _address == address(0)

IRs:
TMP_695(bool) = _value == 0
TMP_696 = CONVERT 0 to address
TMP_697(bool) = _address == TMP_696
TMP_698(bool) = TMP_695 || TMP_697
CONDITION TMP_698"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
activeTier = getActiveTier()

IRs:
TMP_699(uint256) = INTERNAL_CALL, CrowdSale.getActiveTier()()
activeTier(uint256) := TMP_699(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
activeTier == tiers.length

IRs:
REF_396 -> LENGTH tiers
TMP_700(bool) = activeTier == REF_396
CONDITION TMP_700"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8
"];
8->9;
9[label="Node Type: NEW VARIABLE 9
"];
9->10;
10[label="Node Type: NEW VARIABLE 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
(tokenAmount,usdAmount) = calculateTokensAmount(_value)

IRs:
TUPLE_2(uint256,uint256) = INTERNAL_CALL, CrowdSale.calculateTokensAmount(uint256)(_value)
tokenAmount(uint256)= UNPACK TUPLE_2 index: 0 
usdAmount(uint256)= UNPACK TUPLE_2 index: 1 "];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(usdAmount > 0 && tokenAmount > 0)

IRs:
TMP_701(bool) = usdAmount > 0
TMP_702(bool) = tokenAmount > 0
TMP_703(bool) = TMP_701 && TMP_702
TMP_704(None) = SOLIDITY_CALL require(bool)(TMP_703)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
activeTier >= PRE_ICO_TIER_FIRST && activeTier <= PRE_ICO_TIER_LAST

IRs:
TMP_705(bool) = activeTier >= PRE_ICO_TIER_FIRST
TMP_706(bool) = activeTier <= PRE_ICO_TIER_LAST
TMP_707(bool) = TMP_705 && TMP_706
CONDITION TMP_707"];
13->14[label="True"];
13->16[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
mintedAmount = mintPreICO(_address,tokenAmount,_value,usdAmount)

IRs:
TMP_708(uint256) = INTERNAL_CALL, CrowdSale.mintPreICO(address,uint256,uint256,uint256)(_address,tokenAmount,_value,usdAmount)
mintedAmount(uint256) := TMP_708(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
etherHolder.transfer(this.balance)

IRs:
REF_398(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:etherHolder value:REF_398"];
15->24;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
mintedAmount = mintInternal(_address,tokenAmount)

IRs:
TMP_710(uint256) = INTERNAL_CALL, SellableToken.mintInternal(address,uint256)(_address,tokenAmount)
mintedAmount(uint256) := TMP_710(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(soldTokens <= maxTokenSupply.sub(preICOStats.maxTokenSupply))

IRs:
REF_400(uint256) -> preICOStats.maxTokenSupply
TMP_711(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['maxTokenSupply', 'REF_400'] 
TMP_712(bool) = soldTokens <= TMP_711
TMP_713(None) = SOLIDITY_CALL require(bool)(TMP_712)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
collectedUSD = collectedUSD.add(usdAmount)

IRs:
TMP_714(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['collectedUSD', 'usdAmount'] 
collectedUSD(uint256) := TMP_714(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
require(bool)(hardCap >= collectedUSD.add(preICOStats.collectedUSD) && usdAmount > 0 && mintedAmount > 0)

IRs:
REF_403(uint256) -> preICOStats.collectedUSD
TMP_715(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['collectedUSD', 'REF_403'] 
TMP_716(bool) = hardCap >= TMP_715
TMP_717(bool) = usdAmount > 0
TMP_718(bool) = TMP_716 && TMP_717
TMP_719(bool) = mintedAmount > 0
TMP_720(bool) = TMP_718 && TMP_719
TMP_721(None) = SOLIDITY_CALL require(bool)(TMP_720)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
collectedEthers = collectedEthers.add(_value)

IRs:
TMP_722(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['collectedEthers', '_value'] 
collectedEthers(uint256) := TMP_722(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
etherBalances[_address] = etherBalances[_address].add(_value)

IRs:
REF_405(uint256) -> etherBalances[_address]
REF_406(uint256) -> etherBalances[_address]
TMP_723(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_406', '_value'] 
REF_405(uint256) (->etherBalances) := TMP_723(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
icoBalances[_address] = icoBalances[_address].add(tokenAmount)

IRs:
REF_408(uint256) -> icoBalances[_address]
REF_409(uint256) -> icoBalances[_address]
TMP_724(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_409', 'tokenAmount'] 
REF_408(uint256) (->icoBalances) := TMP_724(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
transferEthers()

IRs:
INTERNAL_CALL, CrowdSale.transferEthers()()"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
Contribution(_address,_value,tokenAmount)

IRs:
Emit Contribution(_address,_value,tokenAmount)"];
25->26;
26[label="Node Type: RETURN 26

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-CrowdSale-calculateEthersAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_tokens == 0

IRs:
TMP_623(bool) = _tokens == 0
CONDITION TMP_623"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
(0,0)

IRs:
RETURN 0,0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
activeTier = getActiveTier()

IRs:
TMP_624(uint256) = INTERNAL_CALL, CrowdSale.getActiveTier()()
activeTier(uint256) := TMP_624(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
activeTier == tiers.length

IRs:
REF_336 -> LENGTH tiers
TMP_625(bool) = activeTier == REF_336
CONDITION TMP_625"];
5->6[label="True"];
5->12[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
endTime < block.timestamp

IRs:
TMP_626(bool) = endTime < block.timestamp
CONDITION TMP_626"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
(0,0)

IRs:
RETURN 0,0"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
startTime > block.timestamp

IRs:
TMP_627(bool) = startTime > block.timestamp
CONDITION TMP_627"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
activeTier = PRE_ICO_TIER_FIRST

IRs:
activeTier(uint256) := PRE_ICO_TIER_FIRST(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
usdAmount = _tokens.mul((price * (100 - tiers[activeTier].discount) / 100))

IRs:
REF_338(SellableToken.Tier) -> tiers[activeTier]
REF_339(uint256) -> REF_338.discount
TMP_628(uint256) = 100 - REF_339
TMP_629(uint256) = price * TMP_628
TMP_630(uint256) = TMP_629 / 100
TMP_631(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokens', 'TMP_630'] 
usdAmount(uint256) := TMP_631(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
ethers = usdAmount.div(etherPriceInUSD)

IRs:
TMP_632(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['usdAmount', 'etherPriceInUSD'] 
ethers(uint256) := TMP_632(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
ethers < getMinEthersInvestment()

IRs:
TMP_633(uint256) = INTERNAL_CALL, SellableToken.getMinEthersInvestment()()
TMP_634(bool) = ethers < TMP_633
CONDITION TMP_634"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: RETURN 16

EXPRESSION:
(0,0)

IRs:
RETURN 0,0"];
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
usdAmount = usdAmount.div(uint256(10) ** 18)

IRs:
TMP_635 = CONVERT 10 to uint256
TMP_636(uint256) = TMP_635 ** 18
TMP_637(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['usdAmount', 'TMP_636'] 
usdAmount(uint256) := TMP_637(uint256)"];
18->19;
19[label="Node Type: RETURN 19

EXPRESSION:
(ethers,usdAmount)

IRs:
RETURN ethers,usdAmount"];
}
// Function: 8305.sol-CrowdSale-calculateTokensAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_609(bool) = _value == 0
CONDITION TMP_609"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
(0,0)

IRs:
RETURN 0,0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
activeTier = getActiveTier()

IRs:
TMP_610(uint256) = INTERNAL_CALL, CrowdSale.getActiveTier()()
activeTier(uint256) := TMP_610(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
activeTier == tiers.length

IRs:
REF_330 -> LENGTH tiers
TMP_611(bool) = activeTier == REF_330
CONDITION TMP_611"];
5->6[label="True"];
5->12[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
endTime < block.timestamp

IRs:
TMP_612(bool) = endTime < block.timestamp
CONDITION TMP_612"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: RETURN 7

EXPRESSION:
(0,0)

IRs:
RETURN 0,0"];
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
startTime > block.timestamp

IRs:
TMP_613(bool) = startTime > block.timestamp
CONDITION TMP_613"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
activeTier = PRE_ICO_TIER_FIRST

IRs:
activeTier(uint256) := PRE_ICO_TIER_FIRST(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
usdAmount = _value.mul(etherPriceInUSD)

IRs:
TMP_614(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'etherPriceInUSD'] 
usdAmount(uint256) := TMP_614(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
tokenAmount = usdAmount.div(price * (100 - tiers[activeTier].discount) / 100)

IRs:
REF_333(SellableToken.Tier) -> tiers[activeTier]
REF_334(uint256) -> REF_333.discount
TMP_615(uint256) = 100 - REF_334
TMP_616(uint256) = price * TMP_615
TMP_617(uint256) = TMP_616 / 100
TMP_618(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['usdAmount', 'TMP_617'] 
tokenAmount(uint256) := TMP_618(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
usdAmount = usdAmount.div(uint256(10) ** 18)

IRs:
TMP_619 = CONVERT 10 to uint256
TMP_620(uint256) = TMP_619 ** 18
TMP_621(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['usdAmount', 'TMP_620'] 
usdAmount(uint256) := TMP_621(uint256)"];
15->16;
16[label="Node Type: IF 16

EXPRESSION:
usdAmount < minPurchase

IRs:
TMP_622(bool) = usdAmount < minPurchase
CONDITION TMP_622"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: RETURN 17

EXPRESSION:
(0,0)

IRs:
RETURN 0,0"];
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: RETURN 19

EXPRESSION:
(tokenAmount,usdAmount)

IRs:
RETURN tokenAmount,usdAmount"];
}
// Function: 8305.sol-CrowdSale-changeICODates(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_start != 0 && _start < _end && _tierId < tiers.length)

IRs:
TMP_584(bool) = _start != 0
TMP_585(bool) = _start < _end
TMP_586(bool) = TMP_584 && TMP_585
REF_317 -> LENGTH tiers
TMP_587(bool) = _tierId < REF_317
TMP_588(bool) = TMP_586 && TMP_587
TMP_589(None) = SOLIDITY_CALL require(bool)(TMP_588)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
icoTier = tiers[_tierId]

IRs:
REF_318(SellableToken.Tier) -> tiers[_tierId]
icoTier(SellableToken.Tier) := REF_318(SellableToken.Tier)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
icoTier.startTime = _start

IRs:
REF_319(uint256) -> icoTier.startTime
REF_319(uint256) (->icoTier) := _start(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
icoTier.endTime = _end

IRs:
REF_320(uint256) -> icoTier.endTime
REF_320(uint256) (->icoTier) := _end(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
_tierId == PRE_ICO_TIER_FIRST

IRs:
TMP_590(bool) = _tierId == PRE_ICO_TIER_FIRST
CONDITION TMP_590"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _start

IRs:
startTime(uint256) := _start(uint256)"];
6->10;
7[label="Node Type: IF 7

EXPRESSION:
_tierId == ICO_TIER_LAST

IRs:
TMP_591(bool) = _tierId == ICO_TIER_LAST
CONDITION TMP_591"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
endTime = _end

IRs:
endTime(uint256) := _end(uint256)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: END_IF 10
"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
11->1;
}
// Function: 8305.sol-CrowdSale-getActiveTier()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < tiers.length

IRs:
REF_324 -> LENGTH tiers
TMP_603(bool) = i < REF_324
CONDITION TMP_603"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
block.timestamp >= tiers[i].startTime && block.timestamp <= tiers[i].endTime

IRs:
REF_325(SellableToken.Tier) -> tiers[i]
REF_326(uint256) -> REF_325.startTime
TMP_604(bool) = block.timestamp >= REF_326
REF_327(SellableToken.Tier) -> tiers[i]
REF_328(uint256) -> REF_327.endTime
TMP_605(bool) = block.timestamp <= REF_328
TMP_606(bool) = TMP_604 && TMP_605
CONDITION TMP_606"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
i

IRs:
RETURN i"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_607(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
uint256(tiers.length)

IRs:
REF_329 -> LENGTH tiers
TMP_608 = CONVERT REF_329 to uint256
RETURN TMP_608"];
}
// Function: 8305.sol-CrowdSale-getMinEthersInvestment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint256(1000000000000000000).mul(minPurchase).div(etherPriceInUSD)

IRs:
TMP_459 = CONVERT 1000000000000000000 to uint256
TMP_460(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_459', 'minPurchase'] 
TMP_461(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_460', 'etherPriceInUSD'] 
RETURN TMP_461"];
}
// Function: 8305.sol-CrowdSale-getStats(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
sold = soldTokens

IRs:
sold(uint256) := soldTokens(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
maxSupply = maxTokenSupply.sub(preICOStats.maxTokenSupply)

IRs:
REF_343(uint256) -> preICOStats.maxTokenSupply
TMP_638(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['maxTokenSupply', 'REF_343'] 
maxSupply(uint256) := TMP_638(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
min = minPurchase

IRs:
min(uint256) := minPurchase(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
soft = softCap

IRs:
soft(uint256) := softCap(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
hard = hardCap

IRs:
hard(uint256) := hardCap(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tokenPrice = price

IRs:
tokenPrice(uint256) := price(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
(tokensPerEth,usd) = calculateTokensAmount(1000000000000000000)

IRs:
TUPLE_0(uint256,uint256) = INTERNAL_CALL, CrowdSale.calculateTokensAmount(uint256)(1000000000000000000)
tokensPerEth(uint256)= UNPACK TUPLE_0 index: 0 
usd(uint256)= UNPACK TUPLE_0 index: 1 "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
(tokensPerBtc,usd) = calculateTokensAmount(_ethPerBtc)

IRs:
TUPLE_1(uint256,uint256) = INTERNAL_CALL, CrowdSale.calculateTokensAmount(uint256)(_ethPerBtc)
tokensPerBtc(uint256)= UNPACK TUPLE_1 index: 0 
usd(uint256)= UNPACK TUPLE_1 index: 1 "];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)"];
10->13;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
12->19;
13[label="Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < tiers.length

IRs:
REF_344 -> LENGTH tiers
TMP_639(bool) = i < REF_344
CONDITION TMP_639"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
tiersData[j ++] = uint256(tiers[i].discount)

IRs:
TMP_640(uint256) := j(uint256)
j(uint256) = j + 1
REF_345(uint256) -> tiersData[TMP_640]
REF_346(SellableToken.Tier) -> tiers[i]
REF_347(uint256) -> REF_346.discount
TMP_641 = CONVERT REF_347 to uint256
REF_345(uint256) (->tiersData) := TMP_641(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
tiersData[j ++] = uint256(tiers[i].startTime)

IRs:
TMP_642(uint256) := j(uint256)
j(uint256) = j + 1
REF_348(uint256) -> tiersData[TMP_642]
REF_349(SellableToken.Tier) -> tiers[i]
REF_350(uint256) -> REF_349.startTime
TMP_643 = CONVERT REF_350 to uint256
REF_348(uint256) (->tiersData) := TMP_643(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
tiersData[j ++] = uint256(tiers[i].endTime)

IRs:
TMP_644(uint256) := j(uint256)
j(uint256) = j + 1
REF_351(uint256) -> tiersData[TMP_644]
REF_352(SellableToken.Tier) -> tiers[i]
REF_353(uint256) -> REF_352.endTime
TMP_645 = CONVERT REF_353 to uint256
REF_351(uint256) (->tiersData) := TMP_645(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_646(uint256) := i(uint256)
i(uint256) = i + 1"];
18->14;
19[label="Node Type: RETURN 19

EXPRESSION:
(sold,maxSupply,min,soft,hard,tokenPrice,tokensPerEth,tokensPerBtc,tiersData)

IRs:
RETURN sold,maxSupply,min,soft,hard,tokenPrice,tokensPerEth,tokensPerBtc,tiersData"];
}
// Function: 8305.sol-CrowdSale-isActive()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
hardCap == collectedUSD.add(preICOStats.collectedUSD)

IRs:
REF_322(uint256) -> preICOStats.collectedUSD
TMP_593(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['collectedUSD', 'REF_322'] 
TMP_594(bool) = hardCap == TMP_593
CONDITION TMP_594"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
soldTokens == maxTokenSupply

IRs:
TMP_595(bool) = soldTokens == maxTokenSupply
CONDITION TMP_595"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
withinPeriod()

IRs:
TMP_596(bool) = INTERNAL_CALL, CrowdSale.withinPeriod()()
RETURN TMP_596"];
}
// Function: 8305.sol-CrowdSale-isRefundPossible()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isActive() || block.timestamp < startTime || collectedUSD.add(preICOStats.collectedUSD) >= softCap

IRs:
TMP_661(bool) = INTERNAL_CALL, CrowdSale.isActive()()
TMP_662(bool) = block.timestamp < startTime
TMP_663(bool) = TMP_661 || TMP_662
REF_364(uint256) -> preICOStats.collectedUSD
TMP_664(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['collectedUSD', 'REF_364'] 
TMP_665(bool) = TMP_664 >= softCap
TMP_666(bool) = TMP_663 || TMP_665
CONDITION TMP_666"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-CrowdSale-isTransferAllowed(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
collectedUSD.add(preICOStats.collectedUSD) < softCap

IRs:
REF_357(uint256) -> preICOStats.collectedUSD
TMP_653(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['collectedUSD', 'REF_357'] 
TMP_654(bool) = TMP_653 < softCap
CONDITION TMP_654"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
token.balanceOf(_from) >= icoBalances[_from] && token.balanceOf(_from).sub(icoBalances[_from]) > _value

IRs:
TMP_655(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:balanceOf, arguments:['_from']  
REF_359(uint256) -> icoBalances[_from]
TMP_656(bool) = TMP_655 >= REF_359
TMP_657(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:balanceOf, arguments:['_from']  
REF_362(uint256) -> icoBalances[_from]
TMP_658(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_657', 'REF_362'] 
TMP_659(bool) = TMP_658 > _value
TMP_660(bool) = TMP_656 && TMP_659
CONDITION TMP_660"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
8[label="Node Type: RETURN 8

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 8305.sol-CrowdSale-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
mintInternal(_address,_tokenAmount)

IRs:
TMP_457(uint256) = INTERNAL_CALL, SellableToken.mintInternal(address,uint256)(_address,_tokenAmount)
RETURN TMP_457"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-CrowdSale-mintInternal(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
mintedAmount = token.mint(_address,_tokenAmount)

IRs:
TMP_477(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:mint, arguments:['_address', '_tokenAmount']  
mintedAmount(uint256) := TMP_477(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(mintedAmount == _tokenAmount)

IRs:
TMP_478(bool) = mintedAmount == _tokenAmount
TMP_479(None) = SOLIDITY_CALL require(bool)(TMP_478)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
soldTokens = soldTokens.add(_tokenAmount)

IRs:
TMP_480(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['soldTokens', '_tokenAmount'] 
soldTokens(uint256) := TMP_480(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
maxTokenSupply > 0

IRs:
TMP_481(bool) = maxTokenSupply > 0
CONDITION TMP_481"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(maxTokenSupply >= soldTokens)

IRs:
TMP_482(bool) = maxTokenSupply >= soldTokens
TMP_483(None) = SOLIDITY_CALL require(bool)(TMP_482)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
_tokenAmount

IRs:
RETURN _tokenAmount"];
}
// Function: 8305.sol-CrowdSale-mintPreICO(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
mintedAmount = token.mint(_address,_tokenAmount)

IRs:
TMP_685(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:mint, arguments:['_address', '_tokenAmount']  
mintedAmount(uint256) := TMP_685(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(mintedAmount == _tokenAmount)

IRs:
TMP_686(bool) = mintedAmount == _tokenAmount
TMP_687(None) = SOLIDITY_CALL require(bool)(TMP_686)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
preICOStats.soldTokens = preICOStats.soldTokens.add(_tokenAmount)

IRs:
REF_384(uint256) -> preICOStats.soldTokens
REF_385(uint256) -> preICOStats.soldTokens
TMP_688(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_385', '_tokenAmount'] 
REF_384(uint256) (->preICOStats) := TMP_688(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
preICOStats.collectedEthers = preICOStats.collectedEthers.add(_ethAmount)

IRs:
REF_387(uint256) -> preICOStats.collectedEthers
REF_388(uint256) -> preICOStats.collectedEthers
TMP_689(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_388', '_ethAmount'] 
REF_387(uint256) (->preICOStats) := TMP_689(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
preICOStats.collectedUSD = preICOStats.collectedUSD.add(_usdAmount)

IRs:
REF_390(uint256) -> preICOStats.collectedUSD
REF_391(uint256) -> preICOStats.collectedUSD
TMP_690(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_391', '_usdAmount'] 
REF_390(uint256) (->preICOStats) := TMP_690(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(preICOStats.maxTokenSupply >= preICOStats.soldTokens)

IRs:
REF_393(uint256) -> preICOStats.maxTokenSupply
REF_394(uint256) -> preICOStats.soldTokens
TMP_691(bool) = REF_393 >= REF_394
TMP_692(None) = SOLIDITY_CALL require(bool)(TMP_691)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(maxTokenSupply >= preICOStats.soldTokens)

IRs:
REF_395(uint256) -> preICOStats.soldTokens
TMP_693(bool) = maxTokenSupply >= REF_395
TMP_694(None) = SOLIDITY_CALL require(bool)(TMP_693)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
_tokenAmount

IRs:
RETURN _tokenAmount"];
}
// Function: 8305.sol-CrowdSale-moveUnsoldTokensToICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
unsoldTokens = preICOStats.maxTokenSupply - preICOStats.soldTokens

IRs:
REF_375(uint256) -> preICOStats.maxTokenSupply
REF_376(uint256) -> preICOStats.soldTokens
TMP_679(uint256) = REF_375 - REF_376
unsoldTokens(uint256) := TMP_679(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
unsoldTokens > 0

IRs:
TMP_680(bool) = unsoldTokens > 0
CONDITION TMP_680"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
preICOStats.maxTokenSupply = preICOStats.soldTokens

IRs:
REF_377(uint256) -> preICOStats.maxTokenSupply
REF_378(uint256) -> preICOStats.soldTokens
REF_377(uint256) (->preICOStats) := REF_378(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 8305.sol-CrowdSale-multivestBuy(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(buy(_address,_value) == true)

IRs:
TMP_501(bool) = INTERNAL_CALL, CrowdSale.buy(address,uint256)(_address,_value)
TMP_502(bool) = TMP_501 == True
TMP_503(None) = SOLIDITY_CALL require(bool)(TMP_502)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAllowedMultivests(msg.sender)

IRs:
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(msg.sender)"];
2->1;
}
// Function: 8305.sol-CrowdSale-multivestBuy(address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address == msg.sender && buy(msg.sender,msg.value) == true)

IRs:
TMP_505(bool) = _address == msg.sender
TMP_506(bool) = INTERNAL_CALL, CrowdSale.buy(address,uint256)(msg.sender,msg.value)
TMP_507(bool) = TMP_506 == True
TMP_508(bool) = TMP_505 && TMP_507
TMP_509(None) = SOLIDITY_CALL require(bool)(TMP_508)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAllowedMultivests(verify(keccak256()(msg.sender),_v,_r,_s))

IRs:
TMP_510(bytes32) = SOLIDITY_CALL keccak256()(msg.sender)
TMP_511(address) = INTERNAL_CALL, Multivest.verify(bytes32,uint8,bytes32,bytes32)(TMP_510,_v,_r,_s)
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(TMP_511)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAllowedMultivests(verify(keccak256()(msg.sender),_v,_r,_s))

IRs:
TMP_513(bytes32) = SOLIDITY_CALL keccak256()(msg.sender)
TMP_514(address) = INTERNAL_CALL, Multivest.verify(bytes32,uint8,bytes32,bytes32)(TMP_513,_v,_r,_s)
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(TMP_514)"];
3->1;
}
// Function: 8305.sol-CrowdSale-onlyAllowedMultivests(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(allowedMultivests[_addresss] == true)

IRs:
REF_411(bool) -> allowedMultivests[_addresss]
TMP_729(bool) = REF_411 == True
TMP_730(None) = SOLIDITY_CALL require(bool)(TMP_729)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-CrowdSale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_731(bool) = msg.sender == owner
TMP_732(None) = SOLIDITY_CALL require(bool)(TMP_731)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-CrowdSale-parseInt(string,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bresult = bytes(_a)

IRs:
TMP_484 = CONVERT _a to bytes
bresult(bytes) := TMP_484(bytes)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
res = 0

IRs:
res(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
decimals = false

IRs:
decimals(bool) := False(bool)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->22;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < bresult.length

IRs:
REF_247 -> LENGTH bresult
TMP_485(bool) = i < REF_247
CONDITION TMP_485"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
(bresult[i] >= 48) && (bresult[i] <= 57)

IRs:
REF_248(None) -> bresult[i]
TMP_486(bool) = REF_248 >= 48
REF_249(None) -> bresult[i]
TMP_487(bool) = REF_249 <= 57
TMP_488(bool) = TMP_486 && TMP_487
CONDITION TMP_488"];
8->9[label="True"];
8->17[label="False"];
9[label="Node Type: IF 9

EXPRESSION:
decimals

IRs:
CONDITION decimals"];
9->10[label="True"];
9->14[label="False"];
10[label="Node Type: IF 10

EXPRESSION:
_b == 0

IRs:
TMP_489(bool) = _b == 0
CONDITION TMP_489"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: BREAK 11
"];
11->5;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_b --

IRs:
TMP_490(uint256) := _b(uint256)
_b(uint256) = _b - 1"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
res *= 10

IRs:
res(uint256) = res * 10"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
res += uint256(bresult[i]) - 48

IRs:
REF_250(None) -> bresult[i]
TMP_491 = CONVERT REF_250 to uint256
TMP_492(uint256) = TMP_491 - 48
res(uint256) = res + TMP_492"];
16->20;
17[label="Node Type: IF 17

EXPRESSION:
bresult[i] == 46

IRs:
REF_251(None) -> bresult[i]
TMP_493(bool) = REF_251 == 46
CONDITION TMP_493"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
decimals = true

IRs:
decimals(bool) := True(bool)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
i ++

IRs:
TMP_494(uint256) := i(uint256)
i(uint256) = i + 1"];
21->7;
22[label="Node Type: IF 22

EXPRESSION:
_b > 0

IRs:
TMP_495(bool) = _b > 0
CONDITION TMP_495"];
22->23[label="True"];
22->24[label="False"];
23[label="Node Type: EXPRESSION 23

EXPRESSION:
res *= 10 ** _b

IRs:
TMP_496(uint256) = 10 ** _b
res(uint256) = res * TMP_496"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: RETURN 25

EXPRESSION:
res

IRs:
RETURN res"];
}
// Function: 8305.sol-CrowdSale-refund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isRefundPossible() || etherBalances[msg.sender] == 0

IRs:
TMP_667(bool) = INTERNAL_CALL, CrowdSale.isRefundPossible()()
TMP_668 = UnaryType.BANG TMP_667 
REF_365(uint256) -> etherBalances[msg.sender]
TMP_669(bool) = REF_365 == 0
TMP_670(bool) = TMP_668 || TMP_669
CONDITION TMP_670"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
burnedAmount = token.burnInvestorTokens(msg.sender,icoBalances[msg.sender])

IRs:
REF_367(uint256) -> icoBalances[msg.sender]
TMP_671(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:burnInvestorTokens, arguments:['msg.sender', 'REF_367']  
burnedAmount(uint256) := TMP_671(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
burnedAmount == 0

IRs:
TMP_672(bool) = burnedAmount == 0
CONDITION TMP_672"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
etherBalance = etherBalances[msg.sender]

IRs:
REF_368(uint256) -> etherBalances[msg.sender]
etherBalance(uint256) := REF_368(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
etherBalances[msg.sender] = 0

IRs:
REF_369(uint256) -> etherBalances[msg.sender]
REF_369(uint256) (->etherBalances) := 0(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
msg.sender.transfer(etherBalance)

IRs:
Transfer dest:msg.sender value:etherBalance"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Refund(msg.sender,etherBalance,burnedAmount)

IRs:
Emit Refund(msg.sender,etherBalance,burnedAmount)"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-CrowdSale-setAllowedMultivest(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowedMultivests[_address] = true

IRs:
REF_252(bool) -> allowedMultivests[_address]
REF_252(bool) (->allowedMultivests) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultivestSet(_address)

IRs:
Emit MultivestSet(_address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-CrowdSale-setEtherHolder(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
_etherHolder != address(0)

IRs:
TMP_452 = CONVERT 0 to address
TMP_453(bool) = _etherHolder != TMP_452
CONDITION TMP_453"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
etherHolder = _etherHolder

IRs:
etherHolder(address) := _etherHolder(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-CrowdSale-setEtherInUSD(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bytePrice = bytes(_price)

IRs:
TMP_462 = CONVERT _price to bytes
bytePrice(bytes) := TMP_462(bytes)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
dot = bytePrice.length.sub(uint256(6))

IRs:
REF_241 -> LENGTH bytePrice
TMP_463 = CONVERT 6 to uint256
TMP_464(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_241', 'TMP_463'] 
dot(uint256) := TMP_464(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(0x2e == uint256(bytePrice[dot]))

IRs:
REF_243(None) -> bytePrice[dot]
TMP_465 = CONVERT REF_243 to uint256
TMP_466(bool) = 46 == TMP_465
TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
newPrice = uint256(10 ** 23).div(parseInt(_price,5))

IRs:
TMP_468(uint256) = 10 ** 23
TMP_469 = CONVERT TMP_468 to uint256
TMP_470(uint256) = INTERNAL_CALL, SellableToken.parseInt(string,uint256)(_price,5)
TMP_471(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_469', 'TMP_470'] 
newPrice(uint256) := TMP_471(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(newPrice > 0)

IRs:
TMP_472(bool) = newPrice > 0
TMP_473(None) = SOLIDITY_CALL require(bool)(TMP_472)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
etherPriceInUSD = parseInt(_price,5)

IRs:
TMP_474(uint256) = INTERNAL_CALL, SellableToken.parseInt(string,uint256)(_price,5)
etherPriceInUSD(uint256) := TMP_474(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
priceUpdateAt = block.timestamp

IRs:
priceUpdateAt(uint256) := block.timestamp(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
NewPriceTicker(_price)

IRs:
Emit NewPriceTicker(_price)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyAllowedMultivests(msg.sender)

IRs:
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(msg.sender)"];
9->1;
}
// Function: 8305.sol-CrowdSale-setPrivateSale(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
_privateSale != address(0)

IRs:
TMP_599 = CONVERT 0 to address
TMP_600(bool) = _privateSale != TMP_599
CONDITION TMP_600"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
privateSale = SellableToken(_privateSale)

IRs:
TMP_601 = CONVERT _privateSale to SellableToken
privateSale(SellableToken) := TMP_601(SellableToken)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-CrowdSale-setPurchaseLimits(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
_min < _max

IRs:
TMP_455(bool) = _min < _max
CONDITION TMP_455"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minPurchase = _min

IRs:
minPurchase(uint256) := _min(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
maxPurchase = _max

IRs:
maxPurchase(uint256) := _max(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 8305.sol-CrowdSale-setTokenContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_447 = CONVERT 0 to address
TMP_448(bool) = _token != TMP_447
TMP_449(None) = SOLIDITY_CALL require(bool)(TMP_448)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token = GigToken(_token)

IRs:
TMP_450 = CONVERT _token to GigToken
token(GigToken) := TMP_450(GigToken)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-CrowdSale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MONTH_IN_SEC = 2629743

IRs:
MONTH_IN_SEC(uint256) := 2629743(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
PRE_ICO_TIER_FIRST = 0

IRs:
PRE_ICO_TIER_FIRST(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
PRE_ICO_TIER_LAST = 4

IRs:
PRE_ICO_TIER_LAST(uint256) := 4(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
ICO_TIER_FIRST = 5

IRs:
ICO_TIER_FIRST(uint256) := 5(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
ICO_TIER_LAST = 8

IRs:
ICO_TIER_LAST(uint256) := 8(uint256)"];
}
// Function: 8305.sol-CrowdSale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
minPurchase = 100 * 10 ** 5

IRs:
TMP_727(uint256) = 10 ** 5
TMP_728(uint256) = 100 * TMP_727
minPurchase(uint256) := TMP_728(uint256)"];
}
// Function: 8305.sol-CrowdSale-transferEthers()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
collectedUSD.add(preICOStats.collectedUSD) >= softCap

IRs:
REF_380(uint256) -> preICOStats.collectedUSD
TMP_682(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['collectedUSD', 'REF_380'] 
TMP_683(bool) = TMP_682 >= softCap
CONDITION TMP_683"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
etherHolder.transfer(this.balance)

IRs:
REF_382(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:etherHolder value:REF_382"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 8305.sol-CrowdSale-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_518 = CONVERT 0 to address
TMP_519(bool) = newOwner != TMP_518
TMP_520(None) = SOLIDITY_CALL require(bool)(TMP_519)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-CrowdSale-unsetAllowedMultivest(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowedMultivests[_address] = false

IRs:
REF_253(bool) -> allowedMultivests[_address]
REF_253(bool) (->allowedMultivests) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultivestUnset(_address)

IRs:
Emit MultivestUnset(_address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-CrowdSale-updatePreICOMaxTokenSupply(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == address(privateSale)

IRs:
TMP_675 = CONVERT privateSale to address
TMP_676(bool) = msg.sender == TMP_675
CONDITION TMP_676"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
maxTokenSupply = maxTokenSupply.add(_amount)

IRs:
TMP_677(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['maxTokenSupply', '_amount'] 
maxTokenSupply(uint256) := TMP_677(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
preICOStats.maxTokenSupply = preICOStats.maxTokenSupply.add(_amount)

IRs:
REF_372(uint256) -> preICOStats.maxTokenSupply
REF_373(uint256) -> preICOStats.maxTokenSupply
TMP_678(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_373', '_amount'] 
REF_372(uint256) (->preICOStats) := TMP_678(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 8305.sol-CrowdSale-verify(bytes32,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
prefix = Ethereum Signed Message:
32

IRs:
prefix(bytes) := Ethereum Signed Message:
32(string)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(prefix,_hash),_v,_r,_s)

IRs:
TMP_516(bytes32) = SOLIDITY_CALL keccak256()(prefix,_hash)
TMP_517(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_516,_v,_r,_s)
RETURN TMP_517"];
}
// Function: 8305.sol-CrowdSale-withinPeriod()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
getActiveTier() != tiers.length

IRs:
TMP_597(uint256) = INTERNAL_CALL, CrowdSale.getActiveTier()()
REF_323 -> LENGTH tiers
TMP_598(bool) = TMP_597 != REF_323
RETURN TMP_598"];
}
// Function: 8305.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 8305.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 8305.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 8305.sol-ERC20-totalSupply()
digraph{
}
// Function: 8305.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 8305.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 8305.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 8305.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 8305.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 8305.sol-GigERC20-GigERC20(uint256,string,uint8,string,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
standard = ERC20 0.1

IRs:
standard(string) := ERC20 0.1(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
locked = _locked

IRs:
locked(bool) := _locked(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = _totalSupply

IRs:
totalSupply_(uint256) := _totalSupply(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_transferAllSupplyToOwner

IRs:
CONDITION _transferAllSupplyToOwner"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = totalSupply_

IRs:
REF_92(uint256) -> balances[msg.sender]
REF_92(uint256) (->balances) := totalSupply_(uint256)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[this] = totalSupply_

IRs:
REF_93(uint256) -> balances[this]
REF_93(uint256) (->balances) := totalSupply_(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 8305.sol-GigERC20-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 8305.sol-GigERC20-allowance(address,address)
digraph{
}
// Function: 8305.sol-GigERC20-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
locked

IRs:
CONDITION locked"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
super.approve(_spender,_value)

IRs:
TMP_74(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
RETURN TMP_74"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigERC20-balanceOf(address)
digraph{
}
// Function: 8305.sol-GigERC20-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
locked

IRs:
CONDITION locked"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
super.decreaseApproval(_spender,_subtractedValue)

IRs:
TMP_76(bool) = INTERNAL_CALL, StandardToken.decreaseApproval(address,uint256)(_spender,_subtractedValue)
RETURN TMP_76"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigERC20-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
locked

IRs:
CONDITION locked"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
super.increaseApproval(_spender,_addedValue)

IRs:
TMP_75(bool) = INTERNAL_CALL, StandardToken.increaseApproval(address,uint256)(_spender,_addedValue)
RETURN TMP_75"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigERC20-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_78(bool) = msg.sender == owner
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-GigERC20-setLocked(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
locked = _locked

IRs:
locked(bool) := _locked(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-GigERC20-totalSupply()
digraph{
}
// Function: 8305.sol-GigERC20-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(locked == false)

IRs:
TMP_71(bool) = locked == False
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_73(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)
RETURN TMP_73"];
}
// Function: 8305.sol-GigERC20-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
locked

IRs:
CONDITION locked"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_77(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_77"];
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigERC20-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_40 = CONVERT 0 to address
TMP_41(bool) = newOwner != TMP_40
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-GigToken-GigERC20(uint256,string,uint8,string,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
standard = ERC20 0.1

IRs:
standard(string) := ERC20 0.1(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
locked = _locked

IRs:
locked(bool) := _locked(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = _totalSupply

IRs:
totalSupply_(uint256) := _totalSupply(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_transferAllSupplyToOwner

IRs:
CONDITION _transferAllSupplyToOwner"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = totalSupply_

IRs:
REF_155(uint256) -> balances[msg.sender]
REF_155(uint256) (->balances) := totalSupply_(uint256)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[this] = totalSupply_

IRs:
REF_156(uint256) -> balances[this]
REF_156(uint256) (->balances) := totalSupply_(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 8305.sol-GigToken-GigToken(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
standard = GBTC 0.1

IRs:
standard(string) := GBTC 0.1(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
maxSupply = uint256(1000000000).mul(uint256(10) ** decimals)

IRs:
TMP_204 = CONVERT 1000000000 to uint256
TMP_205 = CONVERT 10 to uint256
TMP_206(uint256) = TMP_205 ** decimals
TMP_207(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_204', 'TMP_206'] 
maxSupply(uint256) := TMP_207(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
MintingERC20(0,maxSupply,GigBit,18,GBTC,false,_locked)

IRs:
INTERNAL_CALL, MintingERC20.MintingERC20(uint256,uint256,string,uint8,string,bool,bool)(0,maxSupply,GigBit,18,GBTC,False,_locked)"];
3->1;
}
// Function: 8305.sol-GigToken-MintingERC20(uint256,uint256,string,uint8,string,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
standard = MintingERC20 0.1

IRs:
standard(string) := MintingERC20 0.1(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minters[msg.sender] = true

IRs:
REF_147(bool) -> minters[msg.sender]
REF_147(bool) (->minters) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
maxSupply = _maxSupply

IRs:
maxSupply(uint256) := _maxSupply(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
GigERC20(_initialSupply,_tokenName,_decimals,_symbol,_transferAllSupplyToOwner,_locked)

IRs:
INTERNAL_CALL, GigERC20.GigERC20(uint256,string,uint8,string,bool,bool)(_initialSupply,_tokenName,_decimals,_symbol,_transferAllSupplyToOwner,_locked)"];
4->1;
}
// Function: 8305.sol-GigToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 8305.sol-GigToken-addMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minters[_newMinter] = true

IRs:
REF_148(bool) -> minters[_newMinter]
REF_148(bool) (->minters) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-GigToken-allowance(address,address)
digraph{
}
// Function: 8305.sol-GigToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(crowdSaleEndTime <= block.timestamp)

IRs:
TMP_256(bool) = crowdSaleEndTime <= block.timestamp
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.approve(_spender,_value)

IRs:
TMP_258(bool) = INTERNAL_CALL, GigERC20.approve(address,uint256)(_spender,_value)
RETURN TMP_258"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigToken-balanceOf(address)
digraph{
}
// Function: 8305.sol-GigToken-burnInvestorTokens(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp > crowdSaleEndTime)

IRs:
TMP_267(bool) = block.timestamp > crowdSaleEndTime
TMP_268(None) = SOLIDITY_CALL require(bool)(TMP_267)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= balances[_address])

IRs:
REF_211(uint256) -> balances[_address]
TMP_269(bool) = _amount <= REF_211
TMP_270(None) = SOLIDITY_CALL require(bool)(TMP_269)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_address] = balances[_address].sub(_amount)

IRs:
REF_212(uint256) -> balances[_address]
REF_213(uint256) -> balances[_address]
TMP_271(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_213', '_amount'] 
REF_212(uint256) (->balances) := TMP_271(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_amount)

IRs:
TMP_272(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_amount'] 
totalSupply_(uint256) := TMP_272(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_address,address(0),_amount)

IRs:
TMP_273 = CONVERT 0 to address
Emit Transfer(_address,TMP_273,_amount)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
_amount

IRs:
RETURN _amount"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyCrowdSale()

IRs:
MODIFIER_CALL, GigToken.onlyCrowdSale()()"];
7->1;
}
// Function: 8305.sol-GigToken-burnUnsoldTokens(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp > crowdSaleEndTime)

IRs:
TMP_276(bool) = block.timestamp > crowdSaleEndTime
TMP_277(None) = SOLIDITY_CALL require(bool)(TMP_276)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
maxSupply = maxSupply.sub(_amount)

IRs:
TMP_278(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['maxSupply', '_amount'] 
maxSupply(uint256) := TMP_278(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
MaxSupplyBurned(_amount)

IRs:
Emit MaxSupplyBurned(_amount)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyCrowdSale()

IRs:
MODIFIER_CALL, GigToken.onlyCrowdSale()()"];
4->1;
}
// Function: 8305.sol-GigToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(crowdSaleEndTime <= block.timestamp)

IRs:
TMP_262(bool) = crowdSaleEndTime <= block.timestamp
TMP_263(None) = SOLIDITY_CALL require(bool)(TMP_262)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.decreaseApproval(_spender,_subtractedValue)

IRs:
TMP_264(bool) = INTERNAL_CALL, GigERC20.decreaseApproval(address,uint256)(_spender,_subtractedValue)
RETURN TMP_264"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigToken-freezing(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferFrozen = _transferFrozen

IRs:
transferFrozen(bool) := _transferFrozen(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-GigToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(crowdSaleEndTime <= block.timestamp)

IRs:
TMP_259(bool) = crowdSaleEndTime <= block.timestamp
TMP_260(None) = SOLIDITY_CALL require(bool)(TMP_259)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.increaseApproval(_spender,_addedValue)

IRs:
TMP_261(bool) = INTERNAL_CALL, GigERC20.increaseApproval(address,uint256)(_spender,_addedValue)
RETURN TMP_261"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigToken-increaseLockedBalance(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
lockedBalancesReleasedAfterOneYear[_address] = lockedBalancesReleasedAfterOneYear[_address].add(_tokens)

IRs:
REF_208(uint256) -> lockedBalancesReleasedAfterOneYear[_address]
REF_209(uint256) -> lockedBalancesReleasedAfterOneYear[_address]
TMP_265(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_209', '_tokens'] 
REF_208(uint256) (->lockedBalancesReleasedAfterOneYear) := TMP_265(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlySales()

IRs:
MODIFIER_CALL, GigToken.onlySales()()"];
2->1;
}
// Function: 8305.sol-GigToken-isTransferAllowed(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
senderBalance = balanceOf(_from)

IRs:
TMP_221(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_from)
senderBalance(uint256) := TMP_221(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
transferFrozen == true || senderBalance < _value

IRs:
TMP_222(bool) = transferFrozen == True
TMP_223(bool) = senderBalance < _value
TMP_224(bool) = TMP_222 || TMP_223
CONDITION TMP_224"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
lockedBalance = lockedBalancesReleasedAfterOneYear[_from]

IRs:
REF_201(uint256) -> lockedBalancesReleasedAfterOneYear[_from]
lockedBalance(uint256) := REF_201(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance

IRs:
TMP_225(bool) = lockedBalance > 0
TMP_226(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['senderBalance', '_value'] 
TMP_227(bool) = TMP_226 < lockedBalance
TMP_228(bool) = TMP_225 && TMP_227
CONDITION TMP_228"];
6->7[label="True"];
6->22[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
unlockTime = crowdSaleEndTime + 220752000

IRs:
TMP_229(uint256) = crowdSaleEndTime + 220752000
unlockTime(uint256) := TMP_229(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
crowdSaleEndTime == 0 || block.timestamp < unlockTime

IRs:
TMP_230(bool) = crowdSaleEndTime == 0
TMP_231(bool) = block.timestamp < unlockTime
TMP_232(bool) = TMP_230 || TMP_231
CONDITION TMP_232"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
secsFromUnlock = block.timestamp.sub(unlockTime)

IRs:
TMP_233(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.timestamp', 'unlockTime'] 
secsFromUnlock(uint256) := TMP_233(uint256)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
months = secsFromUnlock / 2592000

IRs:
TMP_234(uint256) = secsFromUnlock / 2592000
months(uint256) := TMP_234(uint256)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
months > 12

IRs:
TMP_235(bool) = months > 12
CONDITION TMP_235"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
months = 12

IRs:
months(uint256) := 12(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: NEW VARIABLE 16

EXPRESSION:
tokensPerMonth = lockedBalance / 12

IRs:
TMP_236(uint256) = lockedBalance / 12
tokensPerMonth(uint256) := TMP_236(uint256)"];
16->17;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
unlockedBalance = tokensPerMonth.mul(months)

IRs:
TMP_237(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerMonth', 'months'] 
unlockedBalance(uint256) := TMP_237(uint256)"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
actualLockedBalance = lockedBalance.sub(unlockedBalance)

IRs:
TMP_238(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['lockedBalance', 'unlockedBalance'] 
actualLockedBalance(uint256) := TMP_238(uint256)"];
18->19;
19[label="Node Type: IF 19

EXPRESSION:
senderBalance.sub(_value) < actualLockedBalance

IRs:
TMP_239(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['senderBalance', '_value'] 
TMP_240(bool) = TMP_239 < actualLockedBalance
CONDITION TMP_240"];
19->20[label="True"];
19->21[label="False"];
20[label="Node Type: RETURN 20

EXPRESSION:
false

IRs:
RETURN False"];
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
block.timestamp < crowdSaleEndTime && crowdSale != address(0) && crowdSale.isTransferAllowed(_from,_value) == false

IRs:
TMP_241(bool) = block.timestamp < crowdSaleEndTime
TMP_242 = CONVERT 0 to address
TMP_243(bool) = crowdSale != TMP_242
TMP_244(bool) = TMP_241 && TMP_243
TMP_245(bool) = HIGH_LEVEL_CALL, dest:crowdSale(SellableToken), function:isTransferAllowed, arguments:['_from', '_value']  
TMP_246(bool) = TMP_245 == False
TMP_247(bool) = TMP_244 && TMP_246
CONDITION TMP_247"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: RETURN 24

EXPRESSION:
false

IRs:
RETURN False"];
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: RETURN 26

EXPRESSION:
true

IRs:
RETURN True"];
27[label="Node Type: RETURN 27

EXPRESSION:
status

IRs:
RETURN status"];
}
// Function: 8305.sol-GigToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: IF 1

EXPRESSION:
true == locked

IRs:
TMP_153(bool) = True == locked
CONDITION TMP_153"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
uint256(0)

IRs:
TMP_154 = CONVERT 0 to uint256
RETURN TMP_154"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_amount == uint256(0)

IRs:
TMP_155 = CONVERT 0 to uint256
TMP_156(bool) = _amount == TMP_155
CONDITION TMP_156"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
uint256(0)

IRs:
TMP_157 = CONVERT 0 to uint256
RETURN TMP_157"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
totalSupply_.add(_amount) > maxSupply

IRs:
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
TMP_159(bool) = TMP_158 > maxSupply
CONDITION TMP_159"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
uint256(0)

IRs:
TMP_160 = CONVERT 0 to uint256
RETURN TMP_160"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
totalSupply_ = totalSupply_.add(_amount)

IRs:
TMP_161(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
totalSupply_(uint256) := TMP_161(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
balances[_addr] = balances[_addr].add(_amount)

IRs:
REF_152(uint256) -> balances[_addr]
REF_153(uint256) -> balances[_addr]
TMP_162(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_153', '_amount'] 
REF_152(uint256) (->balances) := TMP_162(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(address(0),_addr,_amount)

IRs:
TMP_163 = CONVERT 0 to address
Emit Transfer(TMP_163,_addr,_amount)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
_amount

IRs:
RETURN _amount"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyMinters()

IRs:
MODIFIER_CALL, MintingERC20.onlyMinters()()"];
14->1;
}
// Function: 8305.sol-GigToken-onlyCrowdSale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(crowdSale != address(0) && msg.sender == address(crowdSale))

IRs:
TMP_285 = CONVERT 0 to address
TMP_286(bool) = crowdSale != TMP_285
TMP_287 = CONVERT crowdSale to address
TMP_288(bool) = msg.sender == TMP_287
TMP_289(bool) = TMP_286 && TMP_288
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-GigToken-onlyMinters()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(true == minters[msg.sender])

IRs:
REF_217(bool) -> minters[msg.sender]
TMP_281(bool) = True == REF_217
TMP_282(None) = SOLIDITY_CALL require(bool)(TMP_281)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-GigToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_283(bool) = msg.sender == owner
TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-GigToken-onlySales()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((privateSale != address(0) && msg.sender == address(privateSale)) || (crowdSale != address(0) && msg.sender == address(crowdSale)))

IRs:
TMP_291 = CONVERT 0 to address
TMP_292(bool) = privateSale != TMP_291
TMP_293 = CONVERT privateSale to address
TMP_294(bool) = msg.sender == TMP_293
TMP_295(bool) = TMP_292 && TMP_294
TMP_296 = CONVERT 0 to address
TMP_297(bool) = crowdSale != TMP_296
TMP_298 = CONVERT crowdSale to address
TMP_299(bool) = msg.sender == TMP_298
TMP_300(bool) = TMP_297 && TMP_299
TMP_301(bool) = TMP_295 || TMP_300
TMP_302(None) = SOLIDITY_CALL require(bool)(TMP_301)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-GigToken-removeMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minters[_minter] = false

IRs:
REF_149(bool) -> minters[_minter]
REF_149(bool) (->minters) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-GigToken-setCrowdSale(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_crowdSale != address(0))

IRs:
TMP_209 = CONVERT 0 to address
TMP_210(bool) = _crowdSale != TMP_209
TMP_211(None) = SOLIDITY_CALL require(bool)(TMP_210)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
crowdSale = SellableToken(_crowdSale)

IRs:
TMP_212 = CONVERT _crowdSale to SellableToken
crowdSale(SellableToken) := TMP_212(SellableToken)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
crowdSaleEndTime = crowdSale.endTime()

IRs:
TMP_213(uint256) = HIGH_LEVEL_CALL, dest:crowdSale(SellableToken), function:endTime, arguments:[]  
crowdSaleEndTime(uint256) := TMP_213(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-GigToken-setLocked(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
locked = _locked

IRs:
locked(bool) := _locked(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-GigToken-setPrivateSale(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_privateSale != address(0))

IRs:
TMP_215 = CONVERT 0 to address
TMP_216(bool) = _privateSale != TMP_215
TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
privateSale = SellableToken(_privateSale)

IRs:
TMP_218 = CONVERT _privateSale to SellableToken
privateSale(SellableToken) := TMP_218(SellableToken)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-GigToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
transferFrozen = false

IRs:
transferFrozen(bool) := False(bool)"];
}
// Function: 8305.sol-GigToken-totalSupply()
digraph{
}
// Function: 8305.sol-GigToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isTransferAllowed(msg.sender,_value))

IRs:
TMP_248(bool) = INTERNAL_CALL, GigToken.isTransferAllowed(address,uint256)(msg.sender,_value)
TMP_249(None) = SOLIDITY_CALL require(bool)(TMP_248)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.transfer(_to,_value)

IRs:
TMP_250(bool) = INTERNAL_CALL, GigERC20.transfer(address,uint256)(_to,_value)
RETURN TMP_250"];
}
// Function: 8305.sol-GigToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from,_value))

IRs:
TMP_251(bool) = crowdSaleEndTime <= block.timestamp
TMP_252(bool) = INTERNAL_CALL, GigToken.isTransferAllowed(address,uint256)(_from,_value)
TMP_253(bool) = TMP_251 && TMP_252
TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
super.transferFrom(_from,_to,_value)

IRs:
TMP_255(bool) = INTERNAL_CALL, GigERC20.transferFrom(address,address,uint256)(_from,_to,_value)
RETURN TMP_255"];
3[label="Node Type: RETURN 3

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 8305.sol-GigToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_174 = CONVERT 0 to address
TMP_175(bool) = newOwner != TMP_174
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-MintingERC20-GigERC20(uint256,string,uint8,string,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
standard = ERC20 0.1

IRs:
standard(string) := ERC20 0.1(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
locked = _locked

IRs:
locked(bool) := _locked(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ = _totalSupply

IRs:
totalSupply_(uint256) := _totalSupply(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_transferAllSupplyToOwner

IRs:
CONDITION _transferAllSupplyToOwner"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = totalSupply_

IRs:
REF_94(uint256) -> balances[msg.sender]
REF_94(uint256) (->balances) := totalSupply_(uint256)"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balances[this] = totalSupply_

IRs:
REF_95(uint256) -> balances[this]
REF_95(uint256) (->balances) := totalSupply_(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
name = _tokenName

IRs:
name(string) := _tokenName(string)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
symbol = _tokenSymbol

IRs:
symbol(string) := _tokenSymbol(string)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
decimals = _decimalUnits

IRs:
decimals(uint8) := _decimalUnits(uint8)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
creationBlock = block.number

IRs:
creationBlock(uint256) := block.number(uint256)"];
}
// Function: 8305.sol-MintingERC20-MintingERC20(uint256,uint256,string,uint8,string,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
standard = MintingERC20 0.1

IRs:
standard(string) := MintingERC20 0.1(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minters[msg.sender] = true

IRs:
REF_138(bool) -> minters[msg.sender]
REF_138(bool) (->minters) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
maxSupply = _maxSupply

IRs:
maxSupply(uint256) := _maxSupply(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
GigERC20(_initialSupply,_tokenName,_decimals,_symbol,_transferAllSupplyToOwner,_locked)

IRs:
INTERNAL_CALL, GigERC20.GigERC20(uint256,string,uint8,string,bool,bool)(_initialSupply,_tokenName,_decimals,_symbol,_transferAllSupplyToOwner,_locked)"];
4->1;
}
// Function: 8305.sol-MintingERC20-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 8305.sol-MintingERC20-addMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minters[_newMinter] = true

IRs:
REF_139(bool) -> minters[_newMinter]
REF_139(bool) (->minters) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-MintingERC20-allowance(address,address)
digraph{
}
// Function: 8305.sol-MintingERC20-approve(address,uint256)
digraph{
}
// Function: 8305.sol-MintingERC20-balanceOf(address)
digraph{
}
// Function: 8305.sol-MintingERC20-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_121(mapping(address => uint256)) -> allowed[msg.sender]
REF_122(uint256) -> REF_121[_spender]
oldValue(uint256) := REF_122(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_119(bool) = _subtractedValue > oldValue
CONDITION TMP_119"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_123(mapping(address => uint256)) -> allowed[msg.sender]
REF_124(uint256) -> REF_123[_spender]
REF_124(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_125(mapping(address => uint256)) -> allowed[msg.sender]
REF_126(uint256) -> REF_125[_spender]
TMP_120(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_126(uint256) (->allowed) := TMP_120(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_128(mapping(address => uint256)) -> allowed[msg.sender]
REF_129(uint256) -> REF_128[_spender]
Emit Approval(msg.sender,_spender,REF_129)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-MintingERC20-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_114(mapping(address => uint256)) -> allowed[msg.sender]
REF_115(uint256) -> REF_114[_spender]
REF_116(mapping(address => uint256)) -> allowed[msg.sender]
REF_117(uint256) -> REF_116[_spender]
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', '_addedValue'] 
REF_115(uint256) (->allowed) := TMP_117(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_119(mapping(address => uint256)) -> allowed[msg.sender]
REF_120(uint256) -> REF_119[_spender]
Emit Approval(msg.sender,_spender,REF_120)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-MintingERC20-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: IF 1

EXPRESSION:
true == locked

IRs:
TMP_133(bool) = True == locked
CONDITION TMP_133"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
uint256(0)

IRs:
TMP_134 = CONVERT 0 to uint256
RETURN TMP_134"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
_amount == uint256(0)

IRs:
TMP_135 = CONVERT 0 to uint256
TMP_136(bool) = _amount == TMP_135
CONDITION TMP_136"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
uint256(0)

IRs:
TMP_137 = CONVERT 0 to uint256
RETURN TMP_137"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
totalSupply_.add(_amount) > maxSupply

IRs:
TMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
TMP_139(bool) = TMP_138 > maxSupply
CONDITION TMP_139"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
uint256(0)

IRs:
TMP_140 = CONVERT 0 to uint256
RETURN TMP_140"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
totalSupply_ = totalSupply_.add(_amount)

IRs:
TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] 
totalSupply_(uint256) := TMP_141(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
balances[_addr] = balances[_addr].add(_amount)

IRs:
REF_143(uint256) -> balances[_addr]
REF_144(uint256) -> balances[_addr]
TMP_142(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_144', '_amount'] 
REF_143(uint256) (->balances) := TMP_142(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
Transfer(address(0),_addr,_amount)

IRs:
TMP_143 = CONVERT 0 to address
Emit Transfer(TMP_143,_addr,_amount)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
_amount

IRs:
RETURN _amount"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyMinters()

IRs:
MODIFIER_CALL, MintingERC20.onlyMinters()()"];
14->1;
}
// Function: 8305.sol-MintingERC20-onlyMinters()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(true == minters[msg.sender])

IRs:
REF_146(bool) -> minters[msg.sender]
TMP_148(bool) = True == REF_146
TMP_149(None) = SOLIDITY_CALL require(bool)(TMP_148)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-MintingERC20-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_146(bool) = msg.sender == owner
TMP_147(None) = SOLIDITY_CALL require(bool)(TMP_146)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-MintingERC20-removeMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
minters[_minter] = false

IRs:
REF_140(bool) -> minters[_minter]
REF_140(bool) (->minters) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-MintingERC20-setLocked(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
locked = _locked

IRs:
locked(bool) := _locked(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-MintingERC20-totalSupply()
digraph{
}
// Function: 8305.sol-MintingERC20-transfer(address,uint256)
digraph{
}
// Function: 8305.sol-MintingERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 8305.sol-MintingERC20-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_100 = CONVERT 0 to address
TMP_101(bool) = newOwner != TMP_100
TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-Multivest-Multivest()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 8305.sol-Multivest-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 8305.sol-Multivest-buy(address,uint256)
digraph{
}
// Function: 8305.sol-Multivest-multivestBuy(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(buy(_address,_value) == true)

IRs:
TMP_312(bool) = INTERNAL_CALL, Multivest.buy(address,uint256)(_address,_value)
TMP_313(bool) = TMP_312 == True
TMP_314(None) = SOLIDITY_CALL require(bool)(TMP_313)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAllowedMultivests(msg.sender)

IRs:
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(msg.sender)"];
2->1;
}
// Function: 8305.sol-Multivest-multivestBuy(address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address == msg.sender && buy(msg.sender,msg.value) == true)

IRs:
TMP_316(bool) = _address == msg.sender
TMP_317(bool) = INTERNAL_CALL, Multivest.buy(address,uint256)(msg.sender,msg.value)
TMP_318(bool) = TMP_317 == True
TMP_319(bool) = TMP_316 && TMP_318
TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAllowedMultivests(verify(keccak256()(msg.sender),_v,_r,_s))

IRs:
TMP_321(bytes32) = SOLIDITY_CALL keccak256()(msg.sender)
TMP_322(address) = INTERNAL_CALL, Multivest.verify(bytes32,uint8,bytes32,bytes32)(TMP_321,_v,_r,_s)
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(TMP_322)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAllowedMultivests(verify(keccak256()(msg.sender),_v,_r,_s))

IRs:
TMP_324(bytes32) = SOLIDITY_CALL keccak256()(msg.sender)
TMP_325(address) = INTERNAL_CALL, Multivest.verify(bytes32,uint8,bytes32,bytes32)(TMP_324,_v,_r,_s)
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(TMP_325)"];
3->1;
}
// Function: 8305.sol-Multivest-onlyAllowedMultivests(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(allowedMultivests[_addresss] == true)

IRs:
REF_220(bool) -> allowedMultivests[_addresss]
TMP_331(bool) = REF_220 == True
TMP_332(None) = SOLIDITY_CALL require(bool)(TMP_331)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-Multivest-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_329(bool) = msg.sender == owner
TMP_330(None) = SOLIDITY_CALL require(bool)(TMP_329)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-Multivest-setAllowedMultivest(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowedMultivests[_address] = true

IRs:
REF_218(bool) -> allowedMultivests[_address]
REF_218(bool) (->allowedMultivests) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultivestSet(_address)

IRs:
Emit MultivestSet(_address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-Multivest-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_303 = CONVERT 0 to address
TMP_304(bool) = newOwner != TMP_303
TMP_305(None) = SOLIDITY_CALL require(bool)(TMP_304)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-Multivest-unsetAllowedMultivest(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowedMultivests[_address] = false

IRs:
REF_219(bool) -> allowedMultivests[_address]
REF_219(bool) (->allowedMultivests) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultivestUnset(_address)

IRs:
Emit MultivestUnset(_address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-Multivest-verify(bytes32,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
prefix = Ethereum Signed Message:
32

IRs:
prefix(bytes) := Ethereum Signed Message:
32(string)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(prefix,_hash),_v,_r,_s)

IRs:
TMP_327(bytes32) = SOLIDITY_CALL keccak256()(prefix,_hash)
TMP_328(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_327,_v,_r,_s)
RETURN TMP_328"];
}
// Function: 8305.sol-Ownable-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 8305.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_5(bool) = msg.sender == owner
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_0 = CONVERT 0 to address
TMP_1(bool) = newOwner != TMP_0
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_89(uint256) = a + b
c(uint256) := TMP_89(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_90(bool) = c >= a
TMP_91(None) = SOLIDITY_CALL assert(bool)(TMP_90)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 8305.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_85(uint256) = a / b
c(uint256) := TMP_85(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 8305.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_80(bool) = a == 0
CONDITION TMP_80"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
c = a * b

IRs:
TMP_81(uint256) = a * b
c(uint256) := TMP_81(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_82(uint256) = c / a
TMP_83(bool) = TMP_82 == b
TMP_84(None) = SOLIDITY_CALL assert(bool)(TMP_83)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 8305.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_86(bool) = b <= a
TMP_87(None) = SOLIDITY_CALL assert(bool)(TMP_86)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_88(uint256) = a - b
RETURN TMP_88"];
}
// Function: 8305.sol-SellableToken-Multivest()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 8305.sol-SellableToken-Ownable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 8305.sol-SellableToken-SellableToken(address,address,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0) && _etherHolder != address(0))

IRs:
TMP_359 = CONVERT 0 to address
TMP_360(bool) = _token != TMP_359
TMP_361 = CONVERT 0 to address
TMP_362(bool) = _etherHolder != TMP_361
TMP_363(bool) = TMP_360 && TMP_362
TMP_364(None) = SOLIDITY_CALL require(bool)(TMP_363)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token = GigToken(_token)

IRs:
TMP_365 = CONVERT _token to GigToken
token(GigToken) := TMP_365(GigToken)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_startTime < _endTime)

IRs:
TMP_366(bool) = _startTime < _endTime
TMP_367(None) = SOLIDITY_CALL require(bool)(TMP_366)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
etherHolder = _etherHolder

IRs:
etherHolder(address) := _etherHolder(address)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)((_maxTokenSupply == uint256(0)) || (_maxTokenSupply <= token.maxSupply()))

IRs:
TMP_368 = CONVERT 0 to uint256
TMP_369(bool) = _maxTokenSupply == TMP_368
TMP_370(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:maxSupply, arguments:[]  
TMP_371(bool) = _maxTokenSupply <= TMP_370
TMP_372(bool) = TMP_369 || TMP_371
TMP_373(None) = SOLIDITY_CALL require(bool)(TMP_372)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
startTime = _startTime

IRs:
startTime(uint256) := _startTime(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
endTime = _endTime

IRs:
endTime(uint256) := _endTime(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
maxTokenSupply = _maxTokenSupply

IRs:
maxTokenSupply(uint256) := _maxTokenSupply(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
etherPriceInUSD = _etherPriceInUSD

IRs:
etherPriceInUSD(uint256) := _etherPriceInUSD(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
priceUpdateAt = block.timestamp

IRs:
priceUpdateAt(uint256) := block.timestamp(uint256)"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
Multivest()

IRs:
INTERNAL_CALL, Multivest.Multivest()()"];
11->1;
}
// Function: 8305.sol-SellableToken-buy(address,uint256)
digraph{
}
// Function: 8305.sol-SellableToken-calculateEthersAmount(uint256)
digraph{
}
// Function: 8305.sol-SellableToken-calculateTokensAmount(uint256)
digraph{
}
// Function: 8305.sol-SellableToken-getMinEthersInvestment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
uint256(1000000000000000000).mul(minPurchase).div(etherPriceInUSD)

IRs:
TMP_387 = CONVERT 1000000000000000000 to uint256
TMP_388(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_387', 'minPurchase'] 
TMP_389(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_388', 'etherPriceInUSD'] 
RETURN TMP_389"];
}
// Function: 8305.sol-SellableToken-isActive()
digraph{
}
// Function: 8305.sol-SellableToken-isTransferAllowed(address,uint256)
digraph{
}
// Function: 8305.sol-SellableToken-mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
mintInternal(_address,_tokenAmount)

IRs:
TMP_385(uint256) = INTERNAL_CALL, SellableToken.mintInternal(address,uint256)(_address,_tokenAmount)
RETURN TMP_385"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 8305.sol-SellableToken-mintInternal(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
mintedAmount = token.mint(_address,_tokenAmount)

IRs:
TMP_405(uint256) = HIGH_LEVEL_CALL, dest:token(GigToken), function:mint, arguments:['_address', '_tokenAmount']  
mintedAmount(uint256) := TMP_405(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(mintedAmount == _tokenAmount)

IRs:
TMP_406(bool) = mintedAmount == _tokenAmount
TMP_407(None) = SOLIDITY_CALL require(bool)(TMP_406)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
soldTokens = soldTokens.add(_tokenAmount)

IRs:
TMP_408(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['soldTokens', '_tokenAmount'] 
soldTokens(uint256) := TMP_408(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
maxTokenSupply > 0

IRs:
TMP_409(bool) = maxTokenSupply > 0
CONDITION TMP_409"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(maxTokenSupply >= soldTokens)

IRs:
TMP_410(bool) = maxTokenSupply >= soldTokens
TMP_411(None) = SOLIDITY_CALL require(bool)(TMP_410)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
_tokenAmount

IRs:
RETURN _tokenAmount"];
}
// Function: 8305.sol-SellableToken-multivestBuy(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(buy(_address,_value) == true)

IRs:
TMP_337(bool) = INTERNAL_CALL, Multivest.buy(address,uint256)(_address,_value)
TMP_338(bool) = TMP_337 == True
TMP_339(None) = SOLIDITY_CALL require(bool)(TMP_338)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAllowedMultivests(msg.sender)

IRs:
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(msg.sender)"];
2->1;
}
// Function: 8305.sol-SellableToken-multivestBuy(address,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address == msg.sender && buy(msg.sender,msg.value) == true)

IRs:
TMP_341(bool) = _address == msg.sender
TMP_342(bool) = INTERNAL_CALL, Multivest.buy(address,uint256)(msg.sender,msg.value)
TMP_343(bool) = TMP_342 == True
TMP_344(bool) = TMP_341 && TMP_343
TMP_345(None) = SOLIDITY_CALL require(bool)(TMP_344)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyAllowedMultivests(verify(keccak256()(msg.sender),_v,_r,_s))

IRs:
TMP_346(bytes32) = SOLIDITY_CALL keccak256()(msg.sender)
TMP_347(address) = INTERNAL_CALL, Multivest.verify(bytes32,uint8,bytes32,bytes32)(TMP_346,_v,_r,_s)
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(TMP_347)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyAllowedMultivests(verify(keccak256()(msg.sender),_v,_r,_s))

IRs:
TMP_349(bytes32) = SOLIDITY_CALL keccak256()(msg.sender)
TMP_350(address) = INTERNAL_CALL, Multivest.verify(bytes32,uint8,bytes32,bytes32)(TMP_349,_v,_r,_s)
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(TMP_350)"];
3->1;
}
// Function: 8305.sol-SellableToken-onlyAllowedMultivests(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(allowedMultivests[_addresss] == true)

IRs:
REF_237(bool) -> allowedMultivests[_addresss]
TMP_427(bool) = REF_237 == True
TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-SellableToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_429(bool) = msg.sender == owner
TMP_430(None) = SOLIDITY_CALL require(bool)(TMP_429)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 8305.sol-SellableToken-parseInt(string,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bresult = bytes(_a)

IRs:
TMP_412 = CONVERT _a to bytes
bresult(bytes) := TMP_412(bytes)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
res = 0

IRs:
res(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
decimals = false

IRs:
decimals(bool) := False(bool)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->22;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < bresult.length

IRs:
REF_232 -> LENGTH bresult
TMP_413(bool) = i < REF_232
CONDITION TMP_413"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
(bresult[i] >= 48) && (bresult[i] <= 57)

IRs:
REF_233(None) -> bresult[i]
TMP_414(bool) = REF_233 >= 48
REF_234(None) -> bresult[i]
TMP_415(bool) = REF_234 <= 57
TMP_416(bool) = TMP_414 && TMP_415
CONDITION TMP_416"];
8->9[label="True"];
8->17[label="False"];
9[label="Node Type: IF 9

EXPRESSION:
decimals

IRs:
CONDITION decimals"];
9->10[label="True"];
9->14[label="False"];
10[label="Node Type: IF 10

EXPRESSION:
_b == 0

IRs:
TMP_417(bool) = _b == 0
CONDITION TMP_417"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: BREAK 11
"];
11->5;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_b --

IRs:
TMP_418(uint256) := _b(uint256)
_b(uint256) = _b - 1"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
res *= 10

IRs:
res(uint256) = res * 10"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
res += uint256(bresult[i]) - 48

IRs:
REF_235(None) -> bresult[i]
TMP_419 = CONVERT REF_235 to uint256
TMP_420(uint256) = TMP_419 - 48
res(uint256) = res + TMP_420"];
16->20;
17[label="Node Type: IF 17

EXPRESSION:
bresult[i] == 46

IRs:
REF_236(None) -> bresult[i]
TMP_421(bool) = REF_236 == 46
CONDITION TMP_421"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
decimals = true

IRs:
decimals(bool) := True(bool)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
i ++

IRs:
TMP_422(uint256) := i(uint256)
i(uint256) = i + 1"];
21->7;
22[label="Node Type: IF 22

EXPRESSION:
_b > 0

IRs:
TMP_423(bool) = _b > 0
CONDITION TMP_423"];
22->23[label="True"];
22->24[label="False"];
23[label="Node Type: EXPRESSION 23

EXPRESSION:
res *= 10 ** _b

IRs:
TMP_424(uint256) = 10 ** _b
res(uint256) = res * TMP_424"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: RETURN 25

EXPRESSION:
res

IRs:
RETURN res"];
}
// Function: 8305.sol-SellableToken-setAllowedMultivest(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowedMultivests[_address] = true

IRs:
REF_221(bool) -> allowedMultivests[_address]
REF_221(bool) (->allowedMultivests) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultivestSet(_address)

IRs:
Emit MultivestSet(_address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-SellableToken-setEtherHolder(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
_etherHolder != address(0)

IRs:
TMP_380 = CONVERT 0 to address
TMP_381(bool) = _etherHolder != TMP_380
CONDITION TMP_381"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
etherHolder = _etherHolder

IRs:
etherHolder(address) := _etherHolder(address)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-SellableToken-setEtherInUSD(string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->9;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bytePrice = bytes(_price)

IRs:
TMP_390 = CONVERT _price to bytes
bytePrice(bytes) := TMP_390(bytes)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
dot = bytePrice.length.sub(uint256(6))

IRs:
REF_226 -> LENGTH bytePrice
TMP_391 = CONVERT 6 to uint256
TMP_392(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_226', 'TMP_391'] 
dot(uint256) := TMP_392(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(0x2e == uint256(bytePrice[dot]))

IRs:
REF_228(None) -> bytePrice[dot]
TMP_393 = CONVERT REF_228 to uint256
TMP_394(bool) = 46 == TMP_393
TMP_395(None) = SOLIDITY_CALL require(bool)(TMP_394)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
newPrice = uint256(10 ** 23).div(parseInt(_price,5))

IRs:
TMP_396(uint256) = 10 ** 23
TMP_397 = CONVERT TMP_396 to uint256
TMP_398(uint256) = INTERNAL_CALL, SellableToken.parseInt(string,uint256)(_price,5)
TMP_399(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_397', 'TMP_398'] 
newPrice(uint256) := TMP_399(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(newPrice > 0)

IRs:
TMP_400(bool) = newPrice > 0
TMP_401(None) = SOLIDITY_CALL require(bool)(TMP_400)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
etherPriceInUSD = parseInt(_price,5)

IRs:
TMP_402(uint256) = INTERNAL_CALL, SellableToken.parseInt(string,uint256)(_price,5)
etherPriceInUSD(uint256) := TMP_402(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
priceUpdateAt = block.timestamp

IRs:
priceUpdateAt(uint256) := block.timestamp(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
NewPriceTicker(_price)

IRs:
Emit NewPriceTicker(_price)"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
onlyAllowedMultivests(msg.sender)

IRs:
MODIFIER_CALL, Multivest.onlyAllowedMultivests(address)(msg.sender)"];
9->1;
}
// Function: 8305.sol-SellableToken-setPurchaseLimits(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
_min < _max

IRs:
TMP_383(bool) = _min < _max
CONDITION TMP_383"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minPurchase = _min

IRs:
minPurchase(uint256) := _min(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
maxPurchase = _max

IRs:
maxPurchase(uint256) := _max(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 8305.sol-SellableToken-setTokenContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_375 = CONVERT 0 to address
TMP_376(bool) = _token != TMP_375
TMP_377(None) = SOLIDITY_CALL require(bool)(TMP_376)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
token = GigToken(_token)

IRs:
TMP_378 = CONVERT _token to GigToken
token(GigToken) := TMP_378(GigToken)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-SellableToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MONTH_IN_SEC = 2629743

IRs:
MONTH_IN_SEC(uint256) := 2629743(uint256)"];
}
// Function: 8305.sol-SellableToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
minPurchase = 100 * 10 ** 5

IRs:
TMP_425(uint256) = 10 ** 5
TMP_426(uint256) = 100 * TMP_425
minPurchase(uint256) := TMP_426(uint256)"];
}
// Function: 8305.sol-SellableToken-transferEthers()
digraph{
}
// Function: 8305.sol-SellableToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_354 = CONVERT 0 to address
TMP_355(bool) = newOwner != TMP_354
TMP_356(None) = SOLIDITY_CALL require(bool)(TMP_355)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,newOwner)

IRs:
Emit OwnershipTransferred(owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 8305.sol-SellableToken-unsetAllowedMultivest(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowedMultivests[_address] = false

IRs:
REF_222(bool) -> allowedMultivests[_address]
REF_222(bool) (->allowedMultivests) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultivestUnset(_address)

IRs:
Emit MultivestUnset(_address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 8305.sol-SellableToken-updatePreICOMaxTokenSupply(uint256)
digraph{
}
// Function: 8305.sol-SellableToken-verify(bytes32,uint8,bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
prefix = Ethereum Signed Message:
32

IRs:
prefix(bytes) := Ethereum Signed Message:
32(string)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(prefix,_hash),_v,_r,_s)

IRs:
TMP_352(bytes32) = SOLIDITY_CALL keccak256()(prefix,_hash)
TMP_353(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_352,_v,_r,_s)
RETURN TMP_353"];
}
// Function: 8305.sol-SellableToken-withinPeriod()
digraph{
}
// Function: 8305.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 8305.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 8305.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_37(bool) = _subtractedValue > oldValue
CONDITION TMP_37"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_38(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_35(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 8305.sol-StandardToken-totalSupply()
digraph{
}
// Function: 8305.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 8305.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_23 = CONVERT 0 to address
TMP_24(bool) = _to != TMP_23
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_26(bool) = _value <= REF_16
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_28(bool) = _value <= REF_18
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_30(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_31(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_32(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
}
