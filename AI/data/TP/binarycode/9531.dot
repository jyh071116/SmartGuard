digraph G {
// Function: 9531.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_7(uint256) -> balances[_owner]
RETURN REF_7"];
}
// Function: 9531.sol-BasicToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
totalSupply_

IRs:
RETURN totalSupply_"];
}
// Function: 9531.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_23 = CONVERT 0 to address
TMP_24(bool) = _to != TMP_23
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_26(bool) = _value <= REF_0
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_28(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_29(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 9531.sol-CryptualProjectToken-_getCrowdsaleTokenAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
uncountedWeiRaised = crowdsaleWeiRaised

IRs:
uncountedWeiRaised(uint256) := crowdsaleWeiRaised(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
uncountedWeiAmount = _weiAmount

IRs:
uncountedWeiAmount(uint256) := _weiAmount(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
tokenAmount = 0

IRs:
tokenAmount(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->23;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < crowdsaleWeiAvailableLevels.length

IRs:
REF_126 -> LENGTH crowdsaleWeiAvailableLevels
TMP_177(bool) = i < REF_126
CONDITION TMP_177"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
weiAvailable = crowdsaleWeiAvailableLevels[i]

IRs:
REF_127(uint256) -> crowdsaleWeiAvailableLevels[i]
weiAvailable(uint256) := REF_127(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
uncountedWeiRaised >= weiAvailable

IRs:
TMP_178(bool) = uncountedWeiRaised >= weiAvailable
CONDITION TMP_178"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
uncountedWeiRaised = uncountedWeiRaised.sub(weiAvailable)

IRs:
TMP_179(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['uncountedWeiRaised', 'weiAvailable'] 
uncountedWeiRaised(uint256) := TMP_179(uint256)"];
10->21;
11[label="Node Type: IF 11

EXPRESSION:
uncountedWeiRaised > 0

IRs:
TMP_180(bool) = uncountedWeiRaised > 0
CONDITION TMP_180"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
weiAvailable = weiAvailable.sub(uncountedWeiRaised)

IRs:
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['weiAvailable', 'uncountedWeiRaised'] 
weiAvailable(uint256) := TMP_181(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
uncountedWeiRaised = 0

IRs:
uncountedWeiRaised(uint256) := 0(uint256)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
uncountedWeiAmount <= weiAvailable

IRs:
TMP_182(bool) = uncountedWeiAmount <= weiAvailable
CONDITION TMP_182"];
15->16[label="True"];
15->18[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
tokenAmount = tokenAmount.add(uncountedWeiAmount.mul(crowdsaleRates[i]))

IRs:
REF_132(uint256) -> crowdsaleRates[i]
TMP_183(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['uncountedWeiAmount', 'REF_132'] 
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenAmount', 'TMP_183'] 
tokenAmount(uint256) := TMP_184(uint256)"];
16->17;
17[label="Node Type: BREAK 17
"];
17->5;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
uncountedWeiAmount = uncountedWeiAmount.sub(weiAvailable)

IRs:
TMP_185(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['uncountedWeiAmount', 'weiAvailable'] 
uncountedWeiAmount(uint256) := TMP_185(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
tokenAmount = tokenAmount.add(weiAvailable.mul(crowdsaleRates[i]))

IRs:
REF_136(uint256) -> crowdsaleRates[i]
TMP_186(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAvailable', 'REF_136'] 
TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenAmount', 'TMP_186'] 
tokenAmount(uint256) := TMP_187(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
i ++

IRs:
TMP_188(uint256) := i(uint256)
i(uint256) = i + 1"];
22->7;
23[label="Node Type: RETURN 23

EXPRESSION:
tokenAmount.div(1000000000000000000)

IRs:
TMP_189(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['tokenAmount', '1000000000000000000'] 
RETURN TMP_189"];
}
// Function: 9531.sol-CryptualProjectToken-_processPurchase(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply_ = totalSupply_.add(_tokenAmount)

IRs:
TMP_190(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_tokenAmount'] 
totalSupply_(uint256) := TMP_190(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount)

IRs:
REF_139(uint256) -> balances[_beneficiary]
REF_140(uint256) -> balances[_beneficiary]
TMP_191(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_140', '_tokenAmount'] 
REF_139(uint256) (->balances) := TMP_191(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0x0,_beneficiary,_tokenAmount)

IRs:
Emit Transfer(0,_beneficiary,_tokenAmount)"];
}
// Function: 9531.sol-CryptualProjectToken-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_94 = CONVERT 0 to address
TMP_95(bool) = _newOwner != TMP_94
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 9531.sol-CryptualProjectToken-addManyToPresaleWhitelist(address[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_143 -> LENGTH _beneficiaries
TMP_194(bool) = i < REF_143
CONDITION TMP_194"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
whitelist[_beneficiaries[i]] = true

IRs:
REF_144(address) -> _beneficiaries[i]
REF_145(bool) -> whitelist[REF_144]
REF_145(bool) (->whitelist) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_195(uint256) := i(uint256)
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
7->3;
}
// Function: 9531.sol-CryptualProjectToken-addToPresaleWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = true

IRs:
REF_142(bool) -> whitelist[_beneficiary]
REF_142(bool) (->whitelist) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 9531.sol-CryptualProjectToken-allowance(address,address)
digraph{
}
// Function: 9531.sol-CryptualProjectToken-approve(address,uint256)
digraph{
}
// Function: 9531.sol-CryptualProjectToken-balanceOf(address)
digraph{
}
// Function: 9531.sol-CryptualProjectToken-buyTokens(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_130 = CONVERT 0 to address
TMP_131(bool) = _beneficiary != TMP_130
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(weiAmount != 0)

IRs:
TMP_133(bool) = weiAmount != 0
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME

IRs:
TMP_135(bool) = block.timestamp >= PRESALE_OPENING_TIME
TMP_136(bool) = block.timestamp <= PRESALE_CLOSING_TIME
TMP_137(bool) = TMP_135 && TMP_136
isPresale(bool) := TMP_137(bool)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME

IRs:
TMP_138(bool) = block.timestamp >= CROWDSALE_OPENING_TIME
TMP_139(bool) = block.timestamp <= CROWDSALE_CLOSING_TIME
TMP_140(bool) = TMP_138 && TMP_139
isCrowdsale(bool) := TMP_140(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(isPresale || isCrowdsale)

IRs:
TMP_141(bool) = isPresale || isCrowdsale
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
isCrowdsale

IRs:
CONDITION isCrowdsale"];
8->9[label="True"];
8->14[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP)

IRs:
TMP_143(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['crowdsaleWeiRaised', 'weiAmount'] 
TMP_144(bool) = TMP_143 <= CROWDSALE_WEI_CAP
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap())

IRs:
REF_108(uint256) -> crowdsaleContributions[_beneficiary]
TMP_146(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_108', 'weiAmount'] 
TMP_147(uint256) = INTERNAL_CALL, CryptualProjectToken.getCrowdsaleUserCap()()
TMP_148(bool) = TMP_146 <= TMP_147
TMP_149(None) = SOLIDITY_CALL require(bool)(TMP_148)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
tokens = _getCrowdsaleTokenAmount(weiAmount)

IRs:
TMP_150(uint256) = INTERNAL_CALL, CryptualProjectToken._getCrowdsaleTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_150(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(tokens != 0)

IRs:
TMP_151(bool) = tokens != 0
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
crowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount)

IRs:
TMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['crowdsaleWeiRaised', 'weiAmount'] 
crowdsaleWeiRaised(uint256) := TMP_153(uint256)"];
13->21;
14[label="Node Type: IF 14

EXPRESSION:
isPresale

IRs:
CONDITION isPresale"];
14->15[label="True"];
14->20[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP)

IRs:
TMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presaleWeiRaised', 'weiAmount'] 
TMP_155(bool) = TMP_154 <= PRESALE_WEI_CAP
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
require(bool)(whitelist[_beneficiary])

IRs:
REF_112(bool) -> whitelist[_beneficiary]
TMP_157(None) = SOLIDITY_CALL require(bool)(REF_112)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
tokens = weiAmount.mul(PRESALE_RATE).div(1000000000000000000)

IRs:
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiAmount', 'PRESALE_RATE'] 
TMP_159(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_158', '1000000000000000000'] 
tokens(uint256) := TMP_159(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(tokens != 0)

IRs:
TMP_160(bool) = tokens != 0
TMP_161(None) = SOLIDITY_CALL require(bool)(TMP_160)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
presaleWeiRaised = presaleWeiRaised.add(weiAmount)

IRs:
TMP_162(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presaleWeiRaised', 'weiAmount'] 
presaleWeiRaised(uint256) := TMP_162(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, CryptualProjectToken._processPurchase(address,uint256)(_beneficiary,tokens)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)"];
23->24;
24[label="Node Type: IF 24

EXPRESSION:
isCrowdsale

IRs:
CONDITION isCrowdsale"];
24->25[label="True"];
24->26[label="False"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount)

IRs:
REF_116(uint256) -> crowdsaleContributions[_beneficiary]
REF_117(uint256) -> crowdsaleContributions[_beneficiary]
TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', 'weiAmount'] 
REF_116(uint256) (->crowdsaleContributions) := TMP_165(uint256)"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
vault.deposit.value(msg.value)(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:deposit, arguments:['msg.sender'] value:msg.value "];
}
// Function: 9531.sol-CryptualProjectToken-claimRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isCrowdsaleFinalized)

IRs:
TMP_210(None) = SOLIDITY_CALL require(bool)(isCrowdsaleFinalized)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! combinedGoalReached())

IRs:
TMP_211(bool) = INTERNAL_CALL, CryptualProjectToken.combinedGoalReached()()
TMP_212 = UnaryType.BANG TMP_211 
TMP_213(None) = SOLIDITY_CALL require(bool)(TMP_212)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
vault.refund(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:refund, arguments:['msg.sender']  "];
}
// Function: 9531.sol-CryptualProjectToken-combinedGoalReached()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
presaleWeiRaised.add(crowdsaleWeiRaised) >= COMBINED_WEI_GOAL

IRs:
TMP_215(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presaleWeiRaised', 'crowdsaleWeiRaised'] 
TMP_216(bool) = TMP_215 >= COMBINED_WEI_GOAL
RETURN TMP_216"];
}
// Function: 9531.sol-CryptualProjectToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 9531.sol-CryptualProjectToken-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_123 = CONVERT 0 to address
TMP_124(bool) = _wallet != TMP_123
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
vault = new RefundVault(wallet)

IRs:
TMP_127(RefundVault) = new RefundVault(wallet) 
vault(RefundVault) := TMP_127(RefundVault)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = INITIAL_SUPPLY

IRs:
totalSupply_(uint256) := INITIAL_SUPPLY(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = INITIAL_SUPPLY

IRs:
REF_106(uint256) -> balances[msg.sender]
REF_106(uint256) (->balances) := INITIAL_SUPPLY(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(0x0,msg.sender,INITIAL_SUPPLY)

IRs:
Emit Transfer(0,msg.sender,INITIAL_SUPPLY)"];
}
// Function: 9531.sol-CryptualProjectToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_89(mapping(address => uint256)) -> allowed[msg.sender]
REF_90(uint256) -> REF_89[_spender]
oldValue(uint256) := REF_90(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_112(bool) = _subtractedValue > oldValue
CONDITION TMP_112"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_91(mapping(address => uint256)) -> allowed[msg.sender]
REF_92(uint256) -> REF_91[_spender]
REF_92(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_93(mapping(address => uint256)) -> allowed[msg.sender]
REF_94(uint256) -> REF_93[_spender]
TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_94(uint256) (->allowed) := TMP_113(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_96(mapping(address => uint256)) -> allowed[msg.sender]
REF_97(uint256) -> REF_96[_spender]
Emit Approval(msg.sender,_spender,REF_97)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 9531.sol-CryptualProjectToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
buyTokens(msg.sender)

IRs:
INTERNAL_CALL, CryptualProjectToken.buyTokens(address)(msg.sender)"];
}
// Function: 9531.sol-CryptualProjectToken-finalizeCrowdsale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isCrowdsaleFinalized)

IRs:
TMP_198 = UnaryType.BANG isCrowdsaleFinalized 
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL))

IRs:
TMP_200(bool) = block.timestamp > CROWDSALE_CLOSING_TIME
TMP_201(bool) = block.timestamp > PRESALE_CLOSING_TIME
TMP_202(bool) = presaleWeiRaised < PRESALE_WEI_GOAL
TMP_203(bool) = TMP_201 && TMP_202
TMP_204(bool) = TMP_200 || TMP_203
TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
combinedGoalReached()

IRs:
TMP_206(bool) = INTERNAL_CALL, CryptualProjectToken.combinedGoalReached()()
CONDITION TMP_206"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
vault.close()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  "];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
vault.enableRefunds()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  "];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
CrowdsaleFinalized()

IRs:
Emit CrowdsaleFinalized()"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isCrowdsaleFinalized = true

IRs:
isCrowdsaleFinalized(bool) := True(bool)"];
}
// Function: 9531.sol-CryptualProjectToken-getCrowdsaleUserCap()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME)

IRs:
TMP_168(bool) = block.timestamp >= CROWDSALE_OPENING_TIME
TMP_169(bool) = block.timestamp <= CROWDSALE_CLOSING_TIME
TMP_170(bool) = TMP_168 && TMP_169
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME)

IRs:
TMP_172(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.timestamp', 'CROWDSALE_OPENING_TIME'] 
elapsedTime(uint256) := TMP_172(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
currentMinElapsedTime = 0

IRs:
currentMinElapsedTime(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
currentCap = 0

IRs:
currentCap(uint256) := 0(uint256)"];
4->7;
5[label="Node Type: BEGIN_LOOP 5
"];
5->8;
6[label="Node Type: END_LOOP 6
"];
6->17;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
7->5;
8[label="Node Type: IF_LOOP 8

EXPRESSION:
i < crowdsaleUserCaps.length

IRs:
REF_122 -> LENGTH crowdsaleUserCaps
TMP_173(bool) = i < REF_122
CONDITION TMP_173"];
8->9[label="True"];
8->6[label="False"];
9[label="Node Type: IF 9

EXPRESSION:
elapsedTime < crowdsaleMinElapsedTimeLevels[i]

IRs:
REF_123(uint256) -> crowdsaleMinElapsedTimeLevels[i]
TMP_174(bool) = elapsedTime < REF_123
CONDITION TMP_174"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: CONTINUE 10
"];
10->16;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime

IRs:
REF_124(uint256) -> crowdsaleMinElapsedTimeLevels[i]
TMP_175(bool) = REF_124 < currentMinElapsedTime
CONDITION TMP_175"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: CONTINUE 13
"];
13->16;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
currentCap = crowdsaleUserCaps[i]

IRs:
REF_125(uint256) -> crowdsaleUserCaps[i]
currentCap(uint256) := REF_125(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_176(uint256) := i(uint256)
i(uint256) = i + 1"];
16->8;
17[label="Node Type: RETURN 17

EXPRESSION:
currentCap

IRs:
RETURN currentCap"];
}
// Function: 9531.sol-CryptualProjectToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_82(mapping(address => uint256)) -> allowed[msg.sender]
REF_83(uint256) -> REF_82[_spender]
REF_84(mapping(address => uint256)) -> allowed[msg.sender]
REF_85(uint256) -> REF_84[_spender]
TMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_85', '_addedValue'] 
REF_83(uint256) (->allowed) := TMP_110(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_87(mapping(address => uint256)) -> allowed[msg.sender]
REF_88(uint256) -> REF_87[_spender]
Emit Approval(msg.sender,_spender,REF_88)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 9531.sol-CryptualProjectToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_221(bool) = msg.sender == owner
TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 9531.sol-CryptualProjectToken-removeFromPresaleWhitelist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
whitelist[_beneficiary] = false

IRs:
REF_146(bool) -> whitelist[_beneficiary]
REF_146(bool) (->whitelist) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 9531.sol-CryptualProjectToken-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_90 = CONVERT 0 to address
owner(address) := TMP_90(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 9531.sol-CryptualProjectToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Cryptual Project Token

IRs:
name(string) := Cryptual Project Token(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = CPT

IRs:
symbol(string) := CPT(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 0

IRs:
decimals(uint8) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
INITIAL_SUPPLY = 283000000

IRs:
INITIAL_SUPPLY(uint256) := 283000000(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
PRESALE_OPENING_TIME = 1530356400

IRs:
PRESALE_OPENING_TIME(uint256) := 1530356400(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
PRESALE_CLOSING_TIME = 1530921600

IRs:
PRESALE_CLOSING_TIME(uint256) := 1530921600(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
PRESALE_RATE = 150000

IRs:
PRESALE_RATE(uint256) := 150000(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
PRESALE_WEI_CAP = 500000000000000000000

IRs:
PRESALE_WEI_CAP(uint256) := 500000000000000000000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
PRESALE_WEI_GOAL = 50000000000000000000

IRs:
PRESALE_WEI_GOAL(uint256) := 50000000000000000000(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
CROWDSALE_OPENING_TIME = 1531047600

IRs:
CROWDSALE_OPENING_TIME(uint256) := 1531047600(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
CROWDSALE_CLOSING_TIME = 1533686400

IRs:
CROWDSALE_CLOSING_TIME(uint256) := 1533686400(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
CROWDSALE_WEI_CAP = 5000000000000000000000

IRs:
CROWDSALE_WEI_CAP(uint256) := 5000000000000000000000(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
COMBINED_WEI_GOAL = 750000000000000000000

IRs:
COMBINED_WEI_GOAL(uint256) := 750000000000000000000(uint256)"];
}
// Function: 9531.sol-CryptualProjectToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
crowdsaleWeiAvailableLevels = (1000000000000000000000,1500000000000000000000,2000000000000000000000)

IRs:
crowdsaleWeiAvailableLevels(uint256[]) = ['1000000000000000000000(uint256)', '1500000000000000000000(uint256)', '2000000000000000000000(uint256)']"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
crowdsaleRates = (135000,120000,100000)

IRs:
crowdsaleRates(uint256[]) = ['135000(uint256)', '120000(uint256)', '100000(uint256)']"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
crowdsaleMinElapsedTimeLevels = (0,12 * 3600,18 * 3600,21 * 3600,22 * 3600)

IRs:
TMP_217(uint256) = 12 * 3600
TMP_218(uint256) = 18 * 3600
TMP_219(uint256) = 21 * 3600
TMP_220(uint256) = 22 * 3600
crowdsaleMinElapsedTimeLevels(uint256[]) = ['0(uint256)', 'TMP_217(uint256)', 'TMP_218(uint256)', 'TMP_219(uint256)', 'TMP_220(uint256)']"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
crowdsaleUserCaps = (1000000000000000000,2000000000000000000,4000000000000000000,8000000000000000000,CROWDSALE_WEI_CAP)

IRs:
crowdsaleUserCaps(uint256[]) = ['1000000000000000000(uint256)', '2000000000000000000(uint256)', '4000000000000000000(uint256)', '8000000000000000000(uint256)', 'CROWDSALE_WEI_CAP(uint256)']"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
isCrowdsaleFinalized = false

IRs:
isCrowdsaleFinalized(bool) := False(bool)"];
}
// Function: 9531.sol-CryptualProjectToken-totalSupply()
digraph{
}
// Function: 9531.sol-CryptualProjectToken-transfer(address,uint256)
digraph{
}
// Function: 9531.sol-CryptualProjectToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 9531.sol-CryptualProjectToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 9531.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 9531.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 9531.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 9531.sol-ERC20-totalSupply()
digraph{
}
// Function: 9531.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 9531.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 9531.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 9531.sol-ERC20Basic-totalSupply()
digraph{
}
// Function: 9531.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 9531.sol-Ownable-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_17 = CONVERT 0 to address
TMP_18(bool) = _newOwner != TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 9531.sol-Ownable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 9531.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_21(bool) = msg.sender == owner
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 9531.sol-Ownable-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_13 = CONVERT 0 to address
owner(address) := TMP_13(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 9531.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 9531.sol-RefundVault-_transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newOwner != address(0))

IRs:
TMP_61 = CONVERT 0 to address
TMP_62(bool) = _newOwner != TMP_61
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(owner,_newOwner)

IRs:
Emit OwnershipTransferred(owner,_newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owner = _newOwner

IRs:
owner(address) := _newOwner(address)"];
}
// Function: 9531.sol-RefundVault-close()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_55(RefundVault.State) -> State.Active
TMP_72(bool) = state == REF_55
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_56(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_56(RefundVault.State)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(address(this).balance)

IRs:
TMP_75 = CONVERT this to address
TMP_76(uint256) = SOLIDITY_CALL balance(address)(TMP_75)
Transfer dest:wallet value:TMP_76"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
5->1;
}
// Function: 9531.sol-RefundVault-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 9531.sol-RefundVault-constructor(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_65 = CONVERT 0 to address
TMP_66(bool) = _wallet != TMP_65
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
state = State.Active

IRs:
REF_50(RefundVault.State) -> State.Active
state(RefundVault.State) := REF_50(RefundVault.State)"];
}
// Function: 9531.sol-RefundVault-deposit(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_51(RefundVault.State) -> State.Active
TMP_68(bool) = state == REF_51
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
deposited[investor] = deposited[investor].add(msg.value)

IRs:
REF_52(uint256) -> deposited[investor]
REF_53(uint256) -> deposited[investor]
TMP_70(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_53', 'msg.value'] 
REF_52(uint256) (->deposited) := TMP_70(uint256)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 9531.sol-RefundVault-enableRefunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_58(RefundVault.State) -> State.Active
TMP_79(bool) = state == REF_58
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
state = State.Refunding

IRs:
REF_59(RefundVault.State) -> State.Refunding
state(RefundVault.State) := REF_59(RefundVault.State)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RefundsEnabled()

IRs:
Emit RefundsEnabled()"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 9531.sol-RefundVault-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_87(bool) = msg.sender == owner
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 9531.sol-RefundVault-refund(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_60(RefundVault.State) -> State.Refunding
TMP_83(bool) = state == REF_60
TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_61(uint256) -> deposited[investor]
depositedValue(uint256) := REF_61(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_62(uint256) -> deposited[investor]
REF_62(uint256) (->deposited) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)"];
}
// Function: 9531.sol-RefundVault-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipRenounced(owner)

IRs:
Emit OwnershipRenounced(owner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = address(0)

IRs:
TMP_57 = CONVERT 0 to address
owner(address) := TMP_57(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 9531.sol-RefundVault-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transferOwnership(_newOwner)

IRs:
INTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
2->1;
}
// Function: 9531.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
4[label="Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 9531.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
a / b

IRs:
TMP_5(uint256) = a / b
RETURN TMP_5"];
}
// Function: 9531.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
a == 0

IRs:
TMP_0(bool) = a == 0
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
c = a * b

IRs:
TMP_1(uint256) = a * b
c(uint256) := TMP_1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(c / a == b)

IRs:
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
c

IRs:
RETURN c"];
7[label="Node Type: RETURN 7

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 9531.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_6(bool) = b <= a
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_8(uint256) = a - b
RETURN TMP_8"];
}
// Function: 9531.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_32(mapping(address => uint256)) -> allowed[_owner]
REF_33(uint256) -> REF_32[_spender]
RETURN REF_33"];
}
// Function: 9531.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_30(mapping(address => uint256)) -> allowed[msg.sender]
REF_31(uint256) -> REF_30[_spender]
REF_31(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 9531.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 9531.sol-StandardToken-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
oldValue = allowed[msg.sender][_spender]

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[_spender]
oldValue(uint256) := REF_42(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
_subtractedValue > oldValue

IRs:
TMP_53(bool) = _subtractedValue > oldValue
CONDITION TMP_53"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
allowed[msg.sender][_spender] = 0

IRs:
REF_43(mapping(address => uint256)) -> allowed[msg.sender]
REF_44(uint256) -> REF_43[_spender]
REF_44(uint256) (->allowed) := 0(uint256)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)

IRs:
REF_45(mapping(address => uint256)) -> allowed[msg.sender]
REF_46(uint256) -> REF_45[_spender]
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] 
REF_46(uint256) (->allowed) := TMP_54(uint256)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
Emit Approval(msg.sender,_spender,REF_49)"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 9531.sol-StandardToken-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))

IRs:
REF_34(mapping(address => uint256)) -> allowed[msg.sender]
REF_35(uint256) -> REF_34[_spender]
REF_36(mapping(address => uint256)) -> allowed[msg.sender]
REF_37(uint256) -> REF_36[_spender]
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] 
REF_35(uint256) (->allowed) := TMP_51(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
Emit Approval(msg.sender,_spender,REF_40)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
}
// Function: 9531.sol-StandardToken-totalSupply()
digraph{
}
// Function: 9531.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 9531.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_39 = CONVERT 0 to address
TMP_40(bool) = _to != TMP_39
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_16(uint256) -> balances[_from]
TMP_42(bool) = _value <= REF_16
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowed[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_44(bool) = _value <= REF_18
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_19(uint256) -> balances[_from]
REF_20(uint256) -> balances[_from]
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] 
REF_19(uint256) (->balances) := TMP_46(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_22(uint256) -> balances[_to]
REF_23(uint256) -> balances[_to]
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] 
REF_22(uint256) (->balances) := TMP_47(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)

IRs:
REF_25(mapping(address => uint256)) -> allowed[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_27(mapping(address => uint256)) -> allowed[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] 
REF_26(uint256) (->allowed) := TMP_48(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True"];
}
}
