digraph G {
// Function: 9830.sol-NumericSequence-sumOfN(uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(count > 0)

IRs:
TMP_12(bool) = count > 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
price = 0

IRs:
price(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
price += SafeMath.mul((basePrice + pricePerLevel * owned),count)

IRs:
TMP_14(uint256) = pricePerLevel * owned
TMP_15(uint256) = basePrice + TMP_14
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_15', 'count'] 
price(uint256) = price + TMP_16"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
price += pricePerLevel * (count.mul((count - 1))) / 2

IRs:
TMP_17(uint256) = count - 1
TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['count', 'TMP_17'] 
TMP_19(uint256) = pricePerLevel * TMP_18
TMP_20(uint256) = TMP_19 / 2
price(uint256) = price + TMP_20"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 9830.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_0(uint256) = a + b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(c >= a)

IRs:
TMP_1(bool) = c >= a
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 9830.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_6(uint256) = a * b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(a == 0 || c / a == b)

IRs:
TMP_7(bool) = a == 0
TMP_8(uint256) = c / a
TMP_9(bool) = TMP_8 == b
TMP_10(bool) = TMP_7 || TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 9830.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(b <= a)

IRs:
TMP_3(bool) = b <= a
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_5(uint256) = a - b
c(uint256) := TMP_5(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 9830.sol-SpaceWar-Attack(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender != defenderAddr)

IRs:
TMP_190(bool) = msg.sender != defenderAddr
TMP_191(None) = SOLIDITY_CALL require(bool)(TMP_190)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime != 0)

IRs:
REF_226(SpaceWar.MinerData) -> miners[msg.sender]
REF_227(uint256) -> REF_226.lastUpdateTime
TMP_192(bool) = REF_227 != 0
TMP_193(None) = SOLIDITY_CALL require(bool)(TMP_192)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(miners[defenderAddr].lastUpdateTime != 0)

IRs:
REF_228(SpaceWar.MinerData) -> miners[defenderAddr]
REF_229(uint256) -> REF_228.lastUpdateTime
TMP_194(bool) = REF_229 != 0
TMP_195(None) = SOLIDITY_CALL require(bool)(TMP_194)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
attacker = pvpMap[msg.sender]

IRs:
REF_230(SpaceWar.PVPData) -> pvpMap[msg.sender]
attacker(SpaceWar.PVPData) := REF_230(SpaceWar.PVPData)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
defender = pvpMap[defenderAddr]

IRs:
REF_231(SpaceWar.PVPData) -> pvpMap[defenderAddr]
defender(SpaceWar.PVPData) := REF_231(SpaceWar.PVPData)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(block.timestamp > attacker.exhaustTime)

IRs:
REF_232(uint256) -> attacker.exhaustTime
TMP_196(bool) = block.timestamp > REF_232
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(block.timestamp > defender.immunityTime)

IRs:
REF_233(uint256) -> defender.immunityTime
TMP_198(bool) = block.timestamp > REF_233
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
attacker.immunityTime > block.timestamp

IRs:
REF_234(uint256) -> attacker.immunityTime
TMP_200(bool) = REF_234 > block.timestamp
CONDITION TMP_200"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
attacker.immunityTime = block.timestamp - 1

IRs:
REF_235(uint256) -> attacker.immunityTime
TMP_201(uint256) = block.timestamp - 1
REF_235(uint256) (->attacker) := TMP_201(uint256)"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
attacker.exhaustTime = block.timestamp + 3600

IRs:
REF_236(uint256) -> attacker.exhaustTime
TMP_202(uint256) = block.timestamp + 3600
REF_236(uint256) (->attacker) := TMP_202(uint256)"];
13->14;
14[label="Node Type: NEW VARIABLE 14

EXPRESSION:
attackpower = 0

IRs:
attackpower(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: NEW VARIABLE 15

EXPRESSION:
defensepower = 0

IRs:
defensepower(uint256) := 0(uint256)"];
15->18;
16[label="Node Type: BEGIN_LOOP 16
"];
16->19;
17[label="Node Type: END_LOOP 17
"];
17->23;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
18->16;
19[label="Node Type: IF_LOOP 19

EXPRESSION:
i < ATTACKER_END_IDX

IRs:
TMP_203(bool) = i < ATTACKER_END_IDX
CONDITION TMP_203"];
19->20[label="True"];
19->17[label="False"];
20[label="Node Type: EXPRESSION 20

EXPRESSION:
attackpower += attacker.troops[i] * troopData[i].attackPower

IRs:
REF_237(uint256[6]) -> attacker.troops
REF_238(uint256) -> REF_237[i]
REF_239(SpaceWar.TroopData) -> troopData[i]
REF_240(uint256) -> REF_239.attackPower
TMP_204(uint256) = REF_238 * REF_240
attackpower(uint256) = attackpower + TMP_204"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
defensepower += defender.troops[i + DEFENDER_START_IDX] * troopData[i + DEFENDER_START_IDX].defensePower

IRs:
REF_241(uint256[6]) -> defender.troops
TMP_205(uint256) = i + DEFENDER_START_IDX
REF_242(uint256) -> REF_241[TMP_205]
TMP_206(uint256) = i + DEFENDER_START_IDX
REF_243(SpaceWar.TroopData) -> troopData[TMP_206]
REF_244(uint256) -> REF_243.defensePower
TMP_207(uint256) = REF_242 * REF_244
defensepower(uint256) = defensepower + TMP_207"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
22->19;
23[label="Node Type: IF 23

EXPRESSION:
attackpower > defensepower

IRs:
TMP_208(bool) = attackpower > defensepower
CONDITION TMP_208"];
23->24[label="True"];
23->55[label="False"];
24[label="Node Type: IF 24

EXPRESSION:
defender.immunityTime < block.timestamp + 14400

IRs:
REF_245(uint256) -> defender.immunityTime
TMP_209(uint256) = block.timestamp + 14400
TMP_210(bool) = REF_245 < TMP_209
CONDITION TMP_210"];
24->25[label="True"];
24->26[label="False"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
defender.immunityTime = block.timestamp + 14400

IRs:
REF_246(uint256) -> defender.immunityTime
TMP_211(uint256) = block.timestamp + 14400
REF_246(uint256) (->defender) := TMP_211(uint256)"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
UpdateMoneyAt(defenderAddr)

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoneyAt(address)(defenderAddr)"];
27->28;
28[label="Node Type: NEW VARIABLE 28

EXPRESSION:
m = miners[defenderAddr]

IRs:
REF_247(SpaceWar.MinerData) -> miners[defenderAddr]
m(SpaceWar.MinerData) := REF_247(SpaceWar.MinerData)"];
28->29;
29[label="Node Type: NEW VARIABLE 29

EXPRESSION:
m2 = miners[msg.sender]

IRs:
REF_248(SpaceWar.MinerData) -> miners[msg.sender]
m2(SpaceWar.MinerData) := REF_248(SpaceWar.MinerData)"];
29->30;
30[label="Node Type: NEW VARIABLE 30

EXPRESSION:
moneyStolen = m.money / 2

IRs:
REF_249(uint256) -> m.money
TMP_213(uint256) = REF_249 / 2
moneyStolen(uint256) := TMP_213(uint256)"];
30->33;
31[label="Node Type: BEGIN_LOOP 31
"];
31->34;
32[label="Node Type: END_LOOP 32
"];
32->39;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
i = DEFENDER_START_IDX

IRs:
i(uint256) := DEFENDER_START_IDX(uint8)"];
33->31;
34[label="Node Type: IF_LOOP 34

EXPRESSION:
i < DEFENDER_END_IDX

IRs:
TMP_214(bool) = i < DEFENDER_END_IDX
CONDITION TMP_214"];
34->35[label="True"];
34->32[label="False"];
35[label="Node Type: EXPRESSION 35

EXPRESSION:
defender.troops[i] = defender.troops[i] / 2

IRs:
REF_250(uint256[6]) -> defender.troops
REF_251(uint256) -> REF_250[i]
REF_252(uint256[6]) -> defender.troops
REF_253(uint256) -> REF_252[i]
TMP_215(uint256) = REF_253 / 2
REF_251(uint256) (->defender) := TMP_215(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
36->34;
37[label="Node Type: BEGIN_LOOP 37
"];
37->40;
38[label="Node Type: END_LOOP 38
"];
38->51;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
i = ATTACKER_START_IDX

IRs:
i(uint256) := ATTACKER_START_IDX(uint8)"];
39->37;
40[label="Node Type: IF_LOOP 40

EXPRESSION:
i < ATTACKER_END_IDX

IRs:
TMP_216(bool) = i < ATTACKER_END_IDX
CONDITION TMP_216"];
40->41[label="True"];
40->38[label="False"];
41[label="Node Type: IF 41

EXPRESSION:
troopData[i].attackPower > 0

IRs:
REF_254(SpaceWar.TroopData) -> troopData[i]
REF_255(uint256) -> REF_254.attackPower
TMP_217(bool) = REF_255 > 0
CONDITION TMP_217"];
41->42[label="True"];
41->49[label="False"];
42[label="Node Type: EXPRESSION 42

EXPRESSION:
count = attacker.troops[i]

IRs:
REF_256(uint256[6]) -> attacker.troops
REF_257(uint256) -> REF_256[i]
count(uint256) := REF_257(uint256)"];
42->43;
43[label="Node Type: IF 43

EXPRESSION:
(count * troopData[i].attackPower) > defensepower

IRs:
REF_258(SpaceWar.TroopData) -> troopData[i]
REF_259(uint256) -> REF_258.attackPower
TMP_218(uint256) = count * REF_259
TMP_219(bool) = TMP_218 > defensepower
CONDITION TMP_219"];
43->44[label="True"];
43->45[label="False"];
44[label="Node Type: EXPRESSION 44

EXPRESSION:
count = count * defensepower / attackpower / 2

IRs:
TMP_220(uint256) = count * defensepower
TMP_221(uint256) = TMP_220 / attackpower
TMP_222(uint256) = TMP_221 / 2
count(uint256) := TMP_222(uint256)"];
44->46;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
count = count / 2

IRs:
TMP_223(uint256) = count / 2
count(uint256) := TMP_223(uint256)"];
45->46;
46[label="Node Type: END_IF 46
"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
attacker.troops[i] = SafeMath.sub(attacker.troops[i],count)

IRs:
REF_260(uint256[6]) -> attacker.troops
REF_261(uint256) -> REF_260[i]
REF_263(uint256[6]) -> attacker.troops
REF_264(uint256) -> REF_263[i]
TMP_224(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_264', 'count'] 
REF_261(uint256) (->attacker) := TMP_224(uint256)"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
defensepower -= count * troopData[i].attackPower

IRs:
REF_265(SpaceWar.TroopData) -> troopData[i]
REF_266(uint256) -> REF_265.attackPower
TMP_225(uint256) = count * REF_266
defensepower(uint256) = defensepower - TMP_225"];
48->49;
49[label="Node Type: END_IF 49
"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
50->40;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
m.money -= moneyStolen

IRs:
REF_267(uint256) -> m.money
REF_267(-> m) = REF_267 - moneyStolen"];
51->52;
52[label="Node Type: EXPRESSION 52

EXPRESSION:
m2.money += moneyStolen

IRs:
REF_268(uint256) -> m2.money
REF_268(-> m2) = REF_268 + moneyStolen"];
52->72;
53[label="Node Type: BEGIN_LOOP 53
"];
53->56;
54[label="Node Type: END_LOOP 54
"];
54->61;
55[label="Node Type: EXPRESSION 55

EXPRESSION:
i = ATTACKER_START_IDX

IRs:
i(uint256) := ATTACKER_START_IDX(uint8)"];
55->53;
56[label="Node Type: IF_LOOP 56

EXPRESSION:
i < ATTACKER_END_IDX

IRs:
TMP_226(bool) = i < ATTACKER_END_IDX
CONDITION TMP_226"];
56->57[label="True"];
56->54[label="False"];
57[label="Node Type: EXPRESSION 57

EXPRESSION:
attacker.troops[i] = attacker.troops[i] / 2

IRs:
REF_269(uint256[6]) -> attacker.troops
REF_270(uint256) -> REF_269[i]
REF_271(uint256[6]) -> attacker.troops
REF_272(uint256) -> REF_271[i]
TMP_227(uint256) = REF_272 / 2
REF_270(uint256) (->attacker) := TMP_227(uint256)"];
57->58;
58[label="Node Type: EXPRESSION 58

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
58->56;
59[label="Node Type: BEGIN_LOOP 59
"];
59->62;
60[label="Node Type: END_LOOP 60
"];
60->72;
61[label="Node Type: EXPRESSION 61

EXPRESSION:
i = DEFENDER_START_IDX

IRs:
i(uint256) := DEFENDER_START_IDX(uint8)"];
61->59;
62[label="Node Type: IF_LOOP 62

EXPRESSION:
i < DEFENDER_END_IDX

IRs:
TMP_228(bool) = i < DEFENDER_END_IDX
CONDITION TMP_228"];
62->63[label="True"];
62->60[label="False"];
63[label="Node Type: IF 63

EXPRESSION:
troopData[i].defensePower > 0

IRs:
REF_273(SpaceWar.TroopData) -> troopData[i]
REF_274(uint256) -> REF_273.defensePower
TMP_229(bool) = REF_274 > 0
CONDITION TMP_229"];
63->64[label="True"];
63->70[label="False"];
64[label="Node Type: EXPRESSION 64

EXPRESSION:
count = defender.troops[i]

IRs:
REF_275(uint256[6]) -> defender.troops
REF_276(uint256) -> REF_275[i]
count(uint256) := REF_276(uint256)"];
64->65;
65[label="Node Type: IF 65

EXPRESSION:
(count * troopData[i].defensePower) > attackpower

IRs:
REF_277(SpaceWar.TroopData) -> troopData[i]
REF_278(uint256) -> REF_277.defensePower
TMP_230(uint256) = count * REF_278
TMP_231(bool) = TMP_230 > attackpower
CONDITION TMP_231"];
65->66[label="True"];
65->67[label="False"];
66[label="Node Type: EXPRESSION 66

EXPRESSION:
count = count * attackpower / defensepower / 2

IRs:
TMP_232(uint256) = count * attackpower
TMP_233(uint256) = TMP_232 / defensepower
TMP_234(uint256) = TMP_233 / 2
count(uint256) := TMP_234(uint256)"];
66->67;
67[label="Node Type: END_IF 67
"];
67->68;
68[label="Node Type: EXPRESSION 68

EXPRESSION:
defender.troops[i] -= count

IRs:
REF_279(uint256[6]) -> defender.troops
REF_280(uint256) -> REF_279[i]
REF_280(-> defender) = REF_280 - count"];
68->69;
69[label="Node Type: EXPRESSION 69

EXPRESSION:
attackpower -= count * troopData[i].defensePower

IRs:
REF_281(SpaceWar.TroopData) -> troopData[i]
REF_282(uint256) -> REF_281.defensePower
TMP_235(uint256) = count * REF_282
attackpower(uint256) = attackpower - TMP_235"];
69->70;
70[label="Node Type: END_IF 70
"];
70->71;
71[label="Node Type: EXPRESSION 71

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
71->62;
72[label="Node Type: END_IF 72
"];
}
// Function: 9830.sol-SpaceWar-BuyBooster()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= nextBoosterPrice)

IRs:
TMP_156(bool) = msg.value >= nextBoosterPrice
TMP_157(None) = SOLIDITY_CALL require(bool)(TMP_156)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime != 0)

IRs:
REF_203(SpaceWar.MinerData) -> miners[msg.sender]
REF_204(uint256) -> REF_203.lastUpdateTime
TMP_158(bool) = REF_204 != 0
TMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
4->11;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < NUMBER_OF_BOOSTERS

IRs:
TMP_160(bool) = i < NUMBER_OF_BOOSTERS
CONDITION TMP_160"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: IF 7

EXPRESSION:
boosterHolders[i] == msg.sender

IRs:
REF_205(address) -> boosterHolders[i]
TMP_161(bool) = REF_205 == msg.sender
CONDITION TMP_161"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_162(None) = SOLIDITY_CALL revert()()"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
10->6;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
beneficiary = boosterHolders[boosterIndex]

IRs:
REF_206(address) -> boosterHolders[boosterIndex]
beneficiary(address) := REF_206(address)"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
m = miners[beneficiary]

IRs:
REF_207(SpaceWar.MinerData) -> miners[beneficiary]
m(SpaceWar.MinerData) := REF_207(SpaceWar.MinerData)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
m.unclaimedPot += (msg.value * 9403) / 10000

IRs:
REF_208(uint256) -> m.unclaimedPot
TMP_163(uint256) = msg.value * 9403
TMP_164(uint256) = TMP_163 / 10000
REF_208(-> m) = REF_208 + TMP_164"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
honeyPotAmount += (msg.value * 597) / 20000

IRs:
TMP_165(uint256) = msg.value * 597
TMP_166(uint256) = TMP_165 / 20000
honeyPotAmount(uint256) = honeyPotAmount + TMP_166"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
devFund += (msg.value * 597) / 20000

IRs:
TMP_167(uint256) = msg.value * 597
TMP_168(uint256) = TMP_167 / 20000
devFund(uint256) = devFund + TMP_168"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
nextBoosterPrice += nextBoosterPrice / 20

IRs:
TMP_169(uint256) = nextBoosterPrice / 20
nextBoosterPrice(uint256) = nextBoosterPrice + TMP_169"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
UpdateMoney()

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoney()()"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
UpdateMoneyAt(beneficiary)

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoneyAt(address)(beneficiary)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
boosterHolders[boosterIndex] = msg.sender

IRs:
REF_209(address) -> boosterHolders[boosterIndex]
REF_209(address) (->boosterHolders) := msg.sender(address)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
boosterIndex += 1

IRs:
boosterIndex(uint256) = boosterIndex + 1"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
boosterIndex >= 5

IRs:
TMP_172(bool) = boosterIndex >= 5
CONDITION TMP_172"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
boosterIndex = 0

IRs:
boosterIndex(uint256) := 0(uint256)"];
22->23;
23[label="Node Type: END_IF 23
"];
}
// Function: 9830.sol-SpaceWar-BuyHandler(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
honeyPotAmount += (amount * honeyPotSharePct) / 100

IRs:
TMP_277(uint256) = amount * honeyPotSharePct
TMP_278(uint256) = TMP_277 / 100
honeyPotAmount(uint256) = honeyPotAmount + TMP_278"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
jackPot += amount / 100

IRs:
TMP_279(uint256) = amount / 100
jackPot(uint256) = jackPot + TMP_279"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
devFund += (amount * (100 - (honeyPotSharePct + 1))) / 100

IRs:
TMP_280(uint256) = honeyPotSharePct + 1
TMP_281(uint256) = 100 - TMP_280
TMP_282(uint256) = amount * TMP_281
TMP_283(uint256) = TMP_282 / 100
devFund(uint256) = devFund + TMP_283"];
}
// Function: 9830.sol-SpaceWar-BuyTroop(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(idx < NUMBER_OF_TROOPS)

IRs:
TMP_173(bool) = idx < NUMBER_OF_TROOPS
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(count > 0)

IRs:
TMP_175(bool) = count > 0
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(count <= 1000)

IRs:
TMP_177(bool) = count <= 1000
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
pvp = pvpMap[msg.sender]

IRs:
REF_210(SpaceWar.PVPData) -> pvpMap[msg.sender]
pvp(SpaceWar.PVPData) := REF_210(SpaceWar.PVPData)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
m = miners[msg.sender]

IRs:
REF_211(SpaceWar.MinerData) -> miners[msg.sender]
m(SpaceWar.MinerData) := REF_211(SpaceWar.MinerData)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
owned = pvp.troops[idx]

IRs:
REF_212(uint256[6]) -> pvp.troops
REF_213(uint256) -> REF_212[idx]
owned(uint256) := REF_213(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
priceGold = NumericSequence.sumOfN(troopData[idx].priceGold,troopData[idx].priceGold / 100,owned,count)

IRs:
REF_215(SpaceWar.TroopData) -> troopData[idx]
REF_216(uint256) -> REF_215.priceGold
REF_217(SpaceWar.TroopData) -> troopData[idx]
REF_218(uint256) -> REF_217.priceGold
TMP_179(uint256) = REF_218 / 100
TMP_180(uint256) = LIBRARY_CALL, dest:NumericSequence, function:NumericSequence.sumOfN(uint256,uint256,uint256,uint256), arguments:['REF_216', 'TMP_179', 'owned', 'count'] 
priceGold(uint256) := TMP_180(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
priceETH = (troopData[idx].priceETH).mul(count)

IRs:
REF_219(SpaceWar.TroopData) -> troopData[idx]
REF_220(uint256) -> REF_219.priceETH
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_220', 'count'] 
priceETH(uint256) := TMP_181(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
UpdateMoney()

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoney()()"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(m.money >= priceGold)

IRs:
REF_222(uint256) -> m.money
TMP_183(bool) = REF_222 >= priceGold
TMP_184(None) = SOLIDITY_CALL require(bool)(TMP_183)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(msg.value >= priceETH)

IRs:
TMP_185(bool) = msg.value >= priceETH
TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
priceGold > 0

IRs:
TMP_187(bool) = priceGold > 0
CONDITION TMP_187"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
m.money -= priceGold

IRs:
REF_223(uint256) -> m.money
REF_223(-> m) = REF_223 - priceGold"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
msg.value > 0

IRs:
TMP_188(bool) = msg.value > 0
CONDITION TMP_188"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
BuyHandler(msg.value)

IRs:
INTERNAL_CALL, SpaceWar.BuyHandler(uint256)(msg.value)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
pvp.troops[idx] += count

IRs:
REF_224(uint256[6]) -> pvp.troops
REF_225(uint256) -> REF_224[idx]
REF_225(-> pvp) = REF_225 + count"];
}
// Function: 9830.sol-SpaceWar-BuyUpgrade(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(idx < NUMBER_OF_UPGRADES)

IRs:
TMP_146(bool) = idx < NUMBER_OF_UPGRADES
TMP_147(None) = SOLIDITY_CALL require(bool)(TMP_146)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= boostData[idx].priceInWEI)

IRs:
REF_189(SpaceWar.BoostData) -> boostData[idx]
REF_190(uint256) -> REF_189.priceInWEI
TMP_148(bool) = msg.value >= REF_190
TMP_149(None) = SOLIDITY_CALL require(bool)(TMP_148)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(miners[msg.sender].hasUpgrade[idx] == 0)

IRs:
REF_191(SpaceWar.MinerData) -> miners[msg.sender]
REF_192(uint8[3]) -> REF_191.hasUpgrade
REF_193(uint8) -> REF_192[idx]
TMP_150(bool) = REF_193 == 0
TMP_151(None) = SOLIDITY_CALL require(bool)(TMP_150)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime != 0)

IRs:
REF_194(SpaceWar.MinerData) -> miners[msg.sender]
REF_195(uint256) -> REF_194.lastUpdateTime
TMP_152(bool) = REF_195 != 0
TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
BuyHandler(msg.value)

IRs:
INTERNAL_CALL, SpaceWar.BuyHandler(uint256)(msg.value)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
UpdateMoney()

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoney()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
miners[msg.sender].hasUpgrade[idx] = 1

IRs:
REF_196(SpaceWar.MinerData) -> miners[msg.sender]
REF_197(uint8[3]) -> REF_196.hasUpgrade
REF_198(uint8) -> REF_197[idx]
REF_198(uint8) (->miners) := 1(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
miners[msg.sender].premamentMineBonusPct += boostData[idx].percentBonus

IRs:
REF_199(SpaceWar.MinerData) -> miners[msg.sender]
REF_200(uint256) -> REF_199.premamentMineBonusPct
REF_201(SpaceWar.BoostData) -> boostData[idx]
REF_202(uint256) -> REF_201.percentBonus
REF_200(-> miners) = REF_200 + REF_202"];
}
// Function: 9830.sol-SpaceWar-FundICO(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime != 0)

IRs:
REF_295(SpaceWar.MinerData) -> miners[msg.sender]
REF_296(uint256) -> REF_295.lastUpdateTime
TMP_254(bool) = REF_296 != 0
TMP_255(None) = SOLIDITY_CALL require(bool)(TMP_254)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_256(bool) = amount > 0
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
m = miners[msg.sender]

IRs:
REF_297(SpaceWar.MinerData) -> miners[msg.sender]
m(SpaceWar.MinerData) := REF_297(SpaceWar.MinerData)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
UpdateMoney()

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoney()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(m.money >= amount)

IRs:
REF_298(uint256) -> m.money
TMP_259(bool) = REF_298 >= amount
TMP_260(None) = SOLIDITY_CALL require(bool)(TMP_259)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
m.money = (m.money).sub(amount)

IRs:
REF_299(uint256) -> m.money
REF_300(uint256) -> m.money
TMP_261(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_300', 'amount'] 
REF_299(uint256) (->m) := TMP_261(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
globalICOPerCycle[cycleCount] = globalICOPerCycle[cycleCount].add(uint256(amount))

IRs:
REF_302(uint256) -> globalICOPerCycle[cycleCount]
REF_303(uint256) -> globalICOPerCycle[cycleCount]
TMP_262 = CONVERT amount to uint256
TMP_263(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_303', 'TMP_262'] 
REF_302(uint256) (->globalICOPerCycle) := TMP_263(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
minerICOPerCycle[msg.sender][cycleCount] = minerICOPerCycle[msg.sender][cycleCount].add(uint256(amount))

IRs:
REF_305(mapping(uint256 => uint256)) -> minerICOPerCycle[msg.sender]
REF_306(uint256) -> REF_305[cycleCount]
REF_307(mapping(uint256 => uint256)) -> minerICOPerCycle[msg.sender]
REF_308(uint256) -> REF_307[cycleCount]
TMP_264 = CONVERT amount to uint256
TMP_265(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_308', 'TMP_264'] 
REF_306(uint256) (->minerICOPerCycle) := TMP_265(uint256)"];
}
// Function: 9830.sol-SpaceWar-GetBoosterData()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->7;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < NUMBER_OF_BOOSTERS

IRs:
TMP_62(bool) = i < NUMBER_OF_BOOSTERS
CONDITION TMP_62"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_boosterHolders[i] = boosterHolders[i]

IRs:
REF_56(address) -> _boosterHolders[i]
REF_57(address) -> boosterHolders[i]
REF_56(address) (->_boosterHolders) := REF_57(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
6->4;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
currentPrice = nextBoosterPrice

IRs:
currentPrice(uint256) := nextBoosterPrice(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
currentIndex = boosterIndex

IRs:
currentIndex(uint256) := boosterIndex(uint256)"];
8->9;
9[label="Node Type: RETURN 9

EXPRESSION:
(_boosterHolders,currentPrice,currentIndex)

IRs:
RETURN _boosterHolders,currentPrice,currentIndex"];
}
// Function: 9830.sol-SpaceWar-GetCurrentICOCycle()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
cycleCount

IRs:
RETURN cycleCount"];
}
// Function: 9830.sol-SpaceWar-GetGlobalProduction()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
globalMoney = 0

IRs:
globalMoney(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
globalHashRate = 0

IRs:
globalHashRate(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->12;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < topindex

IRs:
TMP_60(bool) = i < topindex
CONDITION TMP_60"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
m = miners[indexes[i]]

IRs:
REF_52(address) -> indexes[i]
REF_53(SpaceWar.MinerData) -> miners[REF_52]
m(SpaceWar.MinerData) := REF_53(SpaceWar.MinerData)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
globalMoney += m.money

IRs:
REF_54(uint256) -> m.money
globalMoney(uint256) = globalMoney + REF_54"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
globalHashRate += GetProductionPerSecond(indexes[i])

IRs:
REF_55(address) -> indexes[i]
TMP_61(uint256) = INTERNAL_CALL, SpaceWar.GetProductionPerSecond(address)(REF_55)
globalHashRate(uint256) = globalHashRate + TMP_61"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
11->7;
12[label="Node Type: RETURN 12

EXPRESSION:
(globalMoney,globalHashRate)

IRs:
RETURN globalMoney,globalHashRate"];
}
// Function: 9830.sol-SpaceWar-GetICOData(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(idx <= cycleCount)

IRs:
TMP_68(bool) = idx <= cycleCount
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ICOFund = globalICOPerCycle[idx]

IRs:
REF_73(uint256) -> globalICOPerCycle[idx]
ICOFund(uint256) := REF_73(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
idx < cycleCount

IRs:
TMP_70(bool) = idx < cycleCount
CONDITION TMP_70"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ICOPot = honeyPotPerCycle[idx]

IRs:
REF_74(uint256) -> honeyPotPerCycle[idx]
ICOPot(uint256) := REF_74(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ICOPot = honeyPotAmount / 10

IRs:
TMP_71(uint256) = honeyPotAmount / 10
ICOPot(uint256) := TMP_71(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: RETURN 7

EXPRESSION:
(ICOFund,ICOPot)

IRs:
RETURN ICOFund,ICOPot"];
}
// Function: 9830.sol-SpaceWar-GetMinerAt(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(idx < topindex)

IRs:
TMP_52(bool) = idx < topindex
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
minerAddr = indexes[idx]

IRs:
REF_45(address) -> indexes[idx]
minerAddr(address) := REF_45(address)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
minerAddr

IRs:
RETURN minerAddr"];
}
// Function: 9830.sol-SpaceWar-GetMinerData(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
money = miners[minerAddr].money

IRs:
REF_31(SpaceWar.MinerData) -> miners[minerAddr]
REF_32(uint256) -> REF_31.money
money(uint256) := REF_32(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
lastupdate = miners[minerAddr].lastUpdateTime

IRs:
REF_33(SpaceWar.MinerData) -> miners[minerAddr]
REF_34(uint256) -> REF_33.lastUpdateTime
lastupdate(uint256) := REF_34(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
prodPerSec = GetProductionPerSecond(minerAddr)

IRs:
TMP_45(uint256) = INTERNAL_CALL, SpaceWar.GetProductionPerSecond(address)(minerAddr)
prodPerSec(uint256) := TMP_45(uint256)"];
4->7;
5[label="Node Type: BEGIN_LOOP 5
"];
5->8;
6[label="Node Type: END_LOOP 6
"];
6->13;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
7->5;
8[label="Node Type: IF_LOOP 8

EXPRESSION:
i < NUMBER_OF_RIG_TYPES

IRs:
TMP_46(bool) = i < NUMBER_OF_RIG_TYPES
CONDITION TMP_46"];
8->9[label="True"];
8->6[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
spaces[i] = miners[minerAddr].spaces[i]

IRs:
REF_35(uint256) -> spaces[i]
REF_36(SpaceWar.MinerData) -> miners[minerAddr]
REF_37(uint256[9]) -> REF_36.spaces
REF_38(uint256) -> REF_37[i]
REF_35(uint256) (->spaces) := REF_38(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
++ i

IRs:
i(uint8) = i + 1"];
10->8;
11[label="Node Type: BEGIN_LOOP 11
"];
11->14;
12[label="Node Type: END_LOOP 12
"];
12->17;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)"];
13->11;
14[label="Node Type: IF_LOOP 14

EXPRESSION:
i < NUMBER_OF_UPGRADES

IRs:
TMP_47(bool) = i < NUMBER_OF_UPGRADES
CONDITION TMP_47"];
14->15[label="True"];
14->12[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
upgrades[i] = miners[minerAddr].hasUpgrade[i]

IRs:
REF_39(uint256) -> upgrades[i]
REF_40(SpaceWar.MinerData) -> miners[minerAddr]
REF_41(uint8[3]) -> REF_40.hasUpgrade
REF_42(uint8) -> REF_41[i]
REF_39(uint256) (->upgrades) := REF_42(uint8)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
++ i

IRs:
i(uint8) = i + 1"];
16->14;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
unclaimedPot = miners[minerAddr].unclaimedPot

IRs:
REF_43(SpaceWar.MinerData) -> miners[minerAddr]
REF_44(uint256) -> REF_43.unclaimedPot
unclaimedPot(uint256) := REF_44(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
hasBooster = HasBooster(minerAddr)

IRs:
TMP_48(bool) = INTERNAL_CALL, SpaceWar.HasBooster(address)(minerAddr)
hasBooster(bool) := TMP_48(bool)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
unconfirmedMoney = money + (prodPerSec * (now - lastupdate))

IRs:
TMP_49(uint256) = now - lastupdate
TMP_50(uint256) = prodPerSec * TMP_49
TMP_51(uint256) = money + TMP_50
unconfirmedMoney(uint256) := TMP_51(uint256)"];
19->20;
20[label="Node Type: RETURN 20

EXPRESSION:
(money,lastupdate,prodPerSec,spaces,upgrades,unclaimedPot,hasBooster,unconfirmedMoney)

IRs:
RETURN money,lastupdate,prodPerSec,spaces,upgrades,unclaimedPot,hasBooster,unconfirmedMoney"];
}
// Function: 9830.sol-SpaceWar-GetMinerICOData(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(idx <= cycleCount)

IRs:
TMP_72(bool) = idx <= cycleCount
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ICOFund = minerICOPerCycle[miner][idx]

IRs:
REF_75(mapping(uint256 => uint256)) -> minerICOPerCycle[miner]
REF_76(uint256) -> REF_75[idx]
ICOFund(uint256) := REF_76(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
idx < cycleCount

IRs:
TMP_74(bool) = idx < cycleCount
CONDITION TMP_74"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ICOShare = (honeyPotPerCycle[idx] * minerICOPerCycle[miner][idx]) / globalICOPerCycle[idx]

IRs:
REF_77(uint256) -> honeyPotPerCycle[idx]
REF_78(mapping(uint256 => uint256)) -> minerICOPerCycle[miner]
REF_79(uint256) -> REF_78[idx]
TMP_75(uint256) = REF_77 * REF_79
REF_80(uint256) -> globalICOPerCycle[idx]
TMP_76(uint256) = TMP_75 / REF_80
ICOShare(uint256) := TMP_76(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ICOShare = (honeyPotAmount / 10) * minerICOPerCycle[miner][idx] / globalICOPerCycle[idx]

IRs:
TMP_77(uint256) = honeyPotAmount / 10
REF_81(mapping(uint256 => uint256)) -> minerICOPerCycle[miner]
REF_82(uint256) -> REF_81[idx]
TMP_78(uint256) = TMP_77 * REF_82
REF_83(uint256) -> globalICOPerCycle[idx]
TMP_79(uint256) = TMP_78 / REF_83
ICOShare(uint256) := TMP_79(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
lastClaimIndex = miners[miner].lastPotClaimIndex

IRs:
REF_84(SpaceWar.MinerData) -> miners[miner]
REF_85(uint256) -> REF_84.lastPotClaimIndex
lastClaimIndex(uint256) := REF_85(uint256)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
(ICOFund,ICOShare,lastClaimIndex)

IRs:
RETURN ICOFund,ICOShare,lastClaimIndex"];
}
// Function: 9830.sol-SpaceWar-GetMinerUnclaimedICOShare(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
m = miners[miner]

IRs:
REF_86(SpaceWar.MinerData) -> miners[miner]
m(SpaceWar.MinerData) := REF_86(SpaceWar.MinerData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(m.lastUpdateTime != 0)

IRs:
REF_87(uint256) -> m.lastUpdateTime
TMP_80(bool) = REF_87 != 0
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(m.lastPotClaimIndex < cycleCount)

IRs:
REF_88(uint256) -> m.lastPotClaimIndex
TMP_82(bool) = REF_88 < cycleCount
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = m.lastPotClaimIndex

IRs:
REF_89(uint256) -> m.lastPotClaimIndex
i(uint256) := REF_89(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
limit = cycleCount

IRs:
limit(uint256) := cycleCount(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
(limit - i) > 30

IRs:
TMP_84(uint256) = limit - i
TMP_85(bool) = TMP_84 > 30
CONDITION TMP_85"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
limit = i + 30

IRs:
TMP_86(uint256) = i + 30
limit(uint256) := TMP_86(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
unclaimedPot = 0

IRs:
unclaimedPot(uint256) := 0(uint256)"];
9->10;
10[label="Node Type: BEGIN_LOOP 10
"];
10->12;
11[label="Node Type: END_LOOP 11
"];
11->17;
12[label="Node Type: IF_LOOP 12

EXPRESSION:
i < cycleCount

IRs:
TMP_87(bool) = i < cycleCount
CONDITION TMP_87"];
12->13[label="True"];
12->11[label="False"];
13[label="Node Type: IF 13

EXPRESSION:
minerICOPerCycle[miner][i] > 0

IRs:
REF_90(mapping(uint256 => uint256)) -> minerICOPerCycle[miner]
REF_91(uint256) -> REF_90[i]
TMP_88(bool) = REF_91 > 0
CONDITION TMP_88"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[miner][i]) / globalICOPerCycle[i]

IRs:
REF_92(uint256) -> honeyPotPerCycle[i]
REF_93(mapping(uint256 => uint256)) -> minerICOPerCycle[miner]
REF_94(uint256) -> REF_93[i]
TMP_89(uint256) = REF_92 * REF_94
REF_95(uint256) -> globalICOPerCycle[i]
TMP_90(uint256) = TMP_89 / REF_95
unclaimedPot(uint256) = unclaimedPot + TMP_90"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
16->12;
17[label="Node Type: RETURN 17

EXPRESSION:
unclaimedPot

IRs:
RETURN unclaimedPot"];
}
// Function: 9830.sol-SpaceWar-GetPVPData(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
a = pvpMap[addr]

IRs:
REF_59(SpaceWar.PVPData) -> pvpMap[addr]
a(SpaceWar.PVPData) := REF_59(SpaceWar.PVPData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
immunityTime = a.immunityTime

IRs:
REF_60(uint256) -> a.immunityTime
immunityTime(uint256) := REF_60(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
exhaustTime = a.exhaustTime

IRs:
REF_61(uint256) -> a.exhaustTime
exhaustTime(uint256) := REF_61(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
attackpower = 0

IRs:
attackpower(uint256) := 0(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
defensepower = 0

IRs:
defensepower(uint256) := 0(uint256)"];
5->8;
6[label="Node Type: BEGIN_LOOP 6
"];
6->9;
7[label="Node Type: END_LOOP 7
"];
7->14;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
8->6;
9[label="Node Type: IF_LOOP 9

EXPRESSION:
i < NUMBER_OF_TROOPS

IRs:
TMP_65(bool) = i < NUMBER_OF_TROOPS
CONDITION TMP_65"];
9->10[label="True"];
9->7[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
attackpower += a.troops[i] * troopData[i].attackPower

IRs:
REF_62(uint256[6]) -> a.troops
REF_63(uint256) -> REF_62[i]
REF_64(SpaceWar.TroopData) -> troopData[i]
REF_65(uint256) -> REF_64.attackPower
TMP_66(uint256) = REF_63 * REF_65
attackpower(uint256) = attackpower + TMP_66"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
defensepower += a.troops[i] * troopData[i].defensePower

IRs:
REF_66(uint256[6]) -> a.troops
REF_67(uint256) -> REF_66[i]
REF_68(SpaceWar.TroopData) -> troopData[i]
REF_69(uint256) -> REF_68.defensePower
TMP_67(uint256) = REF_67 * REF_69
defensepower(uint256) = defensepower + TMP_67"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
troops[i] = a.troops[i]

IRs:
REF_70(uint256) -> troops[i]
REF_71(uint256[6]) -> a.troops
REF_72(uint256) -> REF_71[i]
REF_70(uint256) (->troops) := REF_72(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
13->9;
14[label="Node Type: RETURN 14

EXPRESSION:
(attackpower,defensepower,immunityTime,exhaustTime,troops)

IRs:
RETURN attackpower,defensepower,immunityTime,exhaustTime,troops"];
}
// Function: 9830.sol-SpaceWar-GetPotInfo()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_honeyPotAmount = honeyPotAmount

IRs:
_honeyPotAmount(uint256) := honeyPotAmount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_devFunds = devFund

IRs:
_devFunds(uint256) := devFund(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_jackPot = jackPot

IRs:
_jackPot(uint256) := jackPot(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_nextDistributionTime = nextPotDistributionTime

IRs:
_nextDistributionTime(uint256) := nextPotDistributionTime(uint256)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
(_honeyPotAmount,_devFunds,_jackPot,_nextDistributionTime)

IRs:
RETURN _honeyPotAmount,_devFunds,_jackPot,_nextDistributionTime"];
}
// Function: 9830.sol-SpaceWar-GetProductionPerSecond(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
m = miners[minerAddr]

IRs:
REF_46(SpaceWar.MinerData) -> miners[minerAddr]
m(SpaceWar.MinerData) := REF_46(SpaceWar.MinerData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
personalProduction = 0

IRs:
personalProduction(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
productionSpeed = 100 + m.premamentMineBonusPct

IRs:
REF_47(uint256) -> m.premamentMineBonusPct
TMP_54(uint256) = 100 + REF_47
productionSpeed(uint256) := TMP_54(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
HasBooster(minerAddr)

IRs:
TMP_55(bool) = INTERNAL_CALL, SpaceWar.HasBooster(address)(minerAddr)
CONDITION TMP_55"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
productionSpeed += 100

IRs:
productionSpeed(uint256) = productionSpeed + 100"];
5->6;
6[label="Node Type: END_IF 6
"];
6->9;
7[label="Node Type: BEGIN_LOOP 7
"];
7->10;
8[label="Node Type: END_LOOP 8
"];
8->13;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
j = 0

IRs:
j(uint8) := 0(uint256)"];
9->7;
10[label="Node Type: IF_LOOP 10

EXPRESSION:
j < NUMBER_OF_RIG_TYPES

IRs:
TMP_56(bool) = j < NUMBER_OF_RIG_TYPES
CONDITION TMP_56"];
10->11[label="True"];
10->8[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
personalProduction += m.spaces[j] * spaceData[j].baseOutput

IRs:
REF_48(uint256[9]) -> m.spaces
REF_49(uint256) -> REF_48[j]
REF_50(SpaceWar.SpaceData) -> spaceData[j]
REF_51(uint256) -> REF_50.baseOutput
TMP_57(uint256) = REF_49 * REF_51
personalProduction(uint256) = personalProduction + TMP_57"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
++ j

IRs:
j(uint8) = j + 1"];
12->10;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
personalProduction = personalProduction * productionSpeed / 100

IRs:
TMP_58(uint256) = personalProduction * productionSpeed
TMP_59(uint256) = TMP_58 / 100
personalProduction(uint256) := TMP_59(uint256)"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
personalProduction

IRs:
RETURN personalProduction"];
}
// Function: 9830.sol-SpaceWar-GetTotalMinerCount()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
count = topindex

IRs:
count(uint256) := topindex(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 9830.sol-SpaceWar-HasBooster(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < NUMBER_OF_BOOSTERS

IRs:
TMP_63(bool) = i < NUMBER_OF_BOOSTERS
CONDITION TMP_63"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
boosterHolders[i] == addr

IRs:
REF_58(address) -> boosterHolders[i]
TMP_64(bool) = REF_58 == addr
CONDITION TMP_64"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False"];
10[label="Node Type: RETURN 10

EXPRESSION:
hasBoost

IRs:
RETURN hasBoost"];
}
// Function: 9830.sol-SpaceWar-ReleaseICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime != 0)

IRs:
REF_283(SpaceWar.MinerData) -> miners[msg.sender]
REF_284(uint256) -> REF_283.lastUpdateTime
TMP_236(bool) = REF_284 != 0
TMP_237(None) = SOLIDITY_CALL require(bool)(TMP_236)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(nextPotDistributionTime <= block.timestamp)

IRs:
TMP_238(bool) = nextPotDistributionTime <= block.timestamp
TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(honeyPotAmount > 0)

IRs:
TMP_240(bool) = honeyPotAmount > 0
TMP_241(None) = SOLIDITY_CALL require(bool)(TMP_240)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(globalICOPerCycle[cycleCount] > 0)

IRs:
REF_285(uint256) -> globalICOPerCycle[cycleCount]
TMP_242(bool) = REF_285 > 0
TMP_243(None) = SOLIDITY_CALL require(bool)(TMP_242)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
nextPotDistributionTime = block.timestamp + 86400

IRs:
TMP_244(uint256) = block.timestamp + 86400
nextPotDistributionTime(uint256) := TMP_244(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
honeyPotPerCycle[cycleCount] = honeyPotAmount / 10

IRs:
REF_286(uint256) -> honeyPotPerCycle[cycleCount]
TMP_245(uint256) = honeyPotAmount / 10
REF_286(uint256) (->honeyPotPerCycle) := TMP_245(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
honeyPotAmount -= honeyPotAmount / 10

IRs:
TMP_246(uint256) = honeyPotAmount / 10
honeyPotAmount(uint256) = honeyPotAmount - TMP_246"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
honeyPotPerCycle.push(0)

IRs:
REF_288 -> LENGTH honeyPotPerCycle
TMP_248(uint256) := REF_288(uint256)
TMP_249(uint256) = TMP_248 + 1
REF_288(uint256) (->honeyPotPerCycle) := TMP_249(uint256)
REF_289(uint256) -> honeyPotPerCycle[TMP_248]
REF_289(uint256) (->honeyPotPerCycle) := 0(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
globalICOPerCycle.push(0)

IRs:
REF_291 -> LENGTH globalICOPerCycle
TMP_251(uint256) := REF_291(uint256)
TMP_252(uint256) = TMP_251 + 1
REF_291(uint256) (->globalICOPerCycle) := TMP_252(uint256)
REF_292(uint256) -> globalICOPerCycle[TMP_251]
REF_292(uint256) (->globalICOPerCycle) := 0(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
cycleCount = cycleCount + 1

IRs:
TMP_253(uint256) = cycleCount + 1
cycleCount(uint256) := TMP_253(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
jakpotWinner = miners[msg.sender]

IRs:
REF_293(SpaceWar.MinerData) -> miners[msg.sender]
jakpotWinner(SpaceWar.MinerData) := REF_293(SpaceWar.MinerData)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
jakpotWinner.unclaimedPot += jackPot

IRs:
REF_294(uint256) -> jakpotWinner.unclaimedPot
REF_294(-> jakpotWinner) = REF_294 + jackPot"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
jackPot = 0

IRs:
jackPot(uint256) := 0(uint256)"];
}
// Function: 9830.sol-SpaceWar-SpaceWar()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
spaceData[0] = SpaceData(500,1,5,0,999)

IRs:
REF_2(SpaceWar.SpaceData) -> spaceData[0]
TMP_21(SpaceWar.SpaceData) = new SpaceData(500,1,5,0,999)
REF_2(SpaceWar.SpaceData) (->spaceData) := TMP_21(SpaceWar.SpaceData)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
spaceData[1] = SpaceData(50000,10,500,0,999)

IRs:
REF_3(SpaceWar.SpaceData) -> spaceData[1]
TMP_22(SpaceWar.SpaceData) = new SpaceData(50000,10,500,0,999)
REF_3(SpaceWar.SpaceData) (->spaceData) := TMP_22(SpaceWar.SpaceData)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
spaceData[2] = SpaceData(5000000,100,50000,0,999)

IRs:
REF_4(SpaceWar.SpaceData) -> spaceData[2]
TMP_23(SpaceWar.SpaceData) = new SpaceData(5000000,100,50000,0,999)
REF_4(SpaceWar.SpaceData) (->spaceData) := TMP_23(SpaceWar.SpaceData)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
spaceData[3] = SpaceData(80000000,1000,800000,0,999)

IRs:
REF_5(SpaceWar.SpaceData) -> spaceData[3]
TMP_24(SpaceWar.SpaceData) = new SpaceData(80000000,1000,800000,0,999)
REF_5(SpaceWar.SpaceData) (->spaceData) := TMP_24(SpaceWar.SpaceData)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
spaceData[4] = SpaceData(500000000,20000,5000000,10000000000000000,999)

IRs:
REF_6(SpaceWar.SpaceData) -> spaceData[4]
TMP_25(SpaceWar.SpaceData) = new SpaceData(500000000,20000,5000000,10000000000000000,999)
REF_6(SpaceWar.SpaceData) (->spaceData) := TMP_25(SpaceWar.SpaceData)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
spaceData[5] = SpaceData(10000000000,100000,100000000,0,999)

IRs:
REF_7(SpaceWar.SpaceData) -> spaceData[5]
TMP_26(SpaceWar.SpaceData) = new SpaceData(10000000000,100000,100000000,0,999)
REF_7(SpaceWar.SpaceData) (->spaceData) := TMP_26(SpaceWar.SpaceData)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
spaceData[6] = SpaceData(100000000000,1000000,1000000000,0,999)

IRs:
REF_8(SpaceWar.SpaceData) -> spaceData[6]
TMP_27(SpaceWar.SpaceData) = new SpaceData(100000000000,1000000,1000000000,0,999)
REF_8(SpaceWar.SpaceData) (->spaceData) := TMP_27(SpaceWar.SpaceData)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
spaceData[7] = SpaceData(1000000000000,50000000,10000000000,100000000000000000,999)

IRs:
REF_9(SpaceWar.SpaceData) -> spaceData[7]
TMP_28(SpaceWar.SpaceData) = new SpaceData(1000000000000,50000000,10000000000,100000000000000000,999)
REF_9(SpaceWar.SpaceData) (->spaceData) := TMP_28(SpaceWar.SpaceData)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
spaceData[8] = SpaceData(10000000000000,100000000,100000000000,0,999)

IRs:
REF_10(SpaceWar.SpaceData) -> spaceData[8]
TMP_29(SpaceWar.SpaceData) = new SpaceData(10000000000000,100000000,100000000000,0,999)
REF_10(SpaceWar.SpaceData) (->spaceData) := TMP_29(SpaceWar.SpaceData)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
boostData[0] = BoostData(30,10000000000000000)

IRs:
REF_11(SpaceWar.BoostData) -> boostData[0]
TMP_30(SpaceWar.BoostData) = new BoostData(30,10000000000000000)
REF_11(SpaceWar.BoostData) (->boostData) := TMP_30(SpaceWar.BoostData)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
boostData[1] = BoostData(50,100000000000000000)

IRs:
REF_12(SpaceWar.BoostData) -> boostData[1]
TMP_31(SpaceWar.BoostData) = new BoostData(50,100000000000000000)
REF_12(SpaceWar.BoostData) (->boostData) := TMP_31(SpaceWar.BoostData)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
boostData[2] = BoostData(100,1000000000000000000)

IRs:
REF_13(SpaceWar.BoostData) -> boostData[2]
TMP_32(SpaceWar.BoostData) = new BoostData(100,1000000000000000000)
REF_13(SpaceWar.BoostData) (->boostData) := TMP_32(SpaceWar.BoostData)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
topindex = 0

IRs:
topindex(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
honeyPotAmount = 0

IRs:
honeyPotAmount(uint256) := 0(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
devFund = 0

IRs:
devFund(uint256) := 0(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
jackPot = 0

IRs:
jackPot(uint256) := 0(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
nextPotDistributionTime = block.timestamp

IRs:
nextPotDistributionTime(uint256) := block.timestamp(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
honeyPotSharePct = 90

IRs:
honeyPotSharePct(uint256) := 90(uint256)"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
boosterHolders[0] = owner

IRs:
REF_14(address) -> boosterHolders[0]
REF_14(address) (->boosterHolders) := owner(address)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
boosterHolders[1] = owner

IRs:
REF_15(address) -> boosterHolders[1]
REF_15(address) (->boosterHolders) := owner(address)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
boosterHolders[2] = owner

IRs:
REF_16(address) -> boosterHolders[2]
REF_16(address) (->boosterHolders) := owner(address)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
boosterHolders[3] = owner

IRs:
REF_17(address) -> boosterHolders[3]
REF_17(address) (->boosterHolders) := owner(address)"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
boosterHolders[4] = owner

IRs:
REF_18(address) -> boosterHolders[4]
REF_18(address) (->boosterHolders) := owner(address)"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
boosterIndex = 0

IRs:
boosterIndex(uint256) := 0(uint256)"];
25->26;
26[label="Node Type: EXPRESSION 26

EXPRESSION:
nextBoosterPrice = 100000000000000000

IRs:
nextBoosterPrice(uint256) := 100000000000000000(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
troopData[0] = TroopData(10,0,100000,0)

IRs:
REF_19(SpaceWar.TroopData) -> troopData[0]
TMP_33(SpaceWar.TroopData) = new TroopData(10,0,100000,0)
REF_19(SpaceWar.TroopData) (->troopData) := TMP_33(SpaceWar.TroopData)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
troopData[1] = TroopData(1000,0,80000000,0)

IRs:
REF_20(SpaceWar.TroopData) -> troopData[1]
TMP_34(SpaceWar.TroopData) = new TroopData(1000,0,80000000,0)
REF_20(SpaceWar.TroopData) (->troopData) := TMP_34(SpaceWar.TroopData)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
troopData[2] = TroopData(100000,0,1000000000,10000000000000000)

IRs:
REF_21(SpaceWar.TroopData) -> troopData[2]
TMP_35(SpaceWar.TroopData) = new TroopData(100000,0,1000000000,10000000000000000)
REF_21(SpaceWar.TroopData) (->troopData) := TMP_35(SpaceWar.TroopData)"];
29->30;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
troopData[3] = TroopData(0,15,100000,0)

IRs:
REF_22(SpaceWar.TroopData) -> troopData[3]
TMP_36(SpaceWar.TroopData) = new TroopData(0,15,100000,0)
REF_22(SpaceWar.TroopData) (->troopData) := TMP_36(SpaceWar.TroopData)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
troopData[4] = TroopData(0,1500,80000000,0)

IRs:
REF_23(SpaceWar.TroopData) -> troopData[4]
TMP_37(SpaceWar.TroopData) = new TroopData(0,1500,80000000,0)
REF_23(SpaceWar.TroopData) (->troopData) := TMP_37(SpaceWar.TroopData)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
troopData[5] = TroopData(0,150000,1000000000,10000000000000000)

IRs:
REF_24(SpaceWar.TroopData) -> troopData[5]
TMP_38(SpaceWar.TroopData) = new TroopData(0,150000,1000000000,10000000000000000)
REF_24(SpaceWar.TroopData) (->troopData) := TMP_38(SpaceWar.TroopData)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
honeyPotPerCycle.push(0)

IRs:
REF_26 -> LENGTH honeyPotPerCycle
TMP_40(uint256) := REF_26(uint256)
TMP_41(uint256) = TMP_40 + 1
REF_26(uint256) (->honeyPotPerCycle) := TMP_41(uint256)
REF_27(uint256) -> honeyPotPerCycle[TMP_40]
REF_27(uint256) (->honeyPotPerCycle) := 0(uint256)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
globalICOPerCycle.push(1)

IRs:
REF_29 -> LENGTH globalICOPerCycle
TMP_43(uint256) := REF_29(uint256)
TMP_44(uint256) = TMP_43 + 1
REF_29(uint256) (->globalICOPerCycle) := TMP_44(uint256)
REF_30(uint256) -> globalICOPerCycle[TMP_43]
REF_30(uint256) (->globalICOPerCycle) := 1(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
cycleCount = 0

IRs:
cycleCount(uint256) := 0(uint256)"];
}
// Function: 9830.sol-SpaceWar-StartNewMiner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime == 0)

IRs:
REF_96(SpaceWar.MinerData) -> miners[msg.sender]
REF_97(uint256) -> REF_96.lastUpdateTime
TMP_91(bool) = REF_97 == 0
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
miners[msg.sender].lastUpdateTime = block.timestamp

IRs:
REF_98(SpaceWar.MinerData) -> miners[msg.sender]
REF_99(uint256) -> REF_98.lastUpdateTime
REF_99(uint256) (->miners) := block.timestamp(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
miners[msg.sender].money = 0

IRs:
REF_100(SpaceWar.MinerData) -> miners[msg.sender]
REF_101(uint256) -> REF_100.money
REF_101(uint256) (->miners) := 0(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
miners[msg.sender].spaces[0] = 1

IRs:
REF_102(SpaceWar.MinerData) -> miners[msg.sender]
REF_103(uint256[9]) -> REF_102.spaces
REF_104(uint256) -> REF_103[0]
REF_104(uint256) (->miners) := 1(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
miners[msg.sender].unclaimedPot = 0

IRs:
REF_105(SpaceWar.MinerData) -> miners[msg.sender]
REF_106(uint256) -> REF_105.unclaimedPot
REF_106(uint256) (->miners) := 0(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
miners[msg.sender].lastPotClaimIndex = cycleCount

IRs:
REF_107(SpaceWar.MinerData) -> miners[msg.sender]
REF_108(uint256) -> REF_107.lastPotClaimIndex
REF_108(uint256) (->miners) := cycleCount(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
pvpMap[msg.sender].immunityTime = block.timestamp + 14400

IRs:
REF_109(SpaceWar.PVPData) -> pvpMap[msg.sender]
REF_110(uint256) -> REF_109.immunityTime
TMP_93(uint256) = block.timestamp + 14400
REF_110(uint256) (->pvpMap) := TMP_93(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
pvpMap[msg.sender].exhaustTime = block.timestamp

IRs:
REF_111(SpaceWar.PVPData) -> pvpMap[msg.sender]
REF_112(uint256) -> REF_111.exhaustTime
REF_112(uint256) (->pvpMap) := block.timestamp(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
indexes[topindex] = msg.sender

IRs:
REF_113(address) -> indexes[topindex]
REF_113(address) (->indexes) := msg.sender(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
++ topindex

IRs:
topindex(uint256) = topindex + 1"];
}
// Function: 9830.sol-SpaceWar-UpdateMoney()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime != 0)

IRs:
REF_173(SpaceWar.MinerData) -> miners[msg.sender]
REF_174(uint256) -> REF_173.lastUpdateTime
TMP_132(bool) = REF_174 != 0
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.timestamp >= miners[msg.sender].lastUpdateTime)

IRs:
REF_175(SpaceWar.MinerData) -> miners[msg.sender]
REF_176(uint256) -> REF_175.lastUpdateTime
TMP_134(bool) = block.timestamp >= REF_176
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
m = miners[msg.sender]

IRs:
REF_177(SpaceWar.MinerData) -> miners[msg.sender]
m(SpaceWar.MinerData) := REF_177(SpaceWar.MinerData)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
diff = block.timestamp - m.lastUpdateTime

IRs:
REF_178(uint256) -> m.lastUpdateTime
TMP_136(uint256) = block.timestamp - REF_178
diff(uint256) := TMP_136(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
revenue = GetProductionPerSecond(msg.sender)

IRs:
TMP_137(uint256) = INTERNAL_CALL, SpaceWar.GetProductionPerSecond(address)(msg.sender)
revenue(uint256) := TMP_137(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
m.lastUpdateTime = block.timestamp

IRs:
REF_179(uint256) -> m.lastUpdateTime
REF_179(uint256) (->m) := block.timestamp(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
revenue > 0

IRs:
TMP_138(bool) = revenue > 0
CONDITION TMP_138"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revenue *= diff

IRs:
revenue(uint256) = revenue * diff"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
m.money += revenue

IRs:
REF_180(uint256) -> m.money
REF_180(-> m) = REF_180 + revenue"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 9830.sol-SpaceWar-UpdateMoneyAt(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(miners[addr].lastUpdateTime != 0)

IRs:
REF_181(SpaceWar.MinerData) -> miners[addr]
REF_182(uint256) -> REF_181.lastUpdateTime
TMP_139(bool) = REF_182 != 0
TMP_140(None) = SOLIDITY_CALL require(bool)(TMP_139)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.timestamp >= miners[addr].lastUpdateTime)

IRs:
REF_183(SpaceWar.MinerData) -> miners[addr]
REF_184(uint256) -> REF_183.lastUpdateTime
TMP_141(bool) = block.timestamp >= REF_184
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
m = miners[addr]

IRs:
REF_185(SpaceWar.MinerData) -> miners[addr]
m(SpaceWar.MinerData) := REF_185(SpaceWar.MinerData)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
diff = block.timestamp - m.lastUpdateTime

IRs:
REF_186(uint256) -> m.lastUpdateTime
TMP_143(uint256) = block.timestamp - REF_186
diff(uint256) := TMP_143(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
revenue = GetProductionPerSecond(addr)

IRs:
TMP_144(uint256) = INTERNAL_CALL, SpaceWar.GetProductionPerSecond(address)(addr)
revenue(uint256) := TMP_144(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
m.lastUpdateTime = block.timestamp

IRs:
REF_187(uint256) -> m.lastUpdateTime
REF_187(uint256) (->m) := block.timestamp(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
revenue > 0

IRs:
TMP_145(bool) = revenue > 0
CONDITION TMP_145"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
revenue *= diff

IRs:
revenue(uint256) = revenue * diff"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
m.money += revenue

IRs:
REF_188(uint256) -> m.money
REF_188(-> m) = REF_188 + revenue"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 9830.sol-SpaceWar-UpgradeSpace(uint8,uint16)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(spaceIdx < NUMBER_OF_RIG_TYPES)

IRs:
TMP_94(bool) = spaceIdx < NUMBER_OF_RIG_TYPES
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(count > 0)

IRs:
TMP_96(bool) = count > 0
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(count <= 999)

IRs:
TMP_98(bool) = count <= 999
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(spaceData[spaceIdx].priceInETH == 0)

IRs:
REF_114(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_115(uint256) -> REF_114.priceInETH
TMP_100(bool) = REF_115 == 0
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
m = miners[msg.sender]

IRs:
REF_116(SpaceWar.MinerData) -> miners[msg.sender]
m(SpaceWar.MinerData) := REF_116(SpaceWar.MinerData)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count))

IRs:
REF_117(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_118(uint256) -> REF_117.limit
REF_119(uint256[9]) -> m.spaces
REF_120(uint256) -> REF_119[spaceIdx]
TMP_102(uint256) = REF_120 + count
TMP_103(bool) = REF_118 >= TMP_102
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
UpdateMoney()

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoney()()"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
price = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice,spaceData[spaceIdx].pricePerLevel,m.spaces[spaceIdx],count)

IRs:
REF_122(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_123(uint256) -> REF_122.basePrice
REF_124(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_125(uint256) -> REF_124.pricePerLevel
REF_126(uint256[9]) -> m.spaces
REF_127(uint256) -> REF_126[spaceIdx]
TMP_106(uint256) = LIBRARY_CALL, dest:NumericSequence, function:NumericSequence.sumOfN(uint256,uint256,uint256,uint256), arguments:['REF_123', 'REF_125', 'REF_127', 'count'] 
price(uint256) := TMP_106(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(m.money >= price)

IRs:
REF_128(uint256) -> m.money
TMP_107(bool) = REF_128 >= price
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
m.spaces[spaceIdx] = m.spaces[spaceIdx] + count

IRs:
REF_129(uint256[9]) -> m.spaces
REF_130(uint256) -> REF_129[spaceIdx]
REF_131(uint256[9]) -> m.spaces
REF_132(uint256) -> REF_131[spaceIdx]
TMP_109(uint256) = REF_132 + count
REF_130(uint256) (->m) := TMP_109(uint256)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
m.spaces[spaceIdx] > spaceData[spaceIdx].limit

IRs:
REF_133(uint256[9]) -> m.spaces
REF_134(uint256) -> REF_133[spaceIdx]
REF_135(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_136(uint256) -> REF_135.limit
TMP_110(bool) = REF_134 > REF_136
CONDITION TMP_110"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
m.spaces[spaceIdx] = spaceData[spaceIdx].limit

IRs:
REF_137(uint256[9]) -> m.spaces
REF_138(uint256) -> REF_137[spaceIdx]
REF_139(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_140(uint256) -> REF_139.limit
REF_138(uint256) (->m) := REF_140(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
m.money -= price

IRs:
REF_141(uint256) -> m.money
REF_141(-> m) = REF_141 - price"];
}
// Function: 9830.sol-SpaceWar-UpgradeSpaceETH(uint8,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(spaceIdx < NUMBER_OF_RIG_TYPES)

IRs:
TMP_111(bool) = spaceIdx < NUMBER_OF_RIG_TYPES
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(count > 0)

IRs:
TMP_113(bool) = count > 0
TMP_114(None) = SOLIDITY_CALL require(bool)(TMP_113)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(count <= 999)

IRs:
TMP_115(bool) = count <= 999
TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(spaceData[spaceIdx].priceInETH > 0)

IRs:
REF_142(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_143(uint256) -> REF_142.priceInETH
TMP_117(bool) = REF_143 > 0
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
m = miners[msg.sender]

IRs:
REF_144(SpaceWar.MinerData) -> miners[msg.sender]
m(SpaceWar.MinerData) := REF_144(SpaceWar.MinerData)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count))

IRs:
REF_145(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_146(uint256) -> REF_145.limit
REF_147(uint256[9]) -> m.spaces
REF_148(uint256) -> REF_147[spaceIdx]
TMP_119(uint256) = REF_148 + count
TMP_120(bool) = REF_146 >= TMP_119
TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
price = (spaceData[spaceIdx].priceInETH).mul(count)

IRs:
REF_149(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_150(uint256) -> REF_149.priceInETH
TMP_122(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_150', 'count'] 
price(uint256) := TMP_122(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
priceCoin = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice,spaceData[spaceIdx].pricePerLevel,m.spaces[spaceIdx],count)

IRs:
REF_153(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_154(uint256) -> REF_153.basePrice
REF_155(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_156(uint256) -> REF_155.pricePerLevel
REF_157(uint256[9]) -> m.spaces
REF_158(uint256) -> REF_157[spaceIdx]
TMP_123(uint256) = LIBRARY_CALL, dest:NumericSequence, function:NumericSequence.sumOfN(uint256,uint256,uint256,uint256), arguments:['REF_154', 'REF_156', 'REF_158', 'count'] 
priceCoin(uint256) := TMP_123(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
UpdateMoney()

IRs:
INTERNAL_CALL, SpaceWar.UpdateMoney()()"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(msg.value >= price)

IRs:
TMP_125(bool) = msg.value >= price
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(m.money >= priceCoin)

IRs:
REF_159(uint256) -> m.money
TMP_127(bool) = REF_159 >= priceCoin
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
BuyHandler(msg.value)

IRs:
INTERNAL_CALL, SpaceWar.BuyHandler(uint256)(msg.value)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
m.spaces[spaceIdx] = m.spaces[spaceIdx] + count

IRs:
REF_160(uint256[9]) -> m.spaces
REF_161(uint256) -> REF_160[spaceIdx]
REF_162(uint256[9]) -> m.spaces
REF_163(uint256) -> REF_162[spaceIdx]
TMP_130(uint256) = REF_163 + count
REF_161(uint256) (->m) := TMP_130(uint256)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
m.spaces[spaceIdx] > spaceData[spaceIdx].limit

IRs:
REF_164(uint256[9]) -> m.spaces
REF_165(uint256) -> REF_164[spaceIdx]
REF_166(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_167(uint256) -> REF_166.limit
TMP_131(bool) = REF_165 > REF_167
CONDITION TMP_131"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
m.spaces[spaceIdx] = spaceData[spaceIdx].limit

IRs:
REF_168(uint256[9]) -> m.spaces
REF_169(uint256) -> REF_168[spaceIdx]
REF_170(SpaceWar.SpaceData) -> spaceData[spaceIdx]
REF_171(uint256) -> REF_170.limit
REF_169(uint256) (->m) := REF_171(uint256)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
m.money -= priceCoin

IRs:
REF_172(uint256) -> m.money
REF_172(-> m) = REF_172 - priceCoin"];
}
// Function: 9830.sol-SpaceWar-WithdrawDevFunds()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_289(bool) = msg.sender == owner
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
owner.send(devFund)

IRs:
TMP_291 = SEND dest:owner value:devFund
CONDITION TMP_291"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
devFund = 0

IRs:
devFund(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 9830.sol-SpaceWar-WithdrawICOEarnings()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
m = miners[msg.sender]

IRs:
REF_310(SpaceWar.MinerData) -> miners[msg.sender]
m(SpaceWar.MinerData) := REF_310(SpaceWar.MinerData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(miners[msg.sender].lastUpdateTime != 0)

IRs:
REF_311(SpaceWar.MinerData) -> miners[msg.sender]
REF_312(uint256) -> REF_311.lastUpdateTime
TMP_266(bool) = REF_312 != 0
TMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(miners[msg.sender].lastPotClaimIndex < cycleCount)

IRs:
REF_313(SpaceWar.MinerData) -> miners[msg.sender]
REF_314(uint256) -> REF_313.lastPotClaimIndex
TMP_268(bool) = REF_314 < cycleCount
TMP_269(None) = SOLIDITY_CALL require(bool)(TMP_268)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = m.lastPotClaimIndex

IRs:
REF_315(uint256) -> m.lastPotClaimIndex
i(uint256) := REF_315(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
limit = cycleCount

IRs:
limit(uint256) := cycleCount(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
(limit - i) > 30

IRs:
TMP_270(uint256) = limit - i
TMP_271(bool) = TMP_270 > 30
CONDITION TMP_271"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
limit = i + 30

IRs:
TMP_272(uint256) = i + 30
limit(uint256) := TMP_272(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
m.lastPotClaimIndex = limit

IRs:
REF_316(uint256) -> m.lastPotClaimIndex
REF_316(uint256) (->m) := limit(uint256)"];
9->10;
10[label="Node Type: BEGIN_LOOP 10
"];
10->12;
11[label="Node Type: END_LOOP 11
"];
12[label="Node Type: IF_LOOP 12

EXPRESSION:
i < cycleCount

IRs:
TMP_273(bool) = i < cycleCount
CONDITION TMP_273"];
12->13[label="True"];
12->11[label="False"];
13[label="Node Type: IF 13

EXPRESSION:
minerICOPerCycle[msg.sender][i] > 0

IRs:
REF_317(mapping(uint256 => uint256)) -> minerICOPerCycle[msg.sender]
REF_318(uint256) -> REF_317[i]
TMP_274(bool) = REF_318 > 0
CONDITION TMP_274"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
m.unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[msg.sender][i]) / globalICOPerCycle[i]

IRs:
REF_319(uint256) -> m.unclaimedPot
REF_320(uint256) -> honeyPotPerCycle[i]
REF_321(mapping(uint256 => uint256)) -> minerICOPerCycle[msg.sender]
REF_322(uint256) -> REF_321[i]
TMP_275(uint256) = REF_320 * REF_322
REF_323(uint256) -> globalICOPerCycle[i]
TMP_276(uint256) = TMP_275 / REF_323
REF_319(-> m) = REF_319 + TMP_276"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
16->12;
}
// Function: 9830.sol-SpaceWar-WithdrawPotShare()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
m = miners[msg.sender]

IRs:
REF_324(SpaceWar.MinerData) -> miners[msg.sender]
m(SpaceWar.MinerData) := REF_324(SpaceWar.MinerData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(m.unclaimedPot > 0)

IRs:
REF_325(uint256) -> m.unclaimedPot
TMP_284(bool) = REF_325 > 0
TMP_285(None) = SOLIDITY_CALL require(bool)(TMP_284)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(m.lastUpdateTime != 0)

IRs:
REF_326(uint256) -> m.lastUpdateTime
TMP_286(bool) = REF_326 != 0
TMP_287(None) = SOLIDITY_CALL require(bool)(TMP_286)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
amntToSend = m.unclaimedPot

IRs:
REF_327(uint256) -> m.unclaimedPot
amntToSend(uint256) := REF_327(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
m.unclaimedPot = 0

IRs:
REF_328(uint256) -> m.unclaimedPot
REF_328(uint256) (->m) := 0(uint256)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
msg.sender.send(amntToSend)

IRs:
TMP_288 = SEND dest:msg.sender value:amntToSend
CONDITION TMP_288"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
m.unclaimedPot = 0

IRs:
REF_330(uint256) -> m.unclaimedPot
REF_330(uint256) (->m) := 0(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
}
// Function: 9830.sol-SpaceWar-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
devFund += msg.value

IRs:
devFund(uint256) = devFund + msg.value"];
}
// Function: 9830.sol-SpaceWar-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
NUMBER_OF_RIG_TYPES = 9

IRs:
NUMBER_OF_RIG_TYPES(uint8) := 9(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
NUMBER_OF_UPGRADES = 3

IRs:
NUMBER_OF_UPGRADES(uint8) := 3(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
NUMBER_OF_TROOPS = 6

IRs:
NUMBER_OF_TROOPS(uint8) := 6(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
ATTACKER_START_IDX = 0

IRs:
ATTACKER_START_IDX(uint8) := 0(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
ATTACKER_END_IDX = 3

IRs:
ATTACKER_END_IDX(uint8) := 3(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
DEFENDER_START_IDX = 3

IRs:
DEFENDER_START_IDX(uint8) := 3(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
DEFENDER_END_IDX = 6

IRs:
DEFENDER_END_IDX(uint8) := 6(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
NUMBER_OF_BOOSTERS = 5

IRs:
NUMBER_OF_BOOSTERS(uint256) := 5(uint256)"];
}
}
