digraph G {
// Function: 20596.sol-BasicToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_6(uint256) -> balances[_owner]
RETURN REF_6"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 20596.sol-BasicToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.data.length >= size + 4)

IRs:
REF_7 -> LENGTH msg.data
TMP_30(uint256) = size + 4
TMP_31(bool) = REF_7 >= TMP_30
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-BasicToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_0(uint256) -> balances[msg.sender]
REF_1(uint256) -> balances[msg.sender]
TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1', '_value'] 
REF_0(uint256) (->balances) := TMP_22(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_3(uint256) -> balances[_to]
REF_4(uint256) -> balances[_to]
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_4', '_value'] 
REF_3(uint256) (->balances) := TMP_23(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_25(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_25)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
unblocked()

IRs:
MODIFIER_CALL, Blocked.unblocked()()"];
6->1;
}
// Function: 20596.sol-BasicToken-unblocked()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > blockedUntil)

IRs:
TMP_28(bool) = now > blockedUntil
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-Blocked-unblocked()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > blockedUntil)

IRs:
TMP_20(bool) = now > blockedUntil
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-BurnableToken-allowance(address,address)
digraph{
}
// Function: 20596.sol-BurnableToken-approve(address,uint256)
digraph{
}
// Function: 20596.sol-BurnableToken-balanceOf(address)
digraph{
}
// Function: 20596.sol-BurnableToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_86(bool) = _value > 0
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_57(uint256) -> balances[msg.sender]
TMP_88(bool) = _value <= REF_57
TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_58(uint256) -> balances[burner]
REF_59(uint256) -> balances[burner]
TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_59', '_value'] 
REF_58(uint256) (->balances) := TMP_90(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = totalSupply.sub(_value)

IRs:
TMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] 
totalSupply(uint256) := TMP_91(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
unblocked()

IRs:
MODIFIER_CALL, Blocked.unblocked()()"];
7->1;
}
// Function: 20596.sol-BurnableToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.data.length >= size + 4)

IRs:
REF_62 -> LENGTH msg.data
TMP_94(uint256) = size + 4
TMP_95(bool) = REF_62 >= TMP_94
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-BurnableToken-transfer(address,uint256)
digraph{
}
// Function: 20596.sol-BurnableToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 20596.sol-BurnableToken-unblocked()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > blockedUntil)

IRs:
TMP_97(bool) = now > blockedUntil
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-Crowdsale-Crowdsale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
token = new DEVCoin(maxTokenAmount,ICOendTime)

IRs:
TMP_172(DEVCoin) = new DEVCoin(maxTokenAmount,ICOendTime) 
token(DEVCoin) := TMP_172(DEVCoin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
leftTokens = maxPreICOTokenAmount

IRs:
leftTokens(uint256) := maxPreICOTokenAmount(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
addCurrencyInternal(0)

IRs:
INTERNAL_CALL, ManualSendingCrowdsale.addCurrencyInternal(uint256)(0)"];
}
// Function: 20596.sol-Crowdsale-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20596.sol-Crowdsale-addCurrency(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
addCurrencyInternal(currency)

IRs:
INTERNAL_CALL, ManualSendingCrowdsale.addCurrencyInternal(uint256)(currency)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 20596.sol-Crowdsale-addCurrencyInternal(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amountData = amountsByCurrency[currency]

IRs:
REF_108(ManualSendingCrowdsale.AmountData) -> amountsByCurrency[currency]
amountData(ManualSendingCrowdsale.AmountData) := REF_108(ManualSendingCrowdsale.AmountData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
amountData.exists = true

IRs:
REF_109(bool) -> amountData.exists
REF_109(bool) (->amountData) := True(bool)"];
}
// Function: 20596.sol-Crowdsale-canBuy()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinished())

IRs:
TMP_296(bool) = INTERNAL_CALL, Crowdsale.isFinished()()
TMP_297 = UnaryType.BANG TMP_296 
TMP_298(None) = SOLIDITY_CALL require(bool)(TMP_297)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isPreICO() || isICO())

IRs:
TMP_299(bool) = INTERNAL_CALL, Crowdsale.isPreICO()()
TMP_300(bool) = INTERNAL_CALL, Crowdsale.isICO()()
TMP_301(bool) = TMP_299 || TMP_300
TMP_302(None) = SOLIDITY_CALL require(bool)(TMP_301)"];
2->3;
3[label="Node Type: _ 3
"];
}
// Function: 20596.sol-Crowdsale-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_owner != 0)

IRs:
TMP_166(bool) = _owner != 0
TMP_167(None) = SOLIDITY_CALL require(bool)(TMP_166)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newOwner = _owner

IRs:
newOwner(address) := _owner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 20596.sol-Crowdsale-confirmOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner == msg.sender)

IRs:
TMP_169(bool) = newOwner == msg.sender
TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete newOwner

IRs:
newOwner = delete newOwner "];
}
// Function: 20596.sol-Crowdsale-currentTime()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
now

IRs:
RETURN now"];
}
// Function: 20596.sol-Crowdsale-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = getBonus(amount)

IRs:
TMP_188(uint256) = INTERNAL_CALL, Crowdsale.getBonus(uint256)(amount)
bonus(uint256) := TMP_188(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
givenTokens = amount.mul(rateToEther).div(100).mul(100 + bonus)

IRs:
TMP_189(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'rateToEther'] 
TMP_190(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_189', '100'] 
TMP_191(uint256) = 100 + bonus
TMP_192(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_190', 'TMP_191'] 
givenTokens(uint256) := TMP_192(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
providedTokens = transferTokensTo(msg.sender,givenTokens)

IRs:
TMP_193(uint256) = INTERNAL_CALL, Crowdsale.transferTokensTo(address,uint256)(msg.sender,givenTokens)
providedTokens(uint256) := TMP_193(uint256)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
givenTokens > providedTokens

IRs:
TMP_194(bool) = givenTokens > providedTokens
CONDITION TMP_194"];
5->6[label="True"];
5->10[label="False"];
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
needAmount = providedTokens.mul(100).div(100 + bonus).div(rateToEther)

IRs:
TMP_195(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['providedTokens', '100'] 
TMP_196(uint256) = 100 + bonus
TMP_197(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_195', 'TMP_196'] 
TMP_198(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_197', 'rateToEther'] 
needAmount(uint256) := TMP_198(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(amount > needAmount)

IRs:
TMP_199(bool) = amount > needAmount
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(msg.sender.call.gas(3000000).value(amount - needAmount)())

IRs:
TMP_202(uint256) = amount - needAmount
TMP_204(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:TMP_202 gas:3000000
TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
amount = needAmount

IRs:
amount(uint256) := needAmount(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
totalAmount = totalAmount.add(amount)

IRs:
TMP_206(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalAmount', 'amount'] 
totalAmount(uint256) := TMP_206(uint256)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
canBuy()

IRs:
MODIFIER_CALL, Crowdsale.canBuy()()"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
minPayment()

IRs:
MODIFIER_CALL, Crowdsale.minPayment()()"];
13->1;
}
// Function: 20596.sol-Crowdsale-finishCrowdsale()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFinished())

IRs:
TMP_237(bool) = INTERNAL_CALL, Crowdsale.isFinished()()
TMP_238(None) = SOLIDITY_CALL require(bool)(TMP_237)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(state == State.ICO)

IRs:
REF_129(Crowdsale.State) -> State.ICO
TMP_239(bool) = state == REF_129
TMP_240(None) = SOLIDITY_CALL require(bool)(TMP_239)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
leftTokens > 0

IRs:
TMP_241(bool) = leftTokens > 0
CONDITION TMP_241"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
token.burn(leftTokens)

IRs:
HIGH_LEVEL_CALL, dest:token(DEVCoin), function:burn, arguments:['leftTokens']  "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
leftTokens = 0

IRs:
leftTokens(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 20596.sol-Crowdsale-getAmountBonus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
amount >= firstAmountBonusBarrier

IRs:
TMP_225(bool) = amount >= firstAmountBonusBarrier
CONDITION TMP_225"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
firstAmountBonus

IRs:
RETURN firstAmountBonus"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
amount >= secondAmountBonusBarrier

IRs:
TMP_226(bool) = amount >= secondAmountBonusBarrier
CONDITION TMP_226"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
secondAmountBonus

IRs:
RETURN secondAmountBonus"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
amount >= thirdAmountBonusBarrier

IRs:
TMP_227(bool) = amount >= thirdAmountBonusBarrier
CONDITION TMP_227"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8

EXPRESSION:
thirdAmountBonus

IRs:
RETURN thirdAmountBonus"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
amount >= fourthAmountBonusBarrier

IRs:
TMP_228(bool) = amount >= fourthAmountBonusBarrier
CONDITION TMP_228"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
fourthAmountBonus

IRs:
RETURN fourthAmountBonus"];
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 20596.sol-Crowdsale-getBonus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
isPreICO()

IRs:
TMP_219(bool) = INTERNAL_CALL, Crowdsale.isPreICO()()
CONDITION TMP_219"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
bonus = getPreICOBonus()

IRs:
TMP_220(uint256) = INTERNAL_CALL, Crowdsale.getPreICOBonus()()
bonus(uint256) := TMP_220(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
isICO()

IRs:
TMP_221(bool) = INTERNAL_CALL, Crowdsale.isICO()()
CONDITION TMP_221"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
bonus = getICOBonus()

IRs:
TMP_222(uint256) = INTERNAL_CALL, Crowdsale.getICOBonus()()
bonus(uint256) := TMP_222(uint256)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
bonus + getAmountBonus(amount)

IRs:
TMP_223(uint256) = INTERNAL_CALL, Crowdsale.getAmountBonus(uint256)(amount)
TMP_224(uint256) = bonus + TMP_223
RETURN TMP_224"];
}
// Function: 20596.sol-Crowdsale-getICOBonus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTime = currentTime()

IRs:
TMP_233(uint256) = INTERNAL_CALL, Crowdsale.currentTime()()
curTime(uint256) := TMP_233(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
curTime < firstICOTimeBarrier

IRs:
TMP_234(bool) = curTime < firstICOTimeBarrier
CONDITION TMP_234"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
firstICOTimeBonus

IRs:
RETURN firstICOTimeBonus"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
curTime < secondICOTimeBarrier

IRs:
TMP_235(bool) = curTime < secondICOTimeBarrier
CONDITION TMP_235"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
secondICOTimeBonus

IRs:
RETURN secondICOTimeBonus"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
curTime < thirdICOTimeBarrier

IRs:
TMP_236(bool) = curTime < thirdICOTimeBarrier
CONDITION TMP_236"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
thirdICOTimeBonus

IRs:
RETURN thirdICOTimeBonus"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 20596.sol-Crowdsale-getPreICOBonus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTime = currentTime()

IRs:
TMP_229(uint256) = INTERNAL_CALL, Crowdsale.currentTime()()
curTime(uint256) := TMP_229(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
curTime < firstPreICOTimeBarrier

IRs:
TMP_230(bool) = curTime < firstPreICOTimeBarrier
CONDITION TMP_230"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
firstPreICOTimeBonus

IRs:
RETURN firstPreICOTimeBonus"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
curTime < secondPreICOTimeBarrier

IRs:
TMP_231(bool) = curTime < secondPreICOTimeBarrier
CONDITION TMP_231"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: RETURN 6

EXPRESSION:
secondPreICOTimeBonus

IRs:
RETURN secondPreICOTimeBonus"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
curTime < thirdPreICOTimeBarrier

IRs:
TMP_232(bool) = curTime < thirdPreICOTimeBarrier
CONDITION TMP_232"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: RETURN 9

EXPRESSION:
thirdPreICOTimeBonus

IRs:
RETURN thirdPreICOTimeBonus"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 20596.sol-Crowdsale-isFinished()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
currentTime() > ICOendTime || (leftTokens == 0 && state == State.ICO)

IRs:
TMP_174(uint256) = INTERNAL_CALL, Crowdsale.currentTime()()
TMP_175(bool) = TMP_174 > ICOendTime
TMP_176(bool) = leftTokens == 0
REF_116(Crowdsale.State) -> State.ICO
TMP_177(bool) = state == REF_116
TMP_178(bool) = TMP_176 && TMP_177
TMP_179(bool) = TMP_175 || TMP_178
RETURN TMP_179"];
}
// Function: 20596.sol-Crowdsale-isICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTime = currentTime()

IRs:
TMP_184(uint256) = INTERNAL_CALL, Crowdsale.currentTime()()
curTime(uint256) := TMP_184(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
curTime < ICOendTime && curTime > ICOstartTime

IRs:
TMP_185(bool) = curTime < ICOendTime
TMP_186(bool) = curTime > ICOstartTime
TMP_187(bool) = TMP_185 && TMP_186
RETURN TMP_187"];
}
// Function: 20596.sol-Crowdsale-isPreICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
curTime = currentTime()

IRs:
TMP_180(uint256) = INTERNAL_CALL, Crowdsale.currentTime()()
curTime(uint256) := TMP_180(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
curTime < preICOendTime && curTime > preICOstartTime

IRs:
TMP_181(bool) = curTime < preICOendTime
TMP_182(bool) = curTime > preICOstartTime
TMP_183(bool) = TMP_181 && TMP_182
RETURN TMP_183"];
}
// Function: 20596.sol-Crowdsale-manualTransferTokensTo(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
manualTransferTokensToInternal(to,givenTokens,currency,amount)

IRs:
TMP_216(uint256) = INTERNAL_CALL, ManualSendingCrowdsale.manualTransferTokensToInternal(address,uint256,uint256,uint256)(to,givenTokens,currency,amount)
RETURN TMP_216"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
canBuy()

IRs:
MODIFIER_CALL, Crowdsale.canBuy()()"];
3->1;
}
// Function: 20596.sol-Crowdsale-manualTransferTokensToInternal(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tempAmountData = amountsByCurrency[currency]

IRs:
REF_110(ManualSendingCrowdsale.AmountData) -> amountsByCurrency[currency]
tempAmountData(ManualSendingCrowdsale.AmountData) := REF_110(ManualSendingCrowdsale.AmountData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tempAmountData.exists)

IRs:
REF_111(bool) -> tempAmountData.exists
TMP_163(None) = SOLIDITY_CALL require(bool)(REF_111)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
amountData = amountsByCurrency[currency]

IRs:
REF_112(ManualSendingCrowdsale.AmountData) -> amountsByCurrency[currency]
amountData(ManualSendingCrowdsale.AmountData) := REF_112(ManualSendingCrowdsale.AmountData)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
amountData.value = amountData.value.add(amount)

IRs:
REF_113(uint256) -> amountData.value
REF_114(uint256) -> amountData.value
TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_114', 'amount'] 
REF_113(uint256) (->amountData) := TMP_164(uint256)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
transferTokensTo(to,givenTokens)

IRs:
TMP_165(uint256) = INTERNAL_CALL, Crowdsale.transferTokensTo(address,uint256)(to,givenTokens)
RETURN TMP_165"];
}
// Function: 20596.sol-Crowdsale-manualTransferTokensToWithBonus(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
bonus = getBonus(0)

IRs:
TMP_209(uint256) = INTERNAL_CALL, Crowdsale.getBonus(uint256)(0)
bonus(uint256) := TMP_209(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
transferedTokens = givenTokens.mul(100 + bonus).div(100)

IRs:
TMP_210(uint256) = 100 + bonus
TMP_211(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['givenTokens', 'TMP_210'] 
TMP_212(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_211', '100'] 
transferedTokens(uint256) := TMP_212(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
manualTransferTokensToInternal(to,transferedTokens,currency,amount)

IRs:
TMP_213(uint256) = INTERNAL_CALL, ManualSendingCrowdsale.manualTransferTokensToInternal(address,uint256,uint256,uint256)(to,transferedTokens,currency,amount)
RETURN TMP_213"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
canBuy()

IRs:
MODIFIER_CALL, Crowdsale.canBuy()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
5->1;
}
// Function: 20596.sol-Crowdsale-minPayment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= minAmountForDeal)

IRs:
TMP_303(bool) = msg.value >= minAmountForDeal
TMP_304(None) = SOLIDITY_CALL require(bool)(TMP_303)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-Crowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_294(bool) = owner == msg.sender
TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-Crowdsale-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
preICOstartTime = 1522454400

IRs:
preICOstartTime(uint256) := 1522454400(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
preICOendTime = 1523750400

IRs:
preICOendTime(uint256) := 1523750400(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
ICOstartTime = 1524355200

IRs:
ICOstartTime(uint256) := 1524355200(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
ICOendTime = 1527033600

IRs:
ICOendTime(uint256) := 1527033600(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
bountyAvailabilityTime = ICOendTime + 7776000

IRs:
TMP_292(uint256) = ICOendTime + 7776000
bountyAvailabilityTime(uint256) := TMP_292(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
maxTokenAmount = 108e24

IRs:
maxTokenAmount(uint256) := 108000000000000000000000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
bountyTokens = 324e23

IRs:
bountyTokens(uint256) := 32400000000000000000000000(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
maxPreICOTokenAmount = 81e23

IRs:
maxPreICOTokenAmount(uint256) := 8100000000000000000000000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
rateToEther = 9000

IRs:
rateToEther(uint256) := 9000(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
minAmountForDeal = 10 ** 17

IRs:
TMP_293(uint256) = 10 ** 17
minAmountForDeal(uint256) := TMP_293(uint256)"];
}
// Function: 20596.sol-Crowdsale-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
state = State.PRE_ICO

IRs:
REF_146(Crowdsale.State) -> State.PRE_ICO
state(Crowdsale.State) := REF_146(Crowdsale.State)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
leftTokens = 0

IRs:
leftTokens(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
totalAmount = 0

IRs:
totalAmount(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
transactionCounter = 0

IRs:
transactionCounter(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
firstAmountBonus = 20

IRs:
firstAmountBonus(uint256) := 20(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
firstAmountBonusBarrier = 500000000000000000000

IRs:
firstAmountBonusBarrier(uint256) := 500000000000000000000(uint256)"];
5->6;
6[label="Node Type: OTHER_ENTRYPOINT 6

EXPRESSION:
secondAmountBonus = 15

IRs:
secondAmountBonus(uint256) := 15(uint256)"];
6->7;
7[label="Node Type: OTHER_ENTRYPOINT 7

EXPRESSION:
secondAmountBonusBarrier = 100000000000000000000

IRs:
secondAmountBonusBarrier(uint256) := 100000000000000000000(uint256)"];
7->8;
8[label="Node Type: OTHER_ENTRYPOINT 8

EXPRESSION:
thirdAmountBonus = 10

IRs:
thirdAmountBonus(uint256) := 10(uint256)"];
8->9;
9[label="Node Type: OTHER_ENTRYPOINT 9

EXPRESSION:
thirdAmountBonusBarrier = 50000000000000000000

IRs:
thirdAmountBonusBarrier(uint256) := 50000000000000000000(uint256)"];
9->10;
10[label="Node Type: OTHER_ENTRYPOINT 10

EXPRESSION:
fourthAmountBonus = 5

IRs:
fourthAmountBonus(uint256) := 5(uint256)"];
10->11;
11[label="Node Type: OTHER_ENTRYPOINT 11

EXPRESSION:
fourthAmountBonusBarrier = 20000000000000000000

IRs:
fourthAmountBonusBarrier(uint256) := 20000000000000000000(uint256)"];
11->12;
12[label="Node Type: OTHER_ENTRYPOINT 12

EXPRESSION:
firstPreICOTimeBarrier = preICOstartTime + 86400

IRs:
TMP_286(uint256) = preICOstartTime + 86400
firstPreICOTimeBarrier(uint256) := TMP_286(uint256)"];
12->13;
13[label="Node Type: OTHER_ENTRYPOINT 13

EXPRESSION:
firstPreICOTimeBonus = 20

IRs:
firstPreICOTimeBonus(uint256) := 20(uint256)"];
13->14;
14[label="Node Type: OTHER_ENTRYPOINT 14

EXPRESSION:
secondPreICOTimeBarrier = preICOstartTime + 604800

IRs:
TMP_287(uint256) = preICOstartTime + 604800
secondPreICOTimeBarrier(uint256) := TMP_287(uint256)"];
14->15;
15[label="Node Type: OTHER_ENTRYPOINT 15

EXPRESSION:
secondPreICOTimeBonus = 10

IRs:
secondPreICOTimeBonus(uint256) := 10(uint256)"];
15->16;
16[label="Node Type: OTHER_ENTRYPOINT 16

EXPRESSION:
thirdPreICOTimeBarrier = preICOstartTime + 1209600

IRs:
TMP_288(uint256) = preICOstartTime + 1209600
thirdPreICOTimeBarrier(uint256) := TMP_288(uint256)"];
16->17;
17[label="Node Type: OTHER_ENTRYPOINT 17

EXPRESSION:
thirdPreICOTimeBonus = 5

IRs:
thirdPreICOTimeBonus(uint256) := 5(uint256)"];
17->18;
18[label="Node Type: OTHER_ENTRYPOINT 18

EXPRESSION:
firstICOTimeBarrier = ICOstartTime + 86400

IRs:
TMP_289(uint256) = ICOstartTime + 86400
firstICOTimeBarrier(uint256) := TMP_289(uint256)"];
18->19;
19[label="Node Type: OTHER_ENTRYPOINT 19

EXPRESSION:
firstICOTimeBonus = 15

IRs:
firstICOTimeBonus(uint256) := 15(uint256)"];
19->20;
20[label="Node Type: OTHER_ENTRYPOINT 20

EXPRESSION:
secondICOTimeBarrier = ICOstartTime + 604800

IRs:
TMP_290(uint256) = ICOstartTime + 604800
secondICOTimeBarrier(uint256) := TMP_290(uint256)"];
20->21;
21[label="Node Type: OTHER_ENTRYPOINT 21

EXPRESSION:
secondICOTimeBonus = 7

IRs:
secondICOTimeBonus(uint256) := 7(uint256)"];
21->22;
22[label="Node Type: OTHER_ENTRYPOINT 22

EXPRESSION:
thirdICOTimeBarrier = ICOstartTime + 1209600

IRs:
TMP_291(uint256) = ICOstartTime + 1209600
thirdICOTimeBarrier(uint256) := TMP_291(uint256)"];
22->23;
23[label="Node Type: OTHER_ENTRYPOINT 23

EXPRESSION:
thirdICOTimeBonus = 4

IRs:
thirdICOTimeBonus(uint256) := 4(uint256)"];
23->24;
24[label="Node Type: OTHER_ENTRYPOINT 24

EXPRESSION:
bonusesPayed = false

IRs:
bonusesPayed(bool) := False(bool)"];
}
// Function: 20596.sol-Crowdsale-startICO()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(currentTime() > preICOendTime)

IRs:
TMP_254(uint256) = INTERNAL_CALL, Crowdsale.currentTime()()
TMP_255(bool) = TMP_254 > preICOendTime
TMP_256(None) = SOLIDITY_CALL require(bool)(TMP_255)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(state == State.PRE_ICO && leftTokens <= maxPreICOTokenAmount)

IRs:
REF_133(Crowdsale.State) -> State.PRE_ICO
TMP_257(bool) = state == REF_133
TMP_258(bool) = leftTokens <= maxPreICOTokenAmount
TMP_259(bool) = TMP_257 && TMP_258
TMP_260(None) = SOLIDITY_CALL require(bool)(TMP_259)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
leftTokens = leftTokens.add(maxTokenAmount).sub(maxPreICOTokenAmount).sub(bountyTokens)

IRs:
TMP_261(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['leftTokens', 'maxTokenAmount'] 
TMP_262(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_261', 'maxPreICOTokenAmount'] 
TMP_263(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_262', 'bountyTokens'] 
leftTokens(uint256) := TMP_263(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
state = State.ICO

IRs:
REF_137(Crowdsale.State) -> State.ICO
state(Crowdsale.State) := REF_137(Crowdsale.State)"];
}
// Function: 20596.sol-Crowdsale-takeBounty()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFinished())

IRs:
TMP_243(bool) = INTERNAL_CALL, Crowdsale.isFinished()()
TMP_244(None) = SOLIDITY_CALL require(bool)(TMP_243)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(state == State.ICO)

IRs:
REF_131(Crowdsale.State) -> State.ICO
TMP_245(bool) = state == REF_131
TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > bountyAvailabilityTime)

IRs:
TMP_247(bool) = now > bountyAvailabilityTime
TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! bonusesPayed)

IRs:
TMP_249 = UnaryType.BANG bonusesPayed 
TMP_250(None) = SOLIDITY_CALL require(bool)(TMP_249)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
bonusesPayed = true

IRs:
bonusesPayed(bool) := True(bool)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(token.transfer(msg.sender,bountyTokens))

IRs:
TMP_251(bool) = HIGH_LEVEL_CALL, dest:token(DEVCoin), function:transfer, arguments:['msg.sender', 'bountyTokens']  
TMP_252(None) = SOLIDITY_CALL require(bool)(TMP_251)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
7->1;
}
// Function: 20596.sol-Crowdsale-transferTokensTo(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
providedTokens = givenTokens

IRs:
providedTokens(uint256) := givenTokens(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
givenTokens > leftTokens

IRs:
TMP_264(bool) = givenTokens > leftTokens
CONDITION TMP_264"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
providedTokens = leftTokens

IRs:
providedTokens(uint256) := leftTokens(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
leftTokens = leftTokens.sub(providedTokens)

IRs:
TMP_265(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['leftTokens', 'providedTokens'] 
leftTokens(uint256) := TMP_265(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(token.manualTransfer(to,providedTokens))

IRs:
TMP_266(bool) = HIGH_LEVEL_CALL, dest:token(DEVCoin), function:manualTransfer, arguments:['to', 'providedTokens']  
TMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
transactionCounter = transactionCounter + 1

IRs:
TMP_268(uint256) = transactionCounter + 1
transactionCounter(uint256) := TMP_268(uint256)"];
7->8;
8[label="Node Type: RETURN 8

EXPRESSION:
providedTokens

IRs:
RETURN providedTokens"];
}
// Function: 20596.sol-Crowdsale-withdraw()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender.call.gas(3000000).value(address(this).balance)())

IRs:
TMP_270 = CONVERT this to address
TMP_271(uint256) = SOLIDITY_CALL balance(address)(TMP_270)
TMP_273(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:TMP_271 gas:3000000
TMP_274(None) = SOLIDITY_CALL require(bool)(TMP_273)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 20596.sol-Crowdsale-withdrawAmount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
givenAmount = amount

IRs:
givenAmount(uint256) := amount(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
address(this).balance < amount

IRs:
TMP_276 = CONVERT this to address
TMP_277(uint256) = SOLIDITY_CALL balance(address)(TMP_276)
TMP_278(bool) = TMP_277 < amount
CONDITION TMP_278"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
givenAmount = address(this).balance

IRs:
TMP_279 = CONVERT this to address
TMP_280(uint256) = SOLIDITY_CALL balance(address)(TMP_279)
givenAmount(uint256) := TMP_280(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(msg.sender.call.gas(3000000).value(givenAmount)())

IRs:
TMP_283(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:givenAmount gas:3000000
TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
6->1;
}
// Function: 20596.sol-DEVCoin-DEVCoin(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = initialSupply

IRs:
totalSupply(uint256) := initialSupply(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[owner] = initialSupply

IRs:
REF_92(uint256) -> balances[owner]
REF_92(uint256) (->balances) := initialSupply(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
blockedUntil = unblockTime

IRs:
blockedUntil(uint256) := unblockTime(uint256)"];
}
// Function: 20596.sol-DEVCoin-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20596.sol-DEVCoin-allowance(address,address)
digraph{
}
// Function: 20596.sol-DEVCoin-approve(address,uint256)
digraph{
}
// Function: 20596.sol-DEVCoin-balanceOf(address)
digraph{
}
// Function: 20596.sol-DEVCoin-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_104(bool) = _value > 0
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_63(uint256) -> balances[msg.sender]
TMP_106(bool) = _value <= REF_63
TMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balances[burner] = balances[burner].sub(_value)

IRs:
REF_64(uint256) -> balances[burner]
REF_65(uint256) -> balances[burner]
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_65', '_value'] 
REF_64(uint256) (->balances) := TMP_108(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = totalSupply.sub(_value)

IRs:
TMP_109(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] 
totalSupply(uint256) := TMP_109(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
unblocked()

IRs:
MODIFIER_CALL, Blocked.unblocked()()"];
7->1;
}
// Function: 20596.sol-DEVCoin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_owner != 0)

IRs:
TMP_99(bool) = _owner != 0
TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newOwner = _owner

IRs:
newOwner(address) := _owner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 20596.sol-DEVCoin-confirmOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner == msg.sender)

IRs:
TMP_102(bool) = newOwner == msg.sender
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete newOwner

IRs:
newOwner = delete newOwner "];
}
// Function: 20596.sol-DEVCoin-manualTransfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_93(uint256) -> balances[msg.sender]
REF_94(uint256) -> balances[msg.sender]
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_94', '_value'] 
REF_93(uint256) (->balances) := TMP_136(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_96(uint256) -> balances[_to]
REF_97(uint256) -> balances[_to]
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_97', '_value'] 
REF_96(uint256) (->balances) := TMP_137(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_139(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_139)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
6->1;
}
// Function: 20596.sol-DEVCoin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_142(bool) = owner == msg.sender
TMP_143(None) = SOLIDITY_CALL require(bool)(TMP_142)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-DEVCoin-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.data.length >= size + 4)

IRs:
REF_99 -> LENGTH msg.data
TMP_144(uint256) = size + 4
TMP_145(bool) = REF_99 >= TMP_144
TMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-DEVCoin-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = Dev Coin

IRs:
name(string) := Dev Coin(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = DEVC

IRs:
symbol(string) := DEVC(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 18

IRs:
decimals(uint32) := 18(uint256)"];
}
// Function: 20596.sol-DEVCoin-transfer(address,uint256)
digraph{
}
// Function: 20596.sol-DEVCoin-transferFrom(address,address,uint256)
digraph{
}
// Function: 20596.sol-DEVCoin-unblocked()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > blockedUntil)

IRs:
TMP_147(bool) = now > blockedUntil
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-ERC20-allowance(address,address)
digraph{
}
// Function: 20596.sol-ERC20-approve(address,uint256)
digraph{
}
// Function: 20596.sol-ERC20-balanceOf(address)
digraph{
}
// Function: 20596.sol-ERC20-transfer(address,uint256)
digraph{
}
// Function: 20596.sol-ERC20-transferFrom(address,address,uint256)
digraph{
}
// Function: 20596.sol-ERC20Basic-balanceOf(address)
digraph{
}
// Function: 20596.sol-ERC20Basic-transfer(address,uint256)
digraph{
}
// Function: 20596.sol-ManualSendingCrowdsale-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20596.sol-ManualSendingCrowdsale-addCurrency(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
addCurrencyInternal(currency)

IRs:
INTERNAL_CALL, ManualSendingCrowdsale.addCurrencyInternal(uint256)(currency)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
2->1;
}
// Function: 20596.sol-ManualSendingCrowdsale-addCurrencyInternal(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
amountData = amountsByCurrency[currency]

IRs:
REF_100(ManualSendingCrowdsale.AmountData) -> amountsByCurrency[currency]
amountData(ManualSendingCrowdsale.AmountData) := REF_100(ManualSendingCrowdsale.AmountData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
amountData.exists = true

IRs:
REF_101(bool) -> amountData.exists
REF_101(bool) (->amountData) := True(bool)"];
}
// Function: 20596.sol-ManualSendingCrowdsale-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_owner != 0)

IRs:
TMP_149(bool) = _owner != 0
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newOwner = _owner

IRs:
newOwner(address) := _owner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 20596.sol-ManualSendingCrowdsale-confirmOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner == msg.sender)

IRs:
TMP_152(bool) = newOwner == msg.sender
TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete newOwner

IRs:
newOwner = delete newOwner "];
}
// Function: 20596.sol-ManualSendingCrowdsale-manualTransferTokensToInternal(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
tempAmountData = amountsByCurrency[currency]

IRs:
REF_102(ManualSendingCrowdsale.AmountData) -> amountsByCurrency[currency]
tempAmountData(ManualSendingCrowdsale.AmountData) := REF_102(ManualSendingCrowdsale.AmountData)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tempAmountData.exists)

IRs:
REF_103(bool) -> tempAmountData.exists
TMP_156(None) = SOLIDITY_CALL require(bool)(REF_103)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
amountData = amountsByCurrency[currency]

IRs:
REF_104(ManualSendingCrowdsale.AmountData) -> amountsByCurrency[currency]
amountData(ManualSendingCrowdsale.AmountData) := REF_104(ManualSendingCrowdsale.AmountData)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
amountData.value = amountData.value.add(amount)

IRs:
REF_105(uint256) -> amountData.value
REF_106(uint256) -> amountData.value
TMP_157(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_106', 'amount'] 
REF_105(uint256) (->amountData) := TMP_157(uint256)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
transferTokensTo(to,givenTokens)

IRs:
TMP_158(uint256) = INTERNAL_CALL, ManualSendingCrowdsale.transferTokensTo(address,uint256)(to,givenTokens)
RETURN TMP_158"];
}
// Function: 20596.sol-ManualSendingCrowdsale-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_159(bool) = owner == msg.sender
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-ManualSendingCrowdsale-transferTokensTo(address,uint256)
digraph{
}
// Function: 20596.sol-Owned-Owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 20596.sol-Owned-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_owner != 0)

IRs:
TMP_13(bool) = _owner != 0
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
newOwner = _owner

IRs:
newOwner(address) := _owner(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()"];
3->1;
}
// Function: 20596.sol-Owned-confirmOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newOwner == msg.sender)

IRs:
TMP_16(bool) = newOwner == msg.sender
TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
delete newOwner

IRs:
newOwner = delete newOwner "];
}
// Function: 20596.sol-Owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_18(bool) = owner == msg.sender
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-SafeMath-add(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 20596.sol-SafeMath-div(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a / b

IRs:
TMP_6(uint256) = a / b
c(uint256) := TMP_6(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 20596.sol-SafeMath-mul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 20596.sol-SafeMath-sub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_7(bool) = b <= a
TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
a - b

IRs:
TMP_9(uint256) = a - b
RETURN TMP_9"];
}
// Function: 20596.sol-StandardToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_30(mapping(address => uint256)) -> allowed[_owner]
REF_31(uint256) -> REF_30[_spender]
RETURN REF_31"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_54(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_54)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
unblocked()

IRs:
MODIFIER_CALL, Blocked.unblocked()()"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 20596.sol-StandardToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((_value == 0) || (allowed[msg.sender][_spender] == 0))

IRs:
TMP_46(bool) = _value == 0
REF_26(mapping(address => uint256)) -> allowed[msg.sender]
REF_27(uint256) -> REF_26[_spender]
TMP_47(bool) = REF_27 == 0
TMP_48(bool) = TMP_46 || TMP_47
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_28(mapping(address => uint256)) -> allowed[msg.sender]
REF_29(uint256) -> REF_28[_spender]
REF_29(uint256) (->allowed) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_51(uint256) = 2 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_51)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
unblocked()

IRs:
MODIFIER_CALL, Blocked.unblocked()()"];
6->1;
}
// Function: 20596.sol-StandardToken-balanceOf(address)
digraph{
}
// Function: 20596.sol-StandardToken-onlyPayloadSize(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.data.length >= size + 4)

IRs:
REF_32 -> LENGTH msg.data
TMP_57(uint256) = size + 4
TMP_58(bool) = REF_32 >= TMP_57
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 20596.sol-StandardToken-transfer(address,uint256)
digraph{
}
// Function: 20596.sol-StandardToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
_allowance = allowed[_from][msg.sender]

IRs:
REF_15(mapping(address => uint256)) -> allowed[_from]
REF_16(uint256) -> REF_15[msg.sender]
_allowance(uint256) := REF_16(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_17(uint256) -> balances[_to]
REF_18(uint256) -> balances[_to]
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_18', '_value'] 
REF_17(uint256) (->balances) := TMP_39(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_20(uint256) -> balances[_from]
REF_21(uint256) -> balances[_from]
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_21', '_value'] 
REF_20(uint256) (->balances) := TMP_40(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] = _allowance.sub(_value)

IRs:
REF_23(mapping(address => uint256)) -> allowed[_from]
REF_24(uint256) -> REF_23[msg.sender]
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_allowance', '_value'] 
REF_24(uint256) (->allowed) := TMP_41(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
onlyPayloadSize(3 * 32)

IRs:
TMP_43(uint256) = 3 * 32
MODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_43)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
unblocked()

IRs:
MODIFIER_CALL, Blocked.unblocked()()"];
8->1;
}
// Function: 20596.sol-StandardToken-unblocked()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > blockedUntil)

IRs:
TMP_60(bool) = now > blockedUntil
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)"];
1->2;
2[label="Node Type: _ 2
"];
}
}
