digraph G {
// Function: 33450.sol-MultiOwner-ConfirmDispose()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->10;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_28 -> LENGTH owners
TMP_29(uint256) = REF_28 - 1
TMP_30(bool) = i < TMP_29
CONDITION TMP_30"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
RequireDispose[owners[i]]

IRs:
REF_29(address) -> owners[i]
REF_30(bool) -> RequireDispose[REF_29]
CONDITION REF_30"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_31(uint256) := i(uint256)
i(uint256) = i + 1"];
9->5;
10[label="Node Type: IF 10

EXPRESSION:
count == ownerRequired

IRs:
TMP_32(bool) = count == ownerRequired
CONDITION TMP_32"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: END_IF 12
"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
13->1;
}
// Function: 33450.sol-MultiOwner-MultiOwner(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
ownerRequired = _required

IRs:
ownerRequired(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isOwner[msg.sender] = true

IRs:
REF_0(bool) -> isOwner[msg.sender]
REF_0(bool) (->isOwner) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owners.push(msg.sender)

IRs:
REF_2 -> LENGTH owners
TMP_1(uint256) := REF_2(uint256)
TMP_2(uint256) = TMP_1 + 1
REF_2(uint256) (->owners) := TMP_2(uint256)
REF_3(address) -> owners[TMP_1]
REF_3(address) (->owners) := msg.sender(address)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < _owners.length

IRs:
REF_4 -> LENGTH _owners
TMP_3(bool) = i < REF_4
CONDITION TMP_3"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(! isOwner[_owners[i]])

IRs:
REF_5(address) -> _owners[i]
REF_6(bool) -> isOwner[REF_5]
TMP_4 = UnaryType.BANG REF_6 
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_7(address) -> _owners[i]
REF_8(bool) -> isOwner[REF_7]
REF_8(bool) (->isOwner) := True(bool)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners.push(_owners[i])

IRs:
REF_10(address) -> _owners[i]
REF_11 -> LENGTH owners
TMP_7(uint256) := REF_11(uint256)
TMP_8(uint256) = TMP_7 + 1
REF_11(uint256) (->owners) := TMP_8(uint256)
REF_12(address) -> owners[TMP_7]
REF_12(address) (->owners) := REF_10(address)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
11->7;
}
// Function: 33450.sol-MultiOwner-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_13(bool) -> isOwner[owner]
REF_13(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_15 -> LENGTH owners
TMP_10(uint256) := REF_15(uint256)
TMP_11(uint256) = TMP_10 + 1
REF_15(uint256) (->owners) := TMP_11(uint256)
REF_16(address) -> owners[TMP_10]
REF_16(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnerAdded(owner)

IRs:
Emit OwnerAdded(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiOwner.ownerDoesNotExist(address)(owner)"];
5->1;
}
// Function: 33450.sol-MultiOwner-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newRequired >= owners.length)

IRs:
REF_27 -> LENGTH owners
TMP_25(bool) = _newRequired >= REF_27
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ownerRequired = _newRequired

IRs:
ownerRequired(uint256) := _newRequired(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RequirementChanged(_newRequired)

IRs:
Emit RequirementChanged(_newRequired)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
4->1;
}
// Function: 33450.sol-MultiOwner-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
RequireDispose[msg.sender] = true

IRs:
REF_31(bool) -> RequireDispose[msg.sender]
REF_31(bool) (->RequireDispose) := True(bool)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
ConfirmDispose()

IRs:
TMP_34(bool) = INTERNAL_CALL, MultiOwner.ConfirmDispose()()
CONDITION TMP_34"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_35(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
5->1;
}
// Function: 33450.sol-MultiOwner-numberOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
NumberOwners = owners.length

IRs:
REF_17 -> LENGTH owners
NumberOwners(uint256) := REF_17(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
NumberOwners

IRs:
RETURN NumberOwners"];
}
// Function: 33450.sol-MultiOwner-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isOwner[msg.sender])

IRs:
REF_32(bool) -> isOwner[msg.sender]
TMP_37(None) = SOLIDITY_CALL require(bool)(REF_32)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-MultiOwner-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isOwner[owner])

IRs:
REF_33(bool) -> isOwner[owner]
TMP_38 = UnaryType.BANG REF_33 
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-MultiOwner-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isOwner[owner])

IRs:
REF_34(bool) -> isOwner[owner]
TMP_40(None) = SOLIDITY_CALL require(bool)(REF_34)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-MultiOwner-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->15;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owners.length > 2)

IRs:
REF_18 -> LENGTH owners
TMP_15(bool) = REF_18 > 2
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isOwner[owner] = false

IRs:
REF_19(bool) -> isOwner[owner]
REF_19(bool) (->isOwner) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RequireDispose[owner] = false

IRs:
REF_20(bool) -> RequireDispose[owner]
REF_20(bool) (->RequireDispose) := False(bool)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length - 1

IRs:
REF_21 -> LENGTH owners
TMP_17(uint256) = REF_21 - 1
TMP_18(bool) = i < TMP_17
CONDITION TMP_18"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
owners[i] == owner

IRs:
REF_22(address) -> owners[i]
TMP_19(bool) = REF_22 == owner
CONDITION TMP_19"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_23(address) -> owners[i]
REF_24 -> LENGTH owners
TMP_20(uint256) = REF_24 - 1
REF_25(address) -> owners[TMP_20]
REF_23(address) (->owners) := REF_25(address)"];
9->10;
10[label="Node Type: BREAK 10
"];
10->5;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_21(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
owners.length -= 1

IRs:
REF_26 -> LENGTH owners
REF_26(-> owners) = REF_26 - 1"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
OwnerRemoved(owner)

IRs:
Emit OwnerRemoved(owner)"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiOwner.ownerExists(address)(owner)"];
16->1;
}
// Function: 33450.sol-VVToken-AccountVoid(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->8;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] > 0)

IRs:
REF_113(uint256) -> balanceOf[_from]
TMP_159(bool) = REF_113 > 0
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
CurrentBalances = balanceOf[_from]

IRs:
REF_114(uint256) -> balanceOf[_from]
CurrentBalances(uint256) := REF_114(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[msg.sender]

IRs:
REF_115(uint256) -> balanceOf[_from]
REF_116(uint256) -> balanceOf[msg.sender]
TMP_161(uint256) = REF_115 + REF_116
previousBalances(uint256) := TMP_161(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[_from] -= CurrentBalances

IRs:
REF_117(uint256) -> balanceOf[_from]
REF_117(-> balanceOf) = REF_117 - CurrentBalances"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[msg.sender] += CurrentBalances

IRs:
REF_118(uint256) -> balanceOf[msg.sender]
REF_118(-> balanceOf) = REF_118 + CurrentBalances"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
VoidAccount(_from,msg.sender,CurrentBalances)

IRs:
Emit VoidAccount(_from,msg.sender,CurrentBalances)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[msg.sender] == previousBalances)

IRs:
REF_119(uint256) -> balanceOf[_from]
REF_120(uint256) -> balanceOf[msg.sender]
TMP_163(uint256) = REF_119 + REF_120
TMP_164(bool) = TMP_163 == previousBalances
TMP_165(None) = SOLIDITY_CALL assert(bool)(TMP_164)"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
8->1;
}
// Function: 33450.sol-VVToken-ConfirmDispose()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->13;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->10;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_63 -> LENGTH owners
TMP_70(uint256) = REF_63 - 1
TMP_71(bool) = i < TMP_70
CONDITION TMP_71"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
RequireDispose[owners[i]]

IRs:
REF_64(address) -> owners[i]
REF_65(bool) -> RequireDispose[REF_64]
CONDITION REF_65"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_72(uint256) := i(uint256)
i(uint256) = i + 1"];
9->5;
10[label="Node Type: IF 10

EXPRESSION:
count == ownerRequired

IRs:
TMP_73(bool) = count == ownerRequired
CONDITION TMP_73"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: END_IF 12
"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
13->1;
}
// Function: 33450.sol-VVToken-MultiOwner(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
ownerRequired = _required

IRs:
ownerRequired(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isOwner[msg.sender] = true

IRs:
REF_35(bool) -> isOwner[msg.sender]
REF_35(bool) (->isOwner) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owners.push(msg.sender)

IRs:
REF_37 -> LENGTH owners
TMP_42(uint256) := REF_37(uint256)
TMP_43(uint256) = TMP_42 + 1
REF_37(uint256) (->owners) := TMP_43(uint256)
REF_38(address) -> owners[TMP_42]
REF_38(address) (->owners) := msg.sender(address)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < _owners.length

IRs:
REF_39 -> LENGTH _owners
TMP_44(bool) = i < REF_39
CONDITION TMP_44"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(! isOwner[_owners[i]])

IRs:
REF_40(address) -> _owners[i]
REF_41(bool) -> isOwner[REF_40]
TMP_45 = UnaryType.BANG REF_41 
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_42(address) -> _owners[i]
REF_43(bool) -> isOwner[REF_42]
REF_43(bool) (->isOwner) := True(bool)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners.push(_owners[i])

IRs:
REF_45(address) -> _owners[i]
REF_46 -> LENGTH owners
TMP_48(uint256) := REF_46(uint256)
TMP_49(uint256) = TMP_48 + 1
REF_46(uint256) (->owners) := TMP_49(uint256)
REF_47(address) -> owners[TMP_48]
REF_47(address) (->owners) := REF_45(address)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1"];
11->7;
}
// Function: 33450.sol-VVToken-VVToken(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[msg.sender] = totalSupply

IRs:
REF_67(uint256) -> balanceOf[msg.sender]
REF_67(uint256) (->balanceOf) := totalSupply(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultiOwner(_owners,_required)

IRs:
INTERNAL_CALL, MultiOwner.MultiOwner(address[],uint256)(_owners,_required)"];
2->1;
}
// Function: 33450.sol-VVToken-_collect_fee(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_93(bool) = _to != 0
TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_78(uint256) -> balanceOf[_from]
TMP_95(bool) = REF_78 >= _value
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_79(uint256) -> balanceOf[_to]
TMP_97(uint256) = REF_79 + _value
REF_80(uint256) -> balanceOf[_to]
TMP_98(bool) = TMP_97 >= REF_80
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! frozenAccount[_from])

IRs:
REF_81(bool) -> frozenAccount[_from]
TMP_100 = UnaryType.BANG REF_81 
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_82(uint256) -> balanceOf[_from]
REF_83(uint256) -> balanceOf[_to]
TMP_102(uint256) = REF_82 + REF_83
previousBalances(uint256) := TMP_102(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_84(uint256) -> balanceOf[_from]
REF_84(-> balanceOf) = REF_84 - _value"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_85(uint256) -> balanceOf[_to]
REF_85(-> balanceOf) = REF_85 + _value"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
FeePaid(_from,_to,_value)

IRs:
Emit FeePaid(_from,_to,_value)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_86(uint256) -> balanceOf[_from]
REF_87(uint256) -> balanceOf[_to]
TMP_104(uint256) = REF_86 + REF_87
TMP_105(bool) = TMP_104 == previousBalances
TMP_106(None) = SOLIDITY_CALL assert(bool)(TMP_105)"];
}
// Function: 33450.sol-VVToken-_transfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_79(bool) = _to != 0
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_68(uint256) -> balanceOf[_from]
TMP_81(bool) = REF_68 >= _value
TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_69(uint256) -> balanceOf[_to]
TMP_83(uint256) = REF_69 + _value
REF_70(uint256) -> balanceOf[_to]
TMP_84(bool) = TMP_83 >= REF_70
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! frozenAccount[_from])

IRs:
REF_71(bool) -> frozenAccount[_from]
TMP_86 = UnaryType.BANG REF_71 
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_72(uint256) -> balanceOf[_from]
REF_73(uint256) -> balanceOf[_to]
TMP_88(uint256) = REF_72 + REF_73
previousBalances(uint256) := TMP_88(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_74(uint256) -> balanceOf[_from]
REF_74(-> balanceOf) = REF_74 - _value"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_75(uint256) -> balanceOf[_to]
REF_75(-> balanceOf) = REF_75 + _value"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_76(uint256) -> balanceOf[_from]
REF_77(uint256) -> balanceOf[_to]
TMP_90(uint256) = REF_76 + REF_77
TMP_91(bool) = TMP_90 == previousBalances
TMP_92(None) = SOLIDITY_CALL assert(bool)(TMP_91)"];
}
// Function: 33450.sol-VVToken-addConfirmation(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Confirmations[TransHash][msg.sender] = true

IRs:
REF_93(mapping(address => bool)) -> Confirmations[TransHash]
REF_94(bool) -> REF_93[msg.sender]
REF_94(bool) (->Confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,TransHash)

IRs:
Emit Confirmation(msg.sender,TransHash)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
notConfirmed(TransHash)

IRs:
MODIFIER_CALL, VVToken.notConfirmed(bytes32)(TransHash)"];
4->1;
}
// Function: 33450.sol-VVToken-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_48(bool) -> isOwner[owner]
REF_48(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_50 -> LENGTH owners
TMP_51(uint256) := REF_50(uint256)
TMP_52(uint256) = TMP_51 + 1
REF_50(uint256) (->owners) := TMP_52(uint256)
REF_51(address) -> owners[TMP_51]
REF_51(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnerAdded(owner)

IRs:
Emit OwnerAdded(owner)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiOwner.ownerDoesNotExist(address)(owner)"];
5->1;
}
// Function: 33450.sol-VVToken-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
TransHash = sha3()(destination,value,data)

IRs:
TMP_137(bytes32) = SOLIDITY_CALL sha3()(destination,value,data)
TransHash(bytes32) := TMP_137(bytes32)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
Transactions[TransHash].destination == 0

IRs:
REF_90(VVToken.Transaction) -> Transactions[TransHash]
REF_91(address) -> REF_90.destination
TMP_138(bool) = REF_91 == 0
CONDITION TMP_138"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Transactions[TransHash] = Transaction({destination:destination,value:value,data:data,executed:false})

IRs:
REF_92(VVToken.Transaction) -> Transactions[TransHash]
TMP_139(VVToken.Transaction) = new Transaction(destination,value,data,False)
REF_92(VVToken.Transaction) (->Transactions) := TMP_139(VVToken.Transaction)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
SubmitTransaction(TransHash)

IRs:
Emit SubmitTransaction(TransHash)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, VVToken.notNull(address)(destination)"];
6->1;
7[label="Node Type: RETURN 7

EXPRESSION:
TransHash

IRs:
RETURN TransHash"];
}
// Function: 33450.sol-VVToken-bonus(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
BonusValue = amount * 10 ** uint256(decimals)

IRs:
TMP_174 = CONVERT decimals to uint256
TMP_175(uint256) = 10 ** TMP_174
TMP_176(uint256) = amount * TMP_175
BonusValue(uint256) := TMP_176(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[this] + BonusValue > balanceOf[this])

IRs:
REF_123(uint256) -> balanceOf[this]
TMP_177(uint256) = REF_123 + BonusValue
REF_124(uint256) -> balanceOf[this]
TMP_178(bool) = TMP_177 > REF_124
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[this] += BonusValue

IRs:
REF_125(uint256) -> balanceOf[this]
REF_125(-> balanceOf) = REF_125 + BonusValue"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply += BonusValue

IRs:
totalSupply(uint256) = totalSupply + BonusValue"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Bonus(BonusValue)

IRs:
Emit Bonus(BonusValue)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
6->1;
}
// Function: 33450.sol-VVToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
BurnValue = amount * 10 ** uint256(decimals)

IRs:
TMP_167 = CONVERT decimals to uint256
TMP_168(uint256) = 10 ** TMP_167
TMP_169(uint256) = amount * TMP_168
BurnValue(uint256) := TMP_169(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[this] >= BurnValue)

IRs:
REF_121(uint256) -> balanceOf[this]
TMP_170(bool) = REF_121 >= BurnValue
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[this] -= BurnValue

IRs:
REF_122(uint256) -> balanceOf[this]
REF_122(-> balanceOf) = REF_122 - BurnValue"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalSupply -= BurnValue

IRs:
totalSupply(uint256) = totalSupply - BurnValue"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Burn(BurnValue)

IRs:
Emit Burn(BurnValue)"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
6->1;
}
// Function: 33450.sol-VVToken-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_newRequired >= owners.length)

IRs:
REF_62 -> LENGTH owners
TMP_66(bool) = _newRequired >= REF_62
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
ownerRequired = _newRequired

IRs:
ownerRequired(uint256) := _newRequired(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RequirementChanged(_newRequired)

IRs:
Emit RequirementChanged(_newRequired)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
4->1;
}
// Function: 33450.sol-VVToken-confirmTransaction(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
addConfirmation(TransHash)

IRs:
INTERNAL_CALL, VVToken.addConfirmation(bytes32)(TransHash)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
executeTransaction(TransHash)

IRs:
INTERNAL_CALL, VVToken.executeTransaction(bytes32)(TransHash)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
3->1;
}
// Function: 33450.sol-VVToken-confirmationCount(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_99 -> LENGTH owners
TMP_148(bool) = i < REF_99
CONDITION TMP_148"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
Confirmations[TransHash][owners[i]]

IRs:
REF_100(mapping(address => bool)) -> Confirmations[TransHash]
REF_101(address) -> owners[i]
REF_102(bool) -> REF_100[REF_101]
CONDITION REF_102"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_149(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 33450.sol-VVToken-confirmed(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(Confirmations[transactionHash][msg.sender])

IRs:
REF_129(mapping(address => bool)) -> Confirmations[transactionHash]
REF_130(bool) -> REF_129[msg.sender]
TMP_191(None) = SOLIDITY_CALL require(bool)(REF_130)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-VVToken-execute(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_r = addTransaction(_to,_value,_data)

IRs:
TMP_133(bytes32) = INTERNAL_CALL, VVToken.addTransaction(address,uint256,bytes)(_to,_value,_data)
_r(bytes32) := TMP_133(bytes32)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(_r)

IRs:
INTERNAL_CALL, VVToken.confirmTransaction(bytes32)(_r)"];
2->5;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
notNull(_to)

IRs:
MODIFIER_CALL, VVToken.notNull(address)(_to)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
4->1;
5[label="Node Type: RETURN 5

EXPRESSION:
_r

IRs:
RETURN _r"];
}
// Function: 33450.sol-VVToken-executeTransaction(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->6;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(TransHash)

IRs:
TMP_153(bool) = INTERNAL_CALL, VVToken.isConfirmed(bytes32)(TransHash)
CONDITION TMP_153"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Transactions[TransHash].executed = true

IRs:
REF_103(VVToken.Transaction) -> Transactions[TransHash]
REF_104(bool) -> REF_103.executed
REF_104(bool) (->Transactions) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data))

IRs:
REF_105(VVToken.Transaction) -> Transactions[TransHash]
REF_106(address) -> REF_105.destination
REF_109(VVToken.Transaction) -> Transactions[TransHash]
REF_110(uint256) -> REF_109.value
REF_111(VVToken.Transaction) -> Transactions[TransHash]
REF_112(bytes) -> REF_111.data
TMP_155(bool) = LOW_LEVEL_CALL, dest:REF_106, function:call, arguments:['REF_112'] value:REF_110 
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Execution(TransHash)

IRs:
Emit Execution(TransHash)"];
4->5;
5[label="Node Type: END_IF 5
"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notExecuted(TransHash)

IRs:
MODIFIER_CALL, VVToken.notExecuted(bytes32)(TransHash)"];
6->1;
}
// Function: 33450.sol-VVToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_125(bool) = msg.value > 0
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * 10 ** uint256(decimals) * EthPerToken / 1000000000000000000

IRs:
TMP_127 = CONVERT decimals to uint256
TMP_128(uint256) = 10 ** TMP_127
TMP_129(uint256) = msg.value * TMP_128
TMP_130(uint256) = TMP_129 * EthPerToken
TMP_131(uint256) = TMP_130 / 1000000000000000000
amount(uint256) := TMP_131(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_transfer(this,msg.sender,amount)

IRs:
INTERNAL_CALL, VVToken._transfer(address,address,uint256)(this,msg.sender,amount)"];
}
// Function: 33450.sol-VVToken-freezeAccount(address,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
frozenAccount[target] = freeze

IRs:
REF_88(bool) -> frozenAccount[target]
REF_88(bool) (->frozenAccount) := freeze(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
FrozenFunds(target,freeze)

IRs:
Emit FrozenFunds(target,freeze)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
3->1;
}
// Function: 33450.sol-VVToken-isConfirmed(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->10;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_95 -> LENGTH owners
TMP_145(bool) = i < REF_95
CONDITION TMP_145"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
Confirmations[TransHash][owners[i]]

IRs:
REF_96(mapping(address => bool)) -> Confirmations[TransHash]
REF_97(address) -> owners[i]
REF_98(bool) -> REF_96[REF_97]
CONDITION REF_98"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_146(uint256) := i(uint256)
i(uint256) = i + 1"];
9->5;
10[label="Node Type: IF 10

EXPRESSION:
count == ownerRequired

IRs:
TMP_147(bool) = count == ownerRequired
CONDITION TMP_147"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: END_IF 12
"];
}
// Function: 33450.sol-VVToken-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
RequireDispose[msg.sender] = true

IRs:
REF_66(bool) -> RequireDispose[msg.sender]
REF_66(bool) (->RequireDispose) := True(bool)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
ConfirmDispose()

IRs:
TMP_75(bool) = INTERNAL_CALL, MultiOwner.ConfirmDispose()()
CONDITION TMP_75"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_76(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
5->1;
}
// Function: 33450.sol-VVToken-notConfirmed(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! Confirmations[transactionHash][msg.sender])

IRs:
REF_131(mapping(address => bool)) -> Confirmations[transactionHash]
REF_132(bool) -> REF_131[msg.sender]
TMP_192 = UnaryType.BANG REF_132 
TMP_193(None) = SOLIDITY_CALL require(bool)(TMP_192)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-VVToken-notExecuted(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! Transactions[TransHash].executed)

IRs:
REF_133(VVToken.Transaction) -> Transactions[TransHash]
REF_134(bool) -> REF_133.executed
TMP_194 = UnaryType.BANG REF_134 
TMP_195(None) = SOLIDITY_CALL require(bool)(TMP_194)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-VVToken-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(destination != 0x0)

IRs:
TMP_189(bool) = destination != 0
TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-VVToken-numberOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
NumberOwners = owners.length

IRs:
REF_52 -> LENGTH owners
NumberOwners(uint256) := REF_52(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
NumberOwners

IRs:
RETURN NumberOwners"];
}
// Function: 33450.sol-VVToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isOwner[msg.sender])

IRs:
REF_126(bool) -> isOwner[msg.sender]
TMP_185(None) = SOLIDITY_CALL require(bool)(REF_126)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-VVToken-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isOwner[owner])

IRs:
REF_127(bool) -> isOwner[owner]
TMP_186 = UnaryType.BANG REF_127 
TMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-VVToken-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isOwner[owner])

IRs:
REF_128(bool) -> isOwner[owner]
TMP_188(None) = SOLIDITY_CALL require(bool)(REF_128)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 33450.sol-VVToken-remainBalanced()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balanceOf[this]

IRs:
REF_89(uint256) -> balanceOf[this]
RETURN REF_89"];
}
// Function: 33450.sol-VVToken-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->15;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owners.length > 2)

IRs:
REF_53 -> LENGTH owners
TMP_56(bool) = REF_53 > 2
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
isOwner[owner] = false

IRs:
REF_54(bool) -> isOwner[owner]
REF_54(bool) (->isOwner) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RequireDispose[owner] = false

IRs:
REF_55(bool) -> RequireDispose[owner]
REF_55(bool) (->RequireDispose) := False(bool)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length - 1

IRs:
REF_56 -> LENGTH owners
TMP_58(uint256) = REF_56 - 1
TMP_59(bool) = i < TMP_58
CONDITION TMP_59"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
owners[i] == owner

IRs:
REF_57(address) -> owners[i]
TMP_60(bool) = REF_57 == owner
CONDITION TMP_60"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_58(address) -> owners[i]
REF_59 -> LENGTH owners
TMP_61(uint256) = REF_59 - 1
REF_60(address) -> owners[TMP_61]
REF_58(address) (->owners) := REF_60(address)"];
9->10;
10[label="Node Type: BREAK 10
"];
10->5;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_62(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
owners.length -= 1

IRs:
REF_61 -> LENGTH owners
REF_61(-> owners) = REF_61 - 1"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
OwnerRemoved(owner)

IRs:
Emit OwnerRemoved(owner)"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiOwner.ownerExists(address)(owner)"];
16->1;
}
// Function: 33450.sol-VVToken-setFee(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
ChargeFee = newValue

IRs:
ChargeFee(uint256) := newValue(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
2->1;
}
// Function: 33450.sol-VVToken-setPrices(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
EthPerToken = newValue

IRs:
EthPerToken(uint256) := newValue(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
2->1;
}
// Function: 33450.sol-VVToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
name = VV Coin

IRs:
name(string) := VV Coin(string)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
symbol = VVI

IRs:
symbol(string) := VVI(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
decimals = 8

IRs:
decimals(uint8) := 8(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
totalSupply = 3000000000 * 10 ** uint256(decimals)

IRs:
TMP_182 = CONVERT decimals to uint256
TMP_183(uint256) = 10 ** TMP_182
TMP_184(uint256) = 3000000000 * TMP_183
totalSupply(uint256) := TMP_184(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
EthPerToken = 300000

IRs:
EthPerToken(uint256) := 300000(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
ChargeFee = 2

IRs:
ChargeFee(uint256) := 2(uint256)"];
}
// Function: 33450.sol-VVToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transfer(msg.sender,_to,_value)

IRs:
INTERNAL_CALL, VVToken._transfer(address,address,uint256)(msg.sender,_to,_value)"];
}
// Function: 33450.sol-VVToken-transferFrom(address,address,uint256,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
charge = 0

IRs:
charge(uint256) := 0(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
t_value = _value

IRs:
t_value(uint256) := _value(uint256)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
_fee

IRs:
CONDITION _fee"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
charge = _value * ChargeFee / 100

IRs:
TMP_108(uint256) = _value * ChargeFee
TMP_109(uint256) = TMP_108 / 100
charge(uint256) := TMP_109(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
charge = _value - (_value / (ChargeFee + 100) * 100)

IRs:
TMP_110(uint256) = ChargeFee + 100
TMP_111(uint256) = _value / TMP_110
TMP_112(uint256) = TMP_111 * 100
TMP_113(uint256) = _value - TMP_112
charge(uint256) := TMP_113(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
t_value = _value - charge

IRs:
TMP_114(uint256) = _value - charge
t_value(uint256) := TMP_114(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(t_value + charge == _value)

IRs:
TMP_115(uint256) = t_value + charge
TMP_116(bool) = TMP_115 == _value
TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_transfer(_from,_to,t_value)

IRs:
INTERNAL_CALL, VVToken._transfer(address,address,uint256)(_from,_to,t_value)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_collect_fee(_from,this,charge)

IRs:
INTERNAL_CALL, VVToken._collect_fee(address,address,uint256)(_from,this,charge)"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()"];
12->1;
13[label="Node Type: RETURN 13

EXPRESSION:
success

IRs:
RETURN success"];
}
}
