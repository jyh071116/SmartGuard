digraph G {
// Function: 35421.sol-DSBaseActor-exec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(tryExec(target,calldata,value))

IRs:
TMP_55(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(target,calldata,value)
TMP_56(None) = SOLIDITY_CALL assert(bool)(TMP_55)"];
}
// Function: 35421.sol-DSBaseActor-mutex()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(! _ds_mutex)

IRs:
TMP_57 = UnaryType.BANG _ds_mutex 
TMP_58(None) = SOLIDITY_CALL assert(bool)(TMP_57)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_ds_mutex = true

IRs:
_ds_mutex(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_ds_mutex = false

IRs:
_ds_mutex(bool) := False(bool)"];
}
// Function: 35421.sol-DSBaseActor-tryExec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
target.call.value(value)(calldata)

IRs:
TMP_53(bool) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['calldata'] value:value 
RETURN TMP_53"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
mutex()

IRs:
MODIFIER_CALL, DSBaseActor.mutex()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
call_ret

IRs:
RETURN call_ret"];
}
// Function: 35421.sol-DSMath-cast(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)((z = uint128(x)) == x)

IRs:
TMP_42 = CONVERT x to uint128
z(uint128) := TMP_42(uint128)
TMP_43(bool) = z == x
TMP_44(None) = SOLIDITY_CALL assert(bool)(TMP_43)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-hadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x + y) >= x)

IRs:
TMP_9(uint128) = x + y
z(uint128) := TMP_9(uint128)
TMP_10(bool) = z >= x
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-hdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = x / y

IRs:
TMP_21(uint128) = x / y
z(uint128) := TMP_21(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-hless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x < y

IRs:
TMP_8(bool) = x < y
RETURN TMP_8"];
}
// Function: 35421.sol-DSMath-hmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_23(bool) = x >= y
CONDITION TMP_23"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-hmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_22(bool) = x <= y
CONDITION TMP_22"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-hmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x > y

IRs:
TMP_7(bool) = x > y
RETURN TMP_7"];
}
// Function: 35421.sol-DSMath-hmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(y == 0 || (z = x * y) / y == x)

IRs:
TMP_15(bool) = y == 0
TMP_16(uint128) = x * y
z(uint128) := TMP_16(uint128)
TMP_17(uint128) = z / y
TMP_18(bool) = TMP_17 == x
TMP_19(bool) = TMP_15 || TMP_18
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-hsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x - y) <= x)

IRs:
TMP_12(uint128) = x - y
z(uint128) := TMP_12(uint128)
TMP_13(bool) = z <= x
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
WAD_Dec = 18

IRs:
WAD_Dec(uint64) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
WAD = 10 ** 18

IRs:
TMP_45(uint256) = 10 ** 18
WAD(uint128) := TMP_45(uint256)"];
}
// Function: 35421.sol-DSMath-wadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hadd(x,y)

IRs:
TMP_26(uint128) = INTERNAL_CALL, DSMath.hadd(uint128,uint128)(x,y)
RETURN TMP_26"];
}
// Function: 35421.sol-DSMath-wdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * WAD + y / 2) / y)

IRs:
TMP_34 = CONVERT x to uint256
TMP_35(uint256) = TMP_34 * WAD
TMP_36(uint128) = y / 2
TMP_37(uint256) = TMP_35 + TMP_36
TMP_38(uint256) = TMP_37 / y
TMP_39(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_38)
z(uint128) := TMP_39(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-wless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hless(x,y)

IRs:
TMP_25(bool) = INTERNAL_CALL, DSMath.hless(uint128,uint128)(x,y)
RETURN TMP_25"];
}
// Function: 35421.sol-DSMath-wmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmax(x,y)

IRs:
TMP_41(uint128) = INTERNAL_CALL, DSMath.hmax(uint128,uint128)(x,y)
RETURN TMP_41"];
}
// Function: 35421.sol-DSMath-wmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmin(x,y)

IRs:
TMP_40(uint128) = INTERNAL_CALL, DSMath.hmin(uint128,uint128)(x,y)
RETURN TMP_40"];
}
// Function: 35421.sol-DSMath-wmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmore(x,y)

IRs:
TMP_24(bool) = INTERNAL_CALL, DSMath.hmore(uint128,uint128)(x,y)
RETURN TMP_24"];
}
// Function: 35421.sol-DSMath-wmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * y + WAD / 2) / WAD)

IRs:
TMP_28 = CONVERT x to uint256
TMP_29(uint256) = TMP_28 * y
TMP_30(uint128) = WAD / 2
TMP_31(uint256) = TMP_29 + TMP_30
TMP_32(uint256) = TMP_31 / WAD
TMP_33(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_32)
z(uint128) := TMP_33(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-DSMath-wsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hsub(x,y)

IRs:
TMP_27(uint128) = INTERNAL_CALL, DSMath.hsub(uint128,uint128)(x,y)
RETURN TMP_27"];
}
// Function: 35421.sol-I_Pricer-QuickPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_Pricer-__callback(bytes32,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_Pricer-collectFee()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_Pricer-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_46(None) = SOLIDITY_CALL revert()()"];
}
// Function: 35421.sol-I_Pricer-queryCost()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_value

IRs:
RETURN _value"];
}
// Function: 35421.sol-I_Pricer-requestPrice(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TrasID

IRs:
RETURN _TrasID"];
}
// Function: 35421.sol-I_Pricer-setMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_coin-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 35421.sol-I_coin-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35421.sol-I_coin-approveAndCall(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_coin-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 35421.sol-I_coin-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-I_coin-decreaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35421.sol-I_coin-increaseApproval(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35421.sol-I_coin-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_47(bool) = msg.sender == owner
CONDITION TMP_47"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_48(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35421.sol-I_coin-meltCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35421.sol-I_coin-mintCoin(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35421.sol-I_coin-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_51(bool) = msg.sender == owner
CONDITION TMP_51"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-I_coin-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35421.sol-I_coin-setMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_coin-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 18

IRs:
decimals(uint8) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
version = 

IRs:
version(string) := (string)"];
}
// Function: 35421.sol-I_coin-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35421.sol-I_coin-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 35421.sol-I_minter-Leverage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_minter-NewRisk()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-I_minter-NewRiskAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-I_minter-NewStatic()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-I_minter-NewStaticAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-I_minter-PriceReturn(uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-I_minter-RetRisk(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-I_minter-RetStatic(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-I_minter-RiskPrice(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35421.sol-I_minter-RiskPrice(uint128,uint128,uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35421.sol-I_minter-Strike()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-canFreeze-Freeze()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-canFreeze-LockIfFrozen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! frozen

IRs:
TMP_62 = UnaryType.BANG frozen 
CONDITION TMP_62"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-canFreeze-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-canFreeze-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_61(bool) = msg.sender == owner
CONDITION TMP_61"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-canFreeze-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35421.sol-canFreeze-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
}
// Function: 35421.sol-minter-ActionNewRisk(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
wless(cast(this.balance),_details.amount)

IRs:
REF_47(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_224(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_47)
REF_48(uint128) -> _details.amount
TMP_225(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(TMP_224,REF_48)
CONDITION TMP_225"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
CurRiskPrice = RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),0)

IRs:
TMP_226(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_227(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_226)
TMP_228(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_229(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_228)
TMP_230(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128,uint128,uint128,uint128)(_Price,TMP_227,TMP_229,0)
CurRiskPrice(uint128) := TMP_230(uint128)"];
3->5;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
CurRiskPrice = RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),wsub(cast(this.balance),_details.amount))

IRs:
TMP_231(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_232(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_231)
TMP_233(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_234(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_233)
REF_53(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_235(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_53)
REF_54(uint128) -> _details.amount
TMP_236(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(TMP_235,REF_54)
TMP_237(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128,uint128,uint128,uint128)(_Price,TMP_232,TMP_234,TMP_236)
CurRiskPrice(uint128) := TMP_237(uint128)"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
CurRiskPrice > 0

IRs:
TMP_238(bool) = CurRiskPrice > 0
CONDITION TMP_238"];
6->7[label="True"];
6->10[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
quantity = wdiv(wmul(_details.amount,_Price),CurRiskPrice)

IRs:
REF_55(uint128) -> _details.amount
TMP_239(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(REF_55,_Price)
TMP_240(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_239,CurRiskPrice)
quantity(uint128) := TMP_240(uint128)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Risk.mintCoin(_details.holder,uint256(quantity))

IRs:
REF_57(address) -> _details.holder
TMP_241 = CONVERT quantity to uint256
TMP_242(bool) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:mintCoin, arguments:['REF_57', 'TMP_241']  "];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
EventCreateRisk(_details.holder,quantity,_TransID,_Price)

IRs:
REF_58(address) -> _details.holder
Emit EventCreateRisk(REF_58,quantity,_TransID,_Price)"];
9->12;
10[label="Node Type: NEW VARIABLE 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
exec(_details.holder,calldata,_details.amount)

IRs:
REF_59(address) -> _details.holder
REF_60(uint128) -> _details.amount
INTERNAL_CALL, DSBaseActor.exec(address,bytes,uint256)(REF_59,calldata,REF_60)"];
11->12;
12[label="Node Type: END_IF 12
"];
}
// Function: 35421.sol-minter-ActionNewStatic(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
CurRiskPrice = RiskPrice(_Price)

IRs:
TMP_205(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128)(_Price)
CurRiskPrice(uint128) := TMP_205(uint128)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
StaticAvail = StaticEthAvailable(cast(Risk.totalSupply()),wsub(cast(this.balance),_details.amount))

IRs:
TMP_206(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_207(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_206)
REF_37(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_208(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_37)
REF_38(uint128) -> _details.amount
TMP_209(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(TMP_208,REF_38)
TMP_210(uint128) = INTERNAL_CALL, minter.StaticEthAvailable(uint128,uint128)(TMP_207,TMP_209)
StaticAvail(uint128) := TMP_210(uint128)"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
wless(_details.amount,StaticAvail)

IRs:
REF_39(uint128) -> _details.amount
TMP_211(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(REF_39,StaticAvail)
CONDITION TMP_211"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
AmountMint = _details.amount

IRs:
REF_40(uint128) -> _details.amount
AmountMint(uint128) := REF_40(uint128)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
AmountReturn = 0

IRs:
AmountReturn(uint128) := 0(uint256)"];
7->10;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
AmountMint = StaticAvail

IRs:
AmountMint(uint128) := StaticAvail(uint128)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
AmountReturn = wsub(_details.amount,StaticAvail)

IRs:
REF_41(uint128) -> _details.amount
TMP_212(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(REF_41,StaticAvail)
AmountReturn(uint128) := TMP_212(uint128)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
0 == CurRiskPrice

IRs:
TMP_213(bool) = 0 == CurRiskPrice
CONDITION TMP_213"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
AmountReturn = _details.amount

IRs:
REF_42(uint128) -> _details.amount
AmountReturn(uint128) := REF_42(uint128)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
CurRiskPrice > 0 && StaticAvail > 0

IRs:
TMP_214(bool) = CurRiskPrice > 0
TMP_215(bool) = StaticAvail > 0
TMP_216(bool) = TMP_214 && TMP_215
CONDITION TMP_216"];
14->15[label="True"];
14->17[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Static.mintCoin(_details.holder,uint256(wmul(AmountMint,_Price)))

IRs:
REF_44(address) -> _details.holder
TMP_217(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(AmountMint,_Price)
TMP_218 = CONVERT TMP_217 to uint256
TMP_219(bool) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:mintCoin, arguments:['REF_44', 'TMP_218']  "];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
EventCreateStatic(_details.holder,wmul(AmountMint,_Price),_TransID,_Price)

IRs:
REF_45(address) -> _details.holder
TMP_220(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(AmountMint,_Price)
Emit EventCreateStatic(REF_45,TMP_220,_TransID,_Price)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
AmountReturn > 0

IRs:
TMP_222(bool) = AmountReturn > 0
CONDITION TMP_222"];
18->19[label="True"];
18->21[label="False"];
19[label="Node Type: NEW VARIABLE 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
exec(_details.holder,calldata,AmountReturn)

IRs:
REF_46(address) -> _details.holder
INTERNAL_CALL, DSBaseActor.exec(address,bytes,uint256)(REF_46,calldata,AmountReturn)"];
20->21;
21[label="Node Type: END_IF 21
"];
}
// Function: 35421.sol-minter-ActionRetRisk(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
CurRiskPrice = RiskPrice(_Price)

IRs:
TMP_258(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128)(_Price)
CurRiskPrice(uint128) := TMP_258(uint128)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
CurRiskPrice > 0

IRs:
TMP_259(bool) = CurRiskPrice > 0
CONDITION TMP_259"];
4->5[label="True"];
4->17[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_ETHReturned = wdiv(wmul(_details.amount,CurRiskPrice),_Price)

IRs:
REF_77(uint128) -> _details.amount
TMP_260(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(REF_77,CurRiskPrice)
TMP_261(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_260,_Price)
_ETHReturned(uint128) := TMP_261(uint128)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
Risk.meltCoin(_details.holder,_details.amount)

IRs:
REF_79(address) -> _details.holder
REF_80(uint128) -> _details.amount
TMP_262(bool) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:meltCoin, arguments:['REF_79', 'REF_80']  
CONDITION TMP_262"];
6->7[label="True"];
6->16[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
EventRedeemRisk(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_81(address) -> _details.holder
REF_82(uint128) -> _details.amount
Emit EventRedeemRisk(REF_81,REF_82,_TransID,_Price)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
wless(cast(this.balance),_ETHReturned)

IRs:
REF_83(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_264(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_83)
TMP_265(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(TMP_264,_ETHReturned)
CONDITION TMP_265"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_ETHReturned = cast(this.balance)

IRs:
REF_84(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_266(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_84)
_ETHReturned(uint128) := TMP_266(uint128)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
tryExec(_details.holder,calldata,_ETHReturned)

IRs:
REF_85(address) -> _details.holder
TMP_267(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(REF_85,calldata,_ETHReturned)
CONDITION TMP_267"];
12->13[label="True"];
12->15[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
Risk.mintCoin(_details.holder,_details.amount)

IRs:
REF_87(address) -> _details.holder
REF_88(uint128) -> _details.amount
TMP_268(bool) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:mintCoin, arguments:['REF_87', 'REF_88']  "];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
EventCreateRisk(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_89(address) -> _details.holder
REF_90(uint128) -> _details.amount
Emit EventCreateRisk(REF_89,REF_90,_TransID,_Price)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
}
// Function: 35421.sol-minter-ActionRetStatic(minter.Trans,uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
0 == Risk.totalSupply()

IRs:
TMP_245(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_246(bool) = 0 == TMP_245
CONDITION TMP_246"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_Price = lastPrice

IRs:
_Price(uint128) := lastPrice(uint128)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_ETHReturned = wdiv(_details.amount,_Price)

IRs:
REF_62(uint128) -> _details.amount
TMP_247(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(REF_62,_Price)
_ETHReturned(uint128) := TMP_247(uint128)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
Static.meltCoin(_details.holder,_details.amount)

IRs:
REF_64(address) -> _details.holder
REF_65(uint128) -> _details.amount
TMP_248(bool) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:meltCoin, arguments:['REF_64', 'REF_65']  
CONDITION TMP_248"];
6->7[label="True"];
6->19[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
EventRedeemStatic(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_66(address) -> _details.holder
REF_67(uint128) -> _details.amount
Emit EventRedeemStatic(REF_66,REF_67,_TransID,_Price)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
wless(cast(this.balance),_ETHReturned)

IRs:
REF_68(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_250(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_68)
TMP_251(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(TMP_250,_ETHReturned)
CONDITION TMP_251"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_ETHReturned = cast(this.balance)

IRs:
REF_69(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_252(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_69)
_ETHReturned(uint128) := TMP_252(uint128)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
tryExec(_details.holder,calldata,_ETHReturned)

IRs:
REF_70(address) -> _details.holder
TMP_253(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(REF_70,calldata,_ETHReturned)
CONDITION TMP_253"];
12->13[label="True"];
12->15[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
Static.mintCoin(_details.holder,_details.amount)

IRs:
REF_72(address) -> _details.holder
REF_73(uint128) -> _details.amount
TMP_254(bool) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:mintCoin, arguments:['REF_72', 'REF_73']  "];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
EventCreateStatic(_details.holder,_details.amount,_TransID,_Price)

IRs:
REF_74(address) -> _details.holder
REF_75(uint128) -> _details.amount
Emit EventCreateStatic(REF_74,REF_75,_TransID,_Price)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: IF 16

EXPRESSION:
0 == this.balance

IRs:
REF_76(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_256(bool) = 0 == REF_76
CONDITION TMP_256"];
16->17[label="True"];
16->18[label="False"];
17[label="Node Type: EXPRESSION 17

EXPRESSION:
Bankrupt()

IRs:
INTERNAL_CALL, minter.Bankrupt()()"];
17->18;
18[label="Node Type: END_IF 18
"];
18->19;
19[label="Node Type: END_IF 19
"];
}
// Function: 35421.sol-minter-Bailout()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 35421.sol-minter-Bankrupt()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
EventBankrupt()

IRs:
Emit EventBankrupt()"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Static.kill()

IRs:
HIGH_LEVEL_CALL, dest:Static(I_coin), function:kill, arguments:[]  "];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Risk.kill()

IRs:
HIGH_LEVEL_CALL, dest:Risk(I_coin), function:kill, arguments:[]  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35421.sol-minter-Freeze()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-minter-IsWallet(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: END INLINE ASM 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(0 == codeLength)

IRs:
TMP_270(bool) = 0 == codeLength
RETURN TMP_270"];
}
// Function: 35421.sol-minter-Leverage()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
Risk.totalSupply() > 0

IRs:
TMP_172(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_173(bool) = TMP_172 > 0
CONDITION TMP_173"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
wdiv(cast(this.balance),cast(Risk.totalSupply()))

IRs:
REF_18(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_174(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_18)
TMP_175(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_176(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_175)
TMP_177(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_174,TMP_176)
RETURN TMP_177"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 35421.sol-minter-LockIfFrozen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! frozen

IRs:
TMP_325 = UnaryType.BANG frozen 
CONDITION TMP_325"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-minter-LockIfUnwritten()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
written

IRs:
CONDITION written"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-minter-NewCoinInternal(address,uint128,minter.Action)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(IsWallet(_user))

IRs:
TMP_290(bool) = INTERNAL_CALL, minter.IsWallet(address)(_user)
TMP_291(None) = SOLIDITY_CALL require(bool)(TMP_290)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
Fee = wmax(wmul(_amount,mintFee),pricer.queryCost())

IRs:
TMP_292(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_amount,mintFee)
TMP_293(uint128) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:queryCost, arguments:[]  
TMP_294(uint128) = INTERNAL_CALL, DSMath.wmax(uint128,uint128)(TMP_292,TMP_293)
Fee(uint128) := TMP_294(uint128)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
wless(_amount,Fee)

IRs:
TMP_295(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(_amount,Fee)
CONDITION TMP_295"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
revert()()

IRs:
TMP_296(None) = SOLIDITY_CALL revert()()"];
4->5;
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
TransID ++

IRs:
TMP_297(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
PricerID = pricer.requestPrice.value(uint256(Fee))(TransID)

IRs:
TMP_298 = CONVERT Fee to uint256
TMP_300(uint256) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:requestPrice, arguments:['TransID'] value:TMP_298 
PricerID(uint256) := TMP_300(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
pending[TransID].push(Trans(wsub(_amount,Fee),_user,_action,PricerID))

IRs:
REF_102(minter.Trans[]) -> pending[TransID]
TMP_301(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(_amount,Fee)
TMP_302(minter.Trans) = new Trans(TMP_301,_user,_action,PricerID)
REF_104 -> LENGTH REF_102
TMP_304(uint256) := REF_104(uint256)
TMP_305(uint256) = TMP_304 + 1
REF_104(uint256) (->pending) := TMP_305(uint256)
REF_105(minter.Trans) -> REF_102[TMP_304]
REF_105(minter.Trans) (->pending) := TMP_302(minter.Trans)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
9->13;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
updates()

IRs:
MODIFIER_CALL, pricerControl.updates()()"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
LockIfUnwritten()

IRs:
MODIFIER_CALL, oneWrite.LockIfUnwritten()()"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
LockIfFrozen()

IRs:
MODIFIER_CALL, canFreeze.LockIfFrozen()()"];
12->1;
13[label="Node Type: RETURN 13

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-NewRisk()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(msg.sender,cast(msg.value),Action.NewRisk)

IRs:
TMP_132(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_6(minter.Action) -> Action.NewRisk
TMP_133(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(msg.sender,TMP_132,REF_6)
_TransID(uint256) := TMP_133(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-NewRiskAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(_user,cast(msg.value),Action.NewRisk)

IRs:
TMP_134(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_7(minter.Action) -> Action.NewRisk
TMP_135(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(_user,TMP_134,REF_7)
_TransID(uint256) := TMP_135(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-NewStatic()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(msg.sender,cast(msg.value),Action.NewStatic)

IRs:
TMP_128(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_4(minter.Action) -> Action.NewStatic
TMP_129(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(msg.sender,TMP_128,REF_4)
_TransID(uint256) := TMP_129(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-NewStaticAdr(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_TransID = NewCoinInternal(_user,cast(msg.value),Action.NewStatic)

IRs:
TMP_130(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_5(minter.Action) -> Action.NewStatic
TMP_131(uint256) = INTERNAL_CALL, minter.NewCoinInternal(address,uint128,minter.Action)(_user,TMP_130,REF_5)
_TransID(uint256) := TMP_131(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-PriceReturn(uint256,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->21;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
details = pending[_TransID][0]

IRs:
REF_23(minter.Trans[]) -> pending[_TransID]
REF_24(minter.Trans) -> REF_23[0]
details(minter.Trans) := REF_24(minter.Trans)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
0 == _Price || frozen

IRs:
TMP_189(bool) = 0 == _Price
TMP_190(bool) = TMP_189 || frozen
CONDITION TMP_190"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_Price = lastPrice

IRs:
_Price(uint128) := lastPrice(uint128)"];
3->7;
4[label="Node Type: IF 4

EXPRESSION:
Static.totalSupply() > 0 && Risk.totalSupply() > 0

IRs:
TMP_191(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_192(bool) = TMP_191 > 0
TMP_193(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_194(bool) = TMP_193 > 0
TMP_195(bool) = TMP_192 && TMP_194
CONDITION TMP_195"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
lastPrice = _Price

IRs:
lastPrice(uint128) := _Price(uint128)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
Action.NewStatic == details.action

IRs:
REF_27(minter.Action) -> Action.NewStatic
REF_28(minter.Action) -> details.action
TMP_196(bool) = REF_27 == REF_28
CONDITION TMP_196"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
ActionNewStatic(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionNewStatic(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
Action.RetStatic == details.action

IRs:
REF_29(minter.Action) -> Action.RetStatic
REF_30(minter.Action) -> details.action
TMP_198(bool) = REF_29 == REF_30
CONDITION TMP_198"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
ActionRetStatic(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionRetStatic(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
Action.NewRisk == details.action

IRs:
REF_31(minter.Action) -> Action.NewRisk
REF_32(minter.Action) -> details.action
TMP_200(bool) = REF_31 == REF_32
CONDITION TMP_200"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ActionNewRisk(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionNewRisk(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
Action.RetRisk == details.action

IRs:
REF_33(minter.Action) -> Action.RetRisk
REF_34(minter.Action) -> details.action
TMP_202(bool) = REF_33 == REF_34
CONDITION TMP_202"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
ActionRetRisk(details,_TransID,_Price)

IRs:
INTERNAL_CALL, minter.ActionRetRisk(minter.Trans,uint256,uint128)(details,_TransID,_Price)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
delete pending[_TransID]

IRs:
REF_35(minter.Trans[]) -> pending[_TransID]
pending = delete REF_35 "];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
onlyPricer()

IRs:
MODIFIER_CALL, pricerControl.onlyPricer()()"];
21->1;
}
// Function: 35421.sol-minter-RetCoinInternal(uint128,uint128,address,minter.Action)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->16;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(IsWallet(_user))

IRs:
TMP_271(bool) = INTERNAL_CALL, minter.IsWallet(address)(_user)
TMP_272(None) = SOLIDITY_CALL require(bool)(TMP_271)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
Fee = pricer.queryCost()

IRs:
TMP_273(uint128) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:queryCost, arguments:[]  
Fee(uint128) := TMP_273(uint128)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
wless(_AmountETH,Fee)

IRs:
TMP_274(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(_AmountETH,Fee)
CONDITION TMP_274"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_275(None) = SOLIDITY_CALL revert()()"];
5->7;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
refund = wsub(_AmountETH,Fee)

IRs:
TMP_276(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(_AmountETH,Fee)
refund(uint128) := TMP_276(uint128)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
0 == _Quantity

IRs:
TMP_277(bool) = 0 == _Quantity
CONDITION TMP_277"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
revert()()

IRs:
TMP_278(None) = SOLIDITY_CALL revert()()"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
TransID ++

IRs:
TMP_279(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
PricerID = pricer.requestPrice.value(uint256(Fee))(TransID)

IRs:
TMP_280 = CONVERT Fee to uint256
TMP_282(uint256) = HIGH_LEVEL_CALL, dest:pricer(I_Pricer), function:requestPrice, arguments:['TransID'] value:TMP_280 
PricerID(uint256) := TMP_282(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
pending[TransID].push(Trans(_Quantity,_user,_action,PricerID))

IRs:
REF_94(minter.Trans[]) -> pending[TransID]
TMP_283(minter.Trans) = new Trans(_Quantity,_user,_action,PricerID)
REF_96 -> LENGTH REF_94
TMP_285(uint256) := REF_96(uint256)
TMP_286(uint256) = TMP_285 + 1
REF_96(uint256) (->pending) := TMP_286(uint256)
REF_97(minter.Trans) -> REF_94[TMP_285]
REF_97(minter.Trans) (->pending) := TMP_283(minter.Trans)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_user.transfer(uint256(refund))

IRs:
TMP_287 = CONVERT refund to uint256
Transfer dest:_user value:TMP_287"];
15->17;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
updates()

IRs:
MODIFIER_CALL, pricerControl.updates()()"];
16->1;
17[label="Node Type: RETURN 17

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-RetRisk(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
TransID ++

IRs:
TMP_136(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ActionRetRisk(Trans(_Quantity,msg.sender,Action.RetRisk,0),TransID,lastPrice)

IRs:
REF_8(minter.Action) -> Action.RetRisk
TMP_137(minter.Trans) = new Trans(_Quantity,msg.sender,REF_8,0)
INTERNAL_CALL, minter.ActionRetRisk(minter.Trans,uint256,uint128)(TMP_137,TransID,lastPrice)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_TransID = RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetRisk)

IRs:
TMP_139(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_9(minter.Action) -> Action.RetRisk
TMP_140(uint256) = INTERNAL_CALL, minter.RetCoinInternal(uint128,uint128,address,minter.Action)(_Quantity,TMP_139,msg.sender,REF_9)
_TransID(uint256) := TMP_140(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
LockIfUnwritten()

IRs:
MODIFIER_CALL, oneWrite.LockIfUnwritten()()"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-RetStatic(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->7;
1[label="Node Type: IF 1

EXPRESSION:
frozen

IRs:
CONDITION frozen"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
TransID ++

IRs:
TMP_142(uint256) := TransID(uint256)
TransID(uint256) = TransID + 1"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ActionRetStatic(Trans(_Quantity,msg.sender,Action.RetStatic,0),TransID,lastPrice)

IRs:
REF_10(minter.Action) -> Action.RetStatic
TMP_143(minter.Trans) = new Trans(_Quantity,msg.sender,REF_10,0)
INTERNAL_CALL, minter.ActionRetStatic(minter.Trans,uint256,uint128)(TMP_143,TransID,lastPrice)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_TransID = TransID

IRs:
_TransID(uint256) := TransID(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_TransID = RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetStatic)

IRs:
TMP_145(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(msg.value)
REF_11(minter.Action) -> Action.RetStatic
TMP_146(uint256) = INTERNAL_CALL, minter.RetCoinInternal(uint128,uint128,address,minter.Action)(_Quantity,TMP_145,msg.sender,REF_11)
_TransID(uint256) := TMP_146(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->8;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
LockIfUnwritten()

IRs:
MODIFIER_CALL, oneWrite.LockIfUnwritten()()"];
7->1;
8[label="Node Type: RETURN 8

EXPRESSION:
_TransID

IRs:
RETURN _TransID"];
}
// Function: 35421.sol-minter-RiskPrice()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
RiskPrice(lastPrice)

IRs:
TMP_165(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128)(lastPrice)
RETURN TMP_165"];
2[label="Node Type: RETURN 2

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35421.sol-minter-RiskPrice(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
RiskPrice(_currentPrice,cast(Static.totalSupply()),cast(Risk.totalSupply()),cast(this.balance))

IRs:
TMP_166(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_167(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_166)
TMP_168(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_169(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_168)
REF_16(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_170(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_16)
TMP_171(uint128) = INTERNAL_CALL, minter.RiskPrice(uint128,uint128,uint128,uint128)(_currentPrice,TMP_167,TMP_169,TMP_170)
RETURN TMP_171"];
2[label="Node Type: RETURN 2

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35421.sol-minter-RiskPrice(uint128,uint128,uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_ETHTotal == 0 || _RiskTotal == 0

IRs:
TMP_156(bool) = _ETHTotal == 0
TMP_157(bool) = _RiskTotal == 0
TMP_158(bool) = TMP_156 || TMP_157
CONDITION TMP_158"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
wmul(_currentPrice,Multiplier)

IRs:
TMP_159(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_currentPrice,Multiplier)
RETURN TMP_159"];
3[label="Node Type: IF 3

EXPRESSION:
hmore(wmul(_ETHTotal,_currentPrice),_StaticTotal)

IRs:
TMP_160(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_ETHTotal,_currentPrice)
TMP_161(bool) = INTERNAL_CALL, DSMath.hmore(uint128,uint128)(TMP_160,_StaticTotal)
CONDITION TMP_161"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: RETURN 4

EXPRESSION:
wdiv(wsub(wmul(_ETHTotal,_currentPrice),_StaticTotal),_RiskTotal)

IRs:
TMP_162(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(_ETHTotal,_currentPrice)
TMP_163(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(TMP_162,_StaticTotal)
TMP_164(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_163,_RiskTotal)
RETURN TMP_164"];
5[label="Node Type: RETURN 5

EXPRESSION:
0

IRs:
RETURN 0"];
8[label="Node Type: RETURN 8

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 35421.sol-minter-StaticEthAvailable()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
StaticEthAvailable(cast(Risk.totalSupply()),cast(this.balance))

IRs:
TMP_148(uint256) = HIGH_LEVEL_CALL, dest:Risk(I_coin), function:totalSupply, arguments:[]  
TMP_149(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_148)
REF_13(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_150(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_13)
TMP_151(uint128) = INTERNAL_CALL, minter.StaticEthAvailable(uint128,uint128)(TMP_149,TMP_150)
RETURN TMP_151"];
}
// Function: 35421.sol-minter-StaticEthAvailable(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
temp = wmul(wadd(Multiplier,levToll),_RiskTotal)

IRs:
TMP_152(uint128) = INTERNAL_CALL, DSMath.wadd(uint128,uint128)(Multiplier,levToll)
TMP_153(uint128) = INTERNAL_CALL, DSMath.wmul(uint128,uint128)(TMP_152,_RiskTotal)
temp(uint128) := TMP_153(uint128)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
wless(_TotalETH,temp)

IRs:
TMP_154(bool) = INTERNAL_CALL, DSMath.wless(uint128,uint128)(_TotalETH,temp)
CONDITION TMP_154"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
wsub(temp,_TotalETH)

IRs:
TMP_155(uint128) = INTERNAL_CALL, DSMath.wsub(uint128,uint128)(temp,_TotalETH)
RETURN TMP_155"];
4[label="Node Type: RETURN 4

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 35421.sol-minter-Strike()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
this.balance > 0

IRs:
REF_20(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_178(bool) = REF_20 > 0
CONDITION TMP_178"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
wdiv(cast(Static.totalSupply()),cast(this.balance))

IRs:
TMP_179(uint256) = HIGH_LEVEL_CALL, dest:Static(I_coin), function:totalSupply, arguments:[]  
TMP_180(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_179)
REF_22(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_181(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(REF_22)
TMP_182(uint128) = INTERNAL_CALL, DSMath.wdiv(uint128,uint128)(TMP_180,TMP_181)
RETURN TMP_182"];
3[label="Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0"];
}
// Function: 35421.sol-minter-cast(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)((z = uint128(x)) == x)

IRs:
TMP_113 = CONVERT x to uint128
z(uint128) := TMP_113(uint128)
TMP_114(bool) = z == x
TMP_115(None) = SOLIDITY_CALL assert(bool)(TMP_114)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-minter-exec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(tryExec(target,calldata,value))

IRs:
TMP_125(bool) = INTERNAL_CALL, DSBaseActor.tryExec(address,bytes,uint256)(target,calldata,value)
TMP_126(None) = SOLIDITY_CALL assert(bool)(TMP_125)"];
}
// Function: 35421.sol-minter-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revert()()

IRs:
TMP_127(None) = SOLIDITY_CALL revert()()"];
}
// Function: 35421.sol-minter-hadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x + y) >= x)

IRs:
TMP_80(uint128) = x + y
z(uint128) := TMP_80(uint128)
TMP_81(bool) = z >= x
TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-hdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = x / y

IRs:
TMP_92(uint128) = x / y
z(uint128) := TMP_92(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-hless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x < y

IRs:
TMP_79(bool) = x < y
RETURN TMP_79"];
}
// Function: 35421.sol-minter-hmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x >= y

IRs:
TMP_94(bool) = x >= y
CONDITION TMP_94"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-hmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
2[label="Node Type: IF 2

EXPRESSION:
x <= y

IRs:
TMP_93(bool) = x <= y
CONDITION TMP_93"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: RETURN 3

EXPRESSION:
x

IRs:
RETURN x"];
4[label="Node Type: RETURN 4

EXPRESSION:
y

IRs:
RETURN y"];
6[label="Node Type: RETURN 6

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-hmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
x > y

IRs:
TMP_78(bool) = x > y
RETURN TMP_78"];
}
// Function: 35421.sol-minter-hmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(y == 0 || (z = x * y) / y == x)

IRs:
TMP_86(bool) = y == 0
TMP_87(uint128) = x * y
z(uint128) := TMP_87(uint128)
TMP_88(uint128) = z / y
TMP_89(bool) = TMP_88 == x
TMP_90(bool) = TMP_86 || TMP_89
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-hsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((z = x - y) <= x)

IRs:
TMP_83(uint128) = x - y
z(uint128) := TMP_83(uint128)
TMP_84(bool) = z <= x
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-minter(string,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Currency = _currency

IRs:
Currency(string) := _currency(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Multiplier = _Multiplier

IRs:
Multiplier(uint128) := _Multiplier(uint128)"];
}
// Function: 35421.sol-minter-mutex()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(! _ds_mutex)

IRs:
TMP_328 = UnaryType.BANG _ds_mutex 
TMP_329(None) = SOLIDITY_CALL assert(bool)(TMP_328)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_ds_mutex = true

IRs:
_ds_mutex(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_ds_mutex = false

IRs:
_ds_mutex(bool) := False(bool)"];
}
// Function: 35421.sol-minter-oneWrite()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35421.sol-minter-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_326(bool) = msg.sender == owner
CONDITION TMP_326"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-minter-onlyPricer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == address(pricer)

IRs:
TMP_323 = CONVERT pricer to address
TMP_324(bool) = msg.sender == TMP_323
CONDITION TMP_324"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-minter-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35421.sol-minter-setCoins(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
Risk = I_coin(newRisk)

IRs:
TMP_184 = CONVERT newRisk to I_coin
Risk(I_coin) := TMP_184(I_coin)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Static = I_coin(newStatic)

IRs:
TMP_185 = CONVERT newStatic to I_coin
Static(I_coin) := TMP_185(I_coin)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
PRICER_DELAY = 172800

IRs:
PRICER_DELAY(uint256) := 172800(uint256)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
updates()

IRs:
MODIFIER_CALL, pricerControl.updates()()"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
writeOnce()

IRs:
MODIFIER_CALL, oneWrite.writeOnce()()"];
6->1;
}
// Function: 35421.sol-minter-setFee(uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
mintFee = _newFee

IRs:
mintFee(uint128) := _newFee(uint128)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-minter-setPricer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
releaseTime = now + PRICER_DELAY

IRs:
TMP_116(uint256) = now + PRICER_DELAY
releaseTime(uint256) := TMP_116(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
future = newAddress

IRs:
future(address) := newAddress(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
EventAddressChange(pricer,future,releaseTime)

IRs:
Emit EventAddressChange(pricer,future,releaseTime)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35421.sol-minter-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
WAD_Dec = 18

IRs:
WAD_Dec(uint64) := 18(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
WAD = 10 ** 18

IRs:
TMP_318(uint256) = 10 ** 18
WAD(uint128) := TMP_318(uint256)"];
}
// Function: 35421.sol-minter-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
PRICER_DELAY = 2

IRs:
PRICER_DELAY(uint256) := 2(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
TransID = 0

IRs:
TransID(uint256) := 0(uint256)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
levToll = 5 * 10 ** (18 - 1)

IRs:
TMP_312(uint256) = 18 - 1
TMP_313(uint256) = 10 ** TMP_312
TMP_314(uint256) = 5 * TMP_313
levToll(uint128) := TMP_314(uint256)"];
4->5;
5[label="Node Type: OTHER_ENTRYPOINT 5

EXPRESSION:
mintFee = 2 * 10 ** (18 - 3)

IRs:
TMP_315(uint256) = 18 - 3
TMP_316(uint256) = 10 ** TMP_315
TMP_317(uint256) = 2 * TMP_316
mintFee(uint128) := TMP_317(uint256)"];
}
// Function: 35421.sol-minter-tryExec(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: RETURN 1

EXPRESSION:
target.call.value(value)(calldata)

IRs:
TMP_123(bool) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['calldata'] value:value 
RETURN TMP_123"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
mutex()

IRs:
MODIFIER_CALL, DSBaseActor.mutex()()"];
2->1;
3[label="Node Type: RETURN 3

EXPRESSION:
call_ret

IRs:
RETURN call_ret"];
}
// Function: 35421.sol-minter-update()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pricer = I_Pricer(future)

IRs:
TMP_119 = CONVERT future to I_Pricer
pricer(I_Pricer) := TMP_119(I_Pricer)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
}
// Function: 35421.sol-minter-updates()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
now > releaseTime && pricer != future

IRs:
TMP_319(bool) = now > releaseTime
TMP_320(bool) = pricer != future
TMP_321(bool) = TMP_319 && TMP_320
CONDITION TMP_321"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
update()

IRs:
INTERNAL_CALL, pricerControl.update()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 35421.sol-minter-wadd(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hadd(x,y)

IRs:
TMP_97(uint128) = INTERNAL_CALL, DSMath.hadd(uint128,uint128)(x,y)
RETURN TMP_97"];
}
// Function: 35421.sol-minter-wdiv(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * WAD + y / 2) / y)

IRs:
TMP_105 = CONVERT x to uint256
TMP_106(uint256) = TMP_105 * WAD
TMP_107(uint128) = y / 2
TMP_108(uint256) = TMP_106 + TMP_107
TMP_109(uint256) = TMP_108 / y
TMP_110(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_109)
z(uint128) := TMP_110(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-wless(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hless(x,y)

IRs:
TMP_96(bool) = INTERNAL_CALL, DSMath.hless(uint128,uint128)(x,y)
RETURN TMP_96"];
}
// Function: 35421.sol-minter-wmax(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmax(x,y)

IRs:
TMP_112(uint128) = INTERNAL_CALL, DSMath.hmax(uint128,uint128)(x,y)
RETURN TMP_112"];
}
// Function: 35421.sol-minter-wmin(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmin(x,y)

IRs:
TMP_111(uint128) = INTERNAL_CALL, DSMath.hmin(uint128,uint128)(x,y)
RETURN TMP_111"];
}
// Function: 35421.sol-minter-wmore(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hmore(x,y)

IRs:
TMP_95(bool) = INTERNAL_CALL, DSMath.hmore(uint128,uint128)(x,y)
RETURN TMP_95"];
}
// Function: 35421.sol-minter-wmul(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
z = cast((uint256(x) * y + WAD / 2) / WAD)

IRs:
TMP_99 = CONVERT x to uint256
TMP_100(uint256) = TMP_99 * y
TMP_101(uint128) = WAD / 2
TMP_102(uint256) = TMP_100 + TMP_101
TMP_103(uint256) = TMP_102 / WAD
TMP_104(uint128) = INTERNAL_CALL, DSMath.cast(uint256)(TMP_103)
z(uint128) := TMP_104(uint128)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
z

IRs:
RETURN z"];
}
// Function: 35421.sol-minter-writeOnce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! written

IRs:
TMP_327 = UnaryType.BANG written 
CONDITION TMP_327"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
written = true

IRs:
written(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 35421.sol-minter-wsub(uint128,uint128)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
hsub(x,y)

IRs:
TMP_98(uint128) = INTERNAL_CALL, DSMath.hsub(uint128,uint128)(x,y)
RETURN TMP_98"];
}
// Function: 35421.sol-mortal-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-mortal-kill()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_3(bool) = msg.sender == owner
CONDITION TMP_3"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_4(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35421.sol-mortal-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_6(bool) = msg.sender == owner
CONDITION TMP_6"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-mortal-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35421.sol-oneWrite-LockIfUnwritten()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
written

IRs:
CONDITION written"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-oneWrite-oneWrite()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35421.sol-oneWrite-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
written = false

IRs:
written(bool) := False(bool)"];
}
// Function: 35421.sol-oneWrite-writeOnce()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! written

IRs:
TMP_63 = UnaryType.BANG written 
CONDITION TMP_63"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
written = true

IRs:
written(bool) := True(bool)"];
2->3;
3[label="Node Type: _ 3
"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 35421.sol-owned-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_1(bool) = msg.sender == owner
CONDITION TMP_1"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-owned-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35421.sol-pricerControl-Freeze()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
frozen = true

IRs:
frozen(bool) := True(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-pricerControl-LockIfFrozen()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! frozen

IRs:
TMP_70 = UnaryType.BANG frozen 
CONDITION TMP_70"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-pricerControl-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 35421.sol-pricerControl-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_71(bool) = msg.sender == owner
CONDITION TMP_71"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-pricerControl-onlyPricer()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == address(pricer)

IRs:
TMP_76 = CONVERT pricer to address
TMP_77(bool) = msg.sender == TMP_76
CONDITION TMP_77"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: _ 2
"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 35421.sol-pricerControl-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 35421.sol-pricerControl-setPricer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
releaseTime = now + PRICER_DELAY

IRs:
TMP_66(uint256) = now + PRICER_DELAY
releaseTime(uint256) := TMP_66(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
future = newAddress

IRs:
future(address) := newAddress(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
EventAddressChange(pricer,future,releaseTime)

IRs:
Emit EventAddressChange(pricer,future,releaseTime)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
4->1;
}
// Function: 35421.sol-pricerControl-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
PRICER_DELAY = 2

IRs:
PRICER_DELAY(uint256) := 2(uint256)"];
}
// Function: 35421.sol-pricerControl-update()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
pricer = I_Pricer(future)

IRs:
TMP_69 = CONVERT future to I_Pricer
pricer(I_Pricer) := TMP_69(I_Pricer)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
frozen = false

IRs:
frozen(bool) := False(bool)"];
}
// Function: 35421.sol-pricerControl-updates()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
now > releaseTime && pricer != future

IRs:
TMP_72(bool) = now > releaseTime
TMP_73(bool) = pricer != future
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
update()

IRs:
INTERNAL_CALL, pricerControl.update()()"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
}
