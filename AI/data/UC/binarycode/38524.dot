digraph G {
// Function: 38524.sol-MultiSig-MultiSig(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_0 -> LENGTH _owners
TMP_3(bool) = i < REF_0
CONDITION TMP_3"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
isOwner[_owners[i]] || _owners[i] == 0

IRs:
REF_1(address) -> _owners[i]
REF_2(bool) -> isOwner[REF_1]
REF_3(address) -> _owners[i]
TMP_4(bool) = REF_3 == 0
TMP_5(bool) = REF_2 || TMP_4
CONDITION TMP_5"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_4(address) -> _owners[i]
REF_5(bool) -> isOwner[REF_4]
REF_5(bool) (->isOwner) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_6 -> LENGTH _owners
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(REF_6,_required)"];
12->3;
}
// Function: 38524.sol-MultiSig-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_7(bool) -> isOwner[owner]
REF_7(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_9 -> LENGTH owners
TMP_9(uint256) := REF_9(uint256)
TMP_10(uint256) = TMP_9 + 1
REF_9(uint256) (->owners) := TMP_10(uint256)
REF_10(address) -> owners[TMP_9]
REF_10(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
changeRequirement(owners.length / 2 + 1)

IRs:
REF_11 -> LENGTH owners
TMP_11(uint256) = REF_11 / 2
TMP_12(uint256) = TMP_11 + 1
INTERNAL_CALL, MultiSig.changeRequirement(uint256)(TMP_12)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerDoesNotExist(address)(owner)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notNull(owner)

IRs:
MODIFIER_CALL, MultiSig.notNull(address)(owner)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
validRequirement(owners.length + 1,required)

IRs:
REF_12 -> LENGTH owners
TMP_18(uint256) = REF_12 + 1
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(TMP_18,required)"];
8->1;
}
// Function: 38524.sol-MultiSig-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = transactionCount

IRs:
transactionId(uint256) := transactionCount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId] = Transaction(destination,value,data,false)

IRs:
REF_35(MultiSig.Transaction) -> transactions[transactionId]
TMP_58(MultiSig.Transaction) = new Transaction(destination,value,data,False)
REF_35(MultiSig.Transaction) (->transactions) := TMP_58(MultiSig.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactionCount += 1

IRs:
transactionCount(uint256) = transactionCount + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSig.notNull(address)(destination)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 38524.sol-MultiSig-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_26 -> LENGTH owners
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(REF_26,_required)"];
4->1;
}
// Function: 38524.sol-MultiSig-confirmTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_27(mapping(address => bool)) -> confirmations[transactionId]
REF_28(bool) -> REF_27[msg.sender]
REF_28(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSig.executeTransaction(uint256)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transactionExists(transactionId)

IRs:
MODIFIER_CALL, MultiSig.transactionExists(uint256)(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSig.notConfirmed(uint256,address)(transactionId,msg.sender)"];
6->1;
}
// Function: 38524.sol-MultiSig-confirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! confirmations[transactionId][owner]

IRs:
REF_64(mapping(address => bool)) -> confirmations[transactionId]
REF_65(bool) -> REF_64[owner]
TMP_96 = UnaryType.BANG REF_65 
CONDITION TMP_96"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-executeTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSig.notExecuted(uint256)(transactionId)"];
}
// Function: 38524.sol-MultiSig-getConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_36 -> LENGTH owners
TMP_61(bool) = i < REF_36
CONDITION TMP_61"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_37(mapping(address => bool)) -> confirmations[transactionId]
REF_38(address) -> owners[i]
REF_39(bool) -> REF_37[REF_38]
CONDITION REF_39"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_62(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 38524.sol-MultiSig-getConfirmations(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
confirmationsTemp = new address[](owners.length)

IRs:
REF_44 -> LENGTH owners
TMP_70(address[])  = new address[](REF_44)
confirmationsTemp(address[]) = ['TMP_70(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length

IRs:
REF_45 -> LENGTH owners
TMP_71(bool) = i < REF_45
CONDITION TMP_71"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_46(mapping(address => bool)) -> confirmations[transactionId]
REF_47(address) -> owners[i]
REF_48(bool) -> REF_46[REF_47]
CONDITION REF_48"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
confirmationsTemp[count] = owners[i]

IRs:
REF_49(address) -> confirmationsTemp[count]
REF_50(address) -> owners[i]
REF_49(address) (->confirmationsTemp) := REF_50(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_72(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_confirmations = new address[](count)

IRs:
TMP_74(address[])  = new address[](count)
_confirmations(address[]) = ['TMP_74(address[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < count

IRs:
TMP_75(bool) = i < count
CONDITION TMP_75"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_confirmations[i] = confirmationsTemp[i]

IRs:
REF_51(address) -> _confirmations[i]
REF_52(address) -> confirmationsTemp[i]
REF_51(address) (->_confirmations) := REF_52(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_76(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_confirmations

IRs:
RETURN _confirmations"];
}
// Function: 38524.sol-MultiSig-getOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owners

IRs:
RETURN owners"];
}
// Function: 38524.sol-MultiSig-getTransactionCount(bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < transactionCount

IRs:
TMP_63(bool) = i < transactionCount
CONDITION TMP_63"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_40(MultiSig.Transaction) -> transactions[i]
REF_41(bool) -> REF_40.executed
TMP_64 = UnaryType.BANG REF_41 
TMP_65(bool) = pending && TMP_64
REF_42(MultiSig.Transaction) -> transactions[i]
REF_43(bool) -> REF_42.executed
TMP_66(bool) = executed && REF_43
TMP_67(bool) = TMP_65 || TMP_66
CONDITION TMP_67"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_68(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 38524.sol-MultiSig-getTransactionIds(uint256,uint256,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
transactionIdsTemp = new uint256[](transactionCount)

IRs:
TMP_78(uint256[])  = new uint256[](transactionCount)
transactionIdsTemp(uint256[]) = ['TMP_78(uint256[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < transactionCount

IRs:
TMP_79(bool) = i < transactionCount
CONDITION TMP_79"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_53(MultiSig.Transaction) -> transactions[i]
REF_54(bool) -> REF_53.executed
TMP_80 = UnaryType.BANG REF_54 
TMP_81(bool) = pending && TMP_80
REF_55(MultiSig.Transaction) -> transactions[i]
REF_56(bool) -> REF_55.executed
TMP_82(bool) = executed && REF_56
TMP_83(bool) = TMP_81 || TMP_82
CONDITION TMP_83"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transactionIdsTemp[count] = i

IRs:
REF_57(uint256) -> transactionIdsTemp[count]
REF_57(uint256) (->transactionIdsTemp) := i(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_84(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_transactionIds = new uint256[](to - from)

IRs:
TMP_86(uint256) = to - from
TMP_87(uint256[])  = new uint256[](TMP_86)
_transactionIds(uint256[]) = ['TMP_87(uint256[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < to

IRs:
TMP_88(bool) = i < to
CONDITION TMP_88"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionIds[i - from] = transactionIdsTemp[i]

IRs:
TMP_89(uint256) = i - from
REF_58(uint256) -> _transactionIds[TMP_89]
REF_59(uint256) -> transactionIdsTemp[i]
REF_58(uint256) (->_transactionIds) := REF_59(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_90(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_transactionIds

IRs:
RETURN _transactionIds"];
}
// Function: 38524.sol-MultiSig-isConfirmed(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_31 -> LENGTH owners
TMP_55(bool) = i < REF_31
CONDITION TMP_55"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_32(mapping(address => bool)) -> confirmations[transactionId]
REF_33(address) -> owners[i]
REF_34(bool) -> REF_32[REF_33]
CONDITION REF_34"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_56(bool) = count == required
CONDITION TMP_56"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_57(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
}
// Function: 38524.sol-MultiSig-notConfirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
confirmations[transactionId][owner]

IRs:
REF_66(mapping(address => bool)) -> confirmations[transactionId]
REF_67(bool) -> REF_66[owner]
CONDITION REF_67"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-notExecuted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].executed

IRs:
REF_68(MultiSig.Transaction) -> transactions[transactionId]
REF_69(bool) -> REF_68.executed
CONDITION REF_69"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_address == 0

IRs:
TMP_97(bool) = _address == 0
CONDITION TMP_97"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_91(bool) = msg.sender != owner
CONDITION TMP_91"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != address(this)

IRs:
TMP_92 = CONVERT this to address
TMP_93(bool) = msg.sender != TMP_92
CONDITION TMP_93"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 38524.sol-MultiSig-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isOwner[owner]

IRs:
REF_60(bool) -> isOwner[owner]
CONDITION REF_60"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isOwner[owner]

IRs:
REF_61(bool) -> isOwner[owner]
TMP_94 = UnaryType.BANG REF_61 
CONDITION TMP_94"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = false

IRs:
REF_13(bool) -> isOwner[owner]
REF_13(bool) (->isOwner) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_14 -> LENGTH owners
TMP_20(uint256) = REF_14 - 1
TMP_21(bool) = i < TMP_20
CONDITION TMP_21"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
owners[i] == owner

IRs:
REF_15(address) -> owners[i]
TMP_22(bool) = REF_15 == owner
CONDITION TMP_22"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_16(address) -> owners[i]
REF_17 -> LENGTH owners
TMP_23(uint256) = REF_17 - 1
REF_18(address) -> owners[TMP_23]
REF_16(address) (->owners) := REF_18(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_24(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
owners.length -= 1

IRs:
REF_19 -> LENGTH owners
REF_19(-> owners) = REF_19 - 1"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
changeRequirement(owners.length / 2 + 1)

IRs:
REF_20 -> LENGTH owners
TMP_25(uint256) = REF_20 / 2
TMP_26(uint256) = TMP_25 + 1
INTERNAL_CALL, MultiSig.changeRequirement(uint256)(TMP_26)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(owner)"];
15->1;
}
// Function: 38524.sol-MultiSig-replaceOwner(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_21 -> LENGTH owners
TMP_31(bool) = i < REF_21
CONDITION TMP_31"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
owners[i] == owner

IRs:
REF_22(address) -> owners[i]
TMP_32(bool) = REF_22 == owner
CONDITION TMP_32"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
owners[i] = newOwner

IRs:
REF_23(address) -> owners[i]
REF_23(address) (->owners) := newOwner(address)"];
6->7;
7[label="Node Type: BREAK 7
"];
7->2;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_33(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
isOwner[owner] = false

IRs:
REF_24(bool) -> isOwner[owner]
REF_24(bool) (->isOwner) := False(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isOwner[newOwner] = true

IRs:
REF_25(bool) -> isOwner[newOwner]
REF_25(bool) (->isOwner) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerAddition(newOwner)

IRs:
Emit OwnerAddition(newOwner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(owner)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerDoesNotExist(newOwner)

IRs:
MODIFIER_CALL, MultiSig.ownerDoesNotExist(address)(newOwner)"];
16->3;
}
// Function: 38524.sol-MultiSig-revokeConfirmation(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_29(mapping(address => bool)) -> confirmations[transactionId]
REF_30(bool) -> REF_29[msg.sender]
REF_30(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSig.confirmed(uint256,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSig.notExecuted(uint256)(transactionId)"];
5->1;
}
// Function: 38524.sol-MultiSig-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_OWNER_COUNT = 50

IRs:
MAX_OWNER_COUNT(uint256) := 50(uint256)"];
}
// Function: 38524.sol-MultiSig-submitTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data)

IRs:
TMP_42(uint256) = INTERNAL_CALL, MultiSig.addTransaction(address,uint256,bytes)(destination,value,data)
transactionId(uint256) := TMP_42(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSig.confirmTransaction(uint256)(transactionId)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 38524.sol-MultiSig-transactionExists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].destination == 0

IRs:
REF_62(MultiSig.Transaction) -> transactions[transactionId]
REF_63(address) -> REF_62.destination
TMP_95(bool) = REF_63 == 0
CONDITION TMP_95"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSig-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 38524.sol-MultiSig-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0

IRs:
TMP_98(bool) = ownerCount > MAX_OWNER_COUNT
TMP_99(bool) = _required > ownerCount
TMP_100(bool) = TMP_98 || TMP_99
TMP_101(bool) = _required == 0
TMP_102(bool) = TMP_100 || TMP_101
TMP_103(bool) = ownerCount == 0
TMP_104(bool) = TMP_102 || TMP_103
CONDITION TMP_104"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-MultiSig(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_148 -> LENGTH _owners
TMP_217(bool) = i < REF_148
CONDITION TMP_217"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
isOwner[_owners[i]] || _owners[i] == 0

IRs:
REF_149(address) -> _owners[i]
REF_150(bool) -> isOwner[REF_149]
REF_151(address) -> _owners[i]
TMP_218(bool) = REF_151 == 0
TMP_219(bool) = REF_150 || TMP_218
CONDITION TMP_219"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_152(address) -> _owners[i]
REF_153(bool) -> isOwner[REF_152]
REF_153(bool) (->isOwner) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_220(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_154 -> LENGTH _owners
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(REF_154,_required)"];
12->3;
}
// Function: 38524.sol-MultiSigToken-MultiSigToken(address[],uint256,token)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenFactory = token(_addressOfTokenFactory)

IRs:
TMP_306 = CONVERT _addressOfTokenFactory to token
tokenFactory(token) := TMP_306(token)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
MultiSig(_owners,_required)

IRs:
INTERNAL_CALL, MultiSig.MultiSig(address[],uint256)(_owners,_required)"];
2->1;
}
// Function: 38524.sol-MultiSigToken-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_155(bool) -> isOwner[owner]
REF_155(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_157 -> LENGTH owners
TMP_223(uint256) := REF_157(uint256)
TMP_224(uint256) = TMP_223 + 1
REF_157(uint256) (->owners) := TMP_224(uint256)
REF_158(address) -> owners[TMP_223]
REF_158(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
changeRequirement(owners.length / 2 + 1)

IRs:
REF_159 -> LENGTH owners
TMP_225(uint256) = REF_159 / 2
TMP_226(uint256) = TMP_225 + 1
INTERNAL_CALL, MultiSig.changeRequirement(uint256)(TMP_226)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerDoesNotExist(address)(owner)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notNull(owner)

IRs:
MODIFIER_CALL, MultiSig.notNull(address)(owner)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
validRequirement(owners.length + 1,required)

IRs:
REF_160 -> LENGTH owners
TMP_232(uint256) = REF_160 + 1
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(TMP_232,required)"];
8->1;
}
// Function: 38524.sol-MultiSigToken-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = transactionCount

IRs:
transactionId(uint256) := transactionCount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId] = Transaction(destination,value,data,false)

IRs:
REF_183(MultiSig.Transaction) -> transactions[transactionId]
TMP_272(MultiSig.Transaction) = new Transaction(destination,value,data,False)
REF_183(MultiSig.Transaction) (->transactions) := TMP_272(MultiSig.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactionCount += 1

IRs:
transactionCount(uint256) = transactionCount + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSig.notNull(address)(destination)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 38524.sol-MultiSigToken-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_174 -> LENGTH owners
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(REF_174,_required)"];
4->1;
}
// Function: 38524.sol-MultiSigToken-confirmTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_175(mapping(address => bool)) -> confirmations[transactionId]
REF_176(bool) -> REF_175[msg.sender]
REF_176(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigToken.executeTransaction(uint256)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transactionExists(transactionId)

IRs:
MODIFIER_CALL, MultiSig.transactionExists(uint256)(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSig.notConfirmed(uint256,address)(transactionId,msg.sender)"];
6->1;
}
// Function: 38524.sol-MultiSigToken-confirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! confirmations[transactionId][owner]

IRs:
REF_218(mapping(address => bool)) -> confirmations[transactionId]
REF_219(bool) -> REF_218[owner]
TMP_317 = UnaryType.BANG REF_219 
CONDITION TMP_317"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-executeTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_308(bool) = INTERNAL_CALL, MultiSig.isConfirmed(uint256)(transactionId)
CONDITION TMP_308"];
1->2[label="True"];
1->9[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tx = transactions[transactionId]

IRs:
REF_208(MultiSig.Transaction) -> transactions[transactionId]
tx(MultiSig.Transaction) := REF_208(MultiSig.Transaction)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
tokenFactory.transfer(tx.destination,tx.value)

IRs:
REF_210(address) -> tx.destination
REF_211(uint256) -> tx.value
TMP_309(bool) = HIGH_LEVEL_CALL, dest:tokenFactory(token), function:transfer, arguments:['REF_210', 'REF_211']  
CONDITION TMP_309"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tx.executed = true

IRs:
REF_212(bool) -> tx.executed
REF_212(bool) (->tx) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)"];
5->8;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
tx.executed = false

IRs:
REF_213(bool) -> tx.executed
REF_213(bool) (->tx) := False(bool)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSig.notExecuted(uint256)(transactionId)"];
10->1;
}
// Function: 38524.sol-MultiSigToken-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: THROW 1
"];
}
// Function: 38524.sol-MultiSigToken-getConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_184 -> LENGTH owners
TMP_275(bool) = i < REF_184
CONDITION TMP_275"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_185(mapping(address => bool)) -> confirmations[transactionId]
REF_186(address) -> owners[i]
REF_187(bool) -> REF_185[REF_186]
CONDITION REF_187"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_276(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 38524.sol-MultiSigToken-getConfirmations(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
confirmationsTemp = new address[](owners.length)

IRs:
REF_192 -> LENGTH owners
TMP_284(address[])  = new address[](REF_192)
confirmationsTemp(address[]) = ['TMP_284(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length

IRs:
REF_193 -> LENGTH owners
TMP_285(bool) = i < REF_193
CONDITION TMP_285"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_194(mapping(address => bool)) -> confirmations[transactionId]
REF_195(address) -> owners[i]
REF_196(bool) -> REF_194[REF_195]
CONDITION REF_196"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
confirmationsTemp[count] = owners[i]

IRs:
REF_197(address) -> confirmationsTemp[count]
REF_198(address) -> owners[i]
REF_197(address) (->confirmationsTemp) := REF_198(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_286(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_confirmations = new address[](count)

IRs:
TMP_288(address[])  = new address[](count)
_confirmations(address[]) = ['TMP_288(address[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < count

IRs:
TMP_289(bool) = i < count
CONDITION TMP_289"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_confirmations[i] = confirmationsTemp[i]

IRs:
REF_199(address) -> _confirmations[i]
REF_200(address) -> confirmationsTemp[i]
REF_199(address) (->_confirmations) := REF_200(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_290(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_confirmations

IRs:
RETURN _confirmations"];
}
// Function: 38524.sol-MultiSigToken-getOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owners

IRs:
RETURN owners"];
}
// Function: 38524.sol-MultiSigToken-getTransactionCount(bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < transactionCount

IRs:
TMP_277(bool) = i < transactionCount
CONDITION TMP_277"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_188(MultiSig.Transaction) -> transactions[i]
REF_189(bool) -> REF_188.executed
TMP_278 = UnaryType.BANG REF_189 
TMP_279(bool) = pending && TMP_278
REF_190(MultiSig.Transaction) -> transactions[i]
REF_191(bool) -> REF_190.executed
TMP_280(bool) = executed && REF_191
TMP_281(bool) = TMP_279 || TMP_280
CONDITION TMP_281"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_282(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 38524.sol-MultiSigToken-getTransactionIds(uint256,uint256,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
transactionIdsTemp = new uint256[](transactionCount)

IRs:
TMP_292(uint256[])  = new uint256[](transactionCount)
transactionIdsTemp(uint256[]) = ['TMP_292(uint256[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < transactionCount

IRs:
TMP_293(bool) = i < transactionCount
CONDITION TMP_293"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_201(MultiSig.Transaction) -> transactions[i]
REF_202(bool) -> REF_201.executed
TMP_294 = UnaryType.BANG REF_202 
TMP_295(bool) = pending && TMP_294
REF_203(MultiSig.Transaction) -> transactions[i]
REF_204(bool) -> REF_203.executed
TMP_296(bool) = executed && REF_204
TMP_297(bool) = TMP_295 || TMP_296
CONDITION TMP_297"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transactionIdsTemp[count] = i

IRs:
REF_205(uint256) -> transactionIdsTemp[count]
REF_205(uint256) (->transactionIdsTemp) := i(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_298(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_transactionIds = new uint256[](to - from)

IRs:
TMP_300(uint256) = to - from
TMP_301(uint256[])  = new uint256[](TMP_300)
_transactionIds(uint256[]) = ['TMP_301(uint256[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < to

IRs:
TMP_302(bool) = i < to
CONDITION TMP_302"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionIds[i - from] = transactionIdsTemp[i]

IRs:
TMP_303(uint256) = i - from
REF_206(uint256) -> _transactionIds[TMP_303]
REF_207(uint256) -> transactionIdsTemp[i]
REF_206(uint256) (->_transactionIds) := REF_207(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_304(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_transactionIds

IRs:
RETURN _transactionIds"];
}
// Function: 38524.sol-MultiSigToken-isConfirmed(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_179 -> LENGTH owners
TMP_269(bool) = i < REF_179
CONDITION TMP_269"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_180(mapping(address => bool)) -> confirmations[transactionId]
REF_181(address) -> owners[i]
REF_182(bool) -> REF_180[REF_181]
CONDITION REF_182"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_270(bool) = count == required
CONDITION TMP_270"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_271(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
}
// Function: 38524.sol-MultiSigToken-notConfirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
confirmations[transactionId][owner]

IRs:
REF_220(mapping(address => bool)) -> confirmations[transactionId]
REF_221(bool) -> REF_220[owner]
CONDITION REF_221"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-notExecuted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].executed

IRs:
REF_222(MultiSig.Transaction) -> transactions[transactionId]
REF_223(bool) -> REF_222.executed
CONDITION REF_223"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_address == 0

IRs:
TMP_318(bool) = _address == 0
CONDITION TMP_318"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_326(bool) = msg.sender != owner
CONDITION TMP_326"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != address(this)

IRs:
TMP_313 = CONVERT this to address
TMP_314(bool) = msg.sender != TMP_313
CONDITION TMP_314"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 38524.sol-MultiSigToken-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isOwner[owner]

IRs:
REF_214(bool) -> isOwner[owner]
CONDITION REF_214"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isOwner[owner]

IRs:
REF_215(bool) -> isOwner[owner]
TMP_315 = UnaryType.BANG REF_215 
CONDITION TMP_315"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = false

IRs:
REF_161(bool) -> isOwner[owner]
REF_161(bool) (->isOwner) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_162 -> LENGTH owners
TMP_234(uint256) = REF_162 - 1
TMP_235(bool) = i < TMP_234
CONDITION TMP_235"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
owners[i] == owner

IRs:
REF_163(address) -> owners[i]
TMP_236(bool) = REF_163 == owner
CONDITION TMP_236"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_164(address) -> owners[i]
REF_165 -> LENGTH owners
TMP_237(uint256) = REF_165 - 1
REF_166(address) -> owners[TMP_237]
REF_164(address) (->owners) := REF_166(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_238(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
owners.length -= 1

IRs:
REF_167 -> LENGTH owners
REF_167(-> owners) = REF_167 - 1"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
changeRequirement(owners.length / 2 + 1)

IRs:
REF_168 -> LENGTH owners
TMP_239(uint256) = REF_168 / 2
TMP_240(uint256) = TMP_239 + 1
INTERNAL_CALL, MultiSig.changeRequirement(uint256)(TMP_240)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(owner)"];
15->1;
}
// Function: 38524.sol-MultiSigToken-replaceOwner(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_169 -> LENGTH owners
TMP_245(bool) = i < REF_169
CONDITION TMP_245"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
owners[i] == owner

IRs:
REF_170(address) -> owners[i]
TMP_246(bool) = REF_170 == owner
CONDITION TMP_246"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
owners[i] = newOwner

IRs:
REF_171(address) -> owners[i]
REF_171(address) (->owners) := newOwner(address)"];
6->7;
7[label="Node Type: BREAK 7
"];
7->2;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_247(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
isOwner[owner] = false

IRs:
REF_172(bool) -> isOwner[owner]
REF_172(bool) (->isOwner) := False(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isOwner[newOwner] = true

IRs:
REF_173(bool) -> isOwner[newOwner]
REF_173(bool) (->isOwner) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerAddition(newOwner)

IRs:
Emit OwnerAddition(newOwner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(owner)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerDoesNotExist(newOwner)

IRs:
MODIFIER_CALL, MultiSig.ownerDoesNotExist(address)(newOwner)"];
16->3;
}
// Function: 38524.sol-MultiSigToken-revokeConfirmation(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_177(mapping(address => bool)) -> confirmations[transactionId]
REF_178(bool) -> REF_177[msg.sender]
REF_178(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSig.confirmed(uint256,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSig.notExecuted(uint256)(transactionId)"];
5->1;
}
// Function: 38524.sol-MultiSigToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_OWNER_COUNT = 50

IRs:
MAX_OWNER_COUNT(uint256) := 50(uint256)"];
}
// Function: 38524.sol-MultiSigToken-submitTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data)

IRs:
TMP_256(uint256) = INTERNAL_CALL, MultiSig.addTransaction(address,uint256,bytes)(destination,value,data)
transactionId(uint256) := TMP_256(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSig.confirmTransaction(uint256)(transactionId)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 38524.sol-MultiSigToken-transactionExists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].destination == 0

IRs:
REF_216(MultiSig.Transaction) -> transactions[transactionId]
REF_217(address) -> REF_216.destination
TMP_316(bool) = REF_217 == 0
CONDITION TMP_316"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 38524.sol-MultiSigToken-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0

IRs:
TMP_319(bool) = ownerCount > MAX_OWNER_COUNT
TMP_320(bool) = _required > ownerCount
TMP_321(bool) = TMP_319 || TMP_320
TMP_322(bool) = _required == 0
TMP_323(bool) = TMP_321 || TMP_322
TMP_324(bool) = ownerCount == 0
TMP_325(bool) = TMP_323 || TMP_324
CONDITION TMP_325"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-MultiSig(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->12;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < _owners.length

IRs:
REF_70 -> LENGTH _owners
TMP_105(bool) = i < REF_70
CONDITION TMP_105"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
isOwner[_owners[i]] || _owners[i] == 0

IRs:
REF_71(address) -> _owners[i]
REF_72(bool) -> isOwner[REF_71]
REF_73(address) -> _owners[i]
TMP_106(bool) = REF_73 == 0
TMP_107(bool) = REF_72 || TMP_106
CONDITION TMP_107"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: THROW 6
"];
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
isOwner[_owners[i]] = true

IRs:
REF_74(address) -> _owners[i]
REF_75(bool) -> isOwner[REF_74]
REF_75(bool) (->isOwner) := True(bool)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_108(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
owners = _owners

IRs:
owners(address[]) := _owners(address[])"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
validRequirement(_owners.length,_required)

IRs:
REF_76 -> LENGTH _owners
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(REF_76,_required)"];
12->3;
}
// Function: 38524.sol-MultiSigWallet-MultiSigWallet(address[],uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
MultiSig(_owners,_required)

IRs:
INTERNAL_CALL, MultiSig.MultiSig(address[],uint256)(_owners,_required)"];
}
// Function: 38524.sol-MultiSigWallet-addOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = true

IRs:
REF_77(bool) -> isOwner[owner]
REF_77(bool) (->isOwner) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owners.push(owner)

IRs:
REF_79 -> LENGTH owners
TMP_111(uint256) := REF_79(uint256)
TMP_112(uint256) = TMP_111 + 1
REF_79(uint256) (->owners) := TMP_112(uint256)
REF_80(address) -> owners[TMP_111]
REF_80(address) (->owners) := owner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
changeRequirement(owners.length / 2 + 1)

IRs:
REF_81 -> LENGTH owners
TMP_113(uint256) = REF_81 / 2
TMP_114(uint256) = TMP_113 + 1
INTERNAL_CALL, MultiSig.changeRequirement(uint256)(TMP_114)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
OwnerAddition(owner)

IRs:
Emit OwnerAddition(owner)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ownerDoesNotExist(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerDoesNotExist(address)(owner)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
notNull(owner)

IRs:
MODIFIER_CALL, MultiSig.notNull(address)(owner)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
validRequirement(owners.length + 1,required)

IRs:
REF_82 -> LENGTH owners
TMP_120(uint256) = REF_82 + 1
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(TMP_120,required)"];
8->1;
}
// Function: 38524.sol-MultiSigWallet-addTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = transactionCount

IRs:
transactionId(uint256) := transactionCount(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId] = Transaction(destination,value,data,false)

IRs:
REF_105(MultiSig.Transaction) -> transactions[transactionId]
TMP_160(MultiSig.Transaction) = new Transaction(destination,value,data,False)
REF_105(MultiSig.Transaction) (->transactions) := TMP_160(MultiSig.Transaction)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
transactionCount += 1

IRs:
transactionCount(uint256) = transactionCount + 1"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Submission(transactionId)

IRs:
Emit Submission(transactionId)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notNull(destination)

IRs:
MODIFIER_CALL, MultiSig.notNull(address)(destination)"];
5->1;
6[label="Node Type: RETURN 6

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 38524.sol-MultiSigWallet-changeRequirement(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
required = _required

IRs:
required(uint256) := _required(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
RequirementChange(_required)

IRs:
Emit RequirementChange(_required)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
validRequirement(owners.length,_required)

IRs:
REF_96 -> LENGTH owners
MODIFIER_CALL, MultiSig.validRequirement(uint256,uint256)(REF_96,_required)"];
4->1;
}
// Function: 38524.sol-MultiSigWallet-confirmTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = true

IRs:
REF_97(mapping(address => bool)) -> confirmations[transactionId]
REF_98(bool) -> REF_97[msg.sender]
REF_98(bool) (->confirmations) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Confirmation(msg.sender,transactionId)

IRs:
Emit Confirmation(msg.sender,transactionId)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
executeTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSigWallet.executeTransaction(uint256)(transactionId)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
transactionExists(transactionId)

IRs:
MODIFIER_CALL, MultiSig.transactionExists(uint256)(transactionId)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
notConfirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSig.notConfirmed(uint256,address)(transactionId,msg.sender)"];
6->1;
}
// Function: 38524.sol-MultiSigWallet-confirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! confirmations[transactionId][owner]

IRs:
REF_142(mapping(address => bool)) -> confirmations[transactionId]
REF_143(bool) -> REF_142[owner]
TMP_207 = UnaryType.BANG REF_143 
CONDITION TMP_207"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-executeTransaction(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->10;
1[label="Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_197(bool) = INTERNAL_CALL, MultiSig.isConfirmed(uint256)(transactionId)
CONDITION TMP_197"];
1->2[label="True"];
1->9[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tx = transactions[transactionId]

IRs:
REF_130(MultiSig.Transaction) -> transactions[transactionId]
tx(MultiSig.Transaction) := REF_130(MultiSig.Transaction)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
tx.destination.call.value(tx.value)(tx.data)

IRs:
REF_131(address) -> tx.destination
REF_134(uint256) -> tx.value
REF_135(bytes) -> tx.data
TMP_199(bool) = LOW_LEVEL_CALL, dest:REF_131, function:call, arguments:['REF_135'] value:REF_134 
CONDITION TMP_199"];
3->4[label="True"];
3->6[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tx.executed = true

IRs:
REF_136(bool) -> tx.executed
REF_136(bool) (->tx) := True(bool)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)"];
5->8;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
tx.executed = false

IRs:
REF_137(bool) -> tx.executed
REF_137(bool) (->tx) := False(bool)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSig.notExecuted(uint256)(transactionId)"];
10->1;
}
// Function: 38524.sol-MultiSigWallet-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_195(bool) = msg.value > 0
CONDITION TMP_195"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)"];
2->3;
3[label="Node Type: END_IF 3
"];
}
// Function: 38524.sol-MultiSigWallet-getConfirmationCount(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_106 -> LENGTH owners
TMP_163(bool) = i < REF_106
CONDITION TMP_163"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_107(mapping(address => bool)) -> confirmations[transactionId]
REF_108(address) -> owners[i]
REF_109(bool) -> REF_107[REF_108]
CONDITION REF_109"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_164(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 38524.sol-MultiSigWallet-getConfirmations(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
confirmationsTemp = new address[](owners.length)

IRs:
REF_114 -> LENGTH owners
TMP_172(address[])  = new address[](REF_114)
confirmationsTemp(address[]) = ['TMP_172(address[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < owners.length

IRs:
REF_115 -> LENGTH owners
TMP_173(bool) = i < REF_115
CONDITION TMP_173"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_116(mapping(address => bool)) -> confirmations[transactionId]
REF_117(address) -> owners[i]
REF_118(bool) -> REF_116[REF_117]
CONDITION REF_118"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
confirmationsTemp[count] = owners[i]

IRs:
REF_119(address) -> confirmationsTemp[count]
REF_120(address) -> owners[i]
REF_119(address) (->confirmationsTemp) := REF_120(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_174(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_confirmations = new address[](count)

IRs:
TMP_176(address[])  = new address[](count)
_confirmations(address[]) = ['TMP_176(address[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < count

IRs:
TMP_177(bool) = i < count
CONDITION TMP_177"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_confirmations[i] = confirmationsTemp[i]

IRs:
REF_121(address) -> _confirmations[i]
REF_122(address) -> confirmationsTemp[i]
REF_121(address) (->_confirmations) := REF_122(address)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_178(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_confirmations

IRs:
RETURN _confirmations"];
}
// Function: 38524.sol-MultiSigWallet-getOwners()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
owners

IRs:
RETURN owners"];
}
// Function: 38524.sol-MultiSigWallet-getTransactionCount(bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->9;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < transactionCount

IRs:
TMP_165(bool) = i < transactionCount
CONDITION TMP_165"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_110(MultiSig.Transaction) -> transactions[i]
REF_111(bool) -> REF_110.executed
TMP_166 = UnaryType.BANG REF_111 
TMP_167(bool) = pending && TMP_166
REF_112(MultiSig.Transaction) -> transactions[i]
REF_113(bool) -> REF_112.executed
TMP_168(bool) = executed && REF_113
TMP_169(bool) = TMP_167 || TMP_168
CONDITION TMP_169"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_170(uint256) := i(uint256)
i(uint256) = i + 1"];
8->4;
9[label="Node Type: RETURN 9

EXPRESSION:
count

IRs:
RETURN count"];
}
// Function: 38524.sol-MultiSigWallet-getTransactionIds(uint256,uint256,bool,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
transactionIdsTemp = new uint256[](transactionCount)

IRs:
TMP_180(uint256[])  = new uint256[](transactionCount)
transactionIdsTemp(uint256[]) = ['TMP_180(uint256[])']"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->13;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i < transactionCount

IRs:
TMP_181(bool) = i < transactionCount
CONDITION TMP_181"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: IF 8

EXPRESSION:
pending && ! transactions[i].executed || executed && transactions[i].executed

IRs:
REF_123(MultiSig.Transaction) -> transactions[i]
REF_124(bool) -> REF_123.executed
TMP_182 = UnaryType.BANG REF_124 
TMP_183(bool) = pending && TMP_182
REF_125(MultiSig.Transaction) -> transactions[i]
REF_126(bool) -> REF_125.executed
TMP_184(bool) = executed && REF_126
TMP_185(bool) = TMP_183 || TMP_184
CONDITION TMP_185"];
8->9[label="True"];
8->11[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
transactionIdsTemp[count] = i

IRs:
REF_127(uint256) -> transactionIdsTemp[count]
REF_127(uint256) (->transactionIdsTemp) := i(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_186(uint256) := i(uint256)
i(uint256) = i + 1"];
12->7;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_transactionIds = new uint256[](to - from)

IRs:
TMP_188(uint256) = to - from
TMP_189(uint256[])  = new uint256[](TMP_188)
_transactionIds(uint256[]) = ['TMP_189(uint256[])']"];
13->16;
14[label="Node Type: BEGIN_LOOP 14
"];
14->17;
15[label="Node Type: END_LOOP 15
"];
15->20;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
i = from

IRs:
i(uint256) := from(uint256)"];
16->14;
17[label="Node Type: IF_LOOP 17

EXPRESSION:
i < to

IRs:
TMP_190(bool) = i < to
CONDITION TMP_190"];
17->18[label="True"];
17->15[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
_transactionIds[i - from] = transactionIdsTemp[i]

IRs:
TMP_191(uint256) = i - from
REF_128(uint256) -> _transactionIds[TMP_191]
REF_129(uint256) -> transactionIdsTemp[i]
REF_128(uint256) (->_transactionIds) := REF_129(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_192(uint256) := i(uint256)
i(uint256) = i + 1"];
19->17;
20[label="Node Type: RETURN 20

EXPRESSION:
_transactionIds

IRs:
RETURN _transactionIds"];
}
// Function: 38524.sol-MultiSigWallet-isConfirmed(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
count = 0

IRs:
count(uint256) := 0(uint256)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length

IRs:
REF_101 -> LENGTH owners
TMP_157(bool) = i < REF_101
CONDITION TMP_157"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
confirmations[transactionId][owners[i]]

IRs:
REF_102(mapping(address => bool)) -> confirmations[transactionId]
REF_103(address) -> owners[i]
REF_104(bool) -> REF_102[REF_103]
CONDITION REF_104"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
count += 1

IRs:
count(uint256) = count + 1"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
count == required

IRs:
TMP_158(bool) = count == required
CONDITION TMP_158"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_159(uint256) := i(uint256)
i(uint256) = i + 1"];
12->5;
}
// Function: 38524.sol-MultiSigWallet-notConfirmed(uint256,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
confirmations[transactionId][owner]

IRs:
REF_144(mapping(address => bool)) -> confirmations[transactionId]
REF_145(bool) -> REF_144[owner]
CONDITION REF_145"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-notExecuted(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].executed

IRs:
REF_146(MultiSig.Transaction) -> transactions[transactionId]
REF_147(bool) -> REF_146.executed
CONDITION REF_147"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-notNull(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
_address == 0

IRs:
TMP_208(bool) = _address == 0
CONDITION TMP_208"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_216(bool) = msg.sender != owner
CONDITION TMP_216"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-onlyWallet()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != address(this)

IRs:
TMP_203 = CONVERT this to address
TMP_204(bool) = msg.sender != TMP_203
CONDITION TMP_204"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 38524.sol-MultiSigWallet-ownerDoesNotExist(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
isOwner[owner]

IRs:
REF_138(bool) -> isOwner[owner]
CONDITION REF_138"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-ownerExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! isOwner[owner]

IRs:
REF_139(bool) -> isOwner[owner]
TMP_205 = UnaryType.BANG REF_139 
CONDITION TMP_205"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-removeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
isOwner[owner] = false

IRs:
REF_83(bool) -> isOwner[owner]
REF_83(bool) (->isOwner) := False(bool)"];
1->4;
2[label="Node Type: BEGIN_LOOP 2
"];
2->5;
3[label="Node Type: END_LOOP 3
"];
3->11;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
4->2;
5[label="Node Type: IF_LOOP 5

EXPRESSION:
i < owners.length - 1

IRs:
REF_84 -> LENGTH owners
TMP_122(uint256) = REF_84 - 1
TMP_123(bool) = i < TMP_122
CONDITION TMP_123"];
5->6[label="True"];
5->3[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
owners[i] == owner

IRs:
REF_85(address) -> owners[i]
TMP_124(bool) = REF_85 == owner
CONDITION TMP_124"];
6->7[label="True"];
6->9[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
owners[i] = owners[owners.length - 1]

IRs:
REF_86(address) -> owners[i]
REF_87 -> LENGTH owners
TMP_125(uint256) = REF_87 - 1
REF_88(address) -> owners[TMP_125]
REF_86(address) (->owners) := REF_88(address)"];
7->8;
8[label="Node Type: BREAK 8
"];
8->3;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_126(uint256) := i(uint256)
i(uint256) = i + 1"];
10->5;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
owners.length -= 1

IRs:
REF_89 -> LENGTH owners
REF_89(-> owners) = REF_89 - 1"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
changeRequirement(owners.length / 2 + 1)

IRs:
REF_90 -> LENGTH owners
TMP_127(uint256) = REF_90 / 2
TMP_128(uint256) = TMP_127 + 1
INTERNAL_CALL, MultiSig.changeRequirement(uint256)(TMP_128)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(owner)"];
15->1;
}
// Function: 38524.sol-MultiSigWallet-replaceOwner(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->14;
1[label="Node Type: BEGIN_LOOP 1
"];
1->4;
2[label="Node Type: END_LOOP 2
"];
2->10;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
3->1;
4[label="Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_91 -> LENGTH owners
TMP_133(bool) = i < REF_91
CONDITION TMP_133"];
4->5[label="True"];
4->2[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
owners[i] == owner

IRs:
REF_92(address) -> owners[i]
TMP_134(bool) = REF_92 == owner
CONDITION TMP_134"];
5->6[label="True"];
5->8[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
owners[i] = newOwner

IRs:
REF_93(address) -> owners[i]
REF_93(address) (->owners) := newOwner(address)"];
6->7;
7[label="Node Type: BREAK 7
"];
7->2;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_135(uint256) := i(uint256)
i(uint256) = i + 1"];
9->4;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
isOwner[owner] = false

IRs:
REF_94(bool) -> isOwner[owner]
REF_94(bool) (->isOwner) := False(bool)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
isOwner[newOwner] = true

IRs:
REF_95(bool) -> isOwner[newOwner]
REF_95(bool) (->isOwner) := True(bool)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
OwnerRemoval(owner)

IRs:
Emit OwnerRemoval(owner)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
OwnerAddition(newOwner)

IRs:
Emit OwnerAddition(newOwner)"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSig.onlyWallet()()"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
ownerExists(owner)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(owner)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
ownerDoesNotExist(newOwner)

IRs:
MODIFIER_CALL, MultiSig.ownerDoesNotExist(address)(newOwner)"];
16->3;
}
// Function: 38524.sol-MultiSigWallet-revokeConfirmation(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
confirmations[transactionId][msg.sender] = false

IRs:
REF_99(mapping(address => bool)) -> confirmations[transactionId]
REF_100(bool) -> REF_99[msg.sender]
REF_100(bool) (->confirmations) := False(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Revocation(msg.sender,transactionId)

IRs:
Emit Revocation(msg.sender,transactionId)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSig.confirmed(uint256,address)(transactionId,msg.sender)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSig.notExecuted(uint256)(transactionId)"];
5->1;
}
// Function: 38524.sol-MultiSigWallet-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
MAX_OWNER_COUNT = 50

IRs:
MAX_OWNER_COUNT(uint256) := 50(uint256)"];
}
// Function: 38524.sol-MultiSigWallet-submitTransaction(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transactionId = addTransaction(destination,value,data)

IRs:
TMP_144(uint256) = INTERNAL_CALL, MultiSig.addTransaction(address,uint256,bytes)(destination,value,data)
transactionId(uint256) := TMP_144(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
confirmTransaction(transactionId)

IRs:
INTERNAL_CALL, MultiSig.confirmTransaction(uint256)(transactionId)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSig.ownerExists(address)(msg.sender)"];
3->1;
4[label="Node Type: RETURN 4

EXPRESSION:
transactionId

IRs:
RETURN transactionId"];
}
// Function: 38524.sol-MultiSigWallet-transactionExists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
transactions[transactionId].destination == 0

IRs:
REF_140(MultiSig.Transaction) -> transactions[transactionId]
REF_141(address) -> REF_140.destination
TMP_206(bool) = REF_141 == 0
CONDITION TMP_206"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-MultiSigWallet-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 38524.sol-MultiSigWallet-validRequirement(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0

IRs:
TMP_209(bool) = ownerCount > MAX_OWNER_COUNT
TMP_210(bool) = _required > ownerCount
TMP_211(bool) = TMP_209 || TMP_210
TMP_212(bool) = _required == 0
TMP_213(bool) = TMP_211 || TMP_212
TMP_214(bool) = ownerCount == 0
TMP_215(bool) = TMP_213 || TMP_214
CONDITION TMP_215"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-owned-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_1(bool) = msg.sender != owner
CONDITION TMP_1"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: _ 4
"];
}
// Function: 38524.sol-owned-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
}
// Function: 38524.sol-owned-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()"];
2->1;
}
// Function: 38524.sol-token-transfer(address,uint256)
digraph{
}
}
