digraph G {
// Function: 39413.sol-E4RowRewards-checkDividends(address)
digraph{
}
// Function: 39413.sol-E4RowRewards-withdrawDividends()
digraph{
}
// Function: 39413.sol-E4Token-E4Token()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developers = msg.sender

IRs:
developers(address) := msg.sender(address)"];
}
// Function: 39413.sol-E4Token-addAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
holderAccounts[_addr].alloced = true

IRs:
REF_13(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_14(bool) -> REF_13.alloced
REF_14(bool) (->holderAccounts) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
holderAccounts[_addr].tokens = (curPayoutId * (2 ** 48))

IRs:
REF_15(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_16(uint256) -> REF_15.tokens
TMP_22(uint256) = 2 ** 48
TMP_23(uint256) = curPayoutId * TMP_22
REF_16(uint256) (->holderAccounts) := TMP_23(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
holderIndexes[numAccounts ++] = _addr

IRs:
TMP_24(uint256) := numAccounts(uint256)
numAccounts(uint256) = numAccounts + 1
REF_17(address) -> holderIndexes[TMP_24]
REF_17(address) (->holderIndexes) := _addr(address)"];
}
// Function: 39413.sol-E4Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_52(mapping(address => uint256)) -> allowed[_owner]
REF_53(uint256) -> REF_52[_spender]
RETURN REF_53"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 39413.sol-E4Token-applySettings(E4Token.SettingStateValue,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_0(bool) = msg.sender != owner
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payoutThreshold = _threshold

IRs:
payoutThreshold(uint256) := _threshold(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
maxPaysPer = _mpp

IRs:
maxPaysPer(uint256) := _mpp(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
minPayInterval = _mpi

IRs:
minPayInterval(uint256) := _mpi(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
settingsState == SettingStateValue.lockedRelease

IRs:
REF_0(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_1(bool) = settingsState == REF_0
CONDITION TMP_1"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8
"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
settingsState = qState

IRs:
settingsState(E4Token.SettingStateValue) := qState(E4Token.SettingStateValue)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
qState == SettingStateValue.lockedRelease

IRs:
REF_1(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_2(bool) = qState == REF_1
CONDITION TMP_2"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
StatEvent(Locking!)

IRs:
Emit StatEvent(Locking!)"];
12->13;
13[label="Node Type: RETURN 13
"];
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
icoStatus = IcoStatusValue.anouncement

IRs:
REF_2(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
icoStatus(E4Token.IcoStatusValue) := REF_2(E4Token.IcoStatusValue)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
rmGas = 100000

IRs:
rmGas(uint256) := 100000(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
rwGas = 10000

IRs:
rwGas(uint256) := 10000(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
rfGas = 10000

IRs:
rfGas(uint256) := 10000(uint256)"];
18->19;
19[label="Node Type: IF 19

EXPRESSION:
totalTokensMinted > 0

IRs:
TMP_4(bool) = totalTokensMinted > 0
CONDITION TMP_4"];
19->22[label="True"];
19->30[label="False"];
20[label="Node Type: BEGIN_LOOP 20
"];
20->23;
21[label="Node Type: END_LOOP 21
"];
21->30;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
22->20;
23[label="Node Type: IF_LOOP 23

EXPRESSION:
i < numAccounts

IRs:
TMP_5(bool) = i < numAccounts
CONDITION TMP_5"];
23->24[label="True"];
23->21[label="False"];
24[label="Node Type: NEW VARIABLE 24

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_3(address) -> holderIndexes[i]
a(address) := REF_3(address)"];
24->25;
25[label="Node Type: IF 25

EXPRESSION:
a != address(0)

IRs:
TMP_6 = CONVERT 0 to address
TMP_7(bool) = a != TMP_6
CONDITION TMP_7"];
25->26[label="True"];
25->28[label="False"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
holderAccounts[a].tokens = 0

IRs:
REF_4(E4Token.tokenAccount) -> holderAccounts[a]
REF_5(uint256) -> REF_4.tokens
REF_5(uint256) (->holderAccounts) := 0(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
holderAccounts[a].balance = 0

IRs:
REF_6(E4Token.tokenAccount) -> holderAccounts[a]
REF_7(uint256) -> REF_6.balance
REF_7(uint256) (->holderAccounts) := 0(uint256)"];
27->28;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
i ++

IRs:
TMP_8(uint256) := i(uint256)
i(uint256) = i + 1"];
29->23;
30[label="Node Type: END_IF 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
totalTokensMinted = 0

IRs:
totalTokensMinted(uint256) := 0(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
totalTokenFundsReceived = 0

IRs:
totalTokenFundsReceived(uint256) := 0(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
partnerCredits = 0

IRs:
partnerCredits(uint256) := 0(uint256)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
fundingStart = _saleStart

IRs:
fundingStart(uint256) := _saleStart(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
fundingDeadline = _saleEnd

IRs:
fundingDeadline(uint256) := _saleEnd(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
usageDeadline = _usageEnd

IRs:
usageDeadline(uint256) := _usageEnd(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
minUsageGoal = _minUsage

IRs:
minUsageGoal(uint256) := _minUsage(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
minIcoTokenGoal = _tokGoal

IRs:
minIcoTokenGoal(uint256) := _tokGoal(uint256)"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
maxMintableTokens = _maxMintable

IRs:
maxMintableTokens(uint256) := _maxMintable(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
tokenPrice = _price

IRs:
tokenPrice(uint256) := _price(uint256)"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
vestTime = fundingStart + (31536000)

IRs:
TMP_9(uint256) = fundingStart + 31536000
vestTime(uint256) := TMP_9(uint256)"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
numDevTokens = 0

IRs:
numDevTokens(uint256) := 0(uint256)"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
remunerationStage = 0

IRs:
remunerationStage(uint256) := 0(uint256)"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
developersGranted = false

IRs:
developersGranted(bool) := False(bool)"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
lastPayoutTime = 0

IRs:
lastPayoutTime(uint256) := 0(uint256)"];
51->52;
52[label="Node Type: IF 52

EXPRESSION:
this.balance > 0

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_10(bool) = REF_8 > 0
CONDITION TMP_10"];
52->53[label="True"];
52->56[label="False"];
53[label="Node Type: IF 53

EXPRESSION:
! owner.call.gas(rfGas).value(this.balance)()

IRs:
REF_12(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_13(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:[] value:REF_12 gas:rfGas
TMP_14 = UnaryType.BANG TMP_13 
CONDITION TMP_14"];
53->54[label="True"];
53->55[label="False"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
StatEvent(ERROR!)

IRs:
Emit StatEvent(ERROR!)"];
54->55;
55[label="Node Type: END_IF 55
"];
55->56;
56[label="Node Type: END_IF 56
"];
56->57;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
StatEvent(ok)

IRs:
Emit StatEvent(ok)"];
}
// Function: 39413.sol-E4Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_50(mapping(address => uint256)) -> allowed[msg.sender]
REF_51(uint256) -> REF_50[_spender]
REF_51(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39413.sol-E4Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_owner].alloced

IRs:
REF_46(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_47(bool) -> REF_46.alloced
CONDITION REF_47"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance = getHeld(holderAccounts[_owner].tokens)

IRs:
REF_48(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_49(uint256) -> REF_48.tokens
TMP_60(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_49)
balance(uint256) := TMP_60(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 39413.sol-E4Token-changeAuxPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_248(bool) = msg.sender != owner
REF_126(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_249(bool) = settingsState == REF_126
TMP_250(bool) = TMP_248 || TMP_249
CONDITION TMP_250"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
auxPartner = _aux

IRs:
auxPartner(address) := _aux(address)"];
}
// Function: 39413.sol-E4Token-changeDevevoperAccont(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_242(bool) = msg.sender != owner
REF_124(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_243(bool) = settingsState == REF_124
TMP_244(bool) = TMP_242 || TMP_243
CONDITION TMP_244"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
developers = _addr

IRs:
developers(address) := _addr(address)"];
}
// Function: 39413.sol-E4Token-changeFounder(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_245(bool) = msg.sender != owner
REF_125(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_246(bool) = settingsState == REF_125
TMP_247(bool) = TMP_245 || TMP_246
CONDITION TMP_247"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
founderOrg = _addr

IRs:
founderOrg(address) := _addr(address)"];
}
// Function: 39413.sol-E4Token-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_239(bool) = msg.sender != owner
REF_123(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_240(bool) = settingsState == REF_123
TMP_241(bool) = TMP_239 || TMP_240
CONDITION TMP_241"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
owner = _addr

IRs:
owner(address) := _addr(address)"];
}
// Function: 39413.sol-E4Token-checkDividends(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_addr].alloced

IRs:
REF_111(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_112(bool) -> REF_111.alloced
CONDITION REF_112"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_amount = holderAccounts[_addr].balance

IRs:
REF_113(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_114(uint256) -> REF_113.balance
_amount(uint256) := REF_114(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39413.sol-E4Token-doDeveloperGrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! developersGranted

IRs:
TMP_265 = UnaryType.BANG developersGranted 
CONDITION TMP_265"];
1->2[label="True"];
1->10[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developersGranted = true

IRs:
developersGranted(bool) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
numDevTokens = (totalTokensMinted * 15) / 100

IRs:
TMP_266(uint256) = totalTokensMinted * 15
TMP_267(uint256) = TMP_266 / 100
numDevTokens(uint256) := TMP_267(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalTokensMinted += numDevTokens

IRs:
totalTokensMinted(uint256) = totalTokensMinted + numDevTokens"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_128(E4Token.tokenAccount) -> holderAccounts[developers]
REF_129(bool) -> REF_128.alloced
TMP_268 = UnaryType.BANG REF_129 
CONDITION TMP_268"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens

IRs:
REF_130(E4Token.tokenAccount) -> holderAccounts[developers]
REF_131(uint256) -> REF_130.tokens
TMP_270(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_131)
TMP_271(uint256) = TMP_270 + numDevTokens
newHeld(uint256) := TMP_271(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
holderAccounts[developers].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_132(E4Token.tokenAccount) -> holderAccounts[developers]
REF_133(uint256) -> REF_132.tokens
TMP_272(uint256) = 2 ** 48
TMP_273(uint256) = curPayoutId * TMP_272
TMP_274(uint256) = newHeld | TMP_273
REF_133(uint256) (->holderAccounts) := TMP_274(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 39413.sol-E4Token-doPayout(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
totalTokensMinted == 0

IRs:
TMP_155(bool) = totalTokensMinted == 0
CONDITION TMP_155"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
(holdoverBalance > 0) && (payoutBalance == 0) && (now > (lastPayoutTime + minPayInterval))

IRs:
TMP_156(bool) = holdoverBalance > 0
TMP_157(bool) = payoutBalance == 0
TMP_158(bool) = TMP_156 && TMP_157
TMP_159(uint256) = lastPayoutTime + minPayInterval
TMP_160(bool) = now > TMP_159
TMP_161(bool) = TMP_158 && TMP_160
CONDITION TMP_161"];
4->5[label="True"];
4->16[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
curPayoutId ++

IRs:
TMP_162(uint256) := curPayoutId(uint256)
curPayoutId(uint256) = curPayoutId + 1"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
curPayoutId >= 32768

IRs:
TMP_163(bool) = curPayoutId >= 32768
CONDITION TMP_163"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
lastPayoutTime = now

IRs:
lastPayoutTime(uint256) := now(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
payoutBalance = int256(holdoverBalance)

IRs:
TMP_164 = CONVERT holdoverBalance to int256
payoutBalance(int256) := TMP_164(int256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
prOrigPayoutBal = payoutBalance

IRs:
prOrigPayoutBal(int256) := payoutBalance(int256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
prOrigTokensMint = totalTokensMinted

IRs:
prOrigTokensMint(uint256) := totalTokensMinted(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
StatEventI(StartRun,uint256(curPayoutId))

IRs:
TMP_165 = CONVERT curPayoutId to uint256
Emit StatEventI(StartRun,TMP_165)"];
15->53;
16[label="Node Type: IF 16

EXPRESSION:
payoutBalance > 0

IRs:
TMP_167(bool) = payoutBalance > 0
CONDITION TMP_167"];
16->17[label="True"];
16->52[label="False"];
17[label="Node Type: NEW VARIABLE 17
"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
nPerTokDistrib = uint256(prOrigPayoutBal) / prOrigTokensMint

IRs:
TMP_168 = CONVERT prOrigPayoutBal to uint256
TMP_169(uint256) = TMP_168 / prOrigTokensMint
nPerTokDistrib(uint256) := TMP_169(uint256)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
paids = 0

IRs:
paids(uint256) := 0(uint256)"];
19->20;
20[label="Node Type: NEW VARIABLE 20
"];
20->23;
21[label="Node Type: BEGIN_LOOP 21
"];
21->24;
22[label="Node Type: END_LOOP 22
"];
22->42;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
i = lastPayoutIndex

IRs:
i(uint256) := lastPayoutIndex(uint256)"];
23->21;
24[label="Node Type: IF_LOOP 24

EXPRESSION:
(paids < _numPays) && (i < numAccounts) && (payoutBalance > 0)

IRs:
TMP_170(bool) = paids < _numPays
TMP_171(bool) = i < numAccounts
TMP_172(bool) = TMP_170 && TMP_171
TMP_173(bool) = payoutBalance > 0
TMP_174(bool) = TMP_172 && TMP_173
CONDITION TMP_174"];
24->25[label="True"];
24->22[label="False"];
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_95(address) -> holderIndexes[i]
a(address) := REF_95(address)"];
25->26;
26[label="Node Type: IF 26

EXPRESSION:
a == address(0)

IRs:
TMP_175 = CONVERT 0 to address
TMP_176(bool) = a == TMP_175
CONDITION TMP_176"];
26->27[label="True"];
26->28[label="False"];
27[label="Node Type: CONTINUE 27
"];
27->41;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: NEW VARIABLE 29
"];
29->30;
30[label="Node Type: NEW VARIABLE 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
(pid,held) = getPayIdAndHeld(holderAccounts[a].tokens)

IRs:
REF_96(E4Token.tokenAccount) -> holderAccounts[a]
REF_97(uint256) -> REF_96.tokens
TUPLE_2(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_97)
pid(uint256)= UNPACK TUPLE_2 index: 0 
held(uint256)= UNPACK TUPLE_2 index: 1 "];
31->32;
32[label="Node Type: IF 32

EXPRESSION:
(held > 0) && (pid != curPayoutId)

IRs:
TMP_177(bool) = held > 0
TMP_178(bool) = pid != curPayoutId
TMP_179(bool) = TMP_177 && TMP_178
CONDITION TMP_179"];
32->33[label="True"];
32->40[label="False"];
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nAmount = nPerTokDistrib * held

IRs:
TMP_180(uint256) = nPerTokDistrib * held
nAmount(uint256) := TMP_180(uint256)"];
33->34;
34[label="Node Type: IF 34

EXPRESSION:
int256(nAmount) <= payoutBalance

IRs:
TMP_181 = CONVERT nAmount to int256
TMP_182(bool) = TMP_181 <= payoutBalance
CONDITION TMP_182"];
34->35[label="True"];
34->39[label="False"];
35[label="Node Type: EXPRESSION 35

EXPRESSION:
holderAccounts[a].balance += nAmount

IRs:
REF_98(E4Token.tokenAccount) -> holderAccounts[a]
REF_99(uint256) -> REF_98.balance
REF_99(-> holderAccounts) = REF_99 + nAmount"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
holderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held

IRs:
REF_100(E4Token.tokenAccount) -> holderAccounts[a]
REF_101(uint256) -> REF_100.tokens
TMP_183(uint256) = 2 ** 48
TMP_184(uint256) = curPayoutId * TMP_183
TMP_185(uint256) = TMP_184 | held
REF_101(uint256) (->holderAccounts) := TMP_185(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
payoutBalance -= int256(nAmount)

IRs:
TMP_186 = CONVERT nAmount to int256
payoutBalance(int256) = payoutBalance - TMP_186"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
paids ++

IRs:
TMP_187(uint256) := paids(uint256)
paids(uint256) = paids + 1"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: END_IF 40
"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
i ++

IRs:
TMP_188(uint256) := i(uint256)
i(uint256) = i + 1"];
41->24;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
lastPayoutIndex = i

IRs:
lastPayoutIndex(uint256) := i(uint256)"];
42->43;
43[label="Node Type: IF 43

EXPRESSION:
lastPayoutIndex >= numAccounts || payoutBalance <= 0

IRs:
TMP_189(bool) = lastPayoutIndex >= numAccounts
TMP_190(bool) = payoutBalance <= 0
TMP_191(bool) = TMP_189 || TMP_190
CONDITION TMP_191"];
43->44[label="True"];
43->50[label="False"];
44[label="Node Type: EXPRESSION 44

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
44->45;
45[label="Node Type: IF 45

EXPRESSION:
payoutBalance > 0

IRs:
TMP_192(bool) = payoutBalance > 0
CONDITION TMP_192"];
45->46[label="True"];
45->47[label="False"];
46[label="Node Type: EXPRESSION 46

EXPRESSION:
holdoverBalance += uint256(payoutBalance)

IRs:
TMP_193 = CONVERT payoutBalance to uint256
holdoverBalance(uint256) = holdoverBalance + TMP_193"];
46->47;
47[label="Node Type: END_IF 47
"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
StatEventI(RunComplete,uint256(prOrigPayoutBal))

IRs:
TMP_194 = CONVERT prOrigPayoutBal to uint256
Emit StatEventI(RunComplete,TMP_194)"];
49->51;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
StatEventI(PayRun,paids)

IRs:
Emit StatEventI(PayRun,paids)"];
50->51;
51[label="Node Type: END_IF 51
"];
51->52;
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: END_IF 53
"];
}
// Function: 39413.sol-E4Token-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == e4_partner

IRs:
TMP_62(bool) = msg.sender == e4_partner
CONDITION TMP_62"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feePayment()

IRs:
INTERNAL_CALL, E4Token.feePayment()()"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
purchaseToken()

IRs:
INTERNAL_CALL, E4Token.purchaseToken()()"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 39413.sol-E4Token-feePayment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != e4_partner

IRs:
TMP_82(bool) = msg.sender != e4_partner
CONDITION TMP_82"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(forbidden)

IRs:
Emit StatEvent(forbidden)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
nfvalue = msg.value

IRs:
nfvalue(uint256) := msg.value(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
holdoverBalance += nfvalue

IRs:
holdoverBalance(uint256) = holdoverBalance + nfvalue"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
partnerCredits += nfvalue

IRs:
partnerCredits(uint256) = partnerCredits + nfvalue"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
StatEventI(Payment,nfvalue)

IRs:
Emit StatEventI(Payment,nfvalue)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
holdoverBalance > payoutThreshold || payoutBalance > 0

IRs:
TMP_86(bool) = holdoverBalance > payoutThreshold
TMP_87(bool) = payoutBalance > 0
TMP_88(bool) = TMP_86 || TMP_87
CONDITION TMP_88"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
doPayout(maxPaysPer)

IRs:
INTERNAL_CALL, E4Token.doPayout(uint256)(maxPaysPer)"];
11->12;
12[label="Node Type: END_IF 12
"];
}
// Function: 39413.sol-E4Token-flushDividends(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(_numPays == 0) || (_numPays > 1000)

IRs:
TMP_256(bool) = _numPays == 0
TMP_257(bool) = _numPays > 1000
TMP_258(bool) = TMP_256 || TMP_257
CONDITION TMP_258"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(Invalid.)

IRs:
Emit StatEvent(Invalid.)"];
2->7;
3[label="Node Type: IF 3

EXPRESSION:
holdoverBalance > 0 || payoutBalance > 0

IRs:
TMP_260(bool) = holdoverBalance > 0
TMP_261(bool) = payoutBalance > 0
TMP_262(bool) = TMP_260 || TMP_261
CONDITION TMP_262"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
doPayout(_numPays)

IRs:
INTERNAL_CALL, E4Token.doPayout(uint256)(_numPays)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(Nothing to do.)

IRs:
Emit StatEvent(Nothing to do.)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 39413.sol-E4Token-getHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_21(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_21(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_held

IRs:
RETURN _held"];
}
// Function: 39413.sol-E4Token-getIcoInfo()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_status = icoStatus

IRs:
_status(E4Token.IcoStatusValue) := icoStatus(E4Token.IcoStatusValue)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_saleStart = fundingStart

IRs:
_saleStart(uint256) := fundingStart(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_saleEnd = fundingDeadline

IRs:
_saleEnd(uint256) := fundingDeadline(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_usageEnd = usageDeadline

IRs:
_usageEnd(uint256) := usageDeadline(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_vest = vestTime

IRs:
_vest(uint256) := vestTime(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_saleGoal = minIcoTokenGoal

IRs:
_saleGoal(uint256) := minIcoTokenGoal(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_usageGoal = minUsageGoal

IRs:
_usageGoal(uint256) := minUsageGoal(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_sold = getNumTokensPurchased()

IRs:
TMP_254(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
_sold(uint256) := TMP_254(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_used = getNumGames()

IRs:
TMP_255(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
_used(uint256) := TMP_255(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_funds = totalTokenFundsReceived

IRs:
_funds(uint256) := totalTokenFundsReceived(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_credits = partnerCredits

IRs:
_credits(uint256) := partnerCredits(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_remuStage = remunerationStage

IRs:
_remuStage(uint256) := remunerationStage(uint256)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
(_status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest)

IRs:
RETURN _status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest"];
}
// Function: 39413.sol-E4Token-getNumGames()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
e4_partner != address(0)

IRs:
TMP_97 = CONVERT 0 to address
TMP_98(bool) = e4_partner != TMP_97
CONDITION TMP_98"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
pe4 = iE4RowEscrow(e4_partner)

IRs:
TMP_99 = CONVERT e4_partner to iE4RowEscrow
pe4(iE4RowEscrow) := TMP_99(iE4RowEscrow)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_games = uint256(pe4.getNumGamesStarted())

IRs:
TMP_100(int256) = HIGH_LEVEL_CALL, dest:pe4(iE4RowEscrow), function:getNumGamesStarted, arguments:[]  
TMP_101 = CONVERT TMP_100 to uint256
_games(uint256) := TMP_101(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_games

IRs:
RETURN _games"];
}
// Function: 39413.sol-E4Token-getNumTokensPurchased()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_purchased = totalTokensMinted - numDevTokens

IRs:
TMP_96(uint256) = totalTokensMinted - numDevTokens
_purchased(uint256) := TMP_96(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_purchased

IRs:
RETURN _purchased"];
}
// Function: 39413.sol-E4Token-getOpGas()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_rm = rmGas

IRs:
_rm(uint256) := rmGas(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_rf = rfGas

IRs:
_rf(uint256) := rfGas(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_rw = rwGas

IRs:
_rw(uint256) := rwGas(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(_rm,_rf,_rw)

IRs:
RETURN _rm,_rf,_rw"];
}
// Function: 39413.sol-E4Token-getPayIdAndHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_payId = (_tokHeld / (2 ** 48)) & 0xffff

IRs:
TMP_17(uint256) = 2 ** 48
TMP_18(uint256) = _tokHeld / TMP_17
TMP_19(uint256) = TMP_18 & 65535
_payId(uint256) := TMP_19(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_20(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_20(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
(_payId,_held)

IRs:
RETURN _payId,_held"];
}
// Function: 39413.sol-E4Token-getSpecialAddresses()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_fndr = founderOrg

IRs:
_fndr(address) := founderOrg(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_aux = auxPartner

IRs:
_aux(address) := auxPartner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_dev = developers

IRs:
_dev(address) := developers(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_e4 = e4_partner

IRs:
_e4(address) := e4_partner(address)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
(_fndr,_aux,_dev,_e4)

IRs:
RETURN _fndr,_aux,_dev,_e4"];
}
// Function: 39413.sol-E4Token-haraKiri()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
settingsState != SettingStateValue.debug

IRs:
REF_127(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_251(bool) = settingsState != REF_127
CONDITION TMP_251"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
msg.sender != owner

IRs:
TMP_252(bool) = msg.sender != owner
CONDITION TMP_252"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
suicide(address)(developers)

IRs:
TMP_253(None) = SOLIDITY_CALL suicide(address)(developers)"];
}
// Function: 39413.sol-E4Token-icoCheckup()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_209(bool) = msg.sender != owner
TMP_210(bool) = msg.sender != developers
TMP_211(bool) = TMP_209 && TMP_210
CONDITION TMP_211"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
icoStatus == IcoStatusValue.saleClosed

IRs:
REF_115(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
TMP_212(bool) = icoStatus == REF_115
CONDITION TMP_212"];
5->6[label="True"];
5->12[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
(getNumTokensPurchased() >= minIcoTokenGoal) && (remunerationStage == 0)

IRs:
TMP_213(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_214(bool) = TMP_213 >= minIcoTokenGoal
TMP_215(bool) = remunerationStage == 0
TMP_216(bool) = TMP_214 && TMP_215
CONDITION TMP_216"];
6->7[label="True"];
6->11[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_217(uint256) = totalTokenFundsReceived / 100
TMP_218(uint256) = TMP_217 * 9
remunerationBalance(uint256) := TMP_218(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_219(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_219(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nmsgmask |= 1

IRs:
nmsgmask(uint256) = nmsgmask | 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
icoStatus == IcoStatusValue.succeeded

IRs:
REF_116(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_220(bool) = icoStatus == REF_116
CONDITION TMP_220"];
13->14[label="True"];
13->25[label="False"];
14[label="Node Type: IF 14

EXPRESSION:
remunerationStage == 0

IRs:
TMP_221(bool) = remunerationStage == 0
CONDITION TMP_221"];
14->15[label="True"];
14->19[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_222(uint256) = totalTokenFundsReceived / 100
TMP_223(uint256) = TMP_222 * 9
remunerationBalance(uint256) := TMP_223(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_224(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_224(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
nmsgmask |= 4

IRs:
nmsgmask(uint256) = nmsgmask | 4"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
remunerationStage == 1

IRs:
TMP_225(bool) = remunerationStage == 1
CONDITION TMP_225"];
20->21[label="True"];
20->24[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
remunerationStage = 2

IRs:
remunerationStage(uint256) := 2(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived / 10)

IRs:
TMP_226(uint256) = totalTokenFundsReceived / 10
TMP_227(uint256) = totalTokenFundsReceived - TMP_226
remunerationBalance(uint256) = remunerationBalance + TMP_227"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
nmsgmask |= 8

IRs:
nmsgmask(uint256) = nmsgmask | 8"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: NEW VARIABLE 26
"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
remunerationBalance > 0

IRs:
TMP_228(bool) = remunerationBalance > 0
CONDITION TMP_228"];
27->28[label="True"];
27->35[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
ntmp = remunerationBalance

IRs:
ntmp(uint256) := remunerationBalance(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
29->30;
30[label="Node Type: IF 30

EXPRESSION:
! founderOrg.call.gas(rmGas).value(ntmp)()

IRs:
TMP_231(bool) = LOW_LEVEL_CALL, dest:founderOrg, function:call, arguments:[] value:ntmp gas:rmGas
TMP_232 = UnaryType.BANG TMP_231 
CONDITION TMP_232"];
30->31[label="True"];
30->33[label="False"];
31[label="Node Type: EXPRESSION 31

EXPRESSION:
remunerationBalance = ntmp

IRs:
remunerationBalance(uint256) := ntmp(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
nmsgmask |= 32

IRs:
nmsgmask(uint256) = nmsgmask | 32"];
32->34;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nmsgmask |= 64

IRs:
nmsgmask(uint256) = nmsgmask | 64"];
33->34;
34[label="Node Type: END_IF 34
"];
34->44;
35[label="Node Type: IF 35

EXPRESSION:
auxPartnerBalance > 0

IRs:
TMP_233(bool) = auxPartnerBalance > 0
CONDITION TMP_233"];
35->36[label="True"];
35->43[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
ntmp = auxPartnerBalance

IRs:
ntmp(uint256) := auxPartnerBalance(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
37->38;
38[label="Node Type: IF 38

EXPRESSION:
! auxPartner.call.gas(rmGas).value(ntmp)()

IRs:
TMP_236(bool) = LOW_LEVEL_CALL, dest:auxPartner, function:call, arguments:[] value:ntmp gas:rmGas
TMP_237 = UnaryType.BANG TMP_236 
CONDITION TMP_237"];
38->39[label="True"];
38->41[label="False"];
39[label="Node Type: EXPRESSION 39

EXPRESSION:
auxPartnerBalance = ntmp

IRs:
auxPartnerBalance(uint256) := ntmp(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
nmsgmask |= 128

IRs:
nmsgmask(uint256) = nmsgmask | 128"];
40->42;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
nmsgmask |= 256

IRs:
nmsgmask(uint256) = nmsgmask | 256"];
41->42;
42[label="Node Type: END_IF 42
"];
42->43;
43[label="Node Type: END_IF 43
"];
43->44;
44[label="Node Type: END_IF 44
"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
StatEventI(ico-checkup,nmsgmask)

IRs:
Emit StatEventI(ico-checkup,nmsgmask)"];
}
// Function: 39413.sol-E4Token-purchaseToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nvalue = msg.value

IRs:
nvalue(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
npurchaser = msg.sender

IRs:
npurchaser(address) := msg.sender(address)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
nvalue < tokenPrice

IRs:
TMP_65(bool) = nvalue < tokenPrice
CONDITION TMP_65"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: THROW 4
"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
qty = nvalue / tokenPrice

IRs:
TMP_66(uint256) = nvalue / tokenPrice
qty(uint256) := TMP_66(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
icoStatus != IcoStatusValue.saleOpen

IRs:
REF_54(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_68(bool) = icoStatus != REF_54
CONDITION TMP_68"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: THROW 9
"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
totalTokensMinted + qty > maxMintableTokens

IRs:
TMP_69(uint256) = totalTokensMinted + qty
TMP_70(bool) = TMP_69 > maxMintableTokens
CONDITION TMP_70"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: THROW 12
"];
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
! holderAccounts[npurchaser].alloced

IRs:
REF_55(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_56(bool) -> REF_55.alloced
TMP_71 = UnaryType.BANG REF_56 
CONDITION TMP_71"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
addAccount(npurchaser)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(npurchaser)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
newHeld = qty + getHeld(holderAccounts[npurchaser].tokens)

IRs:
REF_57(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_58(uint256) -> REF_57.tokens
TMP_73(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_58)
TMP_74(uint256) = qty + TMP_73
newHeld(uint256) := TMP_74(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_59(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_60(uint256) -> REF_59.tokens
TMP_75(uint256) = 2 ** 48
TMP_76(uint256) = curPayoutId * TMP_75
TMP_77(uint256) = newHeld | TMP_76
REF_60(uint256) (->holderAccounts) := TMP_77(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
totalTokensMinted += qty

IRs:
totalTokensMinted(uint256) = totalTokensMinted + qty"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
totalTokenFundsReceived += nvalue

IRs:
totalTokenFundsReceived(uint256) = totalTokenFundsReceived + nvalue"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
totalTokensMinted == maxMintableTokens

IRs:
TMP_78(bool) = totalTokensMinted == maxMintableTokens
CONDITION TMP_78"];
21->22[label="True"];
21->25[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_61(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_61(E4Token.IcoStatusValue)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
StatEventI(Purchased,Granted,qty)

IRs:
Emit StatEventI(Purchased,Granted,qty)"];
24->26;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
StatEventI(Purchased,qty)

IRs:
Emit StatEventI(Purchased,qty)"];
25->26;
26[label="Node Type: END_IF 26
"];
}
// Function: 39413.sol-E4Token-requestRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nrequester = msg.sender

IRs:
nrequester(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
ntokens = getHeld(holderAccounts[nrequester].tokens)

IRs:
REF_75(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_76(uint256) -> REF_75.tokens
TMP_139(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_76)
ntokens(uint256) := TMP_139(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
icoStatus != IcoStatusValue.failed

IRs:
REF_77(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_140(bool) = icoStatus != REF_77
CONDITION TMP_140"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(No Refund)

IRs:
Emit StatEvent(No Refund)"];
5->25;
6[label="Node Type: IF 6

EXPRESSION:
ntokens == 0

IRs:
TMP_142(bool) = ntokens == 0
CONDITION TMP_142"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
StatEvent(No Tokens)

IRs:
Emit StatEvent(No Tokens)"];
7->24;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
nrefund = ntokens * tokenPrice

IRs:
TMP_144(uint256) = ntokens * tokenPrice
nrefund(uint256) := TMP_144(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_145(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_146(bool) = TMP_145 >= minIcoTokenGoal
CONDITION TMP_146"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nrefund -= (nrefund / 10)

IRs:
TMP_147(uint256) = nrefund / 10
nrefund(uint256) = nrefund - TMP_147"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_78(E4Token.tokenAccount) -> holderAccounts[developers]
REF_79(bool) -> REF_78.alloced
TMP_148 = UnaryType.BANG REF_79 
CONDITION TMP_148"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
holderAccounts[developers].tokens += ntokens

IRs:
REF_80(E4Token.tokenAccount) -> holderAccounts[developers]
REF_81(uint256) -> REF_80.tokens
REF_81(-> holderAccounts) = REF_81 + ntokens"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
holderAccounts[nrequester].tokens = 0

IRs:
REF_82(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_83(uint256) -> REF_82.tokens
REF_83(uint256) (->holderAccounts) := 0(uint256)"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
holderAccounts[nrequester].balance > 0

IRs:
REF_84(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_85(uint256) -> REF_84.balance
TMP_150(bool) = REF_85 > 0
CONDITION TMP_150"];
17->18[label="True"];
17->20[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[developers].balance += holderAccounts[nrequester].balance

IRs:
REF_86(E4Token.tokenAccount) -> holderAccounts[developers]
REF_87(uint256) -> REF_86.balance
REF_88(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_89(uint256) -> REF_88.balance
REF_87(-> holderAccounts) = REF_87 + REF_89"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
holderAccounts[nrequester].balance = 0

IRs:
REF_90(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_91(uint256) -> REF_90.balance
REF_91(uint256) (->holderAccounts) := 0(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
! nrequester.call.gas(rfGas).value(nrefund)()

IRs:
TMP_153(bool) = LOW_LEVEL_CALL, dest:nrequester, function:call, arguments:[] value:nrefund gas:rfGas
TMP_154 = UnaryType.BANG TMP_153 
CONDITION TMP_154"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: THROW 22
"];
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39413.sol-E4Token-setE4RowPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_90(bool) = msg.sender == owner
CONDITION TMP_90"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
(e4_partner == address(0)) || (settingsState == SettingStateValue.debug)

IRs:
TMP_91 = CONVERT 0 to address
TMP_92(bool) = e4_partner == TMP_91
REF_62(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_93(bool) = settingsState == REF_62
TMP_94(bool) = TMP_92 || TMP_93
CONDITION TMP_94"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
e4_partner = _addr

IRs:
e4_partner(address) := _addr(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
partnerCredits = 0

IRs:
partnerCredits(uint256) := 0(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(Already Set)

IRs:
Emit StatEvent(Already Set)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 39413.sol-E4Token-setOpGas(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_206(bool) = msg.sender != owner
TMP_207(bool) = msg.sender != developers
TMP_208(bool) = TMP_206 && TMP_207
CONDITION TMP_208"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
rmGas = _rm

IRs:
rmGas(uint256) := _rm(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rfGas = _rf

IRs:
rfGas(uint256) := _rf(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
rwGas = _rw

IRs:
rwGas(uint256) := _rw(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 39413.sol-E4Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen || icoStatus == IcoStatusValue.anouncement

IRs:
REF_18(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_25(bool) = icoStatus == REF_18
REF_19(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_26(bool) = icoStatus == REF_19
TMP_27(bool) = TMP_25 || TMP_26
CONDITION TMP_27"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supply = maxMintableTokens

IRs:
supply(uint256) := maxMintableTokens(uint256)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
supply = totalTokensMinted

IRs:
supply(uint256) := totalTokensMinted(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 39413.sol-E4Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_28(bool) = msg.sender == developers
TMP_29(bool) = now < vestTime
TMP_30(bool) = TMP_28 && TMP_29
CONDITION TMP_30"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens)

IRs:
REF_20(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_21(uint256) -> REF_20.tokens
TUPLE_0(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_21)
pidFrom(uint256)= UNPACK TUPLE_0 index: 0 
heldFrom(uint256)= UNPACK TUPLE_0 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && _value > 0

IRs:
TMP_31(bool) = heldFrom >= _value
TMP_32(bool) = _value > 0
TMP_33(bool) = TMP_31 && TMP_32
CONDITION TMP_33"];
7->8[label="True"];
7->19[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].tokens -= _value

IRs:
REF_22(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_23(uint256) -> REF_22.tokens
REF_23(-> holderAccounts) = REF_23 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_24(E4Token.tokenAccount) -> holderAccounts[_to]
REF_25(bool) -> REF_24.alloced
TMP_34 = UnaryType.BANG REF_25 
CONDITION TMP_34"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_26(E4Token.tokenAccount) -> holderAccounts[_to]
REF_27(uint256) -> REF_26.tokens
TMP_36(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_27)
TMP_37(uint256) = _value + TMP_36
newHeld(uint256) := TMP_37(uint256)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen

IRs:
REF_28(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_38(bool) = icoStatus == REF_28
CONDITION TMP_38"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
pidFrom = curPayoutId

IRs:
pidFrom(uint256) := curPayoutId(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_29(E4Token.tokenAccount) -> holderAccounts[_to]
REF_30(uint256) -> REF_29.tokens
TMP_39(uint256) = 2 ** 48
TMP_40(uint256) = pidFrom * TMP_39
TMP_41(uint256) = newHeld | TMP_40
REF_30(uint256) (->holderAccounts) := TMP_41(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
true

IRs:
RETURN True"];
19[label="Node Type: RETURN 19

EXPRESSION:
false

IRs:
RETURN False"];
21[label="Node Type: RETURN 21

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39413.sol-E4Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(_from == developers) && (now < vestTime)

IRs:
TMP_43(bool) = _from == developers
TMP_44(bool) = now < vestTime
TMP_45(bool) = TMP_43 && TMP_44
CONDITION TMP_45"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens)

IRs:
REF_31(E4Token.tokenAccount) -> holderAccounts[_from]
REF_32(uint256) -> REF_31.tokens
TUPLE_1(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_32)
pidFrom(uint256)= UNPACK TUPLE_1 index: 0 
heldFrom(uint256)= UNPACK TUPLE_1 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
TMP_46(bool) = heldFrom >= _value
REF_33(mapping(address => uint256)) -> allowed[_from]
REF_34(uint256) -> REF_33[msg.sender]
TMP_47(bool) = REF_34 >= _value
TMP_48(bool) = TMP_46 && TMP_47
TMP_49(bool) = _value > 0
TMP_50(bool) = TMP_48 && TMP_49
CONDITION TMP_50"];
7->8[label="True"];
7->20[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[_from].tokens -= _value

IRs:
REF_35(E4Token.tokenAccount) -> holderAccounts[_from]
REF_36(uint256) -> REF_35.tokens
REF_36(-> holderAccounts) = REF_36 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_37(E4Token.tokenAccount) -> holderAccounts[_to]
REF_38(bool) -> REF_37.alloced
TMP_51 = UnaryType.BANG REF_38 
CONDITION TMP_51"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_39(E4Token.tokenAccount) -> holderAccounts[_to]
REF_40(uint256) -> REF_39.tokens
TMP_53(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_40)
TMP_54(uint256) = _value + TMP_53
newHeld(uint256) := TMP_54(uint256)"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen

IRs:
REF_41(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_55(bool) = icoStatus == REF_41
CONDITION TMP_55"];
13->14[label="True"];
13->15[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
pidFrom = curPayoutId

IRs:
pidFrom(uint256) := curPayoutId(uint256)"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_42(E4Token.tokenAccount) -> holderAccounts[_to]
REF_43(uint256) -> REF_42.tokens
TMP_56(uint256) = 2 ** 48
TMP_57(uint256) = pidFrom * TMP_56
TMP_58(uint256) = newHeld | TMP_57
REF_43(uint256) (->holderAccounts) := TMP_58(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_44(mapping(address => uint256)) -> allowed[_from]
REF_45(uint256) -> REF_44[msg.sender]
REF_45(-> allowed) = REF_45 - _value"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
18->19;
19[label="Node Type: RETURN 19

EXPRESSION:
true

IRs:
RETURN True"];
20[label="Node Type: RETURN 20

EXPRESSION:
false

IRs:
RETURN False"];
22[label="Node Type: RETURN 22

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39413.sol-E4Token-updateIcoStatus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.succeeded || icoStatus == IcoStatusValue.failed

IRs:
REF_64(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_102(bool) = icoStatus == REF_64
REF_65(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_103(bool) = icoStatus == REF_65
TMP_104(bool) = TMP_102 || TMP_103
CONDITION TMP_104"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: IF 3

EXPRESSION:
icoStatus == IcoStatusValue.anouncement

IRs:
REF_66(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_105(bool) = icoStatus == REF_66
CONDITION TMP_105"];
3->4[label="True"];
3->10[label="False"];
4[label="Node Type: IF 4

EXPRESSION:
now > fundingStart && now <= fundingDeadline

IRs:
TMP_106(bool) = now > fundingStart
TMP_107(bool) = now <= fundingDeadline
TMP_108(bool) = TMP_106 && TMP_107
CONDITION TMP_108"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
icoStatus = IcoStatusValue.saleOpen

IRs:
REF_67(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
icoStatus(E4Token.IcoStatusValue) := REF_67(E4Token.IcoStatusValue)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
now > fundingDeadline

IRs:
TMP_109(bool) = now > fundingDeadline
CONDITION TMP_109"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_68(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_68(E4Token.IcoStatusValue)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
9->21;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
numP = getNumTokensPurchased()

IRs:
TMP_110(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
numP(uint256) := TMP_110(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
numG = getNumGames()

IRs:
TMP_111(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
numG(uint256) := TMP_111(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
(now > fundingDeadline && numP < minIcoTokenGoal) || (now > usageDeadline && numG < minUsageGoal)

IRs:
TMP_112(bool) = now > fundingDeadline
TMP_113(bool) = numP < minIcoTokenGoal
TMP_114(bool) = TMP_112 && TMP_113
TMP_115(bool) = now > usageDeadline
TMP_116(bool) = numG < minUsageGoal
TMP_117(bool) = TMP_115 && TMP_116
TMP_118(bool) = TMP_114 || TMP_117
CONDITION TMP_118"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
icoStatus = IcoStatusValue.failed

IRs:
REF_69(E4Token.IcoStatusValue) -> IcoStatusValue.failed
icoStatus(E4Token.IcoStatusValue) := REF_69(E4Token.IcoStatusValue)"];
13->17;
14[label="Node Type: IF 14

EXPRESSION:
(now > fundingDeadline) && (numP >= minIcoTokenGoal) && (numG >= minUsageGoal)

IRs:
TMP_119(bool) = now > fundingDeadline
TMP_120(bool) = numP >= minIcoTokenGoal
TMP_121(bool) = TMP_119 && TMP_120
TMP_122(bool) = numG >= minUsageGoal
TMP_123(bool) = TMP_121 && TMP_122
CONDITION TMP_123"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
icoStatus = IcoStatusValue.succeeded

IRs:
REF_70(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
icoStatus(E4Token.IcoStatusValue) := REF_70(E4Token.IcoStatusValue)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen && ((numP >= maxMintableTokens) || (now > fundingDeadline))

IRs:
REF_71(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_124(bool) = icoStatus == REF_71
TMP_125(bool) = numP >= maxMintableTokens
TMP_126(bool) = now > fundingDeadline
TMP_127(bool) = TMP_125 || TMP_126
TMP_128(bool) = TMP_124 && TMP_127
CONDITION TMP_128"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_72(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_72(E4Token.IcoStatusValue)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
! developersGranted && icoStatus != IcoStatusValue.saleOpen && icoStatus != IcoStatusValue.anouncement && getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_129 = UnaryType.BANG developersGranted 
REF_73(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_130(bool) = icoStatus != REF_73
TMP_131(bool) = TMP_129 && TMP_130
REF_74(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_132(bool) = icoStatus != REF_74
TMP_133(bool) = TMP_131 && TMP_132
TMP_134(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_135(bool) = TMP_134 >= minIcoTokenGoal
TMP_136(bool) = TMP_133 && TMP_135
CONDITION TMP_136"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39413.sol-E4Token-withdrawDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[msg.sender].balance == 0

IRs:
REF_102(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_103(uint256) -> REF_102.balance
TMP_197(bool) = REF_103 == 0
CONDITION TMP_197"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(0 Balance)

IRs:
Emit StatEvent(0 Balance)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: IF 4

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_199(bool) = msg.sender == developers
TMP_200(bool) = now < vestTime
TMP_201(bool) = TMP_199 && TMP_200
CONDITION TMP_201"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_amount = holderAccounts[msg.sender].balance

IRs:
REF_104(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_105(uint256) -> REF_104.balance
_amount(uint256) := REF_105(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].balance = 0

IRs:
REF_106(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_107(uint256) -> REF_106.balance
REF_107(uint256) (->holderAccounts) := 0(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! msg.sender.call.gas(rwGas).value(_amount)()

IRs:
TMP_204(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_amount gas:rwGas
TMP_205 = UnaryType.BANG TMP_204 
CONDITION TMP_205"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: THROW 10
"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39413.sol-Token-allowance(address,address)
digraph{
}
// Function: 39413.sol-Token-approve(address,uint256)
digraph{
}
// Function: 39413.sol-Token-balanceOf(address)
digraph{
}
// Function: 39413.sol-Token-totalSupply()
digraph{
}
// Function: 39413.sol-Token-transfer(address,uint256)
digraph{
}
// Function: 39413.sol-Token-transferFrom(address,address,uint256)
digraph{
}
// Function: 39413.sol-iE4RowEscrow-getNumGamesStarted()
digraph{
}
}
