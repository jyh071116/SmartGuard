digraph G {
// Function: 39420.sol-E4RowRewards-checkDividends(address)
digraph{
}
// Function: 39420.sol-E4RowRewards-withdrawDividends()
digraph{
}
// Function: 39420.sol-E4Token-E4Token()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developers = msg.sender

IRs:
developers(address) := msg.sender(address)"];
}
// Function: 39420.sol-E4Token-addAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
holderAccounts[_addr].alloced = true

IRs:
REF_13(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_14(bool) -> REF_13.alloced
REF_14(bool) (->holderAccounts) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
holderAccounts[_addr].tokens = (curPayoutId * (2 ** 48))

IRs:
REF_15(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_16(uint256) -> REF_15.tokens
TMP_22(uint256) = 2 ** 48
TMP_23(uint256) = curPayoutId * TMP_22
REF_16(uint256) (->holderAccounts) := TMP_23(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
holderIndexes[numAccounts ++] = _addr

IRs:
TMP_24(uint256) := numAccounts(uint256)
numAccounts(uint256) = numAccounts + 1
REF_17(address) -> holderIndexes[TMP_24]
REF_17(address) (->holderIndexes) := _addr(address)"];
}
// Function: 39420.sol-E4Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_50(mapping(address => uint256)) -> allowed[_owner]
REF_51(uint256) -> REF_50[_spender]
RETURN REF_51"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 39420.sol-E4Token-applySettings(E4Token.SettingStateValue,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_0(bool) = msg.sender != owner
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payoutThreshold = _threshold

IRs:
payoutThreshold(uint256) := _threshold(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
maxPaysPer = _mpp

IRs:
maxPaysPer(uint256) := _mpp(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
minPayInterval = _mpi

IRs:
minPayInterval(uint256) := _mpi(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
settingsState == SettingStateValue.lockedRelease

IRs:
REF_0(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_1(bool) = settingsState == REF_0
CONDITION TMP_1"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8
"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
settingsState = qState

IRs:
settingsState(E4Token.SettingStateValue) := qState(E4Token.SettingStateValue)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
qState == SettingStateValue.lockedRelease

IRs:
REF_1(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_2(bool) = qState == REF_1
CONDITION TMP_2"];
11->12[label="True"];
11->14[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
StatEvent(Locking!)

IRs:
Emit StatEvent(Locking!)"];
12->13;
13[label="Node Type: RETURN 13
"];
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
icoStatus = IcoStatusValue.anouncement

IRs:
REF_2(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
icoStatus(E4Token.IcoStatusValue) := REF_2(E4Token.IcoStatusValue)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
rmGas = 100000

IRs:
rmGas(uint256) := 100000(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
rwGas = 10000

IRs:
rwGas(uint256) := 10000(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
rfGas = 10000

IRs:
rfGas(uint256) := 10000(uint256)"];
18->19;
19[label="Node Type: IF 19

EXPRESSION:
totalTokensMinted > 0

IRs:
TMP_4(bool) = totalTokensMinted > 0
CONDITION TMP_4"];
19->22[label="True"];
19->30[label="False"];
20[label="Node Type: BEGIN_LOOP 20
"];
20->23;
21[label="Node Type: END_LOOP 21
"];
21->30;
22[label="Node Type: NEW VARIABLE 22

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
22->20;
23[label="Node Type: IF_LOOP 23

EXPRESSION:
i < numAccounts

IRs:
TMP_5(bool) = i < numAccounts
CONDITION TMP_5"];
23->24[label="True"];
23->21[label="False"];
24[label="Node Type: NEW VARIABLE 24

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_3(address) -> holderIndexes[i]
a(address) := REF_3(address)"];
24->25;
25[label="Node Type: IF 25

EXPRESSION:
a != address(0)

IRs:
TMP_6 = CONVERT 0 to address
TMP_7(bool) = a != TMP_6
CONDITION TMP_7"];
25->26[label="True"];
25->28[label="False"];
26[label="Node Type: EXPRESSION 26

EXPRESSION:
holderAccounts[a].tokens = 0

IRs:
REF_4(E4Token.tokenAccount) -> holderAccounts[a]
REF_5(uint256) -> REF_4.tokens
REF_5(uint256) (->holderAccounts) := 0(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
holderAccounts[a].balance = 0

IRs:
REF_6(E4Token.tokenAccount) -> holderAccounts[a]
REF_7(uint256) -> REF_6.balance
REF_7(uint256) (->holderAccounts) := 0(uint256)"];
27->28;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
i ++

IRs:
TMP_8(uint256) := i(uint256)
i(uint256) = i + 1"];
29->23;
30[label="Node Type: END_IF 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
totalTokensMinted = 0

IRs:
totalTokensMinted(uint256) := 0(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
totalTokenFundsReceived = 0

IRs:
totalTokenFundsReceived(uint256) := 0(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
partnerCredits = 0

IRs:
partnerCredits(uint256) := 0(uint256)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
fundingStart = _saleStart

IRs:
fundingStart(uint256) := _saleStart(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
fundingDeadline = _saleEnd

IRs:
fundingDeadline(uint256) := _saleEnd(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
usageDeadline = _usageEnd

IRs:
usageDeadline(uint256) := _usageEnd(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
minUsageGoal = _minUsage

IRs:
minUsageGoal(uint256) := _minUsage(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
minIcoTokenGoal = _tokGoal

IRs:
minIcoTokenGoal(uint256) := _tokGoal(uint256)"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
maxMintableTokens = _maxMintable

IRs:
maxMintableTokens(uint256) := _maxMintable(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
tokenPrice = _price

IRs:
tokenPrice(uint256) := _price(uint256)"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
vestTime = fundingStart + (31536000)

IRs:
TMP_9(uint256) = fundingStart + 31536000
vestTime(uint256) := TMP_9(uint256)"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
numDevTokens = 0

IRs:
numDevTokens(uint256) := 0(uint256)"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
remunerationStage = 0

IRs:
remunerationStage(uint256) := 0(uint256)"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
49->50;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
developersGranted = false

IRs:
developersGranted(bool) := False(bool)"];
50->51;
51[label="Node Type: EXPRESSION 51

EXPRESSION:
lastPayoutTime = 0

IRs:
lastPayoutTime(uint256) := 0(uint256)"];
51->52;
52[label="Node Type: IF 52

EXPRESSION:
this.balance > 0

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_10(bool) = REF_8 > 0
CONDITION TMP_10"];
52->53[label="True"];
52->56[label="False"];
53[label="Node Type: IF 53

EXPRESSION:
! owner.call.gas(rfGas).value(this.balance)()

IRs:
REF_12(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_13(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:[] value:REF_12 gas:rfGas
TMP_14 = UnaryType.BANG TMP_13 
CONDITION TMP_14"];
53->54[label="True"];
53->55[label="False"];
54[label="Node Type: EXPRESSION 54

EXPRESSION:
StatEvent(ERROR!)

IRs:
Emit StatEvent(ERROR!)"];
54->55;
55[label="Node Type: END_IF 55
"];
55->56;
56[label="Node Type: END_IF 56
"];
56->57;
57[label="Node Type: EXPRESSION 57

EXPRESSION:
StatEvent(ok)

IRs:
Emit StatEvent(ok)"];
}
// Function: 39420.sol-E4Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_48(mapping(address => uint256)) -> allowed[msg.sender]
REF_49(uint256) -> REF_48[_spender]
REF_49(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39420.sol-E4Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_owner].alloced

IRs:
REF_44(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_45(bool) -> REF_44.alloced
CONDITION REF_45"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance = getHeld(holderAccounts[_owner].tokens)

IRs:
REF_46(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_47(uint256) -> REF_46.tokens
TMP_58(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_47)
balance(uint256) := TMP_58(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 39420.sol-E4Token-changeAuxPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_246(bool) = msg.sender != owner
REF_124(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_247(bool) = settingsState == REF_124
TMP_248(bool) = TMP_246 || TMP_247
CONDITION TMP_248"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
auxPartner = _aux

IRs:
auxPartner(address) := _aux(address)"];
}
// Function: 39420.sol-E4Token-changeDevevoperAccont(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_240(bool) = msg.sender != owner
REF_122(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_241(bool) = settingsState == REF_122
TMP_242(bool) = TMP_240 || TMP_241
CONDITION TMP_242"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
developers = _addr

IRs:
developers(address) := _addr(address)"];
}
// Function: 39420.sol-E4Token-changeFounder(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_243(bool) = msg.sender != owner
REF_123(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_244(bool) = settingsState == REF_123
TMP_245(bool) = TMP_243 || TMP_244
CONDITION TMP_245"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
founderOrg = _addr

IRs:
founderOrg(address) := _addr(address)"];
}
// Function: 39420.sol-E4Token-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_237(bool) = msg.sender != owner
REF_121(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_238(bool) = settingsState == REF_121
TMP_239(bool) = TMP_237 || TMP_238
CONDITION TMP_239"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
owner = _addr

IRs:
owner(address) := _addr(address)"];
}
// Function: 39420.sol-E4Token-checkDividends(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_addr].alloced

IRs:
REF_109(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_110(bool) -> REF_109.alloced
CONDITION REF_110"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_amount = holderAccounts[_addr].balance

IRs:
REF_111(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_112(uint256) -> REF_111.balance
_amount(uint256) := REF_112(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39420.sol-E4Token-doDeveloperGrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! developersGranted

IRs:
TMP_263 = UnaryType.BANG developersGranted 
CONDITION TMP_263"];
1->2[label="True"];
1->10[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developersGranted = true

IRs:
developersGranted(bool) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
numDevTokens = (totalTokensMinted * 15) / 100

IRs:
TMP_264(uint256) = totalTokensMinted * 15
TMP_265(uint256) = TMP_264 / 100
numDevTokens(uint256) := TMP_265(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalTokensMinted += numDevTokens

IRs:
totalTokensMinted(uint256) = totalTokensMinted + numDevTokens"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_126(E4Token.tokenAccount) -> holderAccounts[developers]
REF_127(bool) -> REF_126.alloced
TMP_266 = UnaryType.BANG REF_127 
CONDITION TMP_266"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens

IRs:
REF_128(E4Token.tokenAccount) -> holderAccounts[developers]
REF_129(uint256) -> REF_128.tokens
TMP_268(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_129)
TMP_269(uint256) = TMP_268 + numDevTokens
newHeld(uint256) := TMP_269(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
holderAccounts[developers].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_130(E4Token.tokenAccount) -> holderAccounts[developers]
REF_131(uint256) -> REF_130.tokens
TMP_270(uint256) = 2 ** 48
TMP_271(uint256) = curPayoutId * TMP_270
TMP_272(uint256) = newHeld | TMP_271
REF_131(uint256) (->holderAccounts) := TMP_272(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 39420.sol-E4Token-doPayout(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
totalTokensMinted == 0

IRs:
TMP_153(bool) = totalTokensMinted == 0
CONDITION TMP_153"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
(holdoverBalance > 0) && (payoutBalance == 0) && (now > (lastPayoutTime + minPayInterval))

IRs:
TMP_154(bool) = holdoverBalance > 0
TMP_155(bool) = payoutBalance == 0
TMP_156(bool) = TMP_154 && TMP_155
TMP_157(uint256) = lastPayoutTime + minPayInterval
TMP_158(bool) = now > TMP_157
TMP_159(bool) = TMP_156 && TMP_158
CONDITION TMP_159"];
4->5[label="True"];
4->16[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
curPayoutId ++

IRs:
TMP_160(uint256) := curPayoutId(uint256)
curPayoutId(uint256) = curPayoutId + 1"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
curPayoutId >= 32768

IRs:
TMP_161(bool) = curPayoutId >= 32768
CONDITION TMP_161"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
lastPayoutTime = now

IRs:
lastPayoutTime(uint256) := now(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
payoutBalance = int256(holdoverBalance)

IRs:
TMP_162 = CONVERT holdoverBalance to int256
payoutBalance(int256) := TMP_162(int256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
prOrigPayoutBal = payoutBalance

IRs:
prOrigPayoutBal(int256) := payoutBalance(int256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
prOrigTokensMint = totalTokensMinted

IRs:
prOrigTokensMint(uint256) := totalTokensMinted(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
StatEventI(StartRun,uint256(curPayoutId))

IRs:
TMP_163 = CONVERT curPayoutId to uint256
Emit StatEventI(StartRun,TMP_163)"];
15->53;
16[label="Node Type: IF 16

EXPRESSION:
payoutBalance > 0

IRs:
TMP_165(bool) = payoutBalance > 0
CONDITION TMP_165"];
16->17[label="True"];
16->52[label="False"];
17[label="Node Type: NEW VARIABLE 17
"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
nPerTokDistrib = uint256(prOrigPayoutBal) / prOrigTokensMint

IRs:
TMP_166 = CONVERT prOrigPayoutBal to uint256
TMP_167(uint256) = TMP_166 / prOrigTokensMint
nPerTokDistrib(uint256) := TMP_167(uint256)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
paids = 0

IRs:
paids(uint256) := 0(uint256)"];
19->20;
20[label="Node Type: NEW VARIABLE 20
"];
20->23;
21[label="Node Type: BEGIN_LOOP 21
"];
21->24;
22[label="Node Type: END_LOOP 22
"];
22->42;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
i = lastPayoutIndex

IRs:
i(uint256) := lastPayoutIndex(uint256)"];
23->21;
24[label="Node Type: IF_LOOP 24

EXPRESSION:
(paids < _numPays) && (i < numAccounts) && (payoutBalance > 0)

IRs:
TMP_168(bool) = paids < _numPays
TMP_169(bool) = i < numAccounts
TMP_170(bool) = TMP_168 && TMP_169
TMP_171(bool) = payoutBalance > 0
TMP_172(bool) = TMP_170 && TMP_171
CONDITION TMP_172"];
24->25[label="True"];
24->22[label="False"];
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_93(address) -> holderIndexes[i]
a(address) := REF_93(address)"];
25->26;
26[label="Node Type: IF 26

EXPRESSION:
a == address(0)

IRs:
TMP_173 = CONVERT 0 to address
TMP_174(bool) = a == TMP_173
CONDITION TMP_174"];
26->27[label="True"];
26->28[label="False"];
27[label="Node Type: CONTINUE 27
"];
27->41;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: NEW VARIABLE 29
"];
29->30;
30[label="Node Type: NEW VARIABLE 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
(pid,held) = getPayIdAndHeld(holderAccounts[a].tokens)

IRs:
REF_94(E4Token.tokenAccount) -> holderAccounts[a]
REF_95(uint256) -> REF_94.tokens
TUPLE_2(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_95)
pid(uint256)= UNPACK TUPLE_2 index: 0 
held(uint256)= UNPACK TUPLE_2 index: 1 "];
31->32;
32[label="Node Type: IF 32

EXPRESSION:
(held > 0) && (pid != curPayoutId)

IRs:
TMP_175(bool) = held > 0
TMP_176(bool) = pid != curPayoutId
TMP_177(bool) = TMP_175 && TMP_176
CONDITION TMP_177"];
32->33[label="True"];
32->40[label="False"];
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nAmount = nPerTokDistrib * held

IRs:
TMP_178(uint256) = nPerTokDistrib * held
nAmount(uint256) := TMP_178(uint256)"];
33->34;
34[label="Node Type: IF 34

EXPRESSION:
int256(nAmount) <= payoutBalance

IRs:
TMP_179 = CONVERT nAmount to int256
TMP_180(bool) = TMP_179 <= payoutBalance
CONDITION TMP_180"];
34->35[label="True"];
34->39[label="False"];
35[label="Node Type: EXPRESSION 35

EXPRESSION:
holderAccounts[a].balance += nAmount

IRs:
REF_96(E4Token.tokenAccount) -> holderAccounts[a]
REF_97(uint256) -> REF_96.balance
REF_97(-> holderAccounts) = REF_97 + nAmount"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
holderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held

IRs:
REF_98(E4Token.tokenAccount) -> holderAccounts[a]
REF_99(uint256) -> REF_98.tokens
TMP_181(uint256) = 2 ** 48
TMP_182(uint256) = curPayoutId * TMP_181
TMP_183(uint256) = TMP_182 | held
REF_99(uint256) (->holderAccounts) := TMP_183(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
payoutBalance -= int256(nAmount)

IRs:
TMP_184 = CONVERT nAmount to int256
payoutBalance(int256) = payoutBalance - TMP_184"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
paids ++

IRs:
TMP_185(uint256) := paids(uint256)
paids(uint256) = paids + 1"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: END_IF 40
"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
i ++

IRs:
TMP_186(uint256) := i(uint256)
i(uint256) = i + 1"];
41->24;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
lastPayoutIndex = i

IRs:
lastPayoutIndex(uint256) := i(uint256)"];
42->43;
43[label="Node Type: IF 43

EXPRESSION:
lastPayoutIndex >= numAccounts || payoutBalance <= 0

IRs:
TMP_187(bool) = lastPayoutIndex >= numAccounts
TMP_188(bool) = payoutBalance <= 0
TMP_189(bool) = TMP_187 || TMP_188
CONDITION TMP_189"];
43->44[label="True"];
43->50[label="False"];
44[label="Node Type: EXPRESSION 44

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
44->45;
45[label="Node Type: IF 45

EXPRESSION:
payoutBalance > 0

IRs:
TMP_190(bool) = payoutBalance > 0
CONDITION TMP_190"];
45->46[label="True"];
45->47[label="False"];
46[label="Node Type: EXPRESSION 46

EXPRESSION:
holdoverBalance += uint256(payoutBalance)

IRs:
TMP_191 = CONVERT payoutBalance to uint256
holdoverBalance(uint256) = holdoverBalance + TMP_191"];
46->47;
47[label="Node Type: END_IF 47
"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
StatEventI(RunComplete,uint256(prOrigPayoutBal))

IRs:
TMP_192 = CONVERT prOrigPayoutBal to uint256
Emit StatEventI(RunComplete,TMP_192)"];
49->51;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
StatEventI(PayRun,paids)

IRs:
Emit StatEventI(PayRun,paids)"];
50->51;
51[label="Node Type: END_IF 51
"];
51->52;
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: END_IF 53
"];
}
// Function: 39420.sol-E4Token-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == e4_partner

IRs:
TMP_60(bool) = msg.sender == e4_partner
CONDITION TMP_60"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feePayment()

IRs:
INTERNAL_CALL, E4Token.feePayment()()"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
purchaseToken()

IRs:
INTERNAL_CALL, E4Token.purchaseToken()()"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 39420.sol-E4Token-feePayment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != e4_partner

IRs:
TMP_80(bool) = msg.sender != e4_partner
CONDITION TMP_80"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(forbidden)

IRs:
Emit StatEvent(forbidden)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
nfvalue = msg.value

IRs:
nfvalue(uint256) := msg.value(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
holdoverBalance += nfvalue

IRs:
holdoverBalance(uint256) = holdoverBalance + nfvalue"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
partnerCredits += nfvalue

IRs:
partnerCredits(uint256) = partnerCredits + nfvalue"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
StatEventI(Payment,nfvalue)

IRs:
Emit StatEventI(Payment,nfvalue)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
holdoverBalance > payoutThreshold || payoutBalance > 0

IRs:
TMP_84(bool) = holdoverBalance > payoutThreshold
TMP_85(bool) = payoutBalance > 0
TMP_86(bool) = TMP_84 || TMP_85
CONDITION TMP_86"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
doPayout(maxPaysPer)

IRs:
INTERNAL_CALL, E4Token.doPayout(uint256)(maxPaysPer)"];
11->12;
12[label="Node Type: END_IF 12
"];
}
// Function: 39420.sol-E4Token-flushDividends(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(_numPays == 0) || (_numPays > 1000)

IRs:
TMP_254(bool) = _numPays == 0
TMP_255(bool) = _numPays > 1000
TMP_256(bool) = TMP_254 || TMP_255
CONDITION TMP_256"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(Invalid.)

IRs:
Emit StatEvent(Invalid.)"];
2->7;
3[label="Node Type: IF 3

EXPRESSION:
holdoverBalance > 0 || payoutBalance > 0

IRs:
TMP_258(bool) = holdoverBalance > 0
TMP_259(bool) = payoutBalance > 0
TMP_260(bool) = TMP_258 || TMP_259
CONDITION TMP_260"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
doPayout(_numPays)

IRs:
INTERNAL_CALL, E4Token.doPayout(uint256)(_numPays)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(Nothing to do.)

IRs:
Emit StatEvent(Nothing to do.)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 39420.sol-E4Token-getHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_21(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_21(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_held

IRs:
RETURN _held"];
}
// Function: 39420.sol-E4Token-getIcoInfo()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_status = icoStatus

IRs:
_status(E4Token.IcoStatusValue) := icoStatus(E4Token.IcoStatusValue)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_saleStart = fundingStart

IRs:
_saleStart(uint256) := fundingStart(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_saleEnd = fundingDeadline

IRs:
_saleEnd(uint256) := fundingDeadline(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_usageEnd = usageDeadline

IRs:
_usageEnd(uint256) := usageDeadline(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_vest = vestTime

IRs:
_vest(uint256) := vestTime(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_saleGoal = minIcoTokenGoal

IRs:
_saleGoal(uint256) := minIcoTokenGoal(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_usageGoal = minUsageGoal

IRs:
_usageGoal(uint256) := minUsageGoal(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_sold = getNumTokensPurchased()

IRs:
TMP_252(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
_sold(uint256) := TMP_252(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_used = getNumGames()

IRs:
TMP_253(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
_used(uint256) := TMP_253(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_funds = totalTokenFundsReceived

IRs:
_funds(uint256) := totalTokenFundsReceived(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_credits = partnerCredits

IRs:
_credits(uint256) := partnerCredits(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_remuStage = remunerationStage

IRs:
_remuStage(uint256) := remunerationStage(uint256)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
(_status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest)

IRs:
RETURN _status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest"];
}
// Function: 39420.sol-E4Token-getNumGames()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
e4_partner != address(0)

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = e4_partner != TMP_95
CONDITION TMP_96"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
pe4 = iE4RowEscrow(e4_partner)

IRs:
TMP_97 = CONVERT e4_partner to iE4RowEscrow
pe4(iE4RowEscrow) := TMP_97(iE4RowEscrow)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_games = uint256(pe4.getNumGamesStarted())

IRs:
TMP_98(int256) = HIGH_LEVEL_CALL, dest:pe4(iE4RowEscrow), function:getNumGamesStarted, arguments:[]  
TMP_99 = CONVERT TMP_98 to uint256
_games(uint256) := TMP_99(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_games

IRs:
RETURN _games"];
}
// Function: 39420.sol-E4Token-getNumTokensPurchased()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_purchased = totalTokensMinted - numDevTokens

IRs:
TMP_94(uint256) = totalTokensMinted - numDevTokens
_purchased(uint256) := TMP_94(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_purchased

IRs:
RETURN _purchased"];
}
// Function: 39420.sol-E4Token-getOpGas()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_rm = rmGas

IRs:
_rm(uint256) := rmGas(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_rf = rfGas

IRs:
_rf(uint256) := rfGas(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_rw = rwGas

IRs:
_rw(uint256) := rwGas(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(_rm,_rf,_rw)

IRs:
RETURN _rm,_rf,_rw"];
}
// Function: 39420.sol-E4Token-getPayIdAndHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_payId = (_tokHeld / (2 ** 48)) & 0xffff

IRs:
TMP_17(uint256) = 2 ** 48
TMP_18(uint256) = _tokHeld / TMP_17
TMP_19(uint256) = TMP_18 & 65535
_payId(uint256) := TMP_19(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_20(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_20(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
(_payId,_held)

IRs:
RETURN _payId,_held"];
}
// Function: 39420.sol-E4Token-getSpecialAddresses()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_fndr = founderOrg

IRs:
_fndr(address) := founderOrg(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_aux = auxPartner

IRs:
_aux(address) := auxPartner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_dev = developers

IRs:
_dev(address) := developers(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_e4 = e4_partner

IRs:
_e4(address) := e4_partner(address)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
(_fndr,_aux,_dev,_e4)

IRs:
RETURN _fndr,_aux,_dev,_e4"];
}
// Function: 39420.sol-E4Token-haraKiri()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
settingsState != SettingStateValue.debug

IRs:
REF_125(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_249(bool) = settingsState != REF_125
CONDITION TMP_249"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
msg.sender != owner

IRs:
TMP_250(bool) = msg.sender != owner
CONDITION TMP_250"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
suicide(address)(developers)

IRs:
TMP_251(None) = SOLIDITY_CALL suicide(address)(developers)"];
}
// Function: 39420.sol-E4Token-icoCheckup()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_207(bool) = msg.sender != owner
TMP_208(bool) = msg.sender != developers
TMP_209(bool) = TMP_207 && TMP_208
CONDITION TMP_209"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
icoStatus == IcoStatusValue.saleClosed

IRs:
REF_113(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
TMP_210(bool) = icoStatus == REF_113
CONDITION TMP_210"];
5->6[label="True"];
5->12[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
(getNumTokensPurchased() >= minIcoTokenGoal) && (remunerationStage == 0)

IRs:
TMP_211(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_212(bool) = TMP_211 >= minIcoTokenGoal
TMP_213(bool) = remunerationStage == 0
TMP_214(bool) = TMP_212 && TMP_213
CONDITION TMP_214"];
6->7[label="True"];
6->11[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_215(uint256) = totalTokenFundsReceived / 100
TMP_216(uint256) = TMP_215 * 9
remunerationBalance(uint256) := TMP_216(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_217(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_217(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nmsgmask |= 1

IRs:
nmsgmask(uint256) = nmsgmask | 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
icoStatus == IcoStatusValue.succeeded

IRs:
REF_114(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_218(bool) = icoStatus == REF_114
CONDITION TMP_218"];
13->14[label="True"];
13->25[label="False"];
14[label="Node Type: IF 14

EXPRESSION:
remunerationStage == 0

IRs:
TMP_219(bool) = remunerationStage == 0
CONDITION TMP_219"];
14->15[label="True"];
14->19[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_220(uint256) = totalTokenFundsReceived / 100
TMP_221(uint256) = TMP_220 * 9
remunerationBalance(uint256) := TMP_221(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_222(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_222(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
nmsgmask |= 4

IRs:
nmsgmask(uint256) = nmsgmask | 4"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
remunerationStage == 1

IRs:
TMP_223(bool) = remunerationStage == 1
CONDITION TMP_223"];
20->21[label="True"];
20->24[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
remunerationStage = 2

IRs:
remunerationStage(uint256) := 2(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived / 10)

IRs:
TMP_224(uint256) = totalTokenFundsReceived / 10
TMP_225(uint256) = totalTokenFundsReceived - TMP_224
remunerationBalance(uint256) = remunerationBalance + TMP_225"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
nmsgmask |= 8

IRs:
nmsgmask(uint256) = nmsgmask | 8"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: NEW VARIABLE 26
"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
remunerationBalance > 0

IRs:
TMP_226(bool) = remunerationBalance > 0
CONDITION TMP_226"];
27->28[label="True"];
27->35[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
ntmp = remunerationBalance

IRs:
ntmp(uint256) := remunerationBalance(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
29->30;
30[label="Node Type: IF 30

EXPRESSION:
! founderOrg.call.gas(rmGas).value(ntmp)()

IRs:
TMP_229(bool) = LOW_LEVEL_CALL, dest:founderOrg, function:call, arguments:[] value:ntmp gas:rmGas
TMP_230 = UnaryType.BANG TMP_229 
CONDITION TMP_230"];
30->31[label="True"];
30->33[label="False"];
31[label="Node Type: EXPRESSION 31

EXPRESSION:
remunerationBalance = ntmp

IRs:
remunerationBalance(uint256) := ntmp(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
nmsgmask |= 32

IRs:
nmsgmask(uint256) = nmsgmask | 32"];
32->34;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nmsgmask |= 64

IRs:
nmsgmask(uint256) = nmsgmask | 64"];
33->34;
34[label="Node Type: END_IF 34
"];
34->44;
35[label="Node Type: IF 35

EXPRESSION:
auxPartnerBalance > 0

IRs:
TMP_231(bool) = auxPartnerBalance > 0
CONDITION TMP_231"];
35->36[label="True"];
35->43[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
ntmp = auxPartnerBalance

IRs:
ntmp(uint256) := auxPartnerBalance(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
37->38;
38[label="Node Type: IF 38

EXPRESSION:
! auxPartner.call.gas(rmGas).value(ntmp)()

IRs:
TMP_234(bool) = LOW_LEVEL_CALL, dest:auxPartner, function:call, arguments:[] value:ntmp gas:rmGas
TMP_235 = UnaryType.BANG TMP_234 
CONDITION TMP_235"];
38->39[label="True"];
38->41[label="False"];
39[label="Node Type: EXPRESSION 39

EXPRESSION:
auxPartnerBalance = ntmp

IRs:
auxPartnerBalance(uint256) := ntmp(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
nmsgmask |= 128

IRs:
nmsgmask(uint256) = nmsgmask | 128"];
40->42;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
nmsgmask |= 256

IRs:
nmsgmask(uint256) = nmsgmask | 256"];
41->42;
42[label="Node Type: END_IF 42
"];
42->43;
43[label="Node Type: END_IF 43
"];
43->44;
44[label="Node Type: END_IF 44
"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
StatEventI(ico-checkup,nmsgmask)

IRs:
Emit StatEventI(ico-checkup,nmsgmask)"];
}
// Function: 39420.sol-E4Token-purchaseToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nvalue = msg.value

IRs:
nvalue(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
npurchaser = msg.sender

IRs:
npurchaser(address) := msg.sender(address)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
nvalue < tokenPrice

IRs:
TMP_63(bool) = nvalue < tokenPrice
CONDITION TMP_63"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: THROW 4
"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
qty = nvalue / tokenPrice

IRs:
TMP_64(uint256) = nvalue / tokenPrice
qty(uint256) := TMP_64(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
icoStatus != IcoStatusValue.saleOpen

IRs:
REF_52(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_66(bool) = icoStatus != REF_52
CONDITION TMP_66"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: THROW 9
"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
totalTokensMinted + qty > maxMintableTokens

IRs:
TMP_67(uint256) = totalTokensMinted + qty
TMP_68(bool) = TMP_67 > maxMintableTokens
CONDITION TMP_68"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: THROW 12
"];
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
! holderAccounts[npurchaser].alloced

IRs:
REF_53(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_54(bool) -> REF_53.alloced
TMP_69 = UnaryType.BANG REF_54 
CONDITION TMP_69"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
addAccount(npurchaser)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(npurchaser)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
newHeld = qty + getHeld(holderAccounts[npurchaser].tokens)

IRs:
REF_55(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_56(uint256) -> REF_55.tokens
TMP_71(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_56)
TMP_72(uint256) = qty + TMP_71
newHeld(uint256) := TMP_72(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_57(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_58(uint256) -> REF_57.tokens
TMP_73(uint256) = 2 ** 48
TMP_74(uint256) = curPayoutId * TMP_73
TMP_75(uint256) = newHeld | TMP_74
REF_58(uint256) (->holderAccounts) := TMP_75(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
totalTokensMinted += qty

IRs:
totalTokensMinted(uint256) = totalTokensMinted + qty"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
totalTokenFundsReceived += nvalue

IRs:
totalTokenFundsReceived(uint256) = totalTokenFundsReceived + nvalue"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
totalTokensMinted == maxMintableTokens

IRs:
TMP_76(bool) = totalTokensMinted == maxMintableTokens
CONDITION TMP_76"];
21->22[label="True"];
21->25[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_59(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_59(E4Token.IcoStatusValue)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
StatEventI(Purchased,Granted,qty)

IRs:
Emit StatEventI(Purchased,Granted,qty)"];
24->26;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
StatEventI(Purchased,qty)

IRs:
Emit StatEventI(Purchased,qty)"];
25->26;
26[label="Node Type: END_IF 26
"];
}
// Function: 39420.sol-E4Token-requestRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nrequester = msg.sender

IRs:
nrequester(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
ntokens = getHeld(holderAccounts[nrequester].tokens)

IRs:
REF_73(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_74(uint256) -> REF_73.tokens
TMP_137(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_74)
ntokens(uint256) := TMP_137(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
icoStatus != IcoStatusValue.failed

IRs:
REF_75(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_138(bool) = icoStatus != REF_75
CONDITION TMP_138"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(No Refund)

IRs:
Emit StatEvent(No Refund)"];
5->25;
6[label="Node Type: IF 6

EXPRESSION:
ntokens == 0

IRs:
TMP_140(bool) = ntokens == 0
CONDITION TMP_140"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
StatEvent(No Tokens)

IRs:
Emit StatEvent(No Tokens)"];
7->24;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
nrefund = ntokens * tokenPrice

IRs:
TMP_142(uint256) = ntokens * tokenPrice
nrefund(uint256) := TMP_142(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_143(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_144(bool) = TMP_143 >= minIcoTokenGoal
CONDITION TMP_144"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nrefund -= (nrefund / 10)

IRs:
TMP_145(uint256) = nrefund / 10
nrefund(uint256) = nrefund - TMP_145"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
holderAccounts[developers].tokens += ntokens

IRs:
REF_76(E4Token.tokenAccount) -> holderAccounts[developers]
REF_77(uint256) -> REF_76.tokens
REF_77(-> holderAccounts) = REF_77 + ntokens"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[nrequester].tokens = 0

IRs:
REF_78(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_79(uint256) -> REF_78.tokens
REF_79(uint256) (->holderAccounts) := 0(uint256)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
holderAccounts[nrequester].balance > 0

IRs:
REF_80(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_81(uint256) -> REF_80.balance
TMP_146(bool) = REF_81 > 0
CONDITION TMP_146"];
14->15[label="True"];
14->20[label="False"];
15[label="Node Type: IF 15

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_82(E4Token.tokenAccount) -> holderAccounts[developers]
REF_83(bool) -> REF_82.alloced
TMP_147 = UnaryType.BANG REF_83 
CONDITION TMP_147"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[developers].balance += holderAccounts[nrequester].balance

IRs:
REF_84(E4Token.tokenAccount) -> holderAccounts[developers]
REF_85(uint256) -> REF_84.balance
REF_86(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_87(uint256) -> REF_86.balance
REF_85(-> holderAccounts) = REF_85 + REF_87"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
holderAccounts[nrequester].balance = 0

IRs:
REF_88(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_89(uint256) -> REF_88.balance
REF_89(uint256) (->holderAccounts) := 0(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
! nrequester.call.gas(rfGas).value(nrefund)()

IRs:
TMP_151(bool) = LOW_LEVEL_CALL, dest:nrequester, function:call, arguments:[] value:nrefund gas:rfGas
TMP_152 = UnaryType.BANG TMP_151 
CONDITION TMP_152"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: THROW 22
"];
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39420.sol-E4Token-setE4RowPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_88(bool) = msg.sender == owner
CONDITION TMP_88"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
(e4_partner == address(0)) || (settingsState == SettingStateValue.debug)

IRs:
TMP_89 = CONVERT 0 to address
TMP_90(bool) = e4_partner == TMP_89
REF_60(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_91(bool) = settingsState == REF_60
TMP_92(bool) = TMP_90 || TMP_91
CONDITION TMP_92"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
e4_partner = _addr

IRs:
e4_partner(address) := _addr(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
partnerCredits = 0

IRs:
partnerCredits(uint256) := 0(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(Already Set)

IRs:
Emit StatEvent(Already Set)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 39420.sol-E4Token-setOpGas(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_204(bool) = msg.sender != owner
TMP_205(bool) = msg.sender != developers
TMP_206(bool) = TMP_204 && TMP_205
CONDITION TMP_206"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
rmGas = _rm

IRs:
rmGas(uint256) := _rm(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rfGas = _rf

IRs:
rfGas(uint256) := _rf(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
rwGas = _rw

IRs:
rwGas(uint256) := _rw(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 39420.sol-E4Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen || icoStatus == IcoStatusValue.anouncement

IRs:
REF_18(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_25(bool) = icoStatus == REF_18
REF_19(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_26(bool) = icoStatus == REF_19
TMP_27(bool) = TMP_25 || TMP_26
CONDITION TMP_27"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supply = maxMintableTokens

IRs:
supply(uint256) := maxMintableTokens(uint256)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
supply = totalTokensMinted

IRs:
supply(uint256) := totalTokensMinted(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 39420.sol-E4Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_28(bool) = msg.sender == developers
TMP_29(bool) = now < vestTime
TMP_30(bool) = TMP_28 && TMP_29
CONDITION TMP_30"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens)

IRs:
REF_20(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_21(uint256) -> REF_20.tokens
TUPLE_0(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_21)
pidFrom(uint256)= UNPACK TUPLE_0 index: 0 
heldFrom(uint256)= UNPACK TUPLE_0 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && _value > 0

IRs:
TMP_31(bool) = heldFrom >= _value
TMP_32(bool) = _value > 0
TMP_33(bool) = TMP_31 && TMP_32
CONDITION TMP_33"];
7->8[label="True"];
7->16[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].tokens -= _value

IRs:
REF_22(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_23(uint256) -> REF_22.tokens
REF_23(-> holderAccounts) = REF_23 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_24(E4Token.tokenAccount) -> holderAccounts[_to]
REF_25(bool) -> REF_24.alloced
TMP_34 = UnaryType.BANG REF_25 
CONDITION TMP_34"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_26(E4Token.tokenAccount) -> holderAccounts[_to]
REF_27(uint256) -> REF_26.tokens
TMP_36(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_27)
TMP_37(uint256) = _value + TMP_36
newHeld(uint256) := TMP_37(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_28(E4Token.tokenAccount) -> holderAccounts[_to]
REF_29(uint256) -> REF_28.tokens
TMP_38(uint256) = 2 ** 48
TMP_39(uint256) = pidFrom * TMP_38
TMP_40(uint256) = newHeld | TMP_39
REF_29(uint256) (->holderAccounts) := TMP_40(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
true

IRs:
RETURN True"];
16[label="Node Type: RETURN 16

EXPRESSION:
false

IRs:
RETURN False"];
18[label="Node Type: RETURN 18

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39420.sol-E4Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(_from == developers) && (now < vestTime)

IRs:
TMP_42(bool) = _from == developers
TMP_43(bool) = now < vestTime
TMP_44(bool) = TMP_42 && TMP_43
CONDITION TMP_44"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens)

IRs:
REF_30(E4Token.tokenAccount) -> holderAccounts[_from]
REF_31(uint256) -> REF_30.tokens
TUPLE_1(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_31)
pidFrom(uint256)= UNPACK TUPLE_1 index: 0 
heldFrom(uint256)= UNPACK TUPLE_1 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
TMP_45(bool) = heldFrom >= _value
REF_32(mapping(address => uint256)) -> allowed[_from]
REF_33(uint256) -> REF_32[msg.sender]
TMP_46(bool) = REF_33 >= _value
TMP_47(bool) = TMP_45 && TMP_46
TMP_48(bool) = _value > 0
TMP_49(bool) = TMP_47 && TMP_48
CONDITION TMP_49"];
7->8[label="True"];
7->17[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[_from].tokens -= _value

IRs:
REF_34(E4Token.tokenAccount) -> holderAccounts[_from]
REF_35(uint256) -> REF_34.tokens
REF_35(-> holderAccounts) = REF_35 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_36(E4Token.tokenAccount) -> holderAccounts[_to]
REF_37(bool) -> REF_36.alloced
TMP_50 = UnaryType.BANG REF_37 
CONDITION TMP_50"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_38(E4Token.tokenAccount) -> holderAccounts[_to]
REF_39(uint256) -> REF_38.tokens
TMP_52(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_39)
TMP_53(uint256) = _value + TMP_52
newHeld(uint256) := TMP_53(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_40(E4Token.tokenAccount) -> holderAccounts[_to]
REF_41(uint256) -> REF_40.tokens
TMP_54(uint256) = 2 ** 48
TMP_55(uint256) = pidFrom * TMP_54
TMP_56(uint256) = newHeld | TMP_55
REF_41(uint256) (->holderAccounts) := TMP_56(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_42(mapping(address => uint256)) -> allowed[_from]
REF_43(uint256) -> REF_42[msg.sender]
REF_43(-> allowed) = REF_43 - _value"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True"];
17[label="Node Type: RETURN 17

EXPRESSION:
false

IRs:
RETURN False"];
19[label="Node Type: RETURN 19

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39420.sol-E4Token-updateIcoStatus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.succeeded || icoStatus == IcoStatusValue.failed

IRs:
REF_62(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_100(bool) = icoStatus == REF_62
REF_63(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_101(bool) = icoStatus == REF_63
TMP_102(bool) = TMP_100 || TMP_101
CONDITION TMP_102"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: IF 3

EXPRESSION:
icoStatus == IcoStatusValue.anouncement

IRs:
REF_64(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_103(bool) = icoStatus == REF_64
CONDITION TMP_103"];
3->4[label="True"];
3->10[label="False"];
4[label="Node Type: IF 4

EXPRESSION:
now > fundingStart && now <= fundingDeadline

IRs:
TMP_104(bool) = now > fundingStart
TMP_105(bool) = now <= fundingDeadline
TMP_106(bool) = TMP_104 && TMP_105
CONDITION TMP_106"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
icoStatus = IcoStatusValue.saleOpen

IRs:
REF_65(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
icoStatus(E4Token.IcoStatusValue) := REF_65(E4Token.IcoStatusValue)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
now > fundingDeadline

IRs:
TMP_107(bool) = now > fundingDeadline
CONDITION TMP_107"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_66(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_66(E4Token.IcoStatusValue)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
9->21;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
numP = getNumTokensPurchased()

IRs:
TMP_108(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
numP(uint256) := TMP_108(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
numG = getNumGames()

IRs:
TMP_109(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
numG(uint256) := TMP_109(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
(now > fundingDeadline && numP < minIcoTokenGoal) || (now > usageDeadline && numG < minUsageGoal)

IRs:
TMP_110(bool) = now > fundingDeadline
TMP_111(bool) = numP < minIcoTokenGoal
TMP_112(bool) = TMP_110 && TMP_111
TMP_113(bool) = now > usageDeadline
TMP_114(bool) = numG < minUsageGoal
TMP_115(bool) = TMP_113 && TMP_114
TMP_116(bool) = TMP_112 || TMP_115
CONDITION TMP_116"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
icoStatus = IcoStatusValue.failed

IRs:
REF_67(E4Token.IcoStatusValue) -> IcoStatusValue.failed
icoStatus(E4Token.IcoStatusValue) := REF_67(E4Token.IcoStatusValue)"];
13->17;
14[label="Node Type: IF 14

EXPRESSION:
(now > fundingDeadline) && (numP >= minIcoTokenGoal) && (numG >= minUsageGoal)

IRs:
TMP_117(bool) = now > fundingDeadline
TMP_118(bool) = numP >= minIcoTokenGoal
TMP_119(bool) = TMP_117 && TMP_118
TMP_120(bool) = numG >= minUsageGoal
TMP_121(bool) = TMP_119 && TMP_120
CONDITION TMP_121"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
icoStatus = IcoStatusValue.succeeded

IRs:
REF_68(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
icoStatus(E4Token.IcoStatusValue) := REF_68(E4Token.IcoStatusValue)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen && ((numP >= maxMintableTokens) || (now > fundingDeadline))

IRs:
REF_69(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_122(bool) = icoStatus == REF_69
TMP_123(bool) = numP >= maxMintableTokens
TMP_124(bool) = now > fundingDeadline
TMP_125(bool) = TMP_123 || TMP_124
TMP_126(bool) = TMP_122 && TMP_125
CONDITION TMP_126"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_70(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_70(E4Token.IcoStatusValue)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
! developersGranted && icoStatus != IcoStatusValue.saleOpen && icoStatus != IcoStatusValue.anouncement && getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_127 = UnaryType.BANG developersGranted 
REF_71(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_128(bool) = icoStatus != REF_71
TMP_129(bool) = TMP_127 && TMP_128
REF_72(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_130(bool) = icoStatus != REF_72
TMP_131(bool) = TMP_129 && TMP_130
TMP_132(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_133(bool) = TMP_132 >= minIcoTokenGoal
TMP_134(bool) = TMP_131 && TMP_133
CONDITION TMP_134"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39420.sol-E4Token-withdrawDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[msg.sender].balance == 0

IRs:
REF_100(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_101(uint256) -> REF_100.balance
TMP_195(bool) = REF_101 == 0
CONDITION TMP_195"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(0 Balance)

IRs:
Emit StatEvent(0 Balance)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: IF 4

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_197(bool) = msg.sender == developers
TMP_198(bool) = now < vestTime
TMP_199(bool) = TMP_197 && TMP_198
CONDITION TMP_199"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_amount = holderAccounts[msg.sender].balance

IRs:
REF_102(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_103(uint256) -> REF_102.balance
_amount(uint256) := REF_103(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].balance = 0

IRs:
REF_104(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_105(uint256) -> REF_104.balance
REF_105(uint256) (->holderAccounts) := 0(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! msg.sender.call.gas(rwGas).value(_amount)()

IRs:
TMP_202(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_amount gas:rwGas
TMP_203 = UnaryType.BANG TMP_202 
CONDITION TMP_203"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: THROW 10
"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39420.sol-Token-allowance(address,address)
digraph{
}
// Function: 39420.sol-Token-approve(address,uint256)
digraph{
}
// Function: 39420.sol-Token-balanceOf(address)
digraph{
}
// Function: 39420.sol-Token-totalSupply()
digraph{
}
// Function: 39420.sol-Token-transfer(address,uint256)
digraph{
}
// Function: 39420.sol-Token-transferFrom(address,address,uint256)
digraph{
}
// Function: 39420.sol-iE4RowEscrow-getNumGamesStarted()
digraph{
}
}
