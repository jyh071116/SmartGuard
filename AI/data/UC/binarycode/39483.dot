digraph G {
// Function: 39483.sol-E4RowRewards-checkDividends(address)
digraph{
}
// Function: 39483.sol-E4RowRewards-withdrawDividends()
digraph{
}
// Function: 39483.sol-E4Token-E4Token()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developers = msg.sender

IRs:
developers(address) := msg.sender(address)"];
}
// Function: 39483.sol-E4Token-addAccount(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
holderAccounts[_addr].alloced = true

IRs:
REF_12(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_13(bool) -> REF_12.alloced
REF_13(bool) (->holderAccounts) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
holderAccounts[_addr].tokens = (curPayoutId * (2 ** 48))

IRs:
REF_14(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_15(uint256) -> REF_14.tokens
TMP_21(uint256) = 2 ** 48
TMP_22(uint256) = curPayoutId * TMP_21
REF_15(uint256) (->holderAccounts) := TMP_22(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
holderIndexes[numAccounts ++] = _addr

IRs:
TMP_23(uint256) := numAccounts(uint256)
numAccounts(uint256) = numAccounts + 1
REF_16(address) -> holderIndexes[TMP_23]
REF_16(address) (->holderIndexes) := _addr(address)"];
}
// Function: 39483.sol-E4Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_49(mapping(address => uint256)) -> allowed[_owner]
REF_50(uint256) -> REF_49[_spender]
RETURN REF_50"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 39483.sol-E4Token-applySettings(E4Token.SettingStateValue,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_0(bool) = msg.sender != owner
CONDITION TMP_0"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
payoutThreshold = _threshold

IRs:
payoutThreshold(uint256) := _threshold(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
maxPaysPer = _mpp

IRs:
maxPaysPer(uint256) := _mpp(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
minPayInterval = _mpi

IRs:
minPayInterval(uint256) := _mpi(uint256)"];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
settingsState == SettingStateValue.lockedRelease

IRs:
REF_0(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_1(bool) = settingsState == REF_0
CONDITION TMP_1"];
7->8[label="True"];
7->9[label="False"];
8[label="Node Type: RETURN 8
"];
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
settingsState = qState

IRs:
settingsState(E4Token.SettingStateValue) := qState(E4Token.SettingStateValue)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
icoStatus = IcoStatusValue.anouncement

IRs:
REF_1(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
icoStatus(E4Token.IcoStatusValue) := REF_1(E4Token.IcoStatusValue)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
rmGas = 100000

IRs:
rmGas(uint256) := 100000(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
rwGas = 10000

IRs:
rwGas(uint256) := 10000(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
rfGas = 10000

IRs:
rfGas(uint256) := 10000(uint256)"];
14->15;
15[label="Node Type: IF 15

EXPRESSION:
totalTokensMinted > 0

IRs:
TMP_2(bool) = totalTokensMinted > 0
CONDITION TMP_2"];
15->18[label="True"];
15->26[label="False"];
16[label="Node Type: BEGIN_LOOP 16
"];
16->19;
17[label="Node Type: END_LOOP 17
"];
17->26;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)"];
18->16;
19[label="Node Type: IF_LOOP 19

EXPRESSION:
i < numAccounts

IRs:
TMP_3(bool) = i < numAccounts
CONDITION TMP_3"];
19->20[label="True"];
19->17[label="False"];
20[label="Node Type: NEW VARIABLE 20

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_2(address) -> holderIndexes[i]
a(address) := REF_2(address)"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
a != address(0)

IRs:
TMP_4 = CONVERT 0 to address
TMP_5(bool) = a != TMP_4
CONDITION TMP_5"];
21->22[label="True"];
21->24[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
holderAccounts[a].tokens = 0

IRs:
REF_3(E4Token.tokenAccount) -> holderAccounts[a]
REF_4(uint256) -> REF_3.tokens
REF_4(uint256) (->holderAccounts) := 0(uint256)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
holderAccounts[a].balance = 0

IRs:
REF_5(E4Token.tokenAccount) -> holderAccounts[a]
REF_6(uint256) -> REF_5.balance
REF_6(uint256) (->holderAccounts) := 0(uint256)"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1"];
25->19;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
totalTokensMinted = 0

IRs:
totalTokensMinted(uint256) := 0(uint256)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
totalTokenFundsReceived = 0

IRs:
totalTokenFundsReceived(uint256) := 0(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
e4_partner = address(0)

IRs:
TMP_7 = CONVERT 0 to address
e4_partner(address) := TMP_7(address)"];
29->30;
30[label="Node Type: EXPRESSION 30

EXPRESSION:
fundingStart = _saleStart

IRs:
fundingStart(uint256) := _saleStart(uint256)"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
fundingDeadline = _saleEnd

IRs:
fundingDeadline(uint256) := _saleEnd(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
usageDeadline = _usageEnd

IRs:
usageDeadline(uint256) := _usageEnd(uint256)"];
32->33;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
minUsageGoal = _minUsage

IRs:
minUsageGoal(uint256) := _minUsage(uint256)"];
33->34;
34[label="Node Type: EXPRESSION 34

EXPRESSION:
minIcoTokenGoal = _tokGoal

IRs:
minIcoTokenGoal(uint256) := _tokGoal(uint256)"];
34->35;
35[label="Node Type: EXPRESSION 35

EXPRESSION:
maxMintableTokens = _maxMintable

IRs:
maxMintableTokens(uint256) := _maxMintable(uint256)"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
tokenPrice = _price

IRs:
tokenPrice(uint256) := _price(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
vestTime = fundingStart + (31536000)

IRs:
TMP_8(uint256) = fundingStart + 31536000
vestTime(uint256) := TMP_8(uint256)"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
numDevTokens = 0

IRs:
numDevTokens(uint256) := 0(uint256)"];
38->39;
39[label="Node Type: EXPRESSION 39

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
41->42;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
42->43;
43[label="Node Type: EXPRESSION 43

EXPRESSION:
remunerationStage = 0

IRs:
remunerationStage(uint256) := 0(uint256)"];
43->44;
44[label="Node Type: EXPRESSION 44

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
45->46;
46[label="Node Type: EXPRESSION 46

EXPRESSION:
developersGranted = false

IRs:
developersGranted(bool) := False(bool)"];
46->47;
47[label="Node Type: EXPRESSION 47

EXPRESSION:
lastPayoutTime = 0

IRs:
lastPayoutTime(uint256) := 0(uint256)"];
47->48;
48[label="Node Type: IF 48

EXPRESSION:
this.balance > 0

IRs:
REF_7(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_9(bool) = REF_7 > 0
CONDITION TMP_9"];
48->49[label="True"];
48->52[label="False"];
49[label="Node Type: IF 49

EXPRESSION:
! owner.call.gas(rfGas).value(this.balance)()

IRs:
REF_11(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_12(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:[] value:REF_11 gas:rfGas
TMP_13 = UnaryType.BANG TMP_12 
CONDITION TMP_13"];
49->50[label="True"];
49->51[label="False"];
50[label="Node Type: EXPRESSION 50

EXPRESSION:
StatEvent(ERROR!)

IRs:
Emit StatEvent(ERROR!)"];
50->51;
51[label="Node Type: END_IF 51
"];
51->52;
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: EXPRESSION 53

EXPRESSION:
StatEvent(ok)

IRs:
Emit StatEvent(ok)"];
}
// Function: 39483.sol-E4Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_47(mapping(address => uint256)) -> allowed[msg.sender]
REF_48(uint256) -> REF_47[_spender]
REF_48(uint256) (->allowed) := _value(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True"];
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39483.sol-E4Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_owner].alloced

IRs:
REF_43(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_44(bool) -> REF_43.alloced
CONDITION REF_44"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balance = getHeld(holderAccounts[_owner].tokens)

IRs:
REF_45(E4Token.tokenAccount) -> holderAccounts[_owner]
REF_46(uint256) -> REF_45.tokens
TMP_57(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_46)
balance(uint256) := TMP_57(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 39483.sol-E4Token-changeAuxPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_245(bool) = msg.sender != owner
REF_125(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_246(bool) = settingsState == REF_125
TMP_247(bool) = TMP_245 || TMP_246
CONDITION TMP_247"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
auxPartner = _aux

IRs:
auxPartner(address) := _aux(address)"];
}
// Function: 39483.sol-E4Token-changeDevevoperAccont(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_239(bool) = msg.sender != owner
REF_123(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_240(bool) = settingsState == REF_123
TMP_241(bool) = TMP_239 || TMP_240
CONDITION TMP_241"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
developers = _addr

IRs:
developers(address) := _addr(address)"];
}
// Function: 39483.sol-E4Token-changeFounder(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_242(bool) = msg.sender != owner
REF_124(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_243(bool) = settingsState == REF_124
TMP_244(bool) = TMP_242 || TMP_243
CONDITION TMP_244"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
founderOrg = _addr

IRs:
founderOrg(address) := _addr(address)"];
}
// Function: 39483.sol-E4Token-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner || settingsState == SettingStateValue.lockedRelease

IRs:
TMP_236(bool) = msg.sender != owner
REF_122(E4Token.SettingStateValue) -> SettingStateValue.lockedRelease
TMP_237(bool) = settingsState == REF_122
TMP_238(bool) = TMP_236 || TMP_237
CONDITION TMP_238"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
owner = _addr

IRs:
owner(address) := _addr(address)"];
}
// Function: 39483.sol-E4Token-checkDividends(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[_addr].alloced

IRs:
REF_110(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_111(bool) -> REF_110.alloced
CONDITION REF_111"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_amount = holderAccounts[_addr].balance

IRs:
REF_112(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_113(uint256) -> REF_112.balance
_amount(uint256) := REF_113(uint256)"];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39483.sol-E4Token-doDeveloperGrant()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! developersGranted

IRs:
TMP_260 = UnaryType.BANG developersGranted 
CONDITION TMP_260"];
1->2[label="True"];
1->10[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
developersGranted = true

IRs:
developersGranted(bool) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
numDevTokens = totalTokensMinted / 10

IRs:
TMP_261(uint256) = totalTokensMinted / 10
numDevTokens(uint256) := TMP_261(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
totalTokensMinted += numDevTokens

IRs:
totalTokensMinted(uint256) = totalTokensMinted + numDevTokens"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_127(E4Token.tokenAccount) -> holderAccounts[developers]
REF_128(bool) -> REF_127.alloced
TMP_262 = UnaryType.BANG REF_128 
CONDITION TMP_262"];
5->6[label="True"];
5->7[label="False"];
6[label="Node Type: EXPRESSION 6

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
6->7;
7[label="Node Type: END_IF 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens

IRs:
REF_129(E4Token.tokenAccount) -> holderAccounts[developers]
REF_130(uint256) -> REF_129.tokens
TMP_264(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_130)
TMP_265(uint256) = TMP_264 + numDevTokens
newHeld(uint256) := TMP_265(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
holderAccounts[developers].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_131(E4Token.tokenAccount) -> holderAccounts[developers]
REF_132(uint256) -> REF_131.tokens
TMP_266(uint256) = 2 ** 48
TMP_267(uint256) = curPayoutId * TMP_266
TMP_268(uint256) = newHeld | TMP_267
REF_132(uint256) (->holderAccounts) := TMP_268(uint256)"];
9->10;
10[label="Node Type: END_IF 10
"];
}
// Function: 39483.sol-E4Token-doPayout()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
totalTokensMinted == 0

IRs:
TMP_152(bool) = totalTokensMinted == 0
CONDITION TMP_152"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
(holdoverBalance > 0) && (payoutBalance == 0) && (now > (lastPayoutTime + minPayInterval))

IRs:
TMP_153(bool) = holdoverBalance > 0
TMP_154(bool) = payoutBalance == 0
TMP_155(bool) = TMP_153 && TMP_154
TMP_156(uint256) = lastPayoutTime + minPayInterval
TMP_157(bool) = now > TMP_156
TMP_158(bool) = TMP_155 && TMP_157
CONDITION TMP_158"];
4->5[label="True"];
4->16[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
curPayoutId ++

IRs:
TMP_159(uint256) := curPayoutId(uint256)
curPayoutId(uint256) = curPayoutId + 1"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
curPayoutId >= 32768

IRs:
TMP_160(bool) = curPayoutId >= 32768
CONDITION TMP_160"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
curPayoutId = 1

IRs:
curPayoutId(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
lastPayoutTime = now

IRs:
lastPayoutTime(uint256) := now(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
payoutBalance = int256(holdoverBalance)

IRs:
TMP_161 = CONVERT holdoverBalance to int256
payoutBalance(int256) := TMP_161(int256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
prOrigPayoutBal = payoutBalance

IRs:
prOrigPayoutBal(int256) := payoutBalance(int256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
prOrigTokensMint = totalTokensMinted

IRs:
prOrigTokensMint(uint256) := totalTokensMinted(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holdoverBalance = 0

IRs:
holdoverBalance(uint256) := 0(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
StatEventI(StartRun,uint256(curPayoutId))

IRs:
TMP_162 = CONVERT curPayoutId to uint256
Emit StatEventI(StartRun,TMP_162)"];
15->53;
16[label="Node Type: IF 16

EXPRESSION:
payoutBalance > 0

IRs:
TMP_164(bool) = payoutBalance > 0
CONDITION TMP_164"];
16->17[label="True"];
16->52[label="False"];
17[label="Node Type: NEW VARIABLE 17
"];
17->18;
18[label="Node Type: NEW VARIABLE 18

EXPRESSION:
nPerTokDistrib = uint256(prOrigPayoutBal) / prOrigTokensMint

IRs:
TMP_165 = CONVERT prOrigPayoutBal to uint256
TMP_166(uint256) = TMP_165 / prOrigTokensMint
nPerTokDistrib(uint256) := TMP_166(uint256)"];
18->19;
19[label="Node Type: NEW VARIABLE 19

EXPRESSION:
paids = 0

IRs:
paids(uint256) := 0(uint256)"];
19->20;
20[label="Node Type: NEW VARIABLE 20
"];
20->23;
21[label="Node Type: BEGIN_LOOP 21
"];
21->24;
22[label="Node Type: END_LOOP 22
"];
22->42;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
i = lastPayoutIndex

IRs:
i(uint256) := lastPayoutIndex(uint256)"];
23->21;
24[label="Node Type: IF_LOOP 24

EXPRESSION:
(paids < maxPaysPer) && (i < numAccounts) && (payoutBalance > 0)

IRs:
TMP_167(bool) = paids < maxPaysPer
TMP_168(bool) = i < numAccounts
TMP_169(bool) = TMP_167 && TMP_168
TMP_170(bool) = payoutBalance > 0
TMP_171(bool) = TMP_169 && TMP_170
CONDITION TMP_171"];
24->25[label="True"];
24->22[label="False"];
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
a = holderIndexes[i]

IRs:
REF_94(address) -> holderIndexes[i]
a(address) := REF_94(address)"];
25->26;
26[label="Node Type: IF 26

EXPRESSION:
a == address(0)

IRs:
TMP_172 = CONVERT 0 to address
TMP_173(bool) = a == TMP_172
CONDITION TMP_173"];
26->27[label="True"];
26->28[label="False"];
27[label="Node Type: CONTINUE 27
"];
27->41;
28[label="Node Type: END_IF 28
"];
28->29;
29[label="Node Type: NEW VARIABLE 29
"];
29->30;
30[label="Node Type: NEW VARIABLE 30
"];
30->31;
31[label="Node Type: EXPRESSION 31

EXPRESSION:
(pid,held) = getPayIdAndHeld(holderAccounts[a].tokens)

IRs:
REF_95(E4Token.tokenAccount) -> holderAccounts[a]
REF_96(uint256) -> REF_95.tokens
TUPLE_2(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_96)
pid(uint256)= UNPACK TUPLE_2 index: 0 
held(uint256)= UNPACK TUPLE_2 index: 1 "];
31->32;
32[label="Node Type: IF 32

EXPRESSION:
(held > 0) && (pid != curPayoutId)

IRs:
TMP_174(bool) = held > 0
TMP_175(bool) = pid != curPayoutId
TMP_176(bool) = TMP_174 && TMP_175
CONDITION TMP_176"];
32->33[label="True"];
32->40[label="False"];
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nAmount = nPerTokDistrib * held

IRs:
TMP_177(uint256) = nPerTokDistrib * held
nAmount(uint256) := TMP_177(uint256)"];
33->34;
34[label="Node Type: IF 34

EXPRESSION:
int256(nAmount) <= payoutBalance

IRs:
TMP_178 = CONVERT nAmount to int256
TMP_179(bool) = TMP_178 <= payoutBalance
CONDITION TMP_179"];
34->35[label="True"];
34->39[label="False"];
35[label="Node Type: EXPRESSION 35

EXPRESSION:
holderAccounts[a].balance += nAmount

IRs:
REF_97(E4Token.tokenAccount) -> holderAccounts[a]
REF_98(uint256) -> REF_97.balance
REF_98(-> holderAccounts) = REF_98 + nAmount"];
35->36;
36[label="Node Type: EXPRESSION 36

EXPRESSION:
holderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held

IRs:
REF_99(E4Token.tokenAccount) -> holderAccounts[a]
REF_100(uint256) -> REF_99.tokens
TMP_180(uint256) = 2 ** 48
TMP_181(uint256) = curPayoutId * TMP_180
TMP_182(uint256) = TMP_181 | held
REF_100(uint256) (->holderAccounts) := TMP_182(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
payoutBalance -= int256(nAmount)

IRs:
TMP_183 = CONVERT nAmount to int256
payoutBalance(int256) = payoutBalance - TMP_183"];
37->38;
38[label="Node Type: EXPRESSION 38

EXPRESSION:
paids ++

IRs:
TMP_184(uint256) := paids(uint256)
paids(uint256) = paids + 1"];
38->39;
39[label="Node Type: END_IF 39
"];
39->40;
40[label="Node Type: END_IF 40
"];
40->41;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
i ++

IRs:
TMP_185(uint256) := i(uint256)
i(uint256) = i + 1"];
41->24;
42[label="Node Type: EXPRESSION 42

EXPRESSION:
lastPayoutIndex = i

IRs:
lastPayoutIndex(uint256) := i(uint256)"];
42->43;
43[label="Node Type: IF 43

EXPRESSION:
lastPayoutIndex >= numAccounts || payoutBalance <= 0

IRs:
TMP_186(bool) = lastPayoutIndex >= numAccounts
TMP_187(bool) = payoutBalance <= 0
TMP_188(bool) = TMP_186 || TMP_187
CONDITION TMP_188"];
43->44[label="True"];
43->50[label="False"];
44[label="Node Type: EXPRESSION 44

EXPRESSION:
lastPayoutIndex = 0

IRs:
lastPayoutIndex(uint256) := 0(uint256)"];
44->45;
45[label="Node Type: IF 45

EXPRESSION:
payoutBalance > 0

IRs:
TMP_189(bool) = payoutBalance > 0
CONDITION TMP_189"];
45->46[label="True"];
45->47[label="False"];
46[label="Node Type: EXPRESSION 46

EXPRESSION:
holdoverBalance += uint256(payoutBalance)

IRs:
TMP_190 = CONVERT payoutBalance to uint256
holdoverBalance(uint256) = holdoverBalance + TMP_190"];
46->47;
47[label="Node Type: END_IF 47
"];
47->48;
48[label="Node Type: EXPRESSION 48

EXPRESSION:
payoutBalance = 0

IRs:
payoutBalance(int256) := 0(int256)"];
48->49;
49[label="Node Type: EXPRESSION 49

EXPRESSION:
StatEventI(RunComplete,uint256(prOrigPayoutBal))

IRs:
TMP_191 = CONVERT prOrigPayoutBal to uint256
Emit StatEventI(RunComplete,TMP_191)"];
49->51;
50[label="Node Type: EXPRESSION 50

EXPRESSION:
StatEventI(PayRun,nPerTokDistrib)

IRs:
Emit StatEventI(PayRun,nPerTokDistrib)"];
50->51;
51[label="Node Type: END_IF 51
"];
51->52;
52[label="Node Type: END_IF 52
"];
52->53;
53[label="Node Type: END_IF 53
"];
}
// Function: 39483.sol-E4Token-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == e4_partner

IRs:
TMP_59(bool) = msg.sender == e4_partner
CONDITION TMP_59"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feePayment()

IRs:
INTERNAL_CALL, E4Token.feePayment()()"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
purchaseToken()

IRs:
INTERNAL_CALL, E4Token.purchaseToken()()"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 39483.sol-E4Token-feePayment()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != e4_partner

IRs:
TMP_79(bool) = msg.sender != e4_partner
CONDITION TMP_79"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(forbidden)

IRs:
Emit StatEvent(forbidden)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
nfvalue = msg.value

IRs:
nfvalue(uint256) := msg.value(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
holdoverBalance += nfvalue

IRs:
holdoverBalance(uint256) = holdoverBalance + nfvalue"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
partnerCredits += nfvalue

IRs:
partnerCredits(uint256) = partnerCredits + nfvalue"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
StatEventI(Payment,nfvalue)

IRs:
Emit StatEventI(Payment,nfvalue)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
holdoverBalance > payoutThreshold || payoutBalance > 0

IRs:
TMP_83(bool) = holdoverBalance > payoutThreshold
TMP_84(bool) = payoutBalance > 0
TMP_85(bool) = TMP_83 || TMP_84
CONDITION TMP_85"];
10->11[label="True"];
10->12[label="False"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
doPayout()

IRs:
INTERNAL_CALL, E4Token.doPayout()()"];
11->12;
12[label="Node Type: END_IF 12
"];
}
// Function: 39483.sol-E4Token-flushDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(msg.sender != owner) && (msg.sender != developers)

IRs:
TMP_253(bool) = msg.sender != owner
TMP_254(bool) = msg.sender != developers
TMP_255(bool) = TMP_253 && TMP_254
CONDITION TMP_255"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
holdoverBalance > 0 || payoutBalance > 0

IRs:
TMP_256(bool) = holdoverBalance > 0
TMP_257(bool) = payoutBalance > 0
TMP_258(bool) = TMP_256 || TMP_257
CONDITION TMP_258"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
doPayout()

IRs:
INTERNAL_CALL, E4Token.doPayout()()"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 39483.sol-E4Token-getHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_20(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_20(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_held

IRs:
RETURN _held"];
}
// Function: 39483.sol-E4Token-getIcoInfo()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_status = icoStatus

IRs:
_status(E4Token.IcoStatusValue) := icoStatus(E4Token.IcoStatusValue)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_saleStart = fundingStart

IRs:
_saleStart(uint256) := fundingStart(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_saleEnd = fundingDeadline

IRs:
_saleEnd(uint256) := fundingDeadline(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_usageEnd = usageDeadline

IRs:
_usageEnd(uint256) := usageDeadline(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_vest = vestTime

IRs:
_vest(uint256) := vestTime(uint256)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_saleGoal = minIcoTokenGoal

IRs:
_saleGoal(uint256) := minIcoTokenGoal(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_usageGoal = minUsageGoal

IRs:
_usageGoal(uint256) := minUsageGoal(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
_sold = getNumTokensPurchased()

IRs:
TMP_251(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
_sold(uint256) := TMP_251(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_used = getNumGames()

IRs:
TMP_252(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
_used(uint256) := TMP_252(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
_funds = totalTokenFundsReceived

IRs:
_funds(uint256) := totalTokenFundsReceived(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
_credits = partnerCredits

IRs:
_credits(uint256) := partnerCredits(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_remuStage = remunerationStage

IRs:
_remuStage(uint256) := remunerationStage(uint256)"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
(_status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest)

IRs:
RETURN _status,_saleStart,_saleEnd,_usageEnd,_saleGoal,_usageGoal,_sold,_used,_funds,_credits,_remuStage,_vest"];
}
// Function: 39483.sol-E4Token-getNumGames()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
e4_partner != address(0)

IRs:
TMP_94 = CONVERT 0 to address
TMP_95(bool) = e4_partner != TMP_94
CONDITION TMP_95"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
pe4 = iE4RowEscrow(e4_partner)

IRs:
TMP_96 = CONVERT e4_partner to iE4RowEscrow
pe4(iE4RowEscrow) := TMP_96(iE4RowEscrow)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_games = uint256(pe4.getNumGamesStarted())

IRs:
TMP_97(int256) = HIGH_LEVEL_CALL, dest:pe4(iE4RowEscrow), function:getNumGamesStarted, arguments:[]  
TMP_98 = CONVERT TMP_97 to uint256
_games(uint256) := TMP_98(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_games

IRs:
RETURN _games"];
}
// Function: 39483.sol-E4Token-getNumTokensPurchased()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_purchased = totalTokensMinted - numDevTokens

IRs:
TMP_93(uint256) = totalTokensMinted - numDevTokens
_purchased(uint256) := TMP_93(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_purchased

IRs:
RETURN _purchased"];
}
// Function: 39483.sol-E4Token-getOpGas()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_rm = rmGas

IRs:
_rm(uint256) := rmGas(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_rf = rfGas

IRs:
_rf(uint256) := rfGas(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_rw = rwGas

IRs:
_rw(uint256) := rwGas(uint256)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
(_rm,_rf,_rw)

IRs:
RETURN _rm,_rf,_rw"];
}
// Function: 39483.sol-E4Token-getPayIdAndHeld(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_payId = (_tokHeld / (2 ** 48)) & 0xffff

IRs:
TMP_16(uint256) = 2 ** 48
TMP_17(uint256) = _tokHeld / TMP_16
TMP_18(uint256) = TMP_17 & 65535
_payId(uint256) := TMP_18(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_held = _tokHeld & 0xffffffffffff

IRs:
TMP_19(uint256) = _tokHeld & 281474976710655
_held(uint256) := TMP_19(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
(_payId,_held)

IRs:
RETURN _payId,_held"];
}
// Function: 39483.sol-E4Token-getSpecialAddresses()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_fndr = founderOrg

IRs:
_fndr(address) := founderOrg(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_aux = auxPartner

IRs:
_aux(address) := auxPartner(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_dev = developers

IRs:
_dev(address) := developers(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_e4 = e4_partner

IRs:
_e4(address) := e4_partner(address)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
(_fndr,_aux,_dev,_e4)

IRs:
RETURN _fndr,_aux,_dev,_e4"];
}
// Function: 39483.sol-E4Token-haraKiri()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
settingsState != SettingStateValue.debug

IRs:
REF_126(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_248(bool) = settingsState != REF_126
CONDITION TMP_248"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
msg.sender != owner

IRs:
TMP_249(bool) = msg.sender != owner
CONDITION TMP_249"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: THROW 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
suicide(address)(developers)

IRs:
TMP_250(None) = SOLIDITY_CALL suicide(address)(developers)"];
}
// Function: 39483.sol-E4Token-holderExists(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_exist = holderAccounts[_addr].alloced

IRs:
REF_51(E4Token.tokenAccount) -> holderAccounts[_addr]
REF_52(bool) -> REF_51.alloced
_exist(bool) := REF_52(bool)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_exist

IRs:
RETURN _exist"];
}
// Function: 39483.sol-E4Token-icoCheckup()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_206(bool) = msg.sender != owner
TMP_207(bool) = msg.sender != developers
TMP_208(bool) = TMP_206 && TMP_207
CONDITION TMP_208"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: IF 5

EXPRESSION:
icoStatus == IcoStatusValue.saleClosed

IRs:
REF_114(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
TMP_209(bool) = icoStatus == REF_114
CONDITION TMP_209"];
5->6[label="True"];
5->12[label="False"];
6[label="Node Type: IF 6

EXPRESSION:
(getNumTokensPurchased() >= minIcoTokenGoal) && (remunerationStage == 0)

IRs:
TMP_210(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_211(bool) = TMP_210 >= minIcoTokenGoal
TMP_212(bool) = remunerationStage == 0
TMP_213(bool) = TMP_211 && TMP_212
CONDITION TMP_213"];
6->7[label="True"];
6->11[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_214(uint256) = totalTokenFundsReceived / 100
TMP_215(uint256) = TMP_214 * 9
remunerationBalance(uint256) := TMP_215(uint256)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_216(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_216(uint256)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nmsgmask |= 1

IRs:
nmsgmask(uint256) = nmsgmask | 1"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: IF 13

EXPRESSION:
icoStatus == IcoStatusValue.succeeded

IRs:
REF_115(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_217(bool) = icoStatus == REF_115
CONDITION TMP_217"];
13->14[label="True"];
13->25[label="False"];
14[label="Node Type: IF 14

EXPRESSION:
remunerationStage == 0

IRs:
TMP_218(bool) = remunerationStage == 0
CONDITION TMP_218"];
14->15[label="True"];
14->19[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
remunerationStage = 1

IRs:
remunerationStage(uint256) := 1(uint256)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
remunerationBalance = (totalTokenFundsReceived / 100) * 9

IRs:
TMP_219(uint256) = totalTokenFundsReceived / 100
TMP_220(uint256) = TMP_219 * 9
remunerationBalance(uint256) := TMP_220(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
auxPartnerBalance = (totalTokenFundsReceived / 100)

IRs:
TMP_221(uint256) = totalTokenFundsReceived / 100
auxPartnerBalance(uint256) := TMP_221(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
nmsgmask |= 4

IRs:
nmsgmask(uint256) = nmsgmask | 4"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
remunerationStage == 1

IRs:
TMP_222(bool) = remunerationStage == 1
CONDITION TMP_222"];
20->21[label="True"];
20->24[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
remunerationStage = 2

IRs:
remunerationStage(uint256) := 2(uint256)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived / 10)

IRs:
TMP_223(uint256) = totalTokenFundsReceived / 10
TMP_224(uint256) = totalTokenFundsReceived - TMP_223
remunerationBalance(uint256) = remunerationBalance + TMP_224"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
nmsgmask |= 8

IRs:
nmsgmask(uint256) = nmsgmask | 8"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
25->26;
26[label="Node Type: NEW VARIABLE 26
"];
26->27;
27[label="Node Type: IF 27

EXPRESSION:
remunerationBalance > 0

IRs:
TMP_225(bool) = remunerationBalance > 0
CONDITION TMP_225"];
27->28[label="True"];
27->35[label="False"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
ntmp = remunerationBalance

IRs:
ntmp(uint256) := remunerationBalance(uint256)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
remunerationBalance = 0

IRs:
remunerationBalance(uint256) := 0(uint256)"];
29->30;
30[label="Node Type: IF 30

EXPRESSION:
! founderOrg.call.gas(rmGas).value(ntmp)()

IRs:
TMP_228(bool) = LOW_LEVEL_CALL, dest:founderOrg, function:call, arguments:[] value:ntmp gas:rmGas
TMP_229 = UnaryType.BANG TMP_228 
CONDITION TMP_229"];
30->31[label="True"];
30->33[label="False"];
31[label="Node Type: EXPRESSION 31

EXPRESSION:
remunerationBalance = ntmp

IRs:
remunerationBalance(uint256) := ntmp(uint256)"];
31->32;
32[label="Node Type: EXPRESSION 32

EXPRESSION:
nmsgmask |= 32

IRs:
nmsgmask(uint256) = nmsgmask | 32"];
32->34;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
nmsgmask |= 64

IRs:
nmsgmask(uint256) = nmsgmask | 64"];
33->34;
34[label="Node Type: END_IF 34
"];
34->44;
35[label="Node Type: IF 35

EXPRESSION:
auxPartnerBalance > 0

IRs:
TMP_230(bool) = auxPartnerBalance > 0
CONDITION TMP_230"];
35->36[label="True"];
35->43[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
ntmp = auxPartnerBalance

IRs:
ntmp(uint256) := auxPartnerBalance(uint256)"];
36->37;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
auxPartnerBalance = 0

IRs:
auxPartnerBalance(uint256) := 0(uint256)"];
37->38;
38[label="Node Type: IF 38

EXPRESSION:
! auxPartner.call.gas(rmGas).value(ntmp)()

IRs:
TMP_233(bool) = LOW_LEVEL_CALL, dest:auxPartner, function:call, arguments:[] value:ntmp gas:rmGas
TMP_234 = UnaryType.BANG TMP_233 
CONDITION TMP_234"];
38->39[label="True"];
38->41[label="False"];
39[label="Node Type: EXPRESSION 39

EXPRESSION:
auxPartnerBalance = ntmp

IRs:
auxPartnerBalance(uint256) := ntmp(uint256)"];
39->40;
40[label="Node Type: EXPRESSION 40

EXPRESSION:
nmsgmask |= 128

IRs:
nmsgmask(uint256) = nmsgmask | 128"];
40->42;
41[label="Node Type: EXPRESSION 41

EXPRESSION:
nmsgmask |= 256

IRs:
nmsgmask(uint256) = nmsgmask | 256"];
41->42;
42[label="Node Type: END_IF 42
"];
42->43;
43[label="Node Type: END_IF 43
"];
43->44;
44[label="Node Type: END_IF 44
"];
44->45;
45[label="Node Type: EXPRESSION 45

EXPRESSION:
StatEventI(ico-checkup,nmsgmask)

IRs:
Emit StatEventI(ico-checkup,nmsgmask)"];
}
// Function: 39483.sol-E4Token-purchaseToken()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nvalue = msg.value

IRs:
nvalue(uint256) := msg.value(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
npurchaser = msg.sender

IRs:
npurchaser(address) := msg.sender(address)"];
2->3;
3[label="Node Type: IF 3

EXPRESSION:
nvalue < tokenPrice

IRs:
TMP_62(bool) = nvalue < tokenPrice
CONDITION TMP_62"];
3->4[label="True"];
3->5[label="False"];
4[label="Node Type: THROW 4
"];
5[label="Node Type: END_IF 5
"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
qty = nvalue / tokenPrice

IRs:
TMP_63(uint256) = nvalue / tokenPrice
qty(uint256) := TMP_63(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
icoStatus != IcoStatusValue.saleOpen

IRs:
REF_53(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_65(bool) = icoStatus != REF_53
CONDITION TMP_65"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: THROW 9
"];
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
totalTokensMinted + qty > maxMintableTokens

IRs:
TMP_66(uint256) = totalTokensMinted + qty
TMP_67(bool) = TMP_66 > maxMintableTokens
CONDITION TMP_67"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: THROW 12
"];
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
! holderAccounts[npurchaser].alloced

IRs:
REF_54(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_55(bool) -> REF_54.alloced
TMP_68 = UnaryType.BANG REF_55 
CONDITION TMP_68"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
addAccount(npurchaser)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(npurchaser)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: NEW VARIABLE 17

EXPRESSION:
newHeld = qty + getHeld(holderAccounts[npurchaser].tokens)

IRs:
REF_56(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_57(uint256) -> REF_56.tokens
TMP_70(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_57)
TMP_71(uint256) = qty + TMP_70
newHeld(uint256) := TMP_71(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48))

IRs:
REF_58(E4Token.tokenAccount) -> holderAccounts[npurchaser]
REF_59(uint256) -> REF_58.tokens
TMP_72(uint256) = 2 ** 48
TMP_73(uint256) = curPayoutId * TMP_72
TMP_74(uint256) = newHeld | TMP_73
REF_59(uint256) (->holderAccounts) := TMP_74(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
totalTokensMinted += qty

IRs:
totalTokensMinted(uint256) = totalTokensMinted + qty"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
totalTokenFundsReceived += nvalue

IRs:
totalTokenFundsReceived(uint256) = totalTokenFundsReceived + nvalue"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
totalTokensMinted == maxMintableTokens

IRs:
TMP_75(bool) = totalTokensMinted == maxMintableTokens
CONDITION TMP_75"];
21->22[label="True"];
21->25[label="False"];
22[label="Node Type: EXPRESSION 22

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_60(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_60(E4Token.IcoStatusValue)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
23->24;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
StatEventI(Purchased,Granted,qty)

IRs:
Emit StatEventI(Purchased,Granted,qty)"];
24->26;
25[label="Node Type: EXPRESSION 25

EXPRESSION:
StatEventI(Purchased,qty)

IRs:
Emit StatEventI(Purchased,qty)"];
25->26;
26[label="Node Type: END_IF 26
"];
}
// Function: 39483.sol-E4Token-requestRefund()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
nrequester = msg.sender

IRs:
nrequester(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
updateIcoStatus()

IRs:
INTERNAL_CALL, E4Token.updateIcoStatus()()"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
ntokens = getHeld(holderAccounts[nrequester].tokens)

IRs:
REF_74(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_75(uint256) -> REF_74.tokens
TMP_136(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_75)
ntokens(uint256) := TMP_136(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
icoStatus != IcoStatusValue.failed

IRs:
REF_76(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_137(bool) = icoStatus != REF_76
CONDITION TMP_137"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(No Refund)

IRs:
Emit StatEvent(No Refund)"];
5->25;
6[label="Node Type: IF 6

EXPRESSION:
ntokens == 0

IRs:
TMP_139(bool) = ntokens == 0
CONDITION TMP_139"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
StatEvent(No Tokens)

IRs:
Emit StatEvent(No Tokens)"];
7->24;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
nrefund = ntokens * tokenPrice

IRs:
TMP_141(uint256) = ntokens * tokenPrice
nrefund(uint256) := TMP_141(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_142(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_143(bool) = TMP_142 >= minIcoTokenGoal
CONDITION TMP_143"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
nrefund -= (nrefund / 10)

IRs:
TMP_144(uint256) = nrefund / 10
nrefund(uint256) = nrefund - TMP_144"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
holderAccounts[developers].tokens += ntokens

IRs:
REF_77(E4Token.tokenAccount) -> holderAccounts[developers]
REF_78(uint256) -> REF_77.tokens
REF_78(-> holderAccounts) = REF_78 + ntokens"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[nrequester].tokens = 0

IRs:
REF_79(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_80(uint256) -> REF_79.tokens
REF_80(uint256) (->holderAccounts) := 0(uint256)"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
holderAccounts[nrequester].balance > 0

IRs:
REF_81(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_82(uint256) -> REF_81.balance
TMP_145(bool) = REF_82 > 0
CONDITION TMP_145"];
14->15[label="True"];
14->20[label="False"];
15[label="Node Type: IF 15

EXPRESSION:
! holderAccounts[developers].alloced

IRs:
REF_83(E4Token.tokenAccount) -> holderAccounts[developers]
REF_84(bool) -> REF_83.alloced
TMP_146 = UnaryType.BANG REF_84 
CONDITION TMP_146"];
15->16[label="True"];
15->17[label="False"];
16[label="Node Type: EXPRESSION 16

EXPRESSION:
addAccount(developers)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(developers)"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
holderAccounts[developers].balance += holderAccounts[nrequester].balance

IRs:
REF_85(E4Token.tokenAccount) -> holderAccounts[developers]
REF_86(uint256) -> REF_85.balance
REF_87(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_88(uint256) -> REF_87.balance
REF_86(-> holderAccounts) = REF_86 + REF_88"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
holderAccounts[nrequester].balance = 0

IRs:
REF_89(E4Token.tokenAccount) -> holderAccounts[nrequester]
REF_90(uint256) -> REF_89.balance
REF_90(uint256) (->holderAccounts) := 0(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: IF 21

EXPRESSION:
! nrequester.call.gas(rfGas).value(nrefund)()

IRs:
TMP_150(bool) = LOW_LEVEL_CALL, dest:nrequester, function:call, arguments:[] value:nrefund gas:rfGas
TMP_151 = UnaryType.BANG TMP_150 
CONDITION TMP_151"];
21->22[label="True"];
21->23[label="False"];
22[label="Node Type: THROW 22
"];
23[label="Node Type: END_IF 23
"];
23->24;
24[label="Node Type: END_IF 24
"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39483.sol-E4Token-setE4RowPartner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_87(bool) = msg.sender == owner
CONDITION TMP_87"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: IF 2

EXPRESSION:
(e4_partner == address(0)) || (settingsState == SettingStateValue.debug)

IRs:
TMP_88 = CONVERT 0 to address
TMP_89(bool) = e4_partner == TMP_88
REF_61(E4Token.SettingStateValue) -> SettingStateValue.debug
TMP_90(bool) = settingsState == REF_61
TMP_91(bool) = TMP_89 || TMP_90
CONDITION TMP_91"];
2->3[label="True"];
2->5[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
e4_partner = _addr

IRs:
e4_partner(address) := _addr(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
partnerCredits = 0

IRs:
partnerCredits(uint256) := 0(uint256)"];
4->6;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
StatEvent(Already Set)

IRs:
Emit StatEvent(Already Set)"];
5->6;
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: END_IF 7
"];
}
// Function: 39483.sol-E4Token-setOpGas(uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != developers

IRs:
TMP_203(bool) = msg.sender != owner
TMP_204(bool) = msg.sender != developers
TMP_205(bool) = TMP_203 && TMP_204
CONDITION TMP_205"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
rmGas = _rm

IRs:
rmGas(uint256) := _rm(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
rfGas = _rf

IRs:
rfGas(uint256) := _rf(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
rwGas = _rw

IRs:
rwGas(uint256) := _rw(uint256)"];
5->6;
6[label="Node Type: END_IF 6
"];
}
// Function: 39483.sol-E4Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen || icoStatus == IcoStatusValue.anouncement

IRs:
REF_17(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_24(bool) = icoStatus == REF_17
REF_18(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_25(bool) = icoStatus == REF_18
TMP_26(bool) = TMP_24 || TMP_25
CONDITION TMP_26"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supply = maxMintableTokens

IRs:
supply(uint256) := maxMintableTokens(uint256)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
supply = totalTokensMinted

IRs:
supply(uint256) := totalTokensMinted(uint256)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 39483.sol-E4Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_27(bool) = msg.sender == developers
TMP_28(bool) = now < vestTime
TMP_29(bool) = TMP_27 && TMP_28
CONDITION TMP_29"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens)

IRs:
REF_19(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_20(uint256) -> REF_19.tokens
TUPLE_0(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_20)
pidFrom(uint256)= UNPACK TUPLE_0 index: 0 
heldFrom(uint256)= UNPACK TUPLE_0 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && _value > 0

IRs:
TMP_30(bool) = heldFrom >= _value
TMP_31(bool) = _value > 0
TMP_32(bool) = TMP_30 && TMP_31
CONDITION TMP_32"];
7->8[label="True"];
7->16[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].tokens -= _value

IRs:
REF_21(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_22(uint256) -> REF_21.tokens
REF_22(-> holderAccounts) = REF_22 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_23(E4Token.tokenAccount) -> holderAccounts[_to]
REF_24(bool) -> REF_23.alloced
TMP_33 = UnaryType.BANG REF_24 
CONDITION TMP_33"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_25(E4Token.tokenAccount) -> holderAccounts[_to]
REF_26(uint256) -> REF_25.tokens
TMP_35(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_26)
TMP_36(uint256) = _value + TMP_35
newHeld(uint256) := TMP_36(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_27(E4Token.tokenAccount) -> holderAccounts[_to]
REF_28(uint256) -> REF_27.tokens
TMP_37(uint256) = 2 ** 48
TMP_38(uint256) = pidFrom * TMP_37
TMP_39(uint256) = newHeld | TMP_38
REF_28(uint256) (->holderAccounts) := TMP_39(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
14->15;
15[label="Node Type: RETURN 15

EXPRESSION:
true

IRs:
RETURN True"];
16[label="Node Type: RETURN 16

EXPRESSION:
false

IRs:
RETURN False"];
18[label="Node Type: RETURN 18

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39483.sol-E4Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
(_from == developers) && (now < vestTime)

IRs:
TMP_41(bool) = _from == developers
TMP_42(bool) = now < vestTime
TMP_43(bool) = TMP_41 && TMP_42
CONDITION TMP_43"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
(pidFrom,heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens)

IRs:
REF_29(E4Token.tokenAccount) -> holderAccounts[_from]
REF_30(uint256) -> REF_29.tokens
TUPLE_1(uint256,uint256) = INTERNAL_CALL, E4Token.getPayIdAndHeld(uint256)(REF_30)
pidFrom(uint256)= UNPACK TUPLE_1 index: 0 
heldFrom(uint256)= UNPACK TUPLE_1 index: 1 "];
6->7;
7[label="Node Type: IF 7

EXPRESSION:
heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
TMP_44(bool) = heldFrom >= _value
REF_31(mapping(address => uint256)) -> allowed[_from]
REF_32(uint256) -> REF_31[msg.sender]
TMP_45(bool) = REF_32 >= _value
TMP_46(bool) = TMP_44 && TMP_45
TMP_47(bool) = _value > 0
TMP_48(bool) = TMP_46 && TMP_47
CONDITION TMP_48"];
7->8[label="True"];
7->17[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[_from].tokens -= _value

IRs:
REF_33(E4Token.tokenAccount) -> holderAccounts[_from]
REF_34(uint256) -> REF_33.tokens
REF_34(-> holderAccounts) = REF_34 - _value"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! holderAccounts[_to].alloced

IRs:
REF_35(E4Token.tokenAccount) -> holderAccounts[_to]
REF_36(bool) -> REF_35.alloced
TMP_49 = UnaryType.BANG REF_36 
CONDITION TMP_49"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: EXPRESSION 10

EXPRESSION:
addAccount(_to)

IRs:
INTERNAL_CALL, E4Token.addAccount(address)(_to)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: NEW VARIABLE 12

EXPRESSION:
newHeld = _value + getHeld(holderAccounts[_to].tokens)

IRs:
REF_37(E4Token.tokenAccount) -> holderAccounts[_to]
REF_38(uint256) -> REF_37.tokens
TMP_51(uint256) = INTERNAL_CALL, E4Token.getHeld(uint256)(REF_38)
TMP_52(uint256) = _value + TMP_51
newHeld(uint256) := TMP_52(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48))

IRs:
REF_39(E4Token.tokenAccount) -> holderAccounts[_to]
REF_40(uint256) -> REF_39.tokens
TMP_53(uint256) = 2 ** 48
TMP_54(uint256) = pidFrom * TMP_53
TMP_55(uint256) = newHeld | TMP_54
REF_40(uint256) (->holderAccounts) := TMP_55(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_41(mapping(address => uint256)) -> allowed[_from]
REF_42(uint256) -> REF_41[msg.sender]
REF_42(-> allowed) = REF_42 - _value"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
15->16;
16[label="Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True"];
17[label="Node Type: RETURN 17

EXPRESSION:
false

IRs:
RETURN False"];
19[label="Node Type: RETURN 19

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39483.sol-E4Token-updateIcoStatus()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
icoStatus == IcoStatusValue.succeeded || icoStatus == IcoStatusValue.failed

IRs:
REF_63(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
TMP_99(bool) = icoStatus == REF_63
REF_64(E4Token.IcoStatusValue) -> IcoStatusValue.failed
TMP_100(bool) = icoStatus == REF_64
TMP_101(bool) = TMP_99 || TMP_100
CONDITION TMP_101"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2
"];
3[label="Node Type: IF 3

EXPRESSION:
icoStatus == IcoStatusValue.anouncement

IRs:
REF_65(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_102(bool) = icoStatus == REF_65
CONDITION TMP_102"];
3->4[label="True"];
3->10[label="False"];
4[label="Node Type: IF 4

EXPRESSION:
now > fundingStart && now <= fundingDeadline

IRs:
TMP_103(bool) = now > fundingStart
TMP_104(bool) = now <= fundingDeadline
TMP_105(bool) = TMP_103 && TMP_104
CONDITION TMP_105"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
icoStatus = IcoStatusValue.saleOpen

IRs:
REF_66(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
icoStatus(E4Token.IcoStatusValue) := REF_66(E4Token.IcoStatusValue)"];
5->9;
6[label="Node Type: IF 6

EXPRESSION:
now > fundingDeadline

IRs:
TMP_106(bool) = now > fundingDeadline
CONDITION TMP_106"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_67(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_67(E4Token.IcoStatusValue)"];
7->8;
8[label="Node Type: END_IF 8
"];
8->9;
9[label="Node Type: END_IF 9
"];
9->21;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
numP = getNumTokensPurchased()

IRs:
TMP_107(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
numP(uint256) := TMP_107(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
numG = getNumGames()

IRs:
TMP_108(uint256) = INTERNAL_CALL, E4Token.getNumGames()()
numG(uint256) := TMP_108(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
(now > fundingDeadline && numP < minIcoTokenGoal) || (now > usageDeadline && numG < minUsageGoal)

IRs:
TMP_109(bool) = now > fundingDeadline
TMP_110(bool) = numP < minIcoTokenGoal
TMP_111(bool) = TMP_109 && TMP_110
TMP_112(bool) = now > usageDeadline
TMP_113(bool) = numG < minUsageGoal
TMP_114(bool) = TMP_112 && TMP_113
TMP_115(bool) = TMP_111 || TMP_114
CONDITION TMP_115"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
icoStatus = IcoStatusValue.failed

IRs:
REF_68(E4Token.IcoStatusValue) -> IcoStatusValue.failed
icoStatus(E4Token.IcoStatusValue) := REF_68(E4Token.IcoStatusValue)"];
13->17;
14[label="Node Type: IF 14

EXPRESSION:
(now > fundingDeadline) && (numP >= minIcoTokenGoal) && (numG >= minUsageGoal)

IRs:
TMP_116(bool) = now > fundingDeadline
TMP_117(bool) = numP >= minIcoTokenGoal
TMP_118(bool) = TMP_116 && TMP_117
TMP_119(bool) = numG >= minUsageGoal
TMP_120(bool) = TMP_118 && TMP_119
CONDITION TMP_120"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
icoStatus = IcoStatusValue.succeeded

IRs:
REF_69(E4Token.IcoStatusValue) -> IcoStatusValue.succeeded
icoStatus(E4Token.IcoStatusValue) := REF_69(E4Token.IcoStatusValue)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: END_IF 17
"];
17->18;
18[label="Node Type: IF 18

EXPRESSION:
icoStatus == IcoStatusValue.saleOpen && ((numP >= maxMintableTokens) || (now > fundingDeadline))

IRs:
REF_70(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_121(bool) = icoStatus == REF_70
TMP_122(bool) = numP >= maxMintableTokens
TMP_123(bool) = now > fundingDeadline
TMP_124(bool) = TMP_122 || TMP_123
TMP_125(bool) = TMP_121 && TMP_124
CONDITION TMP_125"];
18->19[label="True"];
18->20[label="False"];
19[label="Node Type: EXPRESSION 19

EXPRESSION:
icoStatus = IcoStatusValue.saleClosed

IRs:
REF_71(E4Token.IcoStatusValue) -> IcoStatusValue.saleClosed
icoStatus(E4Token.IcoStatusValue) := REF_71(E4Token.IcoStatusValue)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: END_IF 21
"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: IF 23

EXPRESSION:
! developersGranted && icoStatus != IcoStatusValue.saleOpen && icoStatus != IcoStatusValue.anouncement && getNumTokensPurchased() >= minIcoTokenGoal

IRs:
TMP_126 = UnaryType.BANG developersGranted 
REF_72(E4Token.IcoStatusValue) -> IcoStatusValue.saleOpen
TMP_127(bool) = icoStatus != REF_72
TMP_128(bool) = TMP_126 && TMP_127
REF_73(E4Token.IcoStatusValue) -> IcoStatusValue.anouncement
TMP_129(bool) = icoStatus != REF_73
TMP_130(bool) = TMP_128 && TMP_129
TMP_131(uint256) = INTERNAL_CALL, E4Token.getNumTokensPurchased()()
TMP_132(bool) = TMP_131 >= minIcoTokenGoal
TMP_133(bool) = TMP_130 && TMP_132
CONDITION TMP_133"];
23->24[label="True"];
23->25[label="False"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
doDeveloperGrant()

IRs:
INTERNAL_CALL, E4Token.doDeveloperGrant()()"];
24->25;
25[label="Node Type: END_IF 25
"];
}
// Function: 39483.sol-E4Token-withdrawDividends()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
holderAccounts[msg.sender].balance == 0

IRs:
REF_101(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_102(uint256) -> REF_101.balance
TMP_194(bool) = REF_102 == 0
CONDITION TMP_194"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
StatEvent(0 Balance)

IRs:
Emit StatEvent(0 Balance)"];
2->3;
3[label="Node Type: RETURN 3
"];
4[label="Node Type: IF 4

EXPRESSION:
(msg.sender == developers) && (now < vestTime)

IRs:
TMP_196(bool) = msg.sender == developers
TMP_197(bool) = now < vestTime
TMP_198(bool) = TMP_196 && TMP_197
CONDITION TMP_198"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5
"];
6[label="Node Type: END_IF 6
"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_amount = holderAccounts[msg.sender].balance

IRs:
REF_103(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_104(uint256) -> REF_103.balance
_amount(uint256) := REF_104(uint256)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
holderAccounts[msg.sender].balance = 0

IRs:
REF_105(E4Token.tokenAccount) -> holderAccounts[msg.sender]
REF_106(uint256) -> REF_105.balance
REF_106(uint256) (->holderAccounts) := 0(uint256)"];
8->9;
9[label="Node Type: IF 9

EXPRESSION:
! msg.sender.call.gas(rwGas).value(_amount)()

IRs:
TMP_201(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_amount gas:rwGas
TMP_202 = UnaryType.BANG TMP_201 
CONDITION TMP_202"];
9->10[label="True"];
9->11[label="False"];
10[label="Node Type: THROW 10
"];
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: END_IF 12
"];
12->13;
13[label="Node Type: RETURN 13

EXPRESSION:
_amount

IRs:
RETURN _amount"];
}
// Function: 39483.sol-Token-allowance(address,address)
digraph{
}
// Function: 39483.sol-Token-approve(address,uint256)
digraph{
}
// Function: 39483.sol-Token-balanceOf(address)
digraph{
}
// Function: 39483.sol-Token-totalSupply()
digraph{
}
// Function: 39483.sol-Token-transfer(address,uint256)
digraph{
}
// Function: 39483.sol-Token-transferFrom(address,address,uint256)
digraph{
}
// Function: 39483.sol-iE4RowEscrow-getNumGamesStarted()
digraph{
}
}
