digraph G {
// Function: 39817.sol-ProfitContainerAdapter-ProfitContainerAdapter(address,address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
shopLocation = sL

IRs:
shopLocation(address) := sL(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
shopKeeperLocation = sKL

IRs:
shopKeeperLocation(address) := sKL(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
profitContainerLocation = pCL

IRs:
profitContainerLocation(address) := pCL(address)"];
}
// Function: 39817.sol-ProfitContainerAdapter-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_269 = UnaryType.BANG assertion 
CONDITION TMP_269"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39817.sol-ProfitContainerAdapter-changeContainer(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
profitContainerLocation = newContainer

IRs:
profitContainerLocation(address) := newContainer(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ProfitContainerAdapter.owned()()"];
2->1;
}
// Function: 39817.sol-ProfitContainerAdapter-changeKeeper(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shopKeeperLocation = newKeeper

IRs:
shopKeeperLocation(address) := newKeeper(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ProfitContainerAdapter.owned()()"];
2->1;
}
// Function: 39817.sol-ProfitContainerAdapter-changeShop(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shopLocation = newShop

IRs:
shopLocation(address) := newShop(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ProfitContainerAdapter.owned()()"];
2->1;
}
// Function: 39817.sol-ProfitContainerAdapter-giveAwayHoldership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
ShopKeeper(shopKeeperLocation).giveAwayOwnership(holderB)

IRs:
TMP_291 = CONVERT shopKeeperLocation to ShopKeeper
HIGH_LEVEL_CALL, dest:TMP_291(ShopKeeper), function:giveAwayOwnership, arguments:['holderB']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ProfitContainerAdapter.owned()()"];
2->1;
}
// Function: 39817.sol-ProfitContainerAdapter-giveAwayOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = newOwner

IRs:
owner(address) := newOwner(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ProfitContainerAdapter.owned()()"];
2->1;
}
// Function: 39817.sol-ProfitContainerAdapter-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(msg.sender == owner)

IRs:
TMP_295(bool) = msg.sender == owner
INTERNAL_CALL, SafeMath.assert(bool)(TMP_295)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 39817.sol-ProfitContainerAdapter-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_264(uint256) = a + b
c(uint256) := TMP_264(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_265(bool) = c >= a
TMP_266(bool) = c >= b
TMP_267(bool) = TMP_265 && TMP_266
INTERNAL_CALL, SafeMath.assert(bool)(TMP_267)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ProfitContainerAdapter-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_255(uint256) = a * b
c(uint256) := TMP_255(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_256(bool) = a == 0
TMP_257(uint256) = c / a
TMP_258(bool) = TMP_257 == b
TMP_259(bool) = TMP_256 || TMP_258
INTERNAL_CALL, SafeMath.assert(bool)(TMP_259)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ProfitContainerAdapter-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_261(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_261)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_263(uint256) = a - b
c(uint256) := TMP_263(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ProfitContainerAdapter-takeEtherProfits()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
ShopKeeper(shopKeeperLocation).splitProfits()

IRs:
TMP_273 = CONVERT shopKeeperLocation to ShopKeeper
HIGH_LEVEL_CALL, dest:TMP_273(ShopKeeper), function:splitProfits, arguments:[]  "];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
shop = ValueTrader(shopLocation)

IRs:
TMP_275 = CONVERT shopLocation to ValueTrader
shop(ValueTrader) := TMP_275(ValueTrader)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
shop.buyEther(shop.balanceOf(this))

IRs:
TMP_276(uint256) = HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:balanceOf, arguments:['this']  
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:buyEther, arguments:['TMP_276']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(profitContainerLocation.call.value(this.balance)())

IRs:
REF_110(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_279(bool) = LOW_LEVEL_CALL, dest:profitContainerLocation, function:call, arguments:[] value:REF_110 
INTERNAL_CALL, SafeMath.assert(bool)(TMP_279)"];
}
// Function: 39817.sol-ProfitContainerAdapter-takeTokenProfits(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
ShopKeeper(shopKeeperLocation).splitProfits()

IRs:
TMP_281 = CONVERT shopKeeperLocation to ShopKeeper
HIGH_LEVEL_CALL, dest:TMP_281(ShopKeeper), function:splitProfits, arguments:[]  "];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
shop = ValueTrader(shopLocation)

IRs:
TMP_283 = CONVERT shopLocation to ValueTrader
shop(ValueTrader) := TMP_283(ValueTrader)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
shop.buyToken(token,shop.balanceOf(this))

IRs:
TMP_284(uint256) = HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:balanceOf, arguments:['this']  
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:buyToken, arguments:['token', 'TMP_284']  "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this)))

IRs:
TMP_286 = CONVERT token to Token
TMP_287 = CONVERT token to Token
TMP_288(uint256) = HIGH_LEVEL_CALL, dest:TMP_287(Token), function:balanceOf, arguments:['this']  
TMP_289(bool) = HIGH_LEVEL_CALL, dest:TMP_286(Token), function:transfer, arguments:['profitContainerLocation', 'TMP_288']  
INTERNAL_CALL, SafeMath.assert(bool)(TMP_289)"];
}
// Function: 39817.sol-SafeMath-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_14 = UnaryType.BANG assertion 
CONDITION TMP_14"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39817.sol-SafeMath-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_10(bool) = c >= a
TMP_11(bool) = c >= b
TMP_12(bool) = TMP_10 && TMP_11
INTERNAL_CALL, SafeMath.assert(bool)(TMP_12)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-SafeMath-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_0(uint256) = a * b
c(uint256) := TMP_0(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_1(bool) = a == 0
TMP_2(uint256) = c / a
TMP_3(bool) = TMP_2 == b
TMP_4(bool) = TMP_1 || TMP_3
INTERNAL_CALL, SafeMath.assert(bool)(TMP_4)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-SafeMath-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_6(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_6)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_8(uint256) = a - b
c(uint256) := TMP_8(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ShopKeeper-ShopKeeper(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop = new ValueTrader()

IRs:
TMP_216(ValueTrader) = new ValueTrader() 
shop(ValueTrader) := TMP_216(ValueTrader)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
holderA = msg.sender

IRs:
holderA(address) := msg.sender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
holderB = other

IRs:
holderB(address) := other(address)"];
}
// Function: 39817.sol-ShopKeeper-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_214 = UnaryType.BANG assertion 
CONDITION TMP_214"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39817.sol-ShopKeeper-callDividend(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.callDividend(token_)

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:callDividend, arguments:['token_']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyA()

IRs:
MODIFIER_CALL, ShopKeeper.onlyA()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-changeEtherContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.changeEtherContract(eC)

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:changeEtherContract, arguments:['eC']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyHolders()

IRs:
MODIFIER_CALL, ShopKeeper.onlyHolders()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-changeFee(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.changeFee(tradeFee)

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:changeFee, arguments:['tradeFee']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyHolders()

IRs:
MODIFIER_CALL, ShopKeeper.onlyHolders()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
holderB == holderA

IRs:
TMP_239(bool) = holderB == holderA
CONDITION TMP_239"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
shop.changeOwner(owner_)

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:changeOwner, arguments:['owner_']  "];
2->3;
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
holderA = owner_

IRs:
holderA(address) := owner_(address)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyA()

IRs:
MODIFIER_CALL, ShopKeeper.onlyA()()"];
5->1;
}
// Function: 39817.sol-ShopKeeper-changeShop(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: IF 1

EXPRESSION:
holderB == holderA

IRs:
TMP_242(bool) = holderB == holderA
CONDITION TMP_242"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
shop = ValueTrader(newShop)

IRs:
TMP_243 = CONVERT newShop to ValueTrader
shop(ValueTrader) := TMP_243(ValueTrader)"];
2->3;
3[label="Node Type: END_IF 3
"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyA()

IRs:
MODIFIER_CALL, ShopKeeper.onlyA()()"];
4->1;
}
// Function: 39817.sol-ShopKeeper-configureTokenDividend(address,bool,address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.configureTokenDividend(token_,hD_,dA_,dD_)

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:configureTokenDividend, arguments:['token_', 'hD_', 'dA_', 'dD_']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyA()

IRs:
MODIFIER_CALL, ShopKeeper.onlyA()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-die()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.die()

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:die, arguments:[]  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyA()

IRs:
MODIFIER_CALL, ShopKeeper.onlyA()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: THROW 1
"];
}
// Function: 39817.sol-ShopKeeper-giveAwayOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: IF 1

EXPRESSION:
msg.sender == holderB

IRs:
TMP_217(bool) = msg.sender == holderB
CONDITION TMP_217"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
holderB = newHolder

IRs:
holderB(address) := newHolder(address)"];
2->4;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
holderA = newHolder

IRs:
holderA(address) := newHolder(address)"];
3->4;
4[label="Node Type: END_IF 4
"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
onlyHolders()

IRs:
MODIFIER_CALL, ShopKeeper.onlyHolders()()"];
5->1;
}
// Function: 39817.sol-ShopKeeper-invalidateToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.invalidateToken(token_)

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:invalidateToken, arguments:['token_']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyHolders()

IRs:
MODIFIER_CALL, ShopKeeper.onlyHolders()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-onlyA()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(msg.sender == holderA)

IRs:
TMP_253(bool) = msg.sender == holderA
INTERNAL_CALL, SafeMath.assert(bool)(TMP_253)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 39817.sol-ShopKeeper-onlyHolders()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(msg.sender == holderA || msg.sender == holderB)

IRs:
TMP_249(bool) = msg.sender == holderA
TMP_250(bool) = msg.sender == holderB
TMP_251(bool) = TMP_249 || TMP_250
INTERNAL_CALL, SafeMath.assert(bool)(TMP_251)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 39817.sol-ShopKeeper-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_209(uint256) = a + b
c(uint256) := TMP_209(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_210(bool) = c >= a
TMP_211(bool) = c >= b
TMP_212(bool) = TMP_210 && TMP_211
INTERNAL_CALL, SafeMath.assert(bool)(TMP_212)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ShopKeeper-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_200(uint256) = a * b
c(uint256) := TMP_200(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_201(bool) = a == 0
TMP_202(uint256) = c / a
TMP_203(bool) = TMP_202 == b
TMP_204(bool) = TMP_201 || TMP_203
INTERNAL_CALL, SafeMath.assert(bool)(TMP_204)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ShopKeeper-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_206(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_206)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_208(uint256) = a - b
c(uint256) := TMP_208(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ShopKeeper-splitProfits()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
unprocessedProfit = shop.balanceOf(this)

IRs:
TMP_219(uint256) = HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:balanceOf, arguments:['this']  
unprocessedProfit(uint256) := TMP_219(uint256)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
equalShare = unprocessedProfit / 2

IRs:
TMP_220(uint256) = unprocessedProfit / 2
equalShare(uint256) := TMP_220(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(shop.transfer(holderA,equalShare))

IRs:
TMP_221(bool) = HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:transfer, arguments:['holderA', 'equalShare']  
INTERNAL_CALL, SafeMath.assert(bool)(TMP_221)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert(shop.transfer(holderB,equalShare))

IRs:
TMP_223(bool) = HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:transfer, arguments:['holderB', 'equalShare']  
INTERNAL_CALL, SafeMath.assert(bool)(TMP_223)"];
}
// Function: 39817.sol-ShopKeeper-toggleBurn()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.toggleBurn()

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:toggleBurn, arguments:[]  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyA()

IRs:
MODIFIER_CALL, ShopKeeper.onlyA()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-toggleDrain()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.toggleDrain()

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:toggleDrain, arguments:[]  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyA()

IRs:
MODIFIER_CALL, ShopKeeper.onlyA()()"];
2->1;
}
// Function: 39817.sol-ShopKeeper-validateToken(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
shop.validateToken(token_,bP_,bL_,pF_)

IRs:
HIGH_LEVEL_CALL, dest:shop(ValueTrader), function:validateToken, arguments:['token_', 'bP_', 'bL_', 'pF_']  "];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyHolders()

IRs:
MODIFIER_CALL, ShopKeeper.onlyHolders()()"];
2->1;
}
// Function: 39817.sol-Token-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 39817.sol-Token-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-Token-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 39817.sol-Token-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 39817.sol-Token-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-Token-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueToken-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
allowed[_owner][_spender]

IRs:
REF_15(mapping(address => uint256)) -> allowed[_owner]
REF_16(uint256) -> REF_15[_spender]
RETURN REF_16"];
2[label="Node Type: RETURN 2

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 39817.sol-ValueToken-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balances[msg.sender] >= _value

IRs:
REF_12(uint256) -> balances[msg.sender]
TMP_46(bool) = REF_12 >= _value
CONDITION TMP_46"];
1->2[label="True"];
1->5[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_13(mapping(address => uint256)) -> allowed[msg.sender]
REF_14(uint256) -> REF_13[_spender]
REF_14(uint256) (->allowed) := _value(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True"];
5[label="Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False"];
7[label="Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueToken-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_29 = UnaryType.BANG assertion 
CONDITION TMP_29"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39817.sol-ValueToken-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balances[_owner]

IRs:
REF_0(uint256) -> balances[_owner]
RETURN REF_0"];
2[label="Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 39817.sol-ValueToken-createValue(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[_owner] = safeAdd(balances[_owner],_value)

IRs:
REF_17(uint256) -> balances[_owner]
REF_18(uint256) -> balances[_owner]
TMP_48(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_18,_value)
REF_17(uint256) (->balances) := TMP_48(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supplyNow = safeAdd(supplyNow,_value)

IRs:
TMP_49(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(supplyNow,_value)
supplyNow(uint256) := TMP_49(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_owner,_value)

IRs:
Emit Mint(_owner,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueToken-destroyValue(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[_owner] = safeSub(balances[_owner],_value)

IRs:
REF_19(uint256) -> balances[_owner]
REF_20(uint256) -> balances[_owner]
TMP_51(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_20,_value)
REF_19(uint256) (->balances) := TMP_51(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supplyNow = safeSub(supplyNow,_value)

IRs:
TMP_52(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(supplyNow,_value)
supplyNow(uint256) := TMP_52(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Burn(_owner,_value)

IRs:
Emit Burn(_owner,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueToken-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_24(uint256) = a + b
c(uint256) := TMP_24(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_25(bool) = c >= a
TMP_26(bool) = c >= b
TMP_27(bool) = TMP_25 && TMP_26
INTERNAL_CALL, SafeMath.assert(bool)(TMP_27)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ValueToken-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_15(uint256) = a * b
c(uint256) := TMP_15(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_16(bool) = a == 0
TMP_17(uint256) = c / a
TMP_18(bool) = TMP_17 == b
TMP_19(bool) = TMP_16 || TMP_18
INTERNAL_CALL, SafeMath.assert(bool)(TMP_19)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ValueToken-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_21(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_21)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_23(uint256) = a - b
c(uint256) := TMP_23(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ValueToken-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 0

IRs:
decimals(uint256) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
name = Value

IRs:
name(string) := Value(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
supplyNow = 0

IRs:
supplyNow(uint256) := 0(uint256)"];
}
// Function: 39817.sol-ValueToken-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
supplyNow

IRs:
RETURN supplyNow"];
2[label="Node Type: RETURN 2

EXPRESSION:
totalSupply

IRs:
RETURN totalSupply"];
}
// Function: 39817.sol-ValueToken-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balanceOf(msg.sender) >= _value

IRs:
TMP_30(uint256) = INTERNAL_CALL, ValueToken.balanceOf(address)(msg.sender)
TMP_31(bool) = TMP_30 >= _value
CONDITION TMP_31"];
1->2[label="True"];
1->6[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = safeSub(balanceOf(msg.sender),_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_32(uint256) = INTERNAL_CALL, ValueToken.balanceOf(address)(msg.sender)
TMP_33(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_32,_value)
REF_1(uint256) (->balances) := TMP_33(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] = safeAdd(balanceOf(_to),_value)

IRs:
REF_2(uint256) -> balances[_to]
TMP_34(uint256) = INTERNAL_CALL, ValueToken.balanceOf(address)(_to)
TMP_35(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_34,_value)
REF_2(uint256) (->balances) := TMP_35(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True"];
6[label="Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False"];
8[label="Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueToken-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value

IRs:
REF_3(uint256) -> balances[_from]
TMP_37(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_38(bool) = REF_5 >= _value
TMP_39(bool) = TMP_37 && TMP_38
CONDITION TMP_39"];
1->2[label="True"];
1->7[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] = safeAdd(balanceOf(_to),_value)

IRs:
REF_6(uint256) -> balances[_to]
TMP_40(uint256) = INTERNAL_CALL, ValueToken.balanceOf(address)(_to)
TMP_41(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_40,_value)
REF_6(uint256) (->balances) := TMP_41(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] = safeSub(balanceOf(_from),_value)

IRs:
REF_7(uint256) -> balances[_from]
TMP_42(uint256) = INTERNAL_CALL, ValueToken.balanceOf(address)(_from)
TMP_43(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_42,_value)
REF_7(uint256) (->balances) := TMP_43(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value)

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
TMP_44(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_11,_value)
REF_9(uint256) (->allowed) := TMP_44(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)"];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True"];
7[label="Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False"];
9[label="Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueTrader-ValueTrader()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
burning = false

IRs:
burning(bool) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
draining = false

IRs:
draining(bool) := False(bool)"];
}
// Function: 39817.sol-ValueTrader-allowance(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
remaining

IRs:
RETURN remaining"];
}
// Function: 39817.sol-ValueTrader-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueTrader-assert(bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! assertion

IRs:
TMP_92 = UnaryType.BANG assertion 
CONDITION TMP_92"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: THROW 2
"];
3[label="Node Type: END_IF 3
"];
}
// Function: 39817.sol-ValueTrader-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
balance

IRs:
RETURN balance"];
}
// Function: 39817.sol-ValueTrader-burnBlock()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(! burning)

IRs:
TMP_196 = UnaryType.BANG burning 
INTERNAL_CALL, SafeMath.assert(bool)(TMP_196)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 39817.sol-ValueTrader-buyEther(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(valueToToken(etherContract,balances[msg.sender]) >= amount)

IRs:
REF_82(uint256) -> balances[msg.sender]
TMP_159(uint256) = INTERNAL_CALL, ValueTrader.valueToToken(address,uint256)(etherContract,REF_82)
TMP_160(bool) = TMP_159 >= amount
INTERNAL_CALL, SafeMath.assert(bool)(TMP_160)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(destroyValue(msg.sender,tokenToValue(etherContract,amount)))

IRs:
TMP_162(uint256) = INTERNAL_CALL, ValueTrader.tokenToValue(address,uint256)(etherContract,amount)
TMP_163(bool) = INTERNAL_CALL, ValueToken.destroyValue(address,uint256)(msg.sender,TMP_162)
INTERNAL_CALL, SafeMath.assert(bool)(TMP_163)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(msg.sender.call.value(amount)())

IRs:
TMP_166(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
INTERNAL_CALL, SafeMath.assert(bool)(TMP_166)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Buy(etherContract,msg.sender,amount,balances[msg.sender])

IRs:
REF_85(uint256) -> balances[msg.sender]
Emit Buy(etherContract,msg.sender,amount,REF_85)"];
}
// Function: 39817.sol-ValueTrader-buyToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(! (valueToToken(token,balances[msg.sender]) < amount))

IRs:
REF_78(uint256) -> balances[msg.sender]
TMP_143(uint256) = INTERNAL_CALL, ValueTrader.valueToToken(address,uint256)(token,REF_78)
TMP_144(bool) = TMP_143 < amount
TMP_145 = UnaryType.BANG TMP_144 
INTERNAL_CALL, SafeMath.assert(bool)(TMP_145)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(destroyValue(msg.sender,tokenToValue(token,amount)))

IRs:
TMP_147(uint256) = INTERNAL_CALL, ValueTrader.tokenToValue(address,uint256)(token,amount)
TMP_148(bool) = INTERNAL_CALL, ValueToken.destroyValue(address,uint256)(msg.sender,TMP_147)
INTERNAL_CALL, SafeMath.assert(bool)(TMP_148)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(Token(token).transfer(msg.sender,amount))

IRs:
TMP_150 = CONVERT token to Token
TMP_151(bool) = HIGH_LEVEL_CALL, dest:TMP_150(Token), function:transfer, arguments:['msg.sender', 'amount']  
INTERNAL_CALL, SafeMath.assert(bool)(TMP_151)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
Buy(token,msg.sender,amount,balances[msg.sender])

IRs:
REF_80(uint256) -> balances[msg.sender]
Emit Buy(token,msg.sender,amount,REF_80)"];
}
// Function: 39817.sol-ValueTrader-callDividend(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(tokenManage[token_].hasDividend)

IRs:
REF_56(ValueTrader.TokenData) -> tokenManage[token_]
REF_57(bool) -> REF_56.hasDividend
INTERNAL_CALL, SafeMath.assert(bool)(REF_57)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData))

IRs:
REF_58(ValueTrader.TokenData) -> tokenManage[token_]
REF_59(address) -> REF_58.divContractAddress
REF_62(ValueTrader.TokenData) -> tokenManage[token_]
REF_63(bytes) -> REF_62.divData
TMP_109(bool) = LOW_LEVEL_CALL, dest:REF_59, function:call, arguments:['REF_63'] value:0 
INTERNAL_CALL, SafeMath.assert(bool)(TMP_109)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
3->1;
}
// Function: 39817.sol-ValueTrader-changeEtherContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
etherContract = eC

IRs:
etherContract(address) := eC(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
2->1;
}
// Function: 39817.sol-ValueTrader-changeFee(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tradeCoefficient = tradeFee

IRs:
tradeCoefficient(uint256) := tradeFee(uint256)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
2->1;
}
// Function: 39817.sol-ValueTrader-changeOwner(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
2->1;
}
// Function: 39817.sol-ValueTrader-configureTokenDividend(address,bool,address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenManage[token_].hasDividend = hD_

IRs:
REF_50(ValueTrader.TokenData) -> tokenManage[token_]
REF_51(bool) -> REF_50.hasDividend
REF_51(bool) (->tokenManage) := hD_(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tokenManage[token_].divContractAddress = dA_

IRs:
REF_52(ValueTrader.TokenData) -> tokenManage[token_]
REF_53(address) -> REF_52.divContractAddress
REF_53(address) (->tokenManage) := dA_(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenManage[token_].divData = dD_

IRs:
REF_54(ValueTrader.TokenData) -> tokenManage[token_]
REF_55(bytes) -> REF_54.divData
REF_55(bytes) (->tokenManage) := dD_(bytes)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
4->1;
}
// Function: 39817.sol-ValueTrader-createValue(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[_owner] = safeAdd(balances[_owner],_value)

IRs:
REF_38(uint256) -> balances[_owner]
REF_39(uint256) -> balances[_owner]
TMP_72(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_39,_value)
REF_38(uint256) (->balances) := TMP_72(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supplyNow = safeAdd(supplyNow,_value)

IRs:
TMP_73(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(supplyNow,_value)
supplyNow(uint256) := TMP_73(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Mint(_owner,_value)

IRs:
Emit Mint(_owner,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueTrader-currentLiquidity(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
liquidity = Token(token).balanceOf(this)

IRs:
TMP_128 = CONVERT token to Token
TMP_129(uint256) = HIGH_LEVEL_CALL, dest:TMP_128(Token), function:balanceOf, arguments:['this']  
liquidity(uint256) := TMP_129(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
liquidity

IRs:
RETURN liquidity"];
}
// Function: 39817.sol-ValueTrader-currentPrice(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
draining

IRs:
CONDITION draining"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
price = 1

IRs:
price(uint256) := 1(uint256)"];
2->13;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
assert(tokenManage[token].isValid)

IRs:
REF_66(ValueTrader.TokenData) -> tokenManage[token]
REF_67(bool) -> REF_66.isValid
INTERNAL_CALL, SafeMath.assert(bool)(REF_67)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
basePrice = tokenManage[token].basePrice

IRs:
REF_68(ValueTrader.TokenData) -> tokenManage[token]
REF_69(uint256) -> REF_68.basePrice
basePrice(uint256) := REF_69(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
baseLiquidity = tokenManage[token].baseLiquidity

IRs:
REF_70(ValueTrader.TokenData) -> tokenManage[token]
REF_71(uint256) -> REF_70.baseLiquidity
baseLiquidity(uint256) := REF_71(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
priceScaleFactor = tokenManage[token].priceScaleFactor

IRs:
REF_72(ValueTrader.TokenData) -> tokenManage[token]
REF_73(uint256) -> REF_72.priceScaleFactor
priceScaleFactor(uint256) := REF_73(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
token == etherContract

IRs:
TMP_122(bool) = token == etherContract
CONDITION TMP_122"];
8->9[label="True"];
8->10[label="False"];
9[label="Node Type: EXPRESSION 9

EXPRESSION:
currentLiquidity = this.balance

IRs:
REF_74(uint256) = SOLIDITY_CALL balance(address)(this)
currentLiquidity(uint256) := REF_74([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x7f20433f9990>])"];
9->11;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
currentLiquidity = Token(token).balanceOf(this)

IRs:
TMP_123 = CONVERT token to Token
TMP_124(uint256) = HIGH_LEVEL_CALL, dest:TMP_123(Token), function:balanceOf, arguments:['this']  
currentLiquidity(uint256) := TMP_124(uint256)"];
10->11;
11[label="Node Type: END_IF 11
"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
price = safeAdd(basePrice,safeMul(priceScaleFactor,baseLiquidity / currentLiquidity))

IRs:
TMP_125(uint256) = baseLiquidity / currentLiquidity
TMP_126(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(priceScaleFactor,TMP_125)
TMP_127(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(basePrice,TMP_126)
price(uint256) := TMP_127(uint256)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: RETURN 14

EXPRESSION:
price

IRs:
RETURN price"];
}
// Function: 39817.sol-ValueTrader-destroyValue(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
balances[_owner] = safeSub(balances[_owner],_value)

IRs:
REF_40(uint256) -> balances[_owner]
REF_41(uint256) -> balances[_owner]
TMP_75(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_41,_value)
REF_40(uint256) (->balances) := TMP_75(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
supplyNow = safeSub(supplyNow,_value)

IRs:
TMP_76(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(supplyNow,_value)
supplyNow(uint256) := TMP_76(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Burn(_owner,_value)

IRs:
Emit Burn(_owner,_value)"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueTrader-die()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_102(None) = SOLIDITY_CALL selfdestruct(address)(owner)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
burnBlock()

IRs:
MODIFIER_CALL, ValueTrader.burnBlock()()"];
3->1;
}
// Function: 39817.sol-ValueTrader-drainBlock()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(! draining)

IRs:
TMP_198 = UnaryType.BANG draining 
INTERNAL_CALL, SafeMath.assert(bool)(TMP_198)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 39817.sol-ValueTrader-fallback()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 39817.sol-ValueTrader-invalidateToken(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenManage[token_].isValid = false

IRs:
REF_64(ValueTrader.TokenData) -> tokenManage[token_]
REF_65(bool) -> REF_64.isValid
REF_65(bool) (->tokenManage) := False(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
2->1;
}
// Function: 39817.sol-ValueTrader-owned()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(msg.sender == owner)

IRs:
TMP_194(bool) = msg.sender == owner
INTERNAL_CALL, SafeMath.assert(bool)(TMP_194)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 39817.sol-ValueTrader-quickTrade(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
tempInValue = safeAdd(tokenToValue(etherContract,msg.value),tokenToValue(tokenFrom,input))

IRs:
TMP_169(uint256) = INTERNAL_CALL, ValueTrader.tokenToValue(address,uint256)(etherContract,msg.value)
TMP_170(uint256) = INTERNAL_CALL, ValueTrader.tokenToValue(address,uint256)(tokenFrom,input)
TMP_171(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_169,TMP_170)
tempInValue(uint256) := TMP_171(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
inValue = valueWithFee(tempInValue)

IRs:
TMP_172(uint256) = INTERNAL_CALL, ValueTrader.valueWithFee(uint256)(tempInValue)
inValue(uint256) := TMP_172(uint256)"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
outValue = valueToToken(tokenTo,inValue)

IRs:
TMP_173(uint256) = INTERNAL_CALL, ValueTrader.valueToToken(address,uint256)(tokenTo,inValue)
outValue(uint256) := TMP_173(uint256)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
assert(verifiedTransferFrom(tokenFrom,msg.sender,input))

IRs:
TMP_174(bool) = INTERNAL_CALL, ValueTrader.verifiedTransferFrom(address,address,uint256)(tokenFrom,msg.sender,input)
INTERNAL_CALL, SafeMath.assert(bool)(TMP_174)"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
tokenTo == etherContract

IRs:
TMP_176(bool) = tokenTo == etherContract
CONDITION TMP_176"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
assert(msg.sender.call.value(outValue)())

IRs:
TMP_178(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:outValue 
INTERNAL_CALL, SafeMath.assert(bool)(TMP_178)"];
7->9;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
assert(Token(tokenTo).transfer(msg.sender,outValue))

IRs:
TMP_180 = CONVERT tokenTo to Token
TMP_181(bool) = HIGH_LEVEL_CALL, dest:TMP_180(Token), function:transfer, arguments:['msg.sender', 'outValue']  
INTERNAL_CALL, SafeMath.assert(bool)(TMP_181)"];
8->9;
9[label="Node Type: END_IF 9
"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
Trade(tokenFrom,tokenTo,msg.sender,inValue)

IRs:
Emit Trade(tokenFrom,tokenTo,msg.sender,inValue)"];
11[label="Node Type: EXPRESSION 11

EXPRESSION:
drainBlock()

IRs:
MODIFIER_CALL, ValueTrader.drainBlock()()"];
11->1;
}
// Function: 39817.sol-ValueTrader-safeAdd(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_87(uint256) = a + b
c(uint256) := TMP_87(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(c >= a && c >= b)

IRs:
TMP_88(bool) = c >= a
TMP_89(bool) = c >= b
TMP_90(bool) = TMP_88 && TMP_89
INTERNAL_CALL, SafeMath.assert(bool)(TMP_90)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ValueTrader-safeMul(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
c = a * b

IRs:
TMP_78(uint256) = a * b
c(uint256) := TMP_78(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(a == 0 || c / a == b)

IRs:
TMP_79(bool) = a == 0
TMP_80(uint256) = c / a
TMP_81(bool) = TMP_80 == b
TMP_82(bool) = TMP_79 || TMP_81
INTERNAL_CALL, SafeMath.assert(bool)(TMP_82)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ValueTrader-safeSub(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(b <= a)

IRs:
TMP_84(bool) = b <= a
INTERNAL_CALL, SafeMath.assert(bool)(TMP_84)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
c = a - b

IRs:
TMP_86(uint256) = a - b
c(uint256) := TMP_86(uint256)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c"];
}
// Function: 39817.sol-ValueTrader-sellEther()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(createValue(msg.sender,tokenToValue(etherContract,msg.value)))

IRs:
TMP_154(uint256) = INTERNAL_CALL, ValueTrader.tokenToValue(address,uint256)(etherContract,msg.value)
TMP_155(bool) = INTERNAL_CALL, ValueToken.createValue(address,uint256)(msg.sender,TMP_154)
INTERNAL_CALL, SafeMath.assert(bool)(TMP_155)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Sell(etherContract,msg.sender,msg.value,balances[msg.sender])

IRs:
REF_81(uint256) -> balances[msg.sender]
Emit Sell(etherContract,msg.sender,msg.value,REF_81)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
drainBlock()

IRs:
MODIFIER_CALL, ValueTrader.drainBlock()()"];
3->1;
}
// Function: 39817.sol-ValueTrader-sellToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(verifiedTransferFrom(token,msg.sender,amount))

IRs:
TMP_136(bool) = INTERNAL_CALL, ValueTrader.verifiedTransferFrom(address,address,uint256)(token,msg.sender,amount)
INTERNAL_CALL, SafeMath.assert(bool)(TMP_136)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(createValue(msg.sender,tokenToValue(token,amount)))

IRs:
TMP_138(uint256) = INTERNAL_CALL, ValueTrader.tokenToValue(address,uint256)(token,amount)
TMP_139(bool) = INTERNAL_CALL, ValueToken.createValue(address,uint256)(msg.sender,TMP_138)
INTERNAL_CALL, SafeMath.assert(bool)(TMP_139)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
Sell(token,msg.sender,amount,balances[msg.sender])

IRs:
REF_77(uint256) -> balances[msg.sender]
Emit Sell(token,msg.sender,amount,REF_77)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
drainBlock()

IRs:
MODIFIER_CALL, ValueTrader.drainBlock()()"];
4->1;
}
// Function: 39817.sol-ValueTrader-slitherConstructorVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
decimals = 0

IRs:
decimals(uint256) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
name = Value

IRs:
name(string) := Value(string)"];
1->2;
2[label="Node Type: OTHER_ENTRYPOINT 2

EXPRESSION:
supplyNow = 0

IRs:
supplyNow(uint256) := 0(uint256)"];
2->3;
3[label="Node Type: OTHER_ENTRYPOINT 3

EXPRESSION:
burning = false

IRs:
burning(bool) := False(bool)"];
3->4;
4[label="Node Type: OTHER_ENTRYPOINT 4

EXPRESSION:
draining = false

IRs:
draining(bool) := False(bool)"];
}
// Function: 39817.sol-ValueTrader-toggleBurn()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
assert(draining)

IRs:
INTERNAL_CALL, SafeMath.assert(bool)(draining)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(balanceOf(owner) == supplyNow)

IRs:
TMP_97(uint256) = INTERNAL_CALL, ValueToken.balanceOf(address)(owner)
TMP_98(bool) = TMP_97 == supplyNow
INTERNAL_CALL, SafeMath.assert(bool)(TMP_98)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
burning = ! burning

IRs:
TMP_100 = UnaryType.BANG burning 
burning(bool) := TMP_100(bool)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
4->1;
}
// Function: 39817.sol-ValueTrader-toggleDrain()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
draining = ! draining

IRs:
TMP_93 = UnaryType.BANG draining 
draining(bool) := TMP_93(bool)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
burnBlock()

IRs:
MODIFIER_CALL, ValueTrader.burnBlock()()"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
3->1;
}
// Function: 39817.sol-ValueTrader-tokenToValue(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
value = safeMul(amount,currentPrice(token))

IRs:
TMP_134(uint256) = INTERNAL_CALL, ValueTrader.currentPrice(address)(token)
TMP_135(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(amount,TMP_134)
value(uint256) := TMP_135(uint256)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
value

IRs:
RETURN value"];
}
// Function: 39817.sol-ValueTrader-totalSupply()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
supply

IRs:
RETURN supply"];
}
// Function: 39817.sol-ValueTrader-transfer(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueTrader-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success"];
}
// Function: 39817.sol-ValueTrader-validateToken(address,uint256,uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->5;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
tokenManage[token_].isValid = true

IRs:
REF_42(ValueTrader.TokenData) -> tokenManage[token_]
REF_43(bool) -> REF_42.isValid
REF_43(bool) (->tokenManage) := True(bool)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
tokenManage[token_].basePrice = bP_

IRs:
REF_44(ValueTrader.TokenData) -> tokenManage[token_]
REF_45(uint256) -> REF_44.basePrice
REF_45(uint256) (->tokenManage) := bP_(uint256)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
tokenManage[token_].baseLiquidity = bL_

IRs:
REF_46(ValueTrader.TokenData) -> tokenManage[token_]
REF_47(uint256) -> REF_46.baseLiquidity
REF_47(uint256) (->tokenManage) := bL_(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
tokenManage[token_].priceScaleFactor = pF_

IRs:
REF_48(ValueTrader.TokenData) -> tokenManage[token_]
REF_49(uint256) -> REF_48.priceScaleFactor
REF_49(uint256) (->tokenManage) := pF_(uint256)"];
5[label="Node Type: EXPRESSION 5

EXPRESSION:
owned()

IRs:
MODIFIER_CALL, ValueTrader.owned()()"];
5->1;
}
// Function: 39817.sol-ValueTrader-valueToToken(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
value = amount / currentPrice(token)

IRs:
TMP_130(uint256) = INTERNAL_CALL, ValueTrader.currentPrice(address)(token)
TMP_131(uint256) = amount / TMP_130
value(uint256) := TMP_131(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
assert(value != 0)

IRs:
TMP_132(bool) = value != 0
INTERNAL_CALL, SafeMath.assert(bool)(TMP_132)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
value

IRs:
RETURN value"];
}
// Function: 39817.sol-ValueTrader-valueWithFee(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
doneValue = safeMul(tempValue,tradeCoefficient) / 10000

IRs:
TMP_116(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(tempValue,tradeCoefficient)
TMP_117(uint256) = TMP_116 / 10000
doneValue(uint256) := TMP_117(uint256)"];
1->2;
2[label="Node Type: IF 2

EXPRESSION:
tradeCoefficient < 10000

IRs:
TMP_118(bool) = tradeCoefficient < 10000
CONDITION TMP_118"];
2->3[label="True"];
2->4[label="False"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
createValue(owner,safeSub(tempValue,doneValue))

IRs:
TMP_119(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(tempValue,doneValue)
TMP_120(bool) = INTERNAL_CALL, ValueToken.createValue(address,uint256)(owner,TMP_119)"];
3->4;
4[label="Node Type: END_IF 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
doneValue

IRs:
RETURN doneValue"];
}
// Function: 39817.sol-ValueTrader-verifiedTransferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
balanceBefore = Token(tokenFrom).balanceOf(this)

IRs:
TMP_185 = CONVERT tokenFrom to Token
TMP_186(uint256) = HIGH_LEVEL_CALL, dest:TMP_185(Token), function:balanceOf, arguments:['this']  
balanceBefore(uint256) := TMP_186(uint256)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
success = Token(tokenFrom).transferFrom(senderAdd,this,amount)

IRs:
TMP_187 = CONVERT tokenFrom to Token
TMP_188(bool) = HIGH_LEVEL_CALL, dest:TMP_187(Token), function:transferFrom, arguments:['senderAdd', 'this', 'amount']  
success(bool) := TMP_188(bool)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
balanceAfter = Token(tokenFrom).balanceOf(this)

IRs:
TMP_189 = CONVERT tokenFrom to Token
TMP_190(uint256) = HIGH_LEVEL_CALL, dest:TMP_189(Token), function:balanceOf, arguments:['this']  
balanceAfter(uint256) := TMP_190(uint256)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
assert((safeSub(balanceAfter,balanceBefore) == amount))

IRs:
TMP_191(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(balanceAfter,balanceBefore)
TMP_192(bool) = TMP_191 == amount
INTERNAL_CALL, SafeMath.assert(bool)(TMP_192)"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success"];
}
}
