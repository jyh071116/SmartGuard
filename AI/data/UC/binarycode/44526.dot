digraph G {
// Function: 44526.sol-AccessControl-_grantRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! hasRole(role,account)

IRs:
TMP_200(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
TMP_201 = UnaryType.BANG TMP_200 
CONDITION TMP_201"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].members[account] = true

IRs:
REF_53(AccessControl.RoleData) -> _roles[role]
REF_54(mapping(address => bool)) -> REF_53.members
REF_55(bool) -> REF_54[account]
REF_55(bool) (->_roles) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RoleGranted(role,account,_msgSender())

IRs:
TMP_202(address) = INTERNAL_CALL, Context._msgSender()()
Emit RoleGranted(role,account,TMP_202)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 44526.sol-AccessControl-_msgData()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
this
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
msg.data

IRs:
RETURN msg.data"];
}
// Function: 44526.sol-AccessControl-_msgSender()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 44526.sol-AccessControl-_revokeRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
hasRole(role,account)

IRs:
TMP_204(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
CONDITION TMP_204"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].members[account] = false

IRs:
REF_56(AccessControl.RoleData) -> _roles[role]
REF_57(mapping(address => bool)) -> REF_56.members
REF_58(bool) -> REF_57[account]
REF_58(bool) (->_roles) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RoleRevoked(role,account,_msgSender())

IRs:
TMP_205(address) = INTERNAL_CALL, Context._msgSender()()
Emit RoleRevoked(role,account,TMP_205)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 44526.sol-AccessControl-_setRoleAdmin(bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
RoleAdminChanged(role,getRoleAdmin(role),adminRole)

IRs:
TMP_198(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
Emit RoleAdminChanged(role,TMP_198,adminRole)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].adminRole = adminRole

IRs:
REF_51(AccessControl.RoleData) -> _roles[role]
REF_52(bytes32) -> REF_51.adminRole
REF_52(bytes32) (->_roles) := adminRole(bytes32)"];
}
// Function: 44526.sol-AccessControl-_setupRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_grantRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-AccessControl-getRoleAdmin(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_roles[role].adminRole

IRs:
REF_49(AccessControl.RoleData) -> _roles[role]
REF_50(bytes32) -> REF_49.adminRole
RETURN REF_50"];
}
// Function: 44526.sol-AccessControl-grantRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(getRoleAdmin(role),_msgSender()),AccessControl: sender must be an admin to grant)

IRs:
TMP_183(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
TMP_184(address) = INTERNAL_CALL, Context._msgSender()()
TMP_185(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(TMP_183,TMP_184)
TMP_186(None) = SOLIDITY_CALL require(bool,string)(TMP_185,AccessControl: sender must be an admin to grant)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_grantRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-AccessControl-hasRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_roles[role].members[account]

IRs:
REF_46(AccessControl.RoleData) -> _roles[role]
REF_47(mapping(address => bool)) -> REF_46.members
REF_48(bool) -> REF_47[account]
RETURN REF_48"];
}
// Function: 44526.sol-AccessControl-renounceRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)

IRs:
TMP_193(address) = INTERNAL_CALL, Context._msgSender()()
TMP_194(bool) = account == TMP_193
TMP_195(None) = SOLIDITY_CALL require(bool,string)(TMP_194,AccessControl: can only renounce roles for self)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_revokeRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-AccessControl-revokeRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(getRoleAdmin(role),_msgSender()),AccessControl: sender must be an admin to revoke)

IRs:
TMP_188(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
TMP_189(address) = INTERNAL_CALL, Context._msgSender()()
TMP_190(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(TMP_188,TMP_189)
TMP_191(None) = SOLIDITY_CALL require(bool,string)(TMP_190,AccessControl: sender must be an admin to revoke)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_revokeRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-AccessControl-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
DEFAULT_ADMIN_ROLE = 0x00

IRs:
DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)"];
}
// Function: 44526.sol-Address-_verifyCallResult(bool,bytes,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
success

IRs:
CONDITION success"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
returndata

IRs:
RETURN returndata"];
3[label="Node Type: IF 3

EXPRESSION:
returndata.length > 0

IRs:
REF_5 -> LENGTH returndata
TMP_24(bool) = REF_5 > 0
CONDITION TMP_24"];
3->4[label="True"];
3->9[label="False"];
4[label="Node Type: INLINE ASM 4
"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
returndata_size__verifyCallResult_asm_0 = mload(uint256)(returndata)

IRs:
TMP_25(uint256) = SOLIDITY_CALL mload(uint256)(returndata)
returndata_size__verifyCallResult_asm_0(uint256) := TMP_25(uint256)"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
revert(uint256,uint256)(32 + returndata,returndata_size__verifyCallResult_asm_0)

IRs:
TMP_26(uint256) = 32 + returndata
TMP_27(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_26,returndata_size__verifyCallResult_asm_0)"];
7->8;
8[label="Node Type: END INLINE ASM 8
"];
8->10;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
revert(string)(errorMessage)

IRs:
TMP_28(None) = SOLIDITY_CALL revert(string)(errorMessage)"];
9->10;
10[label="Node Type: END_IF 10
"];
10->11;
11[label="Node Type: END_IF 11
"];
}
// Function: 44526.sol-Address-functionCall(address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
functionCall(target,data,Address: low-level call failed)

IRs:
TMP_6(bytes) = INTERNAL_CALL, Address.functionCall(address,bytes,string)(target,data,Address: low-level call failed)
RETURN TMP_6"];
}
// Function: 44526.sol-Address-functionCall(address,bytes,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
functionCallWithValue(target,data,0,errorMessage)

IRs:
TMP_7(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,0,errorMessage)
RETURN TMP_7"];
}
// Function: 44526.sol-Address-functionCallWithValue(address,bytes,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
functionCallWithValue(target,data,value,Address: low-level call with value failed)

IRs:
TMP_8(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,value,Address: low-level call with value failed)
RETURN TMP_8"];
}
// Function: 44526.sol-Address-functionCallWithValue(address,bytes,uint256,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
TMP_11(bool) = TMP_10 >= value
TMP_12(None) = SOLIDITY_CALL require(bool,string)(TMP_11,Address: insufficient balance for call)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(isContract(target),Address: call to non-contract)

IRs:
TMP_13(bool) = INTERNAL_CALL, Address.isContract(address)(target)
TMP_14(None) = SOLIDITY_CALL require(bool,string)(TMP_13,Address: call to non-contract)"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4
"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
(success,returndata) = target.call{value: value}(data)

IRs:
TUPLE_1(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value 
success(bool)= UNPACK TUPLE_1 index: 0 
returndata(bytes)= UNPACK TUPLE_1 index: 1 "];
5->6;
6[label="Node Type: RETURN 6

EXPRESSION:
_verifyCallResult(success,returndata,errorMessage)

IRs:
TMP_15(bytes) = INTERNAL_CALL, Address._verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)
RETURN TMP_15"];
}
// Function: 44526.sol-Address-functionDelegateCall(address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
functionDelegateCall(target,data,Address: low-level delegate call failed)

IRs:
TMP_20(bytes) = INTERNAL_CALL, Address.functionDelegateCall(address,bytes,string)(target,data,Address: low-level delegate call failed)
RETURN TMP_20"];
}
// Function: 44526.sol-Address-functionDelegateCall(address,bytes,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(isContract(target),Address: delegate call to non-contract)

IRs:
TMP_21(bool) = INTERNAL_CALL, Address.isContract(address)(target)
TMP_22(None) = SOLIDITY_CALL require(bool,string)(TMP_21,Address: delegate call to non-contract)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
(success,returndata) = target.delegatecall(data)

IRs:
TUPLE_3(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:delegatecall, arguments:['data']  
success(bool)= UNPACK TUPLE_3 index: 0 
returndata(bytes)= UNPACK TUPLE_3 index: 1 "];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_verifyCallResult(success,returndata,errorMessage)

IRs:
TMP_23(bytes) = INTERNAL_CALL, Address._verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)
RETURN TMP_23"];
}
// Function: 44526.sol-Address-functionStaticCall(address,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
functionStaticCall(target,data,Address: low-level static call failed)

IRs:
TMP_16(bytes) = INTERNAL_CALL, Address.functionStaticCall(address,bytes,string)(target,data,Address: low-level static call failed)
RETURN TMP_16"];
}
// Function: 44526.sol-Address-functionStaticCall(address,bytes,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(isContract(target),Address: static call to non-contract)

IRs:
TMP_17(bool) = INTERNAL_CALL, Address.isContract(address)(target)
TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,Address: static call to non-contract)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
(success,returndata) = target.staticcall(data)

IRs:
TUPLE_2(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:staticcall, arguments:['data']  
success(bool)= UNPACK TUPLE_2 index: 0 
returndata(bytes)= UNPACK TUPLE_2 index: 1 "];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
_verifyCallResult(success,returndata,errorMessage)

IRs:
TMP_19(bytes) = INTERNAL_CALL, Address._verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)
RETURN TMP_19"];
}
// Function: 44526.sol-Address-isContract(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: INLINE ASM 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
size = extcodesize(uint256)(account)

IRs:
REF_0 -> CODESIZE account
size(uint256) := REF_0(uint256)"];
3->4;
4[label="Node Type: END INLINE ASM 4
"];
4->5;
5[label="Node Type: RETURN 5

EXPRESSION:
size > 0

IRs:
TMP_0(bool) = size > 0
RETURN TMP_0"];
}
// Function: 44526.sol-Address-sendValue(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(address(this).balance >= amount,Address: insufficient balance)

IRs:
TMP_1 = CONVERT this to address
TMP_2(uint256) = SOLIDITY_CALL balance(address)(TMP_1)
TMP_3(bool) = TMP_2 >= amount
TMP_4(None) = SOLIDITY_CALL require(bool,string)(TMP_3,Address: insufficient balance)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(success,None) = recipient.call{value: amount}()

IRs:
TUPLE_0(bool,bytes) = LOW_LEVEL_CALL, dest:recipient, function:call, arguments:[''] value:amount 
success(bool)= UNPACK TUPLE_0 index: 0 "];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(success,Address: unable to send value, recipient may have reverted)

IRs:
TMP_5(None) = SOLIDITY_CALL require(bool,string)(success,Address: unable to send value, recipient may have reverted)"];
}
// Function: 44526.sol-Context-_msgData()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
this
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
msg.data

IRs:
RETURN msg.data"];
}
// Function: 44526.sol-Context-_msgSender()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 44526.sol-DMarketNFTToken-_approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_tokenApprovals[tokenID] = to

IRs:
REF_98(address) -> _tokenApprovals[tokenID]
REF_98(address) (->_tokenApprovals) := to(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(ERC721.ownerOf(tokenID),to,tokenID)

IRs:
TMP_350(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
Emit Approval(TMP_350,to,tokenID)"];
}
// Function: 44526.sol-DMarketNFTToken-_baseURI()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_baseTokenURI

IRs:
RETURN _baseTokenURI"];
}
// Function: 44526.sol-DMarketNFTToken-_beforeTokenTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 44526.sol-DMarketNFTToken-_burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
owner = ERC721.ownerOf(tokenID)

IRs:
TMP_333(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
owner(address) := TMP_333(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_beforeTokenTransfer(owner,address(0),tokenID)

IRs:
TMP_334 = CONVERT 0 to address
INTERNAL_CALL, ERC721._beforeTokenTransfer(address,address,uint256)(owner,TMP_334,tokenID)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_approve(address(0),tokenID)

IRs:
TMP_336 = CONVERT 0 to address
INTERNAL_CALL, ERC721._approve(address,uint256)(TMP_336,tokenID)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_balances[owner] -= 1

IRs:
REF_92(uint256) -> _balances[owner]
REF_92(-> _balances) = REF_92 (c)- 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
delete _owners[tokenID]

IRs:
REF_93(address) -> _owners[tokenID]
_owners = delete REF_93 "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(owner,address(0),tokenID)

IRs:
TMP_338 = CONVERT 0 to address
Emit Transfer(owner,TMP_338,tokenID)"];
}
// Function: 44526.sol-DMarketNFTToken-_checkOnERC721Received(address,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
to.isContract()

IRs:
TMP_352(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['to'] 
CONDITION TMP_352"];
1->2[label="True"];
1->12[label="False"];
2[label="Node Type: TRY 2

EXPRESSION:
retval = IERC721Receiver(to).onERC721Received(_msgSender(),from,tokenID,_data)

IRs:
TMP_353 = CONVERT to to IERC721Receiver
TMP_354(address) = INTERNAL_CALL, Context._msgSender()()
TMP_355(bytes4) = HIGH_LEVEL_CALL, dest:TMP_353(IERC721Receiver), function:onERC721Received, arguments:['TMP_354', 'from', 'tokenID', '_data']  
retval(bytes4) := TMP_355(bytes4)"];
2->3;
2->5;
2->13;
3[label="Node Type: CATCH 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
retval == IERC721Receiver(to).onERC721Received.selector

IRs:
TMP_356 = CONVERT to to IERC721Receiver
REF_103(bytes4) (->None) := 353073666(uint256)
TMP_357(bool) = retval == REF_103
RETURN TMP_357"];
5[label="Node Type: CATCH 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
reason.length == 0

IRs:
REF_104 -> LENGTH reason
TMP_358(bool) = REF_104 == 0
CONDITION TMP_358"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
revert(string)(ERC721: transfer to non ERC721Receiver implementer)

IRs:
TMP_359(None) = SOLIDITY_CALL revert(string)(ERC721: transfer to non ERC721Receiver implementer)"];
7->11;
8[label="Node Type: INLINE ASM 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

IRs:
TMP_360(uint256) = 32 + reason
TMP_361(uint256) = SOLIDITY_CALL mload(uint256)(reason)
TMP_362(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_360,TMP_361)"];
9->10;
10[label="Node Type: END INLINE ASM 10
"];
10->11;
11[label="Node Type: END_IF 11
"];
11->13;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
13[label="Node Type: END_IF 13
"];
}
// Function: 44526.sol-DMarketNFTToken-_exists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_owners[tokenID] != address(0)

IRs:
REF_86(address) -> _owners[tokenID]
TMP_307 = CONVERT 0 to address
TMP_308(bool) = REF_86 != TMP_307
RETURN TMP_308"];
}
// Function: 44526.sol-DMarketNFTToken-_grantRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! hasRole(role,account)

IRs:
TMP_387(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
TMP_388 = UnaryType.BANG TMP_387 
CONDITION TMP_388"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].members[account] = true

IRs:
REF_113(AccessControl.RoleData) -> _roles[role]
REF_114(mapping(address => bool)) -> REF_113.members
REF_115(bool) -> REF_114[account]
REF_115(bool) (->_roles) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RoleGranted(role,account,_msgSender())

IRs:
TMP_389(address) = INTERNAL_CALL, Context._msgSender()()
Emit RoleGranted(role,account,TMP_389)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 44526.sol-DMarketNFTToken-_isApprovedOrOwner(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_exists(tokenID),ERC721: operator query for nonexistent token)

IRs:
TMP_309(bool) = INTERNAL_CALL, ERC721._exists(uint256)(tokenID)
TMP_310(None) = SOLIDITY_CALL require(bool,string)(TMP_309,ERC721: operator query for nonexistent token)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
owner = ERC721.ownerOf(tokenID)

IRs:
TMP_311(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
owner(address) := TMP_311(address)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
(spender == owner || getApproved(tokenID) == spender || ERC721.isApprovedForAll(owner,spender))

IRs:
TMP_312(bool) = spender == owner
TMP_313(address) = INTERNAL_CALL, ERC721.getApproved(uint256)(tokenID)
TMP_314(bool) = TMP_313 == spender
TMP_315(bool) = TMP_312 || TMP_314
TMP_316(bool) = INTERNAL_CALL, ERC721.isApprovedForAll(address,address)(owner,spender)
TMP_317(bool) = TMP_315 || TMP_316
RETURN TMP_317"];
}
// Function: 44526.sol-DMarketNFTToken-_mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(to != address(0),ERC721: mint to the zero address)

IRs:
TMP_323 = CONVERT 0 to address
TMP_324(bool) = to != TMP_323
TMP_325(None) = SOLIDITY_CALL require(bool,string)(TMP_324,ERC721: mint to the zero address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(! _exists(tokenID),ERC721: token already minted)

IRs:
TMP_326(bool) = INTERNAL_CALL, ERC721._exists(uint256)(tokenID)
TMP_327 = UnaryType.BANG TMP_326 
TMP_328(None) = SOLIDITY_CALL require(bool,string)(TMP_327,ERC721: token already minted)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_beforeTokenTransfer(address(0),to,tokenID)

IRs:
TMP_329 = CONVERT 0 to address
INTERNAL_CALL, ERC721._beforeTokenTransfer(address,address,uint256)(TMP_329,to,tokenID)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_balances[to] += 1

IRs:
REF_89(uint256) -> _balances[to]
REF_89(-> _balances) = REF_89 (c)+ 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_owners[tokenID] = to

IRs:
REF_90(address) -> _owners[tokenID]
REF_90(address) (->_owners) := to(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(address(0),to,tokenID)

IRs:
TMP_331 = CONVERT 0 to address
Emit Transfer(TMP_331,to,tokenID)"];
}
// Function: 44526.sol-DMarketNFTToken-_msgData()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
this
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
msg.data

IRs:
RETURN msg.data"];
}
// Function: 44526.sol-DMarketNFTToken-_msgSender()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 44526.sol-DMarketNFTToken-_revokeRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
hasRole(role,account)

IRs:
TMP_391(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
CONDITION TMP_391"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].members[account] = false

IRs:
REF_116(AccessControl.RoleData) -> _roles[role]
REF_117(mapping(address => bool)) -> REF_116.members
REF_118(bool) -> REF_117[account]
REF_118(bool) (->_roles) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RoleRevoked(role,account,_msgSender())

IRs:
TMP_392(address) = INTERNAL_CALL, Context._msgSender()()
Emit RoleRevoked(role,account,TMP_392)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 44526.sol-DMarketNFTToken-_safeMint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_safeMint(to,tokenID,)

IRs:
INTERNAL_CALL, ERC721._safeMint(address,uint256,bytes)(to,tokenID,)"];
}
// Function: 44526.sol-DMarketNFTToken-_safeMint(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_mint(to,tokenID)

IRs:
INTERNAL_CALL, ERC721._mint(address,uint256)(to,tokenID)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_checkOnERC721Received(address(0),to,tokenID,_data),ERC721: transfer to non ERC721Receiver implementer)

IRs:
TMP_320 = CONVERT 0 to address
TMP_321(bool) = INTERNAL_CALL, ERC721._checkOnERC721Received(address,address,uint256,bytes)(TMP_320,to,tokenID,_data)
TMP_322(None) = SOLIDITY_CALL require(bool,string)(TMP_321,ERC721: transfer to non ERC721Receiver implementer)"];
}
// Function: 44526.sol-DMarketNFTToken-_safeTransfer(address,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transfer(from,to,tokenID)

IRs:
INTERNAL_CALL, ERC721._transfer(address,address,uint256)(from,to,tokenID)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_checkOnERC721Received(from,to,tokenID,_data),ERC721: transfer to non ERC721Receiver implementer)

IRs:
TMP_305(bool) = INTERNAL_CALL, ERC721._checkOnERC721Received(address,address,uint256,bytes)(from,to,tokenID,_data)
TMP_306(None) = SOLIDITY_CALL require(bool,string)(TMP_305,ERC721: transfer to non ERC721Receiver implementer)"];
}
// Function: 44526.sol-DMarketNFTToken-_setRoleAdmin(bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
RoleAdminChanged(role,getRoleAdmin(role),adminRole)

IRs:
TMP_385(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
Emit RoleAdminChanged(role,TMP_385,adminRole)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].adminRole = adminRole

IRs:
REF_111(AccessControl.RoleData) -> _roles[role]
REF_112(bytes32) -> REF_111.adminRole
REF_112(bytes32) (->_roles) := adminRole(bytes32)"];
}
// Function: 44526.sol-DMarketNFTToken-_setupRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_grantRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-DMarketNFTToken-_transfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ERC721.ownerOf(tokenID) == from,ERC721: transfer of token that is not own)

IRs:
TMP_340(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
TMP_341(bool) = TMP_340 == from
TMP_342(None) = SOLIDITY_CALL require(bool,string)(TMP_341,ERC721: transfer of token that is not own)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(to != address(0),ERC721: transfer to the zero address)

IRs:
TMP_343 = CONVERT 0 to address
TMP_344(bool) = to != TMP_343
TMP_345(None) = SOLIDITY_CALL require(bool,string)(TMP_344,ERC721: transfer to the zero address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_beforeTokenTransfer(from,to,tokenID)

IRs:
INTERNAL_CALL, ERC721._beforeTokenTransfer(address,address,uint256)(from,to,tokenID)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_approve(address(0),tokenID)

IRs:
TMP_347 = CONVERT 0 to address
INTERNAL_CALL, ERC721._approve(address,uint256)(TMP_347,tokenID)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_balances[from] -= 1

IRs:
REF_95(uint256) -> _balances[from]
REF_95(-> _balances) = REF_95 (c)- 1"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_balances[to] += 1

IRs:
REF_96(uint256) -> _balances[to]
REF_96(-> _balances) = REF_96 (c)+ 1"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_owners[tokenID] = to

IRs:
REF_97(address) -> _owners[tokenID]
REF_97(address) (->_owners) := to(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(from,to,tokenID)

IRs:
Emit Transfer(from,to,tokenID)"];
}
// Function: 44526.sol-DMarketNFTToken-addMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
grantRole(MINTER_ROLE,account)

IRs:
INTERNAL_CALL, AccessControl.grantRole(bytes32,address)(MINTER_ROLE,account)"];
}
// Function: 44526.sol-DMarketNFTToken-approve(address,uint256)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-balanceOf(address)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_isApprovedOrOwner(_msgSender(),tokenID),DMarketNFTToken: caller is not owner nor approved)

IRs:
TMP_409(address) = INTERNAL_CALL, Context._msgSender()()
TMP_410(bool) = INTERNAL_CALL, ERC721._isApprovedOrOwner(address,uint256)(TMP_409,tokenID)
TMP_411(None) = SOLIDITY_CALL require(bool,string)(TMP_410,DMarketNFTToken: caller is not owner nor approved)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_burn(tokenID)

IRs:
INTERNAL_CALL, ERC721._burn(uint256)(tokenID)"];
}
// Function: 44526.sol-DMarketNFTToken-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
msgSender = _msgSender()

IRs:
TMP_394(address) = INTERNAL_CALL, Context._msgSender()()
msgSender(address) := TMP_394(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_owner = msgSender

IRs:
_owner(address) := msgSender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnershipTransferred(address(0),msgSender)

IRs:
TMP_395 = CONVERT 0 to address
Emit OwnershipTransferred(TMP_395,msgSender)"];
}
// Function: 44526.sol-DMarketNFTToken-constructor(address,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
transferOwnership(newOwner)

IRs:
INTERNAL_CALL, Ownable.transferOwnership(address)(newOwner)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
grantRole(DEFAULT_ADMIN_ROLE,newOwner)

IRs:
INTERNAL_CALL, AccessControl.grantRole(bytes32,address)(DEFAULT_ADMIN_ROLE,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_baseTokenURI = tokenURIPrefix

IRs:
_baseTokenURI(string) := tokenURIPrefix(string)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
ERC721(DMarket NFT Swap,DM NFT)

IRs:
INTERNAL_CALL, ERC721.constructor(string,string)(DMarket NFT Swap,DM NFT)"];
4->1;
}
// Function: 44526.sol-DMarketNFTToken-constructor(string,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_name = name_

IRs:
_name(string) := name_(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_symbol = symbol_

IRs:
_symbol(string) := symbol_(string)"];
}
// Function: 44526.sol-DMarketNFTToken-getApproved(uint256)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-getRoleAdmin(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_roles[role].adminRole

IRs:
REF_109(AccessControl.RoleData) -> _roles[role]
REF_110(bytes32) -> REF_109.adminRole
RETURN REF_110"];
}
// Function: 44526.sol-DMarketNFTToken-grantRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(getRoleAdmin(role),_msgSender()),AccessControl: sender must be an admin to grant)

IRs:
TMP_370(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
TMP_371(address) = INTERNAL_CALL, Context._msgSender()()
TMP_372(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(TMP_370,TMP_371)
TMP_373(None) = SOLIDITY_CALL require(bool,string)(TMP_372,AccessControl: sender must be an admin to grant)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_grantRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-DMarketNFTToken-hasRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_roles[role].members[account]

IRs:
REF_106(AccessControl.RoleData) -> _roles[role]
REF_107(mapping(address => bool)) -> REF_106.members
REF_108(bool) -> REF_107[account]
RETURN REF_108"];
}
// Function: 44526.sol-DMarketNFTToken-isApprovedForAll(address,address)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-mintToken(address,uint64)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->2;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_mint(to,tokenID)

IRs:
INTERNAL_CALL, ERC721._mint(address,uint256)(to,tokenID)"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
onlyMinter()

IRs:
MODIFIER_CALL, MinterAccess.onlyMinter()()"];
2->1;
}
// Function: 44526.sol-DMarketNFTToken-mintTokenBatch(address[],uint64[])
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->11;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(receivers.length > 0,DMarketNFTToken: must be some receivers)

IRs:
REF_119 -> LENGTH receivers
TMP_415(bool) = REF_119 > 0
TMP_416(None) = SOLIDITY_CALL require(bool,string)(TMP_415,DMarketNFTToken: must be some receivers)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(receivers.length == tokenIDs.length,DMarketNFTToken: must be the same number of receivers/tokenIDs)

IRs:
REF_120 -> LENGTH receivers
REF_121 -> LENGTH tokenIDs
TMP_417(bool) = REF_120 == REF_121
TMP_418(None) = SOLIDITY_CALL require(bool,string)(TMP_417,DMarketNFTToken: must be the same number of receivers/tokenIDs)"];
2->5;
3[label="Node Type: BEGIN_LOOP 3
"];
3->6;
4[label="Node Type: END_LOOP 4
"];
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint64) := 0(uint256)"];
5->3;
6[label="Node Type: IF_LOOP 6

EXPRESSION:
i < receivers.length

IRs:
REF_122 -> LENGTH receivers
TMP_419(bool) = i < REF_122
CONDITION TMP_419"];
6->7[label="True"];
6->4[label="False"];
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
to = receivers[i]

IRs:
REF_123(address) -> receivers[i]
to(address) := REF_123(address)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
tokenID = tokenIDs[i]

IRs:
REF_124(uint64) -> tokenIDs[i]
tokenID(uint256) := REF_124(uint64)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
_mint(to,tokenID)

IRs:
INTERNAL_CALL, ERC721._mint(address,uint256)(to,tokenID)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_421(uint64) := i(uint64)
i(uint64) = i (c)+ 1"];
10->6;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
onlyMinter()

IRs:
MODIFIER_CALL, MinterAccess.onlyMinter()()"];
11->1;
}
// Function: 44526.sol-DMarketNFTToken-name()
digraph{
}
// Function: 44526.sol-DMarketNFTToken-onlyMinter()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(MINTER_ROLE,_msgSender()),MinterAccess: Sender is not a minter)

IRs:
TMP_424(address) = INTERNAL_CALL, Context._msgSender()()
TMP_425(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(MINTER_ROLE,TMP_424)
TMP_426(None) = SOLIDITY_CALL require(bool,string)(TMP_425,MinterAccess: Sender is not a minter)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 44526.sol-DMarketNFTToken-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

IRs:
TMP_427(address) = INTERNAL_CALL, Ownable.owner()()
TMP_428(address) = INTERNAL_CALL, Context._msgSender()()
TMP_429(bool) = TMP_427 == TMP_428
TMP_430(None) = SOLIDITY_CALL require(bool,string)(TMP_429,Ownable: caller is not the owner)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 44526.sol-DMarketNFTToken-owner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_owner

IRs:
RETURN _owner"];
}
// Function: 44526.sol-DMarketNFTToken-ownerOf(uint256)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-renounceMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
renounceRole(MINTER_ROLE,account)

IRs:
INTERNAL_CALL, AccessControl.renounceRole(bytes32,address)(MINTER_ROLE,account)"];
}
// Function: 44526.sol-DMarketNFTToken-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipTransferred(_owner,address(0))

IRs:
TMP_397 = CONVERT 0 to address
Emit OwnershipTransferred(_owner,TMP_397)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_owner = address(0)

IRs:
TMP_399 = CONVERT 0 to address
_owner(address) := TMP_399(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 44526.sol-DMarketNFTToken-renounceRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)

IRs:
TMP_380(address) = INTERNAL_CALL, Context._msgSender()()
TMP_381(bool) = account == TMP_380
TMP_382(None) = SOLIDITY_CALL require(bool,string)(TMP_381,AccessControl: can only renounce roles for self)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_revokeRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-DMarketNFTToken-revokeMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revokeRole(MINTER_ROLE,account)

IRs:
INTERNAL_CALL, AccessControl.revokeRole(bytes32,address)(MINTER_ROLE,account)"];
}
// Function: 44526.sol-DMarketNFTToken-revokeRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(getRoleAdmin(role),_msgSender()),AccessControl: sender must be an admin to revoke)

IRs:
TMP_375(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
TMP_376(address) = INTERNAL_CALL, Context._msgSender()()
TMP_377(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(TMP_375,TMP_376)
TMP_378(None) = SOLIDITY_CALL require(bool,string)(TMP_377,AccessControl: sender must be an admin to revoke)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_revokeRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-DMarketNFTToken-safeTransferFrom(address,address,uint256)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-safeTransferFrom(address,address,uint256,bytes)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-setApprovalForAll(address,bool)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
DEFAULT_ADMIN_ROLE = 0x00

IRs:
DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
MINTER_ROLE = keccak256(bytes)(MINTER_ROLE)

IRs:
TMP_423(bytes32) = SOLIDITY_CALL keccak256(bytes)(MINTER_ROLE)
MINTER_ROLE(bytes32) := TMP_423(bytes32)"];
}
// Function: 44526.sol-DMarketNFTToken-supportsInterface(bytes4)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
interfaceId == type()(IERC165).interfaceId

IRs:
TMP_363(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
REF_105(bytes4) (->None) := 33540519(bytes4)
TMP_364(bool) = interfaceId == REF_105
RETURN TMP_364"];
}
// Function: 44526.sol-DMarketNFTToken-symbol()
digraph{
}
// Function: 44526.sol-DMarketNFTToken-tokenURI(uint256)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-transferFrom(address,address,uint256)
digraph{
}
// Function: 44526.sol-DMarketNFTToken-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

IRs:
TMP_401 = CONVERT 0 to address
TMP_402(bool) = newOwner != TMP_401
TMP_403(None) = SOLIDITY_CALL require(bool,string)(TMP_402,Ownable: new owner is the zero address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(_owner,newOwner)

IRs:
Emit OwnershipTransferred(_owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_owner = newOwner

IRs:
_owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 44526.sol-ERC165-supportsInterface(bytes4)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
interfaceId == type()(IERC165).interfaceId

IRs:
TMP_72(type(IERC165)) = SOLIDITY_CALL type()(IERC165)
REF_11(bytes4) (->None) := 33540519(bytes4)
TMP_73(bool) = interfaceId == REF_11
RETURN TMP_73"];
}
// Function: 44526.sol-ERC721-_approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_tokenApprovals[tokenID] = to

IRs:
REF_39(address) -> _tokenApprovals[tokenID]
REF_39(address) (->_tokenApprovals) := to(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
Approval(ERC721.ownerOf(tokenID),to,tokenID)

IRs:
TMP_170(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
Emit Approval(TMP_170,to,tokenID)"];
}
// Function: 44526.sol-ERC721-_baseURI()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:


IRs:
RETURN "];
}
// Function: 44526.sol-ERC721-_beforeTokenTransfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
}
// Function: 44526.sol-ERC721-_burn(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
owner = ERC721.ownerOf(tokenID)

IRs:
TMP_153(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
owner(address) := TMP_153(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_beforeTokenTransfer(owner,address(0),tokenID)

IRs:
TMP_154 = CONVERT 0 to address
INTERNAL_CALL, ERC721._beforeTokenTransfer(address,address,uint256)(owner,TMP_154,tokenID)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_approve(address(0),tokenID)

IRs:
TMP_156 = CONVERT 0 to address
INTERNAL_CALL, ERC721._approve(address,uint256)(TMP_156,tokenID)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_balances[owner] -= 1

IRs:
REF_33(uint256) -> _balances[owner]
REF_33(-> _balances) = REF_33 (c)- 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
delete _owners[tokenID]

IRs:
REF_34(address) -> _owners[tokenID]
_owners = delete REF_34 "];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(owner,address(0),tokenID)

IRs:
TMP_158 = CONVERT 0 to address
Emit Transfer(owner,TMP_158,tokenID)"];
}
// Function: 44526.sol-ERC721-_checkOnERC721Received(address,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
to.isContract()

IRs:
TMP_172(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['to'] 
CONDITION TMP_172"];
1->2[label="True"];
1->12[label="False"];
2[label="Node Type: TRY 2

EXPRESSION:
retval = IERC721Receiver(to).onERC721Received(_msgSender(),from,tokenID,_data)

IRs:
TMP_173 = CONVERT to to IERC721Receiver
TMP_174(address) = INTERNAL_CALL, Context._msgSender()()
TMP_175(bytes4) = HIGH_LEVEL_CALL, dest:TMP_173(IERC721Receiver), function:onERC721Received, arguments:['TMP_174', 'from', 'tokenID', '_data']  
retval(bytes4) := TMP_175(bytes4)"];
2->3;
2->5;
2->13;
3[label="Node Type: CATCH 3
"];
3->4;
4[label="Node Type: RETURN 4

EXPRESSION:
retval == IERC721Receiver(to).onERC721Received.selector

IRs:
TMP_176 = CONVERT to to IERC721Receiver
REF_44(bytes4) (->None) := 353073666(uint256)
TMP_177(bool) = retval == REF_44
RETURN TMP_177"];
5[label="Node Type: CATCH 5
"];
5->6;
6[label="Node Type: IF 6

EXPRESSION:
reason.length == 0

IRs:
REF_45 -> LENGTH reason
TMP_178(bool) = REF_45 == 0
CONDITION TMP_178"];
6->7[label="True"];
6->8[label="False"];
7[label="Node Type: EXPRESSION 7

EXPRESSION:
revert(string)(ERC721: transfer to non ERC721Receiver implementer)

IRs:
TMP_179(None) = SOLIDITY_CALL revert(string)(ERC721: transfer to non ERC721Receiver implementer)"];
7->11;
8[label="Node Type: INLINE ASM 8
"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
revert(uint256,uint256)(32 + reason,mload(uint256)(reason))

IRs:
TMP_180(uint256) = 32 + reason
TMP_181(uint256) = SOLIDITY_CALL mload(uint256)(reason)
TMP_182(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_180,TMP_181)"];
9->10;
10[label="Node Type: END INLINE ASM 10
"];
10->11;
11[label="Node Type: END_IF 11
"];
11->13;
12[label="Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True"];
13[label="Node Type: END_IF 13
"];
}
// Function: 44526.sol-ERC721-_exists(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_owners[tokenID] != address(0)

IRs:
REF_27(address) -> _owners[tokenID]
TMP_127 = CONVERT 0 to address
TMP_128(bool) = REF_27 != TMP_127
RETURN TMP_128"];
}
// Function: 44526.sol-ERC721-_isApprovedOrOwner(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_exists(tokenID),ERC721: operator query for nonexistent token)

IRs:
TMP_129(bool) = INTERNAL_CALL, ERC721._exists(uint256)(tokenID)
TMP_130(None) = SOLIDITY_CALL require(bool,string)(TMP_129,ERC721: operator query for nonexistent token)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
owner = ERC721.ownerOf(tokenID)

IRs:
TMP_131(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
owner(address) := TMP_131(address)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
(spender == owner || getApproved(tokenID) == spender || ERC721.isApprovedForAll(owner,spender))

IRs:
TMP_132(bool) = spender == owner
TMP_133(address) = INTERNAL_CALL, ERC721.getApproved(uint256)(tokenID)
TMP_134(bool) = TMP_133 == spender
TMP_135(bool) = TMP_132 || TMP_134
TMP_136(bool) = INTERNAL_CALL, ERC721.isApprovedForAll(address,address)(owner,spender)
TMP_137(bool) = TMP_135 || TMP_136
RETURN TMP_137"];
}
// Function: 44526.sol-ERC721-_mint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(to != address(0),ERC721: mint to the zero address)

IRs:
TMP_143 = CONVERT 0 to address
TMP_144(bool) = to != TMP_143
TMP_145(None) = SOLIDITY_CALL require(bool,string)(TMP_144,ERC721: mint to the zero address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(! _exists(tokenID),ERC721: token already minted)

IRs:
TMP_146(bool) = INTERNAL_CALL, ERC721._exists(uint256)(tokenID)
TMP_147 = UnaryType.BANG TMP_146 
TMP_148(None) = SOLIDITY_CALL require(bool,string)(TMP_147,ERC721: token already minted)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_beforeTokenTransfer(address(0),to,tokenID)

IRs:
TMP_149 = CONVERT 0 to address
INTERNAL_CALL, ERC721._beforeTokenTransfer(address,address,uint256)(TMP_149,to,tokenID)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_balances[to] += 1

IRs:
REF_30(uint256) -> _balances[to]
REF_30(-> _balances) = REF_30 (c)+ 1"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_owners[tokenID] = to

IRs:
REF_31(address) -> _owners[tokenID]
REF_31(address) (->_owners) := to(address)"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
Transfer(address(0),to,tokenID)

IRs:
TMP_151 = CONVERT 0 to address
Emit Transfer(TMP_151,to,tokenID)"];
}
// Function: 44526.sol-ERC721-_msgData()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
this
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
msg.data

IRs:
RETURN msg.data"];
}
// Function: 44526.sol-ERC721-_msgSender()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 44526.sol-ERC721-_safeMint(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_safeMint(to,tokenID,)

IRs:
INTERNAL_CALL, ERC721._safeMint(address,uint256,bytes)(to,tokenID,)"];
}
// Function: 44526.sol-ERC721-_safeMint(address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_mint(to,tokenID)

IRs:
INTERNAL_CALL, ERC721._mint(address,uint256)(to,tokenID)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_checkOnERC721Received(address(0),to,tokenID,_data),ERC721: transfer to non ERC721Receiver implementer)

IRs:
TMP_140 = CONVERT 0 to address
TMP_141(bool) = INTERNAL_CALL, ERC721._checkOnERC721Received(address,address,uint256,bytes)(TMP_140,to,tokenID,_data)
TMP_142(None) = SOLIDITY_CALL require(bool,string)(TMP_141,ERC721: transfer to non ERC721Receiver implementer)"];
}
// Function: 44526.sol-ERC721-_safeTransfer(address,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_transfer(from,to,tokenID)

IRs:
INTERNAL_CALL, ERC721._transfer(address,address,uint256)(from,to,tokenID)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_checkOnERC721Received(from,to,tokenID,_data),ERC721: transfer to non ERC721Receiver implementer)

IRs:
TMP_125(bool) = INTERNAL_CALL, ERC721._checkOnERC721Received(address,address,uint256,bytes)(from,to,tokenID,_data)
TMP_126(None) = SOLIDITY_CALL require(bool,string)(TMP_125,ERC721: transfer to non ERC721Receiver implementer)"];
}
// Function: 44526.sol-ERC721-_transfer(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(ERC721.ownerOf(tokenID) == from,ERC721: transfer of token that is not own)

IRs:
TMP_160(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
TMP_161(bool) = TMP_160 == from
TMP_162(None) = SOLIDITY_CALL require(bool,string)(TMP_161,ERC721: transfer of token that is not own)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(to != address(0),ERC721: transfer to the zero address)

IRs:
TMP_163 = CONVERT 0 to address
TMP_164(bool) = to != TMP_163
TMP_165(None) = SOLIDITY_CALL require(bool,string)(TMP_164,ERC721: transfer to the zero address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_beforeTokenTransfer(from,to,tokenID)

IRs:
INTERNAL_CALL, ERC721._beforeTokenTransfer(address,address,uint256)(from,to,tokenID)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_approve(address(0),tokenID)

IRs:
TMP_167 = CONVERT 0 to address
INTERNAL_CALL, ERC721._approve(address,uint256)(TMP_167,tokenID)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_balances[from] -= 1

IRs:
REF_36(uint256) -> _balances[from]
REF_36(-> _balances) = REF_36 (c)- 1"];
5->6;
6[label="Node Type: EXPRESSION 6

EXPRESSION:
_balances[to] += 1

IRs:
REF_37(uint256) -> _balances[to]
REF_37(-> _balances) = REF_37 (c)+ 1"];
6->7;
7[label="Node Type: EXPRESSION 7

EXPRESSION:
_owners[tokenID] = to

IRs:
REF_38(address) -> _owners[tokenID]
REF_38(address) (->_owners) := to(address)"];
7->8;
8[label="Node Type: EXPRESSION 8

EXPRESSION:
Transfer(from,to,tokenID)

IRs:
Emit Transfer(from,to,tokenID)"];
}
// Function: 44526.sol-ERC721-approve(address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
owner = ERC721.ownerOf(tokenID)

IRs:
TMP_97(address) = INTERNAL_CALL, ERC721.ownerOf(uint256)(tokenID)
owner(address) := TMP_97(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(to != owner,ERC721: approval to current owner)

IRs:
TMP_98(bool) = to != owner
TMP_99(None) = SOLIDITY_CALL require(bool,string)(TMP_98,ERC721: approval to current owner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(_msgSender() == owner || ERC721.isApprovedForAll(owner,_msgSender()),ERC721: approve caller is not owner nor approved for all)

IRs:
TMP_100(address) = INTERNAL_CALL, Context._msgSender()()
TMP_101(bool) = TMP_100 == owner
TMP_102(address) = INTERNAL_CALL, Context._msgSender()()
TMP_103(bool) = INTERNAL_CALL, ERC721.isApprovedForAll(address,address)(owner,TMP_102)
TMP_104(bool) = TMP_101 || TMP_103
TMP_105(None) = SOLIDITY_CALL require(bool,string)(TMP_104,ERC721: approve caller is not owner nor approved for all)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
_approve(to,tokenID)

IRs:
INTERNAL_CALL, ERC721._approve(address,uint256)(to,tokenID)"];
}
// Function: 44526.sol-ERC721-balanceOf(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(owner != address(0),ERC721: balance query for the zero address)

IRs:
TMP_83 = CONVERT 0 to address
TMP_84(bool) = owner != TMP_83
TMP_85(None) = SOLIDITY_CALL require(bool,string)(TMP_84,ERC721: balance query for the zero address)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_balances[owner]

IRs:
REF_15(uint256) -> _balances[owner]
RETURN REF_15"];
}
// Function: 44526.sol-ERC721-constructor(string,string)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_name = name_

IRs:
_name(string) := name_(string)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_symbol = symbol_

IRs:
_symbol(string) := symbol_(string)"];
}
// Function: 44526.sol-ERC721-getApproved(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_exists(tokenID),ERC721: approved query for nonexistent token)

IRs:
TMP_107(bool) = INTERNAL_CALL, ERC721._exists(uint256)(tokenID)
TMP_108(None) = SOLIDITY_CALL require(bool,string)(TMP_107,ERC721: approved query for nonexistent token)"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
_tokenApprovals[tokenID]

IRs:
REF_22(address) -> _tokenApprovals[tokenID]
RETURN REF_22"];
}
// Function: 44526.sol-ERC721-isApprovedForAll(address,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_operatorApprovals[owner][operator]

IRs:
REF_25(mapping(address => bool)) -> _operatorApprovals[owner]
REF_26(bool) -> REF_25[operator]
RETURN REF_26"];
}
// Function: 44526.sol-ERC721-name()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_name

IRs:
RETURN _name"];
}
// Function: 44526.sol-ERC721-ownerOf(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
owner = _owners[tokenID]

IRs:
REF_16(address) -> _owners[tokenID]
owner(address) := REF_16(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(owner != address(0),ERC721: owner query for nonexistent token)

IRs:
TMP_86 = CONVERT 0 to address
TMP_87(bool) = owner != TMP_86
TMP_88(None) = SOLIDITY_CALL require(bool,string)(TMP_87,ERC721: owner query for nonexistent token)"];
2->3;
3[label="Node Type: RETURN 3

EXPRESSION:
owner

IRs:
RETURN owner"];
}
// Function: 44526.sol-ERC721-safeTransferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
safeTransferFrom(from,to,tokenID,)

IRs:
INTERNAL_CALL, ERC721.safeTransferFrom(address,address,uint256,bytes)(from,to,tokenID,)"];
}
// Function: 44526.sol-ERC721-safeTransferFrom(address,address,uint256,bytes)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_isApprovedOrOwner(_msgSender(),tokenID),ERC721: transfer caller is not owner nor approved)

IRs:
TMP_120(address) = INTERNAL_CALL, Context._msgSender()()
TMP_121(bool) = INTERNAL_CALL, ERC721._isApprovedOrOwner(address,uint256)(TMP_120,tokenID)
TMP_122(None) = SOLIDITY_CALL require(bool,string)(TMP_121,ERC721: transfer caller is not owner nor approved)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_safeTransfer(from,to,tokenID,_data)

IRs:
INTERNAL_CALL, ERC721._safeTransfer(address,address,uint256,bytes)(from,to,tokenID,_data)"];
}
// Function: 44526.sol-ERC721-setApprovalForAll(address,bool)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(operator != _msgSender(),ERC721: approve to caller)

IRs:
TMP_109(address) = INTERNAL_CALL, Context._msgSender()()
TMP_110(bool) = operator != TMP_109
TMP_111(None) = SOLIDITY_CALL require(bool,string)(TMP_110,ERC721: approve to caller)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_operatorApprovals[_msgSender()][operator] = approved

IRs:
TMP_112(address) = INTERNAL_CALL, Context._msgSender()()
REF_23(mapping(address => bool)) -> _operatorApprovals[TMP_112]
REF_24(bool) -> REF_23[operator]
REF_24(bool) (->_operatorApprovals) := approved(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
ApprovalForAll(_msgSender(),operator,approved)

IRs:
TMP_113(address) = INTERNAL_CALL, Context._msgSender()()
Emit ApprovalForAll(TMP_113,operator,approved)"];
}
// Function: 44526.sol-ERC721-supportsInterface(bytes4)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
interfaceId == type()(IERC721).interfaceId || interfaceId == type()(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId)

IRs:
TMP_76(type(IERC721)) = SOLIDITY_CALL type()(IERC721)
REF_13(bytes4) (->None) := 2169737578(bytes4)
TMP_77(bool) = interfaceId == REF_13
TMP_78(type(IERC721Metadata)) = SOLIDITY_CALL type()(IERC721Metadata)
REF_14(bytes4) (->None) := 3658318581(bytes4)
TMP_79(bool) = interfaceId == REF_14
TMP_80(bool) = TMP_77 || TMP_79
TMP_81(bool) = INTERNAL_CALL, ERC165.supportsInterface(bytes4)(interfaceId)
TMP_82(bool) = TMP_80 || TMP_81
RETURN TMP_82"];
}
// Function: 44526.sol-ERC721-symbol()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_symbol

IRs:
RETURN _symbol"];
}
// Function: 44526.sol-ERC721-tokenURI(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_exists(tokenID),ERC721Metadata: URI query for nonexistent token)

IRs:
TMP_89(bool) = INTERNAL_CALL, ERC721._exists(uint256)(tokenID)
TMP_90(None) = SOLIDITY_CALL require(bool,string)(TMP_89,ERC721Metadata: URI query for nonexistent token)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
baseURI = _baseURI()

IRs:
TMP_91(string) = INTERNAL_CALL, ERC721._baseURI()()
baseURI(string) := TMP_91(string)"];
2->4;
4[label="Node Type: IF 4

EXPRESSION:
bytes(baseURI).length > 0

IRs:
TMP_92 = CONVERT baseURI to bytes
REF_17 -> LENGTH TMP_92
TMP_93(bool) = REF_17 > 0
CONDITION TMP_93"];
4->5[label="True"];
4->6[label="False"];
5[label="Node Type: RETURN 5

EXPRESSION:
string(abi.encodePacked(baseURI,tokenID.toString()))

IRs:
TMP_94(string) = LIBRARY_CALL, dest:Strings, function:Strings.toString(uint256), arguments:['tokenID'] 
TMP_95(bytes) = SOLIDITY_CALL abi.encodePacked()(baseURI,TMP_94)
TMP_96 = CONVERT TMP_95 to string
RETURN TMP_96"];
6[label="Node Type: RETURN 6

EXPRESSION:


IRs:
RETURN "];
}
// Function: 44526.sol-ERC721-transferFrom(address,address,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_isApprovedOrOwner(_msgSender(),tokenID),ERC721: transfer caller is not owner nor approved)

IRs:
TMP_115(address) = INTERNAL_CALL, Context._msgSender()()
TMP_116(bool) = INTERNAL_CALL, ERC721._isApprovedOrOwner(address,uint256)(TMP_115,tokenID)
TMP_117(None) = SOLIDITY_CALL require(bool,string)(TMP_116,ERC721: transfer caller is not owner nor approved)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_transfer(from,to,tokenID)

IRs:
INTERNAL_CALL, ERC721._transfer(address,address,uint256)(from,to,tokenID)"];
}
// Function: 44526.sol-IERC165-supportsInterface(bytes4)
digraph{
}
// Function: 44526.sol-IERC721-approve(address,uint256)
digraph{
}
// Function: 44526.sol-IERC721-balanceOf(address)
digraph{
}
// Function: 44526.sol-IERC721-getApproved(uint256)
digraph{
}
// Function: 44526.sol-IERC721-isApprovedForAll(address,address)
digraph{
}
// Function: 44526.sol-IERC721-ownerOf(uint256)
digraph{
}
// Function: 44526.sol-IERC721-safeTransferFrom(address,address,uint256)
digraph{
}
// Function: 44526.sol-IERC721-safeTransferFrom(address,address,uint256,bytes)
digraph{
}
// Function: 44526.sol-IERC721-setApprovalForAll(address,bool)
digraph{
}
// Function: 44526.sol-IERC721-supportsInterface(bytes4)
digraph{
}
// Function: 44526.sol-IERC721-transferFrom(address,address,uint256)
digraph{
}
// Function: 44526.sol-IERC721Metadata-approve(address,uint256)
digraph{
}
// Function: 44526.sol-IERC721Metadata-balanceOf(address)
digraph{
}
// Function: 44526.sol-IERC721Metadata-getApproved(uint256)
digraph{
}
// Function: 44526.sol-IERC721Metadata-isApprovedForAll(address,address)
digraph{
}
// Function: 44526.sol-IERC721Metadata-name()
digraph{
}
// Function: 44526.sol-IERC721Metadata-ownerOf(uint256)
digraph{
}
// Function: 44526.sol-IERC721Metadata-safeTransferFrom(address,address,uint256)
digraph{
}
// Function: 44526.sol-IERC721Metadata-safeTransferFrom(address,address,uint256,bytes)
digraph{
}
// Function: 44526.sol-IERC721Metadata-setApprovalForAll(address,bool)
digraph{
}
// Function: 44526.sol-IERC721Metadata-supportsInterface(bytes4)
digraph{
}
// Function: 44526.sol-IERC721Metadata-symbol()
digraph{
}
// Function: 44526.sol-IERC721Metadata-tokenURI(uint256)
digraph{
}
// Function: 44526.sol-IERC721Metadata-transferFrom(address,address,uint256)
digraph{
}
// Function: 44526.sol-IERC721Receiver-onERC721Received(address,address,uint256,bytes)
digraph{
}
// Function: 44526.sol-MinterAccess-_grantRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
! hasRole(role,account)

IRs:
TMP_224(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
TMP_225 = UnaryType.BANG TMP_224 
CONDITION TMP_225"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].members[account] = true

IRs:
REF_66(AccessControl.RoleData) -> _roles[role]
REF_67(mapping(address => bool)) -> REF_66.members
REF_68(bool) -> REF_67[account]
REF_68(bool) (->_roles) := True(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RoleGranted(role,account,_msgSender())

IRs:
TMP_226(address) = INTERNAL_CALL, Context._msgSender()()
Emit RoleGranted(role,account,TMP_226)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 44526.sol-MinterAccess-_msgData()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
this
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
msg.data

IRs:
RETURN msg.data"];
}
// Function: 44526.sol-MinterAccess-_msgSender()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 44526.sol-MinterAccess-_revokeRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
hasRole(role,account)

IRs:
TMP_228(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(role,account)
CONDITION TMP_228"];
1->2[label="True"];
1->4[label="False"];
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].members[account] = false

IRs:
REF_69(AccessControl.RoleData) -> _roles[role]
REF_70(mapping(address => bool)) -> REF_69.members
REF_71(bool) -> REF_70[account]
REF_71(bool) (->_roles) := False(bool)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
RoleRevoked(role,account,_msgSender())

IRs:
TMP_229(address) = INTERNAL_CALL, Context._msgSender()()
Emit RoleRevoked(role,account,TMP_229)"];
3->4;
4[label="Node Type: END_IF 4
"];
}
// Function: 44526.sol-MinterAccess-_setRoleAdmin(bytes32,bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
RoleAdminChanged(role,getRoleAdmin(role),adminRole)

IRs:
TMP_222(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
Emit RoleAdminChanged(role,TMP_222,adminRole)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_roles[role].adminRole = adminRole

IRs:
REF_64(AccessControl.RoleData) -> _roles[role]
REF_65(bytes32) -> REF_64.adminRole
REF_65(bytes32) (->_roles) := adminRole(bytes32)"];
}
// Function: 44526.sol-MinterAccess-_setupRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_grantRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-MinterAccess-addMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
grantRole(MINTER_ROLE,account)

IRs:
INTERNAL_CALL, AccessControl.grantRole(bytes32,address)(MINTER_ROLE,account)"];
}
// Function: 44526.sol-MinterAccess-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
_setupRole(DEFAULT_ADMIN_ROLE,msg.sender)

IRs:
INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(DEFAULT_ADMIN_ROLE,msg.sender)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_setupRole(MINTER_ROLE,msg.sender)

IRs:
INTERNAL_CALL, AccessControl._setupRole(bytes32,address)(MINTER_ROLE,msg.sender)"];
}
// Function: 44526.sol-MinterAccess-getRoleAdmin(bytes32)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_roles[role].adminRole

IRs:
REF_62(AccessControl.RoleData) -> _roles[role]
REF_63(bytes32) -> REF_62.adminRole
RETURN REF_63"];
}
// Function: 44526.sol-MinterAccess-grantRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(getRoleAdmin(role),_msgSender()),AccessControl: sender must be an admin to grant)

IRs:
TMP_207(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
TMP_208(address) = INTERNAL_CALL, Context._msgSender()()
TMP_209(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(TMP_207,TMP_208)
TMP_210(None) = SOLIDITY_CALL require(bool,string)(TMP_209,AccessControl: sender must be an admin to grant)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_grantRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._grantRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-MinterAccess-hasRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_roles[role].members[account]

IRs:
REF_59(AccessControl.RoleData) -> _roles[role]
REF_60(mapping(address => bool)) -> REF_59.members
REF_61(bool) -> REF_60[account]
RETURN REF_61"];
}
// Function: 44526.sol-MinterAccess-onlyMinter()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(MINTER_ROLE,_msgSender()),MinterAccess: Sender is not a minter)

IRs:
TMP_253(address) = INTERNAL_CALL, Context._msgSender()()
TMP_254(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(MINTER_ROLE,TMP_253)
TMP_255(None) = SOLIDITY_CALL require(bool,string)(TMP_254,MinterAccess: Sender is not a minter)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 44526.sol-MinterAccess-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

IRs:
TMP_249(address) = INTERNAL_CALL, Ownable.owner()()
TMP_250(address) = INTERNAL_CALL, Context._msgSender()()
TMP_251(bool) = TMP_249 == TMP_250
TMP_252(None) = SOLIDITY_CALL require(bool,string)(TMP_251,Ownable: caller is not the owner)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 44526.sol-MinterAccess-owner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_owner

IRs:
RETURN _owner"];
}
// Function: 44526.sol-MinterAccess-renounceMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
renounceRole(MINTER_ROLE,account)

IRs:
INTERNAL_CALL, AccessControl.renounceRole(bytes32,address)(MINTER_ROLE,account)"];
}
// Function: 44526.sol-MinterAccess-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipTransferred(_owner,address(0))

IRs:
TMP_234 = CONVERT 0 to address
Emit OwnershipTransferred(_owner,TMP_234)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_owner = address(0)

IRs:
TMP_236 = CONVERT 0 to address
_owner(address) := TMP_236(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 44526.sol-MinterAccess-renounceRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(account == _msgSender(),AccessControl: can only renounce roles for self)

IRs:
TMP_217(address) = INTERNAL_CALL, Context._msgSender()()
TMP_218(bool) = account == TMP_217
TMP_219(None) = SOLIDITY_CALL require(bool,string)(TMP_218,AccessControl: can only renounce roles for self)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_revokeRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-MinterAccess-revokeMinter(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
revokeRole(MINTER_ROLE,account)

IRs:
INTERNAL_CALL, AccessControl.revokeRole(bytes32,address)(MINTER_ROLE,account)"];
}
// Function: 44526.sol-MinterAccess-revokeRole(bytes32,address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasRole(getRoleAdmin(role),_msgSender()),AccessControl: sender must be an admin to revoke)

IRs:
TMP_212(bytes32) = INTERNAL_CALL, AccessControl.getRoleAdmin(bytes32)(role)
TMP_213(address) = INTERNAL_CALL, Context._msgSender()()
TMP_214(bool) = INTERNAL_CALL, AccessControl.hasRole(bytes32,address)(TMP_212,TMP_213)
TMP_215(None) = SOLIDITY_CALL require(bool,string)(TMP_214,AccessControl: sender must be an admin to revoke)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_revokeRole(role,account)

IRs:
INTERNAL_CALL, AccessControl._revokeRole(bytes32,address)(role,account)"];
}
// Function: 44526.sol-MinterAccess-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
DEFAULT_ADMIN_ROLE = 0x00

IRs:
DEFAULT_ADMIN_ROLE(bytes32) := 0(uint256)"];
0->1;
1[label="Node Type: OTHER_ENTRYPOINT 1

EXPRESSION:
MINTER_ROLE = keccak256(bytes)(MINTER_ROLE)

IRs:
TMP_248(bytes32) = SOLIDITY_CALL keccak256(bytes)(MINTER_ROLE)
MINTER_ROLE(bytes32) := TMP_248(bytes32)"];
}
// Function: 44526.sol-MinterAccess-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

IRs:
TMP_238 = CONVERT 0 to address
TMP_239(bool) = newOwner != TMP_238
TMP_240(None) = SOLIDITY_CALL require(bool,string)(TMP_239,Ownable: new owner is the zero address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(_owner,newOwner)

IRs:
Emit OwnershipTransferred(_owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_owner = newOwner

IRs:
_owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 44526.sol-Ownable-_msgData()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
this
"];
1->2;
2[label="Node Type: RETURN 2

EXPRESSION:
msg.data

IRs:
RETURN msg.data"];
}
// Function: 44526.sol-Ownable-_msgSender()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
msg.sender

IRs:
RETURN msg.sender"];
}
// Function: 44526.sol-Ownable-constructor()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
msgSender = _msgSender()

IRs:
TMP_56(address) = INTERNAL_CALL, Context._msgSender()()
msgSender(address) := TMP_56(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_owner = msgSender

IRs:
_owner(address) := msgSender(address)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
OwnershipTransferred(address(0),msgSender)

IRs:
TMP_57 = CONVERT 0 to address
Emit OwnershipTransferred(TMP_57,msgSender)"];
}
// Function: 44526.sol-Ownable-onlyOwner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(owner() == _msgSender(),Ownable: caller is not the owner)

IRs:
TMP_68(address) = INTERNAL_CALL, Ownable.owner()()
TMP_69(address) = INTERNAL_CALL, Context._msgSender()()
TMP_70(bool) = TMP_68 == TMP_69
TMP_71(None) = SOLIDITY_CALL require(bool,string)(TMP_70,Ownable: caller is not the owner)"];
1->2;
2[label="Node Type: _ 2
"];
}
// Function: 44526.sol-Ownable-owner()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: RETURN 1

EXPRESSION:
_owner

IRs:
RETURN _owner"];
}
// Function: 44526.sol-Ownable-renounceOwnership()
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->3;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
OwnershipTransferred(_owner,address(0))

IRs:
TMP_59 = CONVERT 0 to address
Emit OwnershipTransferred(_owner,TMP_59)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
_owner = address(0)

IRs:
TMP_61 = CONVERT 0 to address
_owner(address) := TMP_61(address)"];
3[label="Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
3->1;
}
// Function: 44526.sol-Ownable-transferOwnership(address)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->4;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(newOwner != address(0),Ownable: new owner is the zero address)

IRs:
TMP_63 = CONVERT 0 to address
TMP_64(bool) = newOwner != TMP_63
TMP_65(None) = SOLIDITY_CALL require(bool,string)(TMP_64,Ownable: new owner is the zero address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
OwnershipTransferred(_owner,newOwner)

IRs:
Emit OwnershipTransferred(_owner,newOwner)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
_owner = newOwner

IRs:
_owner(address) := newOwner(address)"];
4[label="Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()"];
4->1;
}
// Function: 44526.sol-Strings-slitherConstructorConstantVariables()
digraph{
0[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
alphabet = 0123456789abcdef

IRs:
alphabet(bytes16) := 0123456789abcdef(string)"];
}
// Function: 44526.sol-Strings-toHexString(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
value == 0

IRs:
TMP_41(bool) = value == 0
CONDITION TMP_41"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0x00

IRs:
RETURN 0x00"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
temp = value

IRs:
temp(uint256) := value(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
length = 0

IRs:
length(uint256) := 0(uint256)"];
5->6;
6[label="Node Type: BEGIN_LOOP 6
"];
6->7;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
temp != 0

IRs:
TMP_42(bool) = temp != 0
CONDITION TMP_42"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
length ++

IRs:
TMP_43(uint256) := length(uint256)
length(uint256) = length (c)+ 1"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
temp >>= 8

IRs:
temp(uint256) = temp >> 8"];
9->7;
10[label="Node Type: END_LOOP 10
"];
10->11;
11[label="Node Type: RETURN 11

EXPRESSION:
toHexString(value,length)

IRs:
TMP_44(string) = INTERNAL_CALL, Strings.toHexString(uint256,uint256)(value,length)
RETURN TMP_44"];
}
// Function: 44526.sol-Strings-toHexString(uint256,uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
buffer = new bytes(2 * length + 2)

IRs:
TMP_46(uint256) = 2 (c)* length
TMP_47(uint256) = TMP_46 (c)+ 2
TMP_48 = new bytes(TMP_47)
buffer(bytes) := TMP_48(bytes)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
buffer[0] = 0

IRs:
REF_7(string) -> buffer[0]
REF_7(string) (->buffer) := 0(string)"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
buffer[1] = x

IRs:
REF_8(string) -> buffer[1]
REF_8(string) (->buffer) := x(string)"];
3->6;
4[label="Node Type: BEGIN_LOOP 4
"];
4->7;
5[label="Node Type: END_LOOP 5
"];
5->11;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
i = 2 * length + 1

IRs:
TMP_49(uint256) = 2 (c)* length
TMP_50(uint256) = TMP_49 (c)+ 1
i(uint256) := TMP_50(uint256)"];
6->4;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
i > 1

IRs:
TMP_51(bool) = i > 1
CONDITION TMP_51"];
7->8[label="True"];
7->5[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
buffer[i] = alphabet[value & 0xf]

IRs:
REF_9(None) -> buffer[i]
TMP_52(uint256) = value & 15
REF_10(None) -> alphabet[TMP_52]
REF_9(None) (->buffer) := REF_10(None)"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
value >>= 4

IRs:
value(uint256) = value >> 4"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
-- i

IRs:
i(uint256) = i (c)- 1"];
10->7;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(value == 0,Strings: hex length insufficient)

IRs:
TMP_53(bool) = value == 0
TMP_54(None) = SOLIDITY_CALL require(bool,string)(TMP_53,Strings: hex length insufficient)"];
11->12;
12[label="Node Type: RETURN 12

EXPRESSION:
string(buffer)

IRs:
TMP_55 = CONVERT buffer to string
RETURN TMP_55"];
}
// Function: 44526.sol-Strings-toString(uint256)
digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: IF 1

EXPRESSION:
value == 0

IRs:
TMP_29(bool) = value == 0
CONDITION TMP_29"];
1->2[label="True"];
1->3[label="False"];
2[label="Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0"];
3[label="Node Type: END_IF 3
"];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
temp = value

IRs:
temp(uint256) := value(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5
"];
5->6;
6[label="Node Type: BEGIN_LOOP 6
"];
6->7;
7[label="Node Type: IF_LOOP 7

EXPRESSION:
temp != 0

IRs:
TMP_30(bool) = temp != 0
CONDITION TMP_30"];
7->8[label="True"];
7->10[label="False"];
8[label="Node Type: EXPRESSION 8

EXPRESSION:
digits ++

IRs:
TMP_31(uint256) := digits(uint256)
digits(uint256) = digits (c)+ 1"];
8->9;
9[label="Node Type: EXPRESSION 9

EXPRESSION:
temp /= 10

IRs:
temp(uint256) = temp (c)/ 10"];
9->7;
10[label="Node Type: END_LOOP 10
"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
buffer = new bytes(digits)

IRs:
TMP_33 = new bytes(digits)
buffer(bytes) := TMP_33(bytes)"];
11->12;
12[label="Node Type: BEGIN_LOOP 12
"];
12->13;
13[label="Node Type: IF_LOOP 13

EXPRESSION:
value != 0

IRs:
TMP_34(bool) = value != 0
CONDITION TMP_34"];
13->14[label="True"];
13->17[label="False"];
14[label="Node Type: EXPRESSION 14

EXPRESSION:
digits -= 1

IRs:
digits(uint256) = digits (c)- 1"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
buffer[digits] = bytes1(uint8(48 + uint256(value % 10)))

IRs:
REF_6(bytes1) -> buffer[digits]
TMP_35(uint256) = value % 10
TMP_36 = CONVERT TMP_35 to uint256
TMP_37(uint256) = 48 (c)+ TMP_36
TMP_38 = CONVERT TMP_37 to uint8
TMP_39 = CONVERT TMP_38 to bytes1
REF_6(bytes1) (->buffer) := TMP_39(bytes1)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
value /= 10

IRs:
value(uint256) = value (c)/ 10"];
16->13;
17[label="Node Type: END_LOOP 17
"];
17->18;
18[label="Node Type: RETURN 18

EXPRESSION:
string(buffer)

IRs:
TMP_40 = CONVERT buffer to string
RETURN TMP_40"];
}
}
