{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 0.sol-BREBuy-changeConfig(uint32,uint256,uint8)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->11;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncurConfig.hasChange = true\\n\\nIRs:\\nREF_7(bool) -> curConfig.hasChange\\nREF_7(bool) (->curConfig) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nsetConfig.totalSize != _totalSize\\n\\nIRs:\\nREF_8(uint32) -> setConfig.totalSize\\nTMP_24(bool) = REF_8 != _totalSize\\nCONDITION TMP_24\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetConfig.totalSize = _totalSize\\n\\nIRs:\\nREF_9(uint32) -> setConfig.totalSize\\nREF_9(uint32) (->setConfig) := _totalSize(uint32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\nsetConfig.pumpRate != _pumpRate\\n\\nIRs:\\nREF_10(uint8) -> setConfig.pumpRate\\nTMP_25(bool) = REF_10 != _pumpRate\\nCONDITION TMP_25\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nsetConfig.pumpRate = _pumpRate\\n\\nIRs:\\nREF_11(uint8) -> setConfig.pumpRate\\nREF_11(uint8) (->setConfig) := _pumpRate(uint8)\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\nsetConfig.singlePrice != _singlePrice * 1000000000000000\\n\\nIRs:\\nREF_12(uint256) -> setConfig.singlePrice\\nTMP_26(uint256) = _singlePrice * 1000000000000000\\nTMP_27(bool) = REF_12 != TMP_26\\nCONDITION TMP_27\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nsetConfig.singlePrice = _singlePrice * 1000000000000000\\n\\nIRs:\\nREF_13(uint256) -> setConfig.singlePrice\\nTMP_28(uint256) = _singlePrice * 1000000000000000\\nREF_13(uint256) (->setConfig) := TMP_28(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, BREBuy.onlyOwner()()\\\"];\\n11->1;\\n}\\n// Function: 0.sol-BREBuy-constructor(uint32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nsetConfig = ContractParam(_totalSize,_singlePrice * 1000000000000000,5,false)\\n\\nIRs:\\nTMP_0(uint256) = _singlePrice * 1000000000000000\\nTMP_1(BREBuy.ContractParam) = new ContractParam(_totalSize,TMP_0,5,False)\\nsetConfig(BREBuy.ContractParam) := TMP_1(BREBuy.ContractParam)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ncurConfig = ContractParam(_totalSize,_singlePrice * 1000000000000000,5,false)\\n\\nIRs:\\nTMP_2(uint256) = _singlePrice * 1000000000000000\\nTMP_3(BREBuy.ContractParam) = new ContractParam(_totalSize,TMP_2,5,False)\\ncurConfig(BREBuy.ContractParam) := TMP_3(BREBuy.ContractParam)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nstartNewGame()\\n\\nIRs:\\nINTERNAL_CALL, BREBuy.startNewGame()()\\\"];\\n}\\n// Function: 0.sol-BREBuy-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->11;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(msg.sender == tx.origin,msg.sender must equipt tx.origin)\\n\\nIRs:\\nTMP_53(bool) = msg.sender == tx.origin\\nTMP_54(None) = SOLIDITY_CALL require(bool,string)(TMP_53,msg.sender must equipt tx.origin)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(isNotContract(msg.sender),msg.sender not is Contract)\\n\\nIRs:\\nTMP_55(bool) = INTERNAL_CALL, BREBuy.isNotContract(address)(msg.sender)\\nTMP_56(None) = SOLIDITY_CALL require(bool,string)(TMP_55,msg.sender not is Contract)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool,string)(msg.value == curConfig.singlePrice,msg.value error)\\n\\nIRs:\\nREF_44(uint256) -> curConfig.singlePrice\\nTMP_57(bool) = msg.value == REF_44\\nTMP_58(None) = SOLIDITY_CALL require(bool,string)(TMP_57,msg.value error)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalPrice = totalPrice + msg.value\\n\\nIRs:\\nTMP_59(uint256) = totalPrice + msg.value\\ntotalPrice(uint256) := TMP_59(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\naddressArray.push(msg.sender)\\n\\nIRs:\\nREF_46 -> LENGTH addressArray\\nTMP_61(uint256) := REF_46(uint256)\\nTMP_62(uint256) = TMP_61 + 1\\nREF_46(uint256) (->addressArray) := TMP_62(uint256)\\nREF_47(address) -> addressArray[TMP_61]\\nREF_47(address) (->addressArray) := msg.sender(address)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\naddPlayerEvent(gameIndex,msg.sender)\\n\\nIRs:\\nEmit addPlayerEvent(gameIndex,msg.sender)\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\naddressArray.length >= curConfig.totalSize\\n\\nIRs:\\nREF_48 -> LENGTH addressArray\\nREF_49(uint32) -> curConfig.totalSize\\nTMP_64(bool) = REF_48 >= REF_49\\nCONDITION TMP_64\\\"];\\n7->8[label=\\\"True\\\"];\\n7->10[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ngameResult()\\n\\nIRs:\\nINTERNAL_CALL, BREBuy.gameResult()()\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nstartNewGame()\\n\\nIRs:\\nINTERNAL_CALL, BREBuy.startNewGame()()\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nnotLock()\\n\\nIRs:\\nMODIFIER_CALL, BREBuy.notLock()()\\\"];\\n11->1;\\n}\\n// Function: 0.sol-BREBuy-gameResult()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nindex = getRamdon()\\n\\nIRs:\\nTMP_34(uint256) = INTERNAL_CALL, BREBuy.getRamdon()()\\nindex(uint256) := TMP_34(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nlastAddress = addressArray[index]\\n\\nIRs:\\nREF_32(address) -> addressArray[index]\\nlastAddress(address) := REF_32(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ntotalBalace = address(this).balance\\n\\nIRs:\\nTMP_35 = CONVERT this to address\\nTMP_36(uint256) = SOLIDITY_CALL balance(address)(TMP_35)\\ntotalBalace(uint256) := TMP_36(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ngiveToOwn = totalBalace * curConfig.pumpRate / 100\\n\\nIRs:\\nREF_33(uint8) -> curConfig.pumpRate\\nTMP_37(uint256) = totalBalace * REF_33\\nTMP_38(uint256) = TMP_37 / 100\\ngiveToOwn(uint256) := TMP_38(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ngiveToActor = totalBalace - giveToOwn\\n\\nIRs:\\nTMP_39(uint256) = totalBalace - giveToOwn\\ngiveToActor(uint256) := TMP_39(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nowner.transfer(giveToOwn)\\n\\nIRs:\\nTransfer dest:owner value:giveToOwn\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nlastAddress.transfer(giveToActor)\\n\\nIRs:\\nTransfer dest:lastAddress value:giveToActor\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ngameOverEvent(gameIndex,curConfig.totalSize,curConfig.singlePrice,curConfig.pumpRate,lastAddress,now)\\n\\nIRs:\\nREF_36(uint32) -> curConfig.totalSize\\nREF_37(uint256) -> curConfig.singlePrice\\nREF_38(uint8) -> curConfig.pumpRate\\nEmit gameOverEvent(gameIndex,REF_36,REF_37,REF_38,lastAddress,now)\\\"];\\n}\\n// Function: 0.sol-BREBuy-getGameInfo()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n(gameIndex,curConfig.totalSize,curConfig.singlePrice,curConfig.pumpRate,addressArray,totalPrice,isLock)\\n\\nIRs:\\nREF_29(uint32) -> curConfig.totalSize\\nREF_30(uint256) -> curConfig.singlePrice\\nREF_31(uint8) -> curConfig.pumpRate\\nRETURN gameIndex,REF_29,REF_30,REF_31,addressArray,totalPrice,isLock\\\"];\\n}\\n// Function: 0.sol-BREBuy-getRamdon()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nramdon = keccak256()(abi.encodePacked(ramdon,now,blockhash(uint256)(block.number - 1)))\\n\\nIRs:\\nTMP_43(uint256) = block.number - 1\\nTMP_44(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_43)\\nTMP_45(bytes) = SOLIDITY_CALL abi.encodePacked()(ramdon,now,TMP_44)\\nTMP_46(bytes32) = SOLIDITY_CALL keccak256()(TMP_45)\\nramdon(bytes32) := TMP_46(bytes32)\\\"];\\n1->4;\\n2[label=\\\"Node Type: BEGIN_LOOP 2\\n\\\"];\\n2->5;\\n3[label=\\\"Node Type: END_LOOP 3\\n\\\"];\\n3->8;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n4->2;\\n5[label=\\\"Node Type: IF_LOOP 5\\n\\nEXPRESSION:\\ni < addressArray.length\\n\\nIRs:\\nREF_40 -> LENGTH addressArray\\nTMP_47(bool) = i < REF_40\\nCONDITION TMP_47\\\"];\\n5->6[label=\\\"True\\\"];\\n5->3[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nramdon = keccak256()(abi.encodePacked(ramdon,now,addressArray[i]))\\n\\nIRs:\\nREF_42(address) -> addressArray[i]\\nTMP_48(bytes) = SOLIDITY_CALL abi.encodePacked()(ramdon,now,REF_42)\\nTMP_49(bytes32) = SOLIDITY_CALL keccak256()(TMP_48)\\nramdon(bytes32) := TMP_49(bytes32)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_50(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n7->5;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\nindex = uint256(ramdon) % addressArray.length\\n\\nIRs:\\nTMP_51 = CONVERT ramdon to uint256\\nREF_43 -> LENGTH addressArray\\nTMP_52(uint256) = TMP_51 % REF_43\\nindex(uint256) := TMP_52(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nindex\\n\\nIRs:\\nRETURN index\\\"];\\n}\\n// Function: 0.sol-BREBuy-isNotContract(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsize <= 0\\n\\nIRs:\\nTMP_5(bool) = size <= 0\\nRETURN TMP_5\\\"];\\n}\\n// Function: 0.sol-BREBuy-notLock()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(isLock == false,contract current is lock status)\\n\\nIRs:\\nTMP_72(bool) = isLock == False\\nTMP_73(None) = SOLIDITY_CALL require(bool,string)(TMP_72,contract current is lock status)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 0.sol-BREBuy-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(msg.sender == owner,only owner can call this function)\\n\\nIRs:\\nTMP_70(bool) = msg.sender == owner\\nTMP_71(None) = SOLIDITY_CALL require(bool,string)(TMP_70,only owner can call this function)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 0.sol-BREBuy-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nowner = 0x0\\n\\nIRs:\\nowner(address) := 0(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\ngameIndex = 0\\n\\nIRs:\\ngameIndex(uint32) := 0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ntotalPrice = 0\\n\\nIRs:\\ntotalPrice(uint256) := 0(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nisLock = false\\n\\nIRs:\\nisLock(bool) := False(bool)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\naddressArray = new address[](0)\\n\\nIRs:\\nTMP_69(address[])  = new address[](0)\\naddressArray(address[]) = ['TMP_69(address[])']\\\"];\\n}\\n// Function: 0.sol-BREBuy-startNewGame()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ngameIndex ++\\n\\nIRs:\\nTMP_30(uint32) := gameIndex(uint32)\\ngameIndex(uint32) = gameIndex + 1\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\ncurConfig.hasChange\\n\\nIRs:\\nREF_14(bool) -> curConfig.hasChange\\nCONDITION REF_14\\\"];\\n2->3[label=\\\"True\\\"];\\n2->13[label=\\\"False\\\"];\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\ncurConfig.totalSize != setConfig.totalSize\\n\\nIRs:\\nREF_15(uint32) -> curConfig.totalSize\\nREF_16(uint32) -> setConfig.totalSize\\nTMP_31(bool) = REF_15 != REF_16\\nCONDITION TMP_31\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ncurConfig.totalSize = setConfig.totalSize\\n\\nIRs:\\nREF_17(uint32) -> curConfig.totalSize\\nREF_18(uint32) -> setConfig.totalSize\\nREF_17(uint32) (->curConfig) := REF_18(uint32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: IF 6\\n\\nEXPRESSION:\\ncurConfig.singlePrice != setConfig.singlePrice\\n\\nIRs:\\nREF_19(uint256) -> curConfig.singlePrice\\nREF_20(uint256) -> setConfig.singlePrice\\nTMP_32(bool) = REF_19 != REF_20\\nCONDITION TMP_32\\\"];\\n6->7[label=\\\"True\\\"];\\n6->8[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ncurConfig.singlePrice = setConfig.singlePrice\\n\\nIRs:\\nREF_21(uint256) -> curConfig.singlePrice\\nREF_22(uint256) -> setConfig.singlePrice\\nREF_21(uint256) (->curConfig) := REF_22(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n8->9;\\n9[label=\\\"Node Type: IF 9\\n\\nEXPRESSION:\\ncurConfig.pumpRate != setConfig.pumpRate\\n\\nIRs:\\nREF_23(uint8) -> curConfig.pumpRate\\nREF_24(uint8) -> setConfig.pumpRate\\nTMP_33(bool) = REF_23 != REF_24\\nCONDITION TMP_33\\\"];\\n9->10[label=\\\"True\\\"];\\n9->11[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ncurConfig.pumpRate = setConfig.pumpRate\\n\\nIRs:\\nREF_25(uint8) -> curConfig.pumpRate\\nREF_26(uint8) -> setConfig.pumpRate\\nREF_25(uint8) (->curConfig) := REF_26(uint8)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ncurConfig.hasChange = false\\n\\nIRs:\\nREF_27(bool) -> curConfig.hasChange\\nREF_27(bool) (->curConfig) := False(bool)\\\"];\\n12->13;\\n13[label=\\\"Node Type: END_IF 13\\n\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\naddressArray.length = 0\\n\\nIRs:\\nREF_28 -> LENGTH addressArray\\nREF_28(uint256) (->addressArray) := 0(uint256)\\\"];\\n}\\n// Function: 0.sol-BREBuy-stopGame()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->15;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\naddressArray.length <= 0\\n\\nIRs:\\nREF_0 -> LENGTH addressArray\\nTMP_12(bool) = REF_0 <= 0\\nCONDITION TMP_12\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ntotalBalace = address(this).balance\\n\\nIRs:\\nTMP_13 = CONVERT this to address\\nTMP_14(uint256) = SOLIDITY_CALL balance(address)(TMP_13)\\ntotalBalace(uint256) := TMP_14(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nprice = totalBalace / addressArray.length\\n\\nIRs:\\nREF_1 -> LENGTH addressArray\\nTMP_15(uint256) = totalBalace / REF_1\\nprice(uint256) := TMP_15(uint256)\\\"];\\n5->8;\\n6[label=\\\"Node Type: BEGIN_LOOP 6\\n\\\"];\\n6->9;\\n7[label=\\\"Node Type: END_LOOP 7\\n\\\"];\\n7->13;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n8->6;\\n9[label=\\\"Node Type: IF_LOOP 9\\n\\nEXPRESSION:\\ni < addressArray.length\\n\\nIRs:\\nREF_2 -> LENGTH addressArray\\nTMP_16(bool) = i < REF_2\\nCONDITION TMP_16\\\"];\\n9->10[label=\\\"True\\\"];\\n9->7[label=\\\"False\\\"];\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\ncurPlayer = addressArray[i]\\n\\nIRs:\\nREF_3(address) -> addressArray[i]\\ncurPlayer(address) := REF_3(address)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ncurPlayer.transfer(price)\\n\\nIRs:\\nTransfer dest:curPlayer value:price\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_18(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n12->9;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nstopGameEvent(totalBalace,addressArray.length,price)\\n\\nIRs:\\nREF_5 -> LENGTH addressArray\\nEmit stopGameEvent(totalBalace,REF_5,price)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\naddressArray.length = 0\\n\\nIRs:\\nREF_6 -> LENGTH addressArray\\nREF_6(uint256) (->addressArray) := 0(uint256)\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, BREBuy.onlyOwner()()\\\"];\\n15->1;\\n}\\n// Function: 0.sol-BREBuy-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_21 = CONVERT 0 to address\\nTMP_22(bool) = newOwner != TMP_21\\nCONDITION TMP_22\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, BREBuy.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 0.sol-BREBuy-updateLock(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->8;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(isLock != b, updateLock new status == old status)\\n\\nIRs:\\nTMP_6(bool) = isLock != b\\nTMP_7(None) = SOLIDITY_CALL require(bool,string)(TMP_6, updateLock new status == old status)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nisLock = b\\n\\nIRs:\\nisLock(bool) := b(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nisLock\\n\\nIRs:\\nCONDITION isLock\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nstopGame()\\n\\nIRs:\\nINTERNAL_CALL, BREBuy.stopGame()()\\\"];\\n4->7;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nstartNewGame()\\n\\nIRs:\\nINTERNAL_CALL, BREBuy.startNewGame()()\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nopenLockEvent()\\n\\nIRs:\\nEmit openLockEvent()\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, BREBuy.onlyOwner()()\\\"];\\n8->1;\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Block Number Dependency\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 2.sol-BasicToken-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 2.sol-BasicToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_12(uint256) -> balances[_owner]\\nRETURN REF_12\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 2.sol-BasicToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_32(bool) = msg.sender == owner\\nTMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-BasicToken-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! (msg.data.length < size + 4))\\n\\nIRs:\\nREF_13 -> LENGTH msg.data\\nTMP_34(uint256) = size + 4\\nTMP_35(bool) = REF_13 < TMP_34\\nTMP_36 = UnaryType.BANG TMP_35 \\nTMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-BasicToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nbasisPointsRate = 0\\n\\nIRs:\\nbasisPointsRate(uint256) := 0(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nmaximumFee = 0\\n\\nIRs:\\nmaximumFee(uint256) := 0(uint256)\\\"];\\n}\\n// Function: 2.sol-BasicToken-totalSupply()\\ndigraph{\\n}\\n// Function: 2.sol-BasicToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nfee = (_value.mul(basisPointsRate)).div(10000)\\n\\nIRs:\\nTMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] \\nTMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_20', '10000'] \\nfee(uint256) := TMP_21(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nfee > maximumFee\\n\\nIRs:\\nTMP_22(bool) = fee > maximumFee\\nCONDITION TMP_22\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nfee = maximumFee\\n\\nIRs:\\nfee(uint256) := maximumFee(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nsendAmount = _value.sub(fee)\\n\\nIRs:\\nTMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] \\nsendAmount(uint256) := TMP_23(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_3(uint256) -> balances[msg.sender]\\nREF_4(uint256) -> balances[msg.sender]\\nTMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_4', '_value'] \\nREF_3(uint256) (->balances) := TMP_24(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(sendAmount)\\n\\nIRs:\\nREF_6(uint256) -> balances[_to]\\nREF_7(uint256) -> balances[_to]\\nTMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_7', 'sendAmount'] \\nREF_6(uint256) (->balances) := TMP_25(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\nfee > 0\\n\\nIRs:\\nTMP_26(bool) = fee > 0\\nCONDITION TMP_26\\\"];\\n8->9[label=\\\"True\\\"];\\n8->11[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nbalances[owner] = balances[owner].add(fee)\\n\\nIRs:\\nREF_9(uint256) -> balances[owner]\\nREF_10(uint256) -> balances[owner]\\nTMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_10', 'fee'] \\nREF_9(uint256) (->balances) := TMP_27(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nTransfer(msg.sender,owner,fee)\\n\\nIRs:\\nEmit Transfer(msg.sender,owner,fee)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,sendAmount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,sendAmount)\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_30(uint256) = 2 * 32\\nMODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_30)\\\"];\\n13->1;\\n}\\n// Function: 2.sol-BasicToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_17 = CONVERT 0 to address\\nTMP_18(bool) = newOwner != TMP_17\\nCONDITION TMP_18\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-BlackList-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 2.sol-BlackList-addBlackList(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nisBlackListed[_evilUser] = true\\n\\nIRs:\\nREF_65(bool) -> isBlackListed[_evilUser]\\nREF_65(bool) (->isBlackListed) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nAddedBlackList(_evilUser)\\n\\nIRs:\\nEmit AddedBlackList(_evilUser)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 2.sol-BlackList-balanceOf(address)\\ndigraph{\\n}\\n// Function: 2.sol-BlackList-destroyBlackFunds(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(isBlackListed[_blackListedUser])\\n\\nIRs:\\nREF_67(bool) -> isBlackListed[_blackListedUser]\\nTMP_116(None) = SOLIDITY_CALL require(bool)(REF_67)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ndirtyFunds = balanceOf(_blackListedUser)\\n\\nIRs:\\nTMP_117(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_blackListedUser)\\ndirtyFunds(uint256) := TMP_117(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_blackListedUser] = 0\\n\\nIRs:\\nREF_68(uint256) -> balances[_blackListedUser]\\nREF_68(uint256) (->balances) := 0(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_totalSupply -= dirtyFunds\\n\\nIRs:\\n_totalSupply(uint256) = _totalSupply - dirtyFunds\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nDestroyedBlackFunds(_blackListedUser,dirtyFunds)\\n\\nIRs:\\nEmit DestroyedBlackFunds(_blackListedUser,dirtyFunds)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 2.sol-BlackList-getBlackListStatus(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nisBlackListed[_maker]\\n\\nIRs:\\nREF_64(bool) -> isBlackListed[_maker]\\nRETURN REF_64\\\"];\\n}\\n// Function: 2.sol-BlackList-getOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nowner\\n\\nIRs:\\nRETURN owner\\\"];\\n}\\n// Function: 2.sol-BlackList-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_124(bool) = msg.sender == owner\\nTMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-BlackList-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! (msg.data.length < size + 4))\\n\\nIRs:\\nREF_69 -> LENGTH msg.data\\nTMP_120(uint256) = size + 4\\nTMP_121(bool) = REF_69 < TMP_120\\nTMP_122 = UnaryType.BANG TMP_121 \\nTMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-BlackList-removeBlackList(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nisBlackListed[_clearedUser] = false\\n\\nIRs:\\nREF_66(bool) -> isBlackListed[_clearedUser]\\nREF_66(bool) (->isBlackListed) := False(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nRemovedBlackList(_clearedUser)\\n\\nIRs:\\nEmit RemovedBlackList(_clearedUser)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 2.sol-BlackList-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nbasisPointsRate = 0\\n\\nIRs:\\nbasisPointsRate(uint256) := 0(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nmaximumFee = 0\\n\\nIRs:\\nmaximumFee(uint256) := 0(uint256)\\\"];\\n}\\n// Function: 2.sol-BlackList-totalSupply()\\ndigraph{\\n}\\n// Function: 2.sol-BlackList-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-BlackList-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_109 = CONVERT 0 to address\\nTMP_110(bool) = newOwner != TMP_109\\nCONDITION TMP_110\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 2.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 2.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 2.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 2.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 2.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-Ownable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 2.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_15(bool) = msg.sender == owner\\nTMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_12 = CONVERT 0 to address\\nTMP_13(bool) = newOwner != TMP_12\\nCONDITION TMP_13\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-Pausable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 2.sol-Pausable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_92(bool) = msg.sender == owner\\nTMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-Pausable-pause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = true\\n\\nIRs:\\npaused(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nPause()\\n\\nIRs:\\nEmit Pause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenNotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenNotPaused()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-Pausable-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n}\\n// Function: 2.sol-Pausable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_83 = CONVERT 0 to address\\nTMP_84(bool) = newOwner != TMP_83\\nCONDITION TMP_84\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-Pausable-unpause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nUnpause()\\n\\nIRs:\\nEmit Unpause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenPaused()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-Pausable-whenNotPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! paused)\\n\\nIRs:\\nTMP_94 = UnaryType.BANG paused \\nTMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-Pausable-whenPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(paused)\\n\\nIRs:\\nTMP_96(None) = SOLIDITY_CALL require(bool)(paused)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 2.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nc(uint256) := TMP_5(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 2.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 2.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n// Function: 2.sol-StandardToken-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 2.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowed[_owner]\\nREF_49(uint256) -> REF_48[_spender]\\nRETURN REF_49\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 2.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! ((_value != 0) && (allowed[msg.sender][_spender] != 0)))\\n\\nIRs:\\nTMP_67(bool) = _value != 0\\nREF_44(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_45(uint256) -> REF_44[_spender]\\nTMP_68(bool) = REF_45 != 0\\nTMP_69(bool) = TMP_67 && TMP_68\\nTMP_70 = UnaryType.BANG TMP_69 \\nTMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_46(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_47(uint256) -> REF_46[_spender]\\nREF_47(uint256) (->allowed) := _value(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_73(uint256) = 2 * 32\\nMODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_73)\\\"];\\n4->1;\\n}\\n// Function: 2.sol-StandardToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_26(uint256) -> balances[_owner]\\nRETURN REF_26\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 2.sol-StandardToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_81(bool) = msg.sender == owner\\nTMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-StandardToken-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! (msg.data.length < size + 4))\\n\\nIRs:\\nREF_50 -> LENGTH msg.data\\nTMP_77(uint256) = size + 4\\nTMP_78(bool) = REF_50 < TMP_77\\nTMP_79 = UnaryType.BANG TMP_78 \\nTMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-StandardToken-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nMAX_UINT = 2 ** 256 - 1\\n\\nIRs:\\nTMP_75(uint256) = 2 ** 256\\nTMP_76(uint256) = TMP_75 - 1\\nMAX_UINT(uint256) := TMP_76(uint256)\\\"];\\n}\\n// Function: 2.sol-StandardToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nbasisPointsRate = 0\\n\\nIRs:\\nbasisPointsRate(uint256) := 0(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nmaximumFee = 0\\n\\nIRs:\\nmaximumFee(uint256) := 0(uint256)\\\"];\\n}\\n// Function: 2.sol-StandardToken-totalSupply()\\ndigraph{\\n}\\n// Function: 2.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nfee = (_value.mul(basisPointsRate)).div(10000)\\n\\nIRs:\\nTMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] \\nTMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', '10000'] \\nfee(uint256) := TMP_39(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nfee > maximumFee\\n\\nIRs:\\nTMP_40(bool) = fee > maximumFee\\nCONDITION TMP_40\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nfee = maximumFee\\n\\nIRs:\\nfee(uint256) := maximumFee(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nsendAmount = _value.sub(fee)\\n\\nIRs:\\nTMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] \\nsendAmount(uint256) := TMP_41(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_17(uint256) -> balances[msg.sender]\\nREF_18(uint256) -> balances[msg.sender]\\nTMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_18', '_value'] \\nREF_17(uint256) (->balances) := TMP_42(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(sendAmount)\\n\\nIRs:\\nREF_20(uint256) -> balances[_to]\\nREF_21(uint256) -> balances[_to]\\nTMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_21', 'sendAmount'] \\nREF_20(uint256) (->balances) := TMP_43(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\nfee > 0\\n\\nIRs:\\nTMP_44(bool) = fee > 0\\nCONDITION TMP_44\\\"];\\n8->9[label=\\\"True\\\"];\\n8->11[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nbalances[owner] = balances[owner].add(fee)\\n\\nIRs:\\nREF_23(uint256) -> balances[owner]\\nREF_24(uint256) -> balances[owner]\\nTMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_24', 'fee'] \\nREF_23(uint256) (->balances) := TMP_45(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nTransfer(msg.sender,owner,fee)\\n\\nIRs:\\nEmit Transfer(msg.sender,owner,fee)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,sendAmount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,sendAmount)\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_48(uint256) = 2 * 32\\nMODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_48)\\\"];\\n13->1;\\n}\\n// Function: 2.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->17;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\n_allowance = allowed[_from][msg.sender]\\n\\nIRs:\\nREF_27(mapping(address => uint256)) -> allowed[_from]\\nREF_28(uint256) -> REF_27[msg.sender]\\n_allowance(uint256) := REF_28(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nfee = (_value.mul(basisPointsRate)).div(10000)\\n\\nIRs:\\nTMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] \\nTMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_53', '10000'] \\nfee(uint256) := TMP_54(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nfee > maximumFee\\n\\nIRs:\\nTMP_55(bool) = fee > maximumFee\\nCONDITION TMP_55\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nfee = maximumFee\\n\\nIRs:\\nfee(uint256) := maximumFee(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: IF 6\\n\\nEXPRESSION:\\n_allowance < MAX_UINT\\n\\nIRs:\\nTMP_56(bool) = _allowance < MAX_UINT\\nCONDITION TMP_56\\\"];\\n6->7[label=\\\"True\\\"];\\n6->8[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = _allowance.sub(_value)\\n\\nIRs:\\nREF_31(mapping(address => uint256)) -> allowed[_from]\\nREF_32(uint256) -> REF_31[msg.sender]\\nTMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_allowance', '_value'] \\nREF_32(uint256) (->allowed) := TMP_57(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n8->9;\\n9[label=\\\"Node Type: NEW VARIABLE 9\\n\\nEXPRESSION:\\nsendAmount = _value.sub(fee)\\n\\nIRs:\\nTMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] \\nsendAmount(uint256) := TMP_58(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_35(uint256) -> balances[_from]\\nREF_36(uint256) -> balances[_from]\\nTMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_36', '_value'] \\nREF_35(uint256) (->balances) := TMP_59(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(sendAmount)\\n\\nIRs:\\nREF_38(uint256) -> balances[_to]\\nREF_39(uint256) -> balances[_to]\\nTMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_39', 'sendAmount'] \\nREF_38(uint256) (->balances) := TMP_60(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: IF 12\\n\\nEXPRESSION:\\nfee > 0\\n\\nIRs:\\nTMP_61(bool) = fee > 0\\nCONDITION TMP_61\\\"];\\n12->13[label=\\\"True\\\"];\\n12->15[label=\\\"False\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nbalances[owner] = balances[owner].add(fee)\\n\\nIRs:\\nREF_41(uint256) -> balances[owner]\\nREF_42(uint256) -> balances[owner]\\nTMP_62(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_42', 'fee'] \\nREF_41(uint256) (->balances) := TMP_62(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nTransfer(_from,owner,fee)\\n\\nIRs:\\nEmit Transfer(_from,owner,fee)\\\"];\\n14->15;\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nTransfer(_from,_to,sendAmount)\\n\\nIRs:\\nEmit Transfer(_from,_to,sendAmount)\\\"];\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nonlyPayloadSize(3 * 32)\\n\\nIRs:\\nTMP_65(uint256) = 3 * 32\\nMODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_65)\\\"];\\n17->1;\\n}\\n// Function: 2.sol-StandardToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_50 = CONVERT 0 to address\\nTMP_51(bool) = newOwner != TMP_50\\nCONDITION TMP_51\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-USDCToken-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 2.sol-USDCToken-USDCToken()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_totalSupply = 100000000\\n\\nIRs:\\n_totalSupply(uint256) := 100000000(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = USDC Token\\n\\nIRs:\\nname(string) := USDC Token(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsymbol = USDC\\n\\nIRs:\\nsymbol(string) := USDC(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ndecimals = 6\\n\\nIRs:\\ndecimals(uint256) := 6(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[owner] = _totalSupply\\n\\nIRs:\\nREF_148(uint256) -> balances[owner]\\nREF_148(uint256) (->balances) := _totalSupply(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ndeprecated = false\\n\\nIRs:\\ndeprecated(bool) := False(bool)\\\"];\\n}\\n// Function: 2.sol-USDCToken-addBlackList(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nisBlackListed[_evilUser] = true\\n\\nIRs:\\nREF_108(bool) -> isBlackListed[_evilUser]\\nREF_108(bool) (->isBlackListed) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nAddedBlackList(_evilUser)\\n\\nIRs:\\nEmit AddedBlackList(_evilUser)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 2.sol-USDCToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ndeprecated\\n\\nIRs:\\nCONDITION deprecated\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nStandardToken(upgradedAddress).allowance(_owner,_spender)\\n\\nIRs:\\nTMP_242 = CONVERT upgradedAddress to StandardToken\\nTMP_243(uint256) = HIGH_LEVEL_CALL, dest:TMP_242(StandardToken), function:allowance, arguments:['_owner', '_spender']  \\nRETURN TMP_243\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuper.allowance(_owner,_spender)\\n\\nIRs:\\nTMP_244(uint256) = INTERNAL_CALL, StandardToken.allowance(address,address)(_owner,_spender)\\nRETURN TMP_244\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 2.sol-USDCToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ndeprecated\\n\\nIRs:\\nCONDITION deprecated\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nUpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender,_spender,_value)\\n\\nIRs:\\nTMP_237 = CONVERT upgradedAddress to UpgradedStandardToken\\nHIGH_LEVEL_CALL, dest:TMP_237(UpgradedStandardToken), function:approveByLegacy, arguments:['msg.sender', '_spender', '_value']  \\nRETURN TMP_238\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuper.approve(_spender,_value)\\n\\nIRs:\\nINTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)\\nRETURN TMP_239\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_240(uint256) = 2 * 32\\nMODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_240)\\\"];\\n5->1;\\n}\\n// Function: 2.sol-USDCToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ndeprecated\\n\\nIRs:\\nCONDITION deprecated\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nUpgradedStandardToken(upgradedAddress).balanceOf(who)\\n\\nIRs:\\nTMP_234 = CONVERT upgradedAddress to UpgradedStandardToken\\nTMP_235(uint256) = HIGH_LEVEL_CALL, dest:TMP_234(UpgradedStandardToken), function:balanceOf, arguments:['who']  \\nRETURN TMP_235\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuper.balanceOf(who)\\n\\nIRs:\\nTMP_236(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(who)\\nRETURN TMP_236\\\"];\\n}\\n// Function: 2.sol-USDCToken-deprecate(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndeprecated = true\\n\\nIRs:\\ndeprecated(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nupgradedAddress = _upgradedAddress\\n\\nIRs:\\nupgradedAddress(address) := _upgradedAddress(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nDeprecate(_upgradedAddress)\\n\\nIRs:\\nEmit Deprecate(_upgradedAddress)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-USDCToken-destroyBlackFunds(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(isBlackListed[_blackListedUser])\\n\\nIRs:\\nREF_110(bool) -> isBlackListed[_blackListedUser]\\nTMP_175(None) = SOLIDITY_CALL require(bool)(REF_110)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ndirtyFunds = balanceOf(_blackListedUser)\\n\\nIRs:\\nTMP_176(uint256) = INTERNAL_CALL, USDCToken.balanceOf(address)(_blackListedUser)\\ndirtyFunds(uint256) := TMP_176(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_blackListedUser] = 0\\n\\nIRs:\\nREF_111(uint256) -> balances[_blackListedUser]\\nREF_111(uint256) (->balances) := 0(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_totalSupply -= dirtyFunds\\n\\nIRs:\\n_totalSupply(uint256) = _totalSupply - dirtyFunds\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nDestroyedBlackFunds(_blackListedUser,dirtyFunds)\\n\\nIRs:\\nEmit DestroyedBlackFunds(_blackListedUser,dirtyFunds)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 2.sol-USDCToken-getBlackListStatus(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nisBlackListed[_maker]\\n\\nIRs:\\nREF_107(bool) -> isBlackListed[_maker]\\nRETURN REF_107\\\"];\\n}\\n// Function: 2.sol-USDCToken-getOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nowner\\n\\nIRs:\\nRETURN owner\\\"];\\n}\\n// Function: 2.sol-USDCToken-issue(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_totalSupply + amount > _totalSupply)\\n\\nIRs:\\nTMP_249(uint256) = _totalSupply + amount\\nTMP_250(bool) = TMP_249 > _totalSupply\\nTMP_251(None) = SOLIDITY_CALL require(bool)(TMP_250)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balances[owner] + amount > balances[owner])\\n\\nIRs:\\nREF_157(uint256) -> balances[owner]\\nTMP_252(uint256) = REF_157 + amount\\nREF_158(uint256) -> balances[owner]\\nTMP_253(bool) = TMP_252 > REF_158\\nTMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[owner] += amount\\n\\nIRs:\\nREF_159(uint256) -> balances[owner]\\nREF_159(-> balances) = REF_159 + amount\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_totalSupply += amount\\n\\nIRs:\\n_totalSupply(uint256) = _totalSupply + amount\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nIssue(amount)\\n\\nIRs:\\nEmit Issue(amount)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 2.sol-USDCToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_277(bool) = msg.sender == owner\\nTMP_278(None) = SOLIDITY_CALL require(bool)(TMP_277)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-USDCToken-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! (msg.data.length < size + 4))\\n\\nIRs:\\nREF_163 -> LENGTH msg.data\\nTMP_273(uint256) = size + 4\\nTMP_274(bool) = REF_163 < TMP_273\\nTMP_275 = UnaryType.BANG TMP_274 \\nTMP_276(None) = SOLIDITY_CALL require(bool)(TMP_275)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-USDCToken-pause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = true\\n\\nIRs:\\npaused(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nPause()\\n\\nIRs:\\nEmit Pause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenNotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenNotPaused()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-USDCToken-redeem(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_totalSupply >= amount)\\n\\nIRs:\\nTMP_257(bool) = _totalSupply >= amount\\nTMP_258(None) = SOLIDITY_CALL require(bool)(TMP_257)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balances[owner] >= amount)\\n\\nIRs:\\nREF_160(uint256) -> balances[owner]\\nTMP_259(bool) = REF_160 >= amount\\nTMP_260(None) = SOLIDITY_CALL require(bool)(TMP_259)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_totalSupply -= amount\\n\\nIRs:\\n_totalSupply(uint256) = _totalSupply - amount\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[owner] -= amount\\n\\nIRs:\\nREF_161(uint256) -> balances[owner]\\nREF_161(-> balances) = REF_161 - amount\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nRedeem(amount)\\n\\nIRs:\\nEmit Redeem(amount)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 2.sol-USDCToken-removeBlackList(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nisBlackListed[_clearedUser] = false\\n\\nIRs:\\nREF_109(bool) -> isBlackListed[_clearedUser]\\nREF_109(bool) (->isBlackListed) := False(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nRemovedBlackList(_clearedUser)\\n\\nIRs:\\nEmit RemovedBlackList(_clearedUser)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 2.sol-USDCToken-setParams(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newBasisPoints < 20)\\n\\nIRs:\\nTMP_263(bool) = newBasisPoints < 20\\nTMP_264(None) = SOLIDITY_CALL require(bool)(TMP_263)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(newMaxFee < 50)\\n\\nIRs:\\nTMP_265(bool) = newMaxFee < 50\\nTMP_266(None) = SOLIDITY_CALL require(bool)(TMP_265)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbasisPointsRate = newBasisPoints\\n\\nIRs:\\nbasisPointsRate(uint256) := newBasisPoints(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nmaximumFee = newMaxFee.mul(10 ** decimals)\\n\\nIRs:\\nTMP_267(uint256) = 10 ** decimals\\nTMP_268(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['newMaxFee', 'TMP_267'] \\nmaximumFee(uint256) := TMP_268(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nParams(basisPointsRate,maximumFee)\\n\\nIRs:\\nEmit Params(basisPointsRate,maximumFee)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 2.sol-USDCToken-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nMAX_UINT = 2 ** 256 - 1\\n\\nIRs:\\nTMP_271(uint256) = 2 ** 256\\nTMP_272(uint256) = TMP_271 - 1\\nMAX_UINT(uint256) := TMP_272(uint256)\\\"];\\n}\\n// Function: 2.sol-USDCToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nbasisPointsRate = 0\\n\\nIRs:\\nbasisPointsRate(uint256) := 0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nmaximumFee = 0\\n\\nIRs:\\nmaximumFee(uint256) := 0(uint256)\\\"];\\n}\\n// Function: 2.sol-USDCToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ndeprecated\\n\\nIRs:\\nCONDITION deprecated\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nStandardToken(upgradedAddress).totalSupply()\\n\\nIRs:\\nTMP_247 = CONVERT upgradedAddress to StandardToken\\nTMP_248(uint256) = HIGH_LEVEL_CALL, dest:TMP_247(StandardToken), function:totalSupply, arguments:[]  \\nRETURN TMP_248\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\n_totalSupply\\n\\nIRs:\\nRETURN _totalSupply\\\"];\\n}\\n// Function: 2.sol-USDCToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! isBlackListed[msg.sender])\\n\\nIRs:\\nREF_149(bool) -> isBlackListed[msg.sender]\\nTMP_222 = UnaryType.BANG REF_149 \\nTMP_223(None) = SOLIDITY_CALL require(bool)(TMP_222)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\ndeprecated\\n\\nIRs:\\nCONDITION deprecated\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nUpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender,_to,_value)\\n\\nIRs:\\nTMP_224 = CONVERT upgradedAddress to UpgradedStandardToken\\nHIGH_LEVEL_CALL, dest:TMP_224(UpgradedStandardToken), function:transferByLegacy, arguments:['msg.sender', '_to', '_value']  \\nRETURN TMP_225\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuper.transfer(_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, BasicToken.transfer(address,uint256)(_to,_value)\\nRETURN TMP_226\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nwhenNotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenNotPaused()()\\\"];\\n6->1;\\n}\\n// Function: 2.sol-USDCToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! isBlackListed[_from])\\n\\nIRs:\\nREF_151(bool) -> isBlackListed[_from]\\nTMP_228 = UnaryType.BANG REF_151 \\nTMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\ndeprecated\\n\\nIRs:\\nCONDITION deprecated\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nUpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender,_from,_to,_value)\\n\\nIRs:\\nTMP_230 = CONVERT upgradedAddress to UpgradedStandardToken\\nHIGH_LEVEL_CALL, dest:TMP_230(UpgradedStandardToken), function:transferFromByLegacy, arguments:['msg.sender', '_from', '_to', '_value']  \\nRETURN TMP_231\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuper.transferFrom(_from,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)\\nRETURN TMP_232\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nwhenNotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenNotPaused()()\\\"];\\n6->1;\\n}\\n// Function: 2.sol-USDCToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_191 = CONVERT 0 to address\\nTMP_192(bool) = newOwner != TMP_191\\nCONDITION TMP_192\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-USDCToken-unpause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nUnpause()\\n\\nIRs:\\nEmit Unpause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenPaused()()\\\"];\\n4->1;\\n}\\n// Function: 2.sol-USDCToken-whenNotPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! paused)\\n\\nIRs:\\nTMP_279 = UnaryType.BANG paused \\nTMP_280(None) = SOLIDITY_CALL require(bool)(TMP_279)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-USDCToken-whenPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(paused)\\n\\nIRs:\\nTMP_281(None) = SOLIDITY_CALL require(bool)(paused)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-UpgradedStandardToken-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 2.sol-UpgradedStandardToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 2.sol-UpgradedStandardToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-UpgradedStandardToken-approveByLegacy(address,address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-UpgradedStandardToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_105(uint256) -> balances[_owner]\\nRETURN REF_105\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 2.sol-UpgradedStandardToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_169(bool) = msg.sender == owner\\nTMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-UpgradedStandardToken-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! (msg.data.length < size + 4))\\n\\nIRs:\\nREF_106 -> LENGTH msg.data\\nTMP_165(uint256) = size + 4\\nTMP_166(bool) = REF_106 < TMP_165\\nTMP_167 = UnaryType.BANG TMP_166 \\nTMP_168(None) = SOLIDITY_CALL require(bool)(TMP_167)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 2.sol-UpgradedStandardToken-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nMAX_UINT = 2 ** 256 - 1\\n\\nIRs:\\nTMP_163(uint256) = 2 ** 256\\nTMP_164(uint256) = TMP_163 - 1\\nMAX_UINT(uint256) := TMP_164(uint256)\\\"];\\n}\\n// Function: 2.sol-UpgradedStandardToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nbasisPointsRate = 0\\n\\nIRs:\\nbasisPointsRate(uint256) := 0(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nmaximumFee = 0\\n\\nIRs:\\nmaximumFee(uint256) := 0(uint256)\\\"];\\n}\\n// Function: 2.sol-UpgradedStandardToken-totalSupply()\\ndigraph{\\n}\\n// Function: 2.sol-UpgradedStandardToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nfee = (_value.mul(basisPointsRate)).div(10000)\\n\\nIRs:\\nTMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_value', 'basisPointsRate'] \\nTMP_149(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_148', '10000'] \\nfee(uint256) := TMP_149(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nfee > maximumFee\\n\\nIRs:\\nTMP_150(bool) = fee > maximumFee\\nCONDITION TMP_150\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nfee = maximumFee\\n\\nIRs:\\nfee(uint256) := maximumFee(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nsendAmount = _value.sub(fee)\\n\\nIRs:\\nTMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_value', 'fee'] \\nsendAmount(uint256) := TMP_151(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_96(uint256) -> balances[msg.sender]\\nREF_97(uint256) -> balances[msg.sender]\\nTMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_97', '_value'] \\nREF_96(uint256) (->balances) := TMP_152(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(sendAmount)\\n\\nIRs:\\nREF_99(uint256) -> balances[_to]\\nREF_100(uint256) -> balances[_to]\\nTMP_153(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_100', 'sendAmount'] \\nREF_99(uint256) (->balances) := TMP_153(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\nfee > 0\\n\\nIRs:\\nTMP_154(bool) = fee > 0\\nCONDITION TMP_154\\\"];\\n8->9[label=\\\"True\\\"];\\n8->11[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nbalances[owner] = balances[owner].add(fee)\\n\\nIRs:\\nREF_102(uint256) -> balances[owner]\\nREF_103(uint256) -> balances[owner]\\nTMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_103', 'fee'] \\nREF_102(uint256) (->balances) := TMP_155(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nTransfer(msg.sender,owner,fee)\\n\\nIRs:\\nEmit Transfer(msg.sender,owner,fee)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,sendAmount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,sendAmount)\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_158(uint256) = 2 * 32\\nMODIFIER_CALL, BasicToken.onlyPayloadSize(uint256)(TMP_158)\\\"];\\n13->1;\\n}\\n// Function: 2.sol-UpgradedStandardToken-transferByLegacy(address,address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-UpgradedStandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-UpgradedStandardToken-transferFromByLegacy(address,address,address,uint256)\\ndigraph{\\n}\\n// Function: 2.sol-UpgradedStandardToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_160 = CONVERT 0 to address\\nTMP_161(bool) = newOwner != TMP_160\\nCONDITION TMP_161\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 3.sol-ContractReceiver-tokenFallback(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntkn.sender = _from\\n\\nIRs:\\nREF_0(address) -> tkn.sender\\nREF_0(address) (->tkn) := _from(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntkn.value = _value\\n\\nIRs:\\nREF_1(uint256) -> tkn.value\\nREF_1(uint256) (->tkn) := _value(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntkn.data = _data\\n\\nIRs:\\nREF_2(bytes) -> tkn.data\\nREF_2(bytes) (->tkn) := _data(bytes)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nu = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)\\n\\nIRs:\\nREF_3(None) -> _data[3]\\nTMP_19 = CONVERT REF_3 to uint32\\nREF_4(None) -> _data[2]\\nTMP_20 = CONVERT REF_4 to uint32\\nTMP_21(uint32) = TMP_20 << 8\\nTMP_22(uint32) = TMP_19 + TMP_21\\nREF_5(None) -> _data[1]\\nTMP_23 = CONVERT REF_5 to uint32\\nTMP_24(uint32) = TMP_23 << 16\\nTMP_25(uint32) = TMP_22 + TMP_24\\nREF_6(None) -> _data[0]\\nTMP_26 = CONVERT REF_6 to uint32\\nTMP_27(uint32) = TMP_26 << 24\\nTMP_28(uint32) = TMP_25 + TMP_27\\nu(uint32) := TMP_28(uint32)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ntkn.sig = bytes4(u)\\n\\nIRs:\\nREF_7(bytes4) -> tkn.sig\\nTMP_29 = CONVERT u to bytes4\\nREF_7(bytes4) (->tkn) := TMP_29(bytes4)\\\"];\\n}\\n// Function: 3.sol-ERC223-balanceOf(address)\\ndigraph{\\n}\\n// Function: 3.sol-ERC223-decimals()\\ndigraph{\\n}\\n// Function: 3.sol-ERC223-name()\\ndigraph{\\n}\\n// Function: 3.sol-ERC223-symbol()\\ndigraph{\\n}\\n// Function: 3.sol-ERC223-totalSupply()\\ndigraph{\\n}\\n// Function: 3.sol-ERC223-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 3.sol-ERC223-transfer(address,uint256,bytes)\\ndigraph{\\n}\\n// Function: 3.sol-ERC223-transfer(address,uint256,bytes,string)\\ndigraph{\\n}\\n// Function: 3.sol-NIZIGEN-NIZIGEN()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = initialSupply\\n\\nIRs:\\ntotalSupply(uint256) := initialSupply(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] = totalSupply\\n\\nIRs:\\nREF_8(uint256) -> balances[msg.sender]\\nREF_8(uint256) (->balances) := totalSupply(uint256)\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-autoDistribute()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(distributeAmount > 0 && balanceOf(owner) >= distributeAmount && frozenAccount[msg.sender] == false && now > unlockUnixTime[msg.sender])\\n\\nIRs:\\nTMP_193(bool) = distributeAmount > 0\\nTMP_194(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(owner)\\nTMP_195(bool) = TMP_194 >= distributeAmount\\nTMP_196(bool) = TMP_193 && TMP_195\\nREF_114(bool) -> frozenAccount[msg.sender]\\nTMP_197(bool) = REF_114 == False\\nTMP_198(bool) = TMP_196 && TMP_197\\nREF_115(uint256) -> unlockUnixTime[msg.sender]\\nTMP_199(bool) = now > REF_115\\nTMP_200(bool) = TMP_198 && TMP_199\\nTMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nmsg.value > 0\\n\\nIRs:\\nTMP_202(bool) = msg.value > 0\\nCONDITION TMP_202\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner.transfer(msg.value)\\n\\nIRs:\\nTransfer dest:owner value:msg.value\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[owner] = SafeMath.sub(balances[owner],distributeAmount)\\n\\nIRs:\\nREF_117(uint256) -> balances[owner]\\nREF_119(uint256) -> balances[owner]\\nTMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_119', 'distributeAmount'] \\nREF_117(uint256) (->balances) := TMP_204(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[msg.sender] = SafeMath.add(balances[msg.sender],distributeAmount)\\n\\nIRs:\\nREF_120(uint256) -> balances[msg.sender]\\nREF_122(uint256) -> balances[msg.sender]\\nTMP_205(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_122', 'distributeAmount'] \\nREF_120(uint256) (->balances) := TMP_205(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(owner,msg.sender,distributeAmount)\\n\\nIRs:\\nEmit Transfer(owner,msg.sender,distributeAmount)\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_9(uint256) -> balances[_owner]\\nRETURN REF_9\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-burn(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_unitAmount > 0 && balanceOf(_from) >= _unitAmount)\\n\\nIRs:\\nTMP_126(bool) = _unitAmount > 0\\nTMP_127(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(_from)\\nTMP_128(bool) = TMP_127 >= _unitAmount\\nTMP_129(bool) = TMP_126 && TMP_128\\nTMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[_from] = SafeMath.sub(balances[_from],_unitAmount)\\n\\nIRs:\\nREF_55(uint256) -> balances[_from]\\nREF_57(uint256) -> balances[_from]\\nTMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_57', '_unitAmount'] \\nREF_55(uint256) (->balances) := TMP_131(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply = SafeMath.sub(totalSupply,_unitAmount)\\n\\nIRs:\\nTMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_unitAmount'] \\ntotalSupply(uint256) := TMP_132(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nBurn(_from,_unitAmount)\\n\\nIRs:\\nEmit Burn(_from,_unitAmount)\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 3.sol-NIZIGEN-canMint()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! mintingFinished)\\n\\nIRs:\\nTMP_214 = UnaryType.BANG mintingFinished \\nTMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-collectTokens(address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->16;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(addresses.length > 0 && addresses.length == amounts.length)\\n\\nIRs:\\nREF_85 -> LENGTH addresses\\nTMP_170(bool) = REF_85 > 0\\nREF_86 -> LENGTH addresses\\nREF_87 -> LENGTH amounts\\nTMP_171(bool) = REF_86 == REF_87\\nTMP_172(bool) = TMP_170 && TMP_171\\nTMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ntotalAmount = 0\\n\\nIRs:\\ntotalAmount(uint256) := 0(uint256)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->14;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < addresses.length\\n\\nIRs:\\nREF_88 -> LENGTH addresses\\nTMP_174(bool) = i < REF_88\\nCONDITION TMP_174\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrequire(bool)(amounts[i] > 0 && addresses[i] != 0x0 && frozenAccount[addresses[i]] == false && now > unlockUnixTime[addresses[i]])\\n\\nIRs:\\nREF_89(uint256) -> amounts[i]\\nTMP_175(bool) = REF_89 > 0\\nREF_90(address) -> addresses[i]\\nTMP_176(bool) = REF_90 != 0\\nTMP_177(bool) = TMP_175 && TMP_176\\nREF_91(address) -> addresses[i]\\nREF_92(bool) -> frozenAccount[REF_91]\\nTMP_178(bool) = REF_92 == False\\nTMP_179(bool) = TMP_177 && TMP_178\\nREF_93(address) -> addresses[i]\\nREF_94(uint256) -> unlockUnixTime[REF_93]\\nTMP_180(bool) = now > REF_94\\nTMP_181(bool) = TMP_179 && TMP_180\\nTMP_182(None) = SOLIDITY_CALL require(bool)(TMP_181)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\namounts[i] = SafeMath.mul(amounts[i],1e8)\\n\\nIRs:\\nREF_95(uint256) -> amounts[i]\\nREF_97(uint256) -> amounts[i]\\nTMP_183(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_97', '100000000'] \\nREF_95(uint256) (->amounts) := TMP_183(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nrequire(bool)(balances[addresses[i]] >= amounts[i])\\n\\nIRs:\\nREF_98(address) -> addresses[i]\\nREF_99(uint256) -> balances[REF_98]\\nREF_100(uint256) -> amounts[i]\\nTMP_184(bool) = REF_99 >= REF_100\\nTMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nbalances[addresses[i]] = SafeMath.sub(balances[addresses[i]],amounts[i])\\n\\nIRs:\\nREF_101(address) -> addresses[i]\\nREF_102(uint256) -> balances[REF_101]\\nREF_104(address) -> addresses[i]\\nREF_105(uint256) -> balances[REF_104]\\nREF_106(uint256) -> amounts[i]\\nTMP_186(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_105', 'REF_106'] \\nREF_102(uint256) (->balances) := TMP_186(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ntotalAmount = SafeMath.add(totalAmount,amounts[i])\\n\\nIRs:\\nREF_108(uint256) -> amounts[i]\\nTMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalAmount', 'REF_108'] \\ntotalAmount(uint256) := TMP_187(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nTransfer(addresses[i],msg.sender,amounts[i])\\n\\nIRs:\\nREF_109(address) -> addresses[i]\\nREF_110(uint256) -> amounts[i]\\nEmit Transfer(REF_109,msg.sender,REF_110)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_189(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n13->6;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nbalances[msg.sender] = SafeMath.add(balances[msg.sender],totalAmount)\\n\\nIRs:\\nREF_111(uint256) -> balances[msg.sender]\\nREF_113(uint256) -> balances[msg.sender]\\nTMP_190(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_113', 'totalAmount'] \\nREF_111(uint256) (->balances) := TMP_190(uint256)\\\"];\\n14->15;\\n15[label=\\\"Node Type: RETURN 15\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n16->1;\\n}\\n// Function: 3.sol-NIZIGEN-decimals()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ndecimals\\n\\nIRs:\\nRETURN decimals\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n_decimals\\n\\nIRs:\\nRETURN _decimals\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-distributeAirdrop(address[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(amount > 0 && addresses.length > 0 && frozenAccount[msg.sender] == false && now > unlockUnixTime[msg.sender])\\n\\nIRs:\\nTMP_147(bool) = amount > 0\\nREF_63 -> LENGTH addresses\\nTMP_148(bool) = REF_63 > 0\\nTMP_149(bool) = TMP_147 && TMP_148\\nREF_64(bool) -> frozenAccount[msg.sender]\\nTMP_150(bool) = REF_64 == False\\nTMP_151(bool) = TMP_149 && TMP_150\\nREF_65(uint256) -> unlockUnixTime[msg.sender]\\nTMP_152(bool) = now > REF_65\\nTMP_153(bool) = TMP_151 && TMP_152\\nTMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\namount = SafeMath.mul(amount,1e8)\\n\\nIRs:\\nTMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', '100000000'] \\namount(uint256) := TMP_155(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ntotalAmount = SafeMath.mul(amount,addresses.length)\\n\\nIRs:\\nREF_68 -> LENGTH addresses\\nTMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'REF_68'] \\ntotalAmount(uint256) := TMP_156(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(balances[msg.sender] >= totalAmount)\\n\\nIRs:\\nREF_69(uint256) -> balances[msg.sender]\\nTMP_157(bool) = REF_69 >= totalAmount\\nTMP_158(None) = SOLIDITY_CALL require(bool)(TMP_157)\\\"];\\n4->7;\\n5[label=\\\"Node Type: BEGIN_LOOP 5\\n\\\"];\\n5->8;\\n6[label=\\\"Node Type: END_LOOP 6\\n\\\"];\\n6->13;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n7->5;\\n8[label=\\\"Node Type: IF_LOOP 8\\n\\nEXPRESSION:\\ni < addresses.length\\n\\nIRs:\\nREF_70 -> LENGTH addresses\\nTMP_159(bool) = i < REF_70\\nCONDITION TMP_159\\\"];\\n8->9[label=\\\"True\\\"];\\n8->6[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nrequire(bool)(addresses[i] != 0x0 && frozenAccount[addresses[i]] == false && now > unlockUnixTime[addresses[i]])\\n\\nIRs:\\nREF_71(address) -> addresses[i]\\nTMP_160(bool) = REF_71 != 0\\nREF_72(address) -> addresses[i]\\nREF_73(bool) -> frozenAccount[REF_72]\\nTMP_161(bool) = REF_73 == False\\nTMP_162(bool) = TMP_160 && TMP_161\\nREF_74(address) -> addresses[i]\\nREF_75(uint256) -> unlockUnixTime[REF_74]\\nTMP_163(bool) = now > REF_75\\nTMP_164(bool) = TMP_162 && TMP_163\\nTMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nbalances[addresses[i]] = SafeMath.add(balances[addresses[i]],amount)\\n\\nIRs:\\nREF_76(address) -> addresses[i]\\nREF_77(uint256) -> balances[REF_76]\\nREF_79(address) -> addresses[i]\\nREF_80(uint256) -> balances[REF_79]\\nTMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_80', 'amount'] \\nREF_77(uint256) (->balances) := TMP_166(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nTransfer(msg.sender,addresses[i],amount)\\n\\nIRs:\\nREF_81(address) -> addresses[i]\\nEmit Transfer(msg.sender,REF_81,amount)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_168(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n12->8;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nbalances[msg.sender] = SafeMath.sub(balances[msg.sender],totalAmount)\\n\\nIRs:\\nREF_82(uint256) -> balances[msg.sender]\\nREF_84(uint256) -> balances[msg.sender]\\nTMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_84', 'totalAmount'] \\nREF_82(uint256) (->balances) := TMP_169(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: RETURN 14\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nautoDistribute()\\n\\nIRs:\\nINTERNAL_CALL, NIZIGEN.autoDistribute()()\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-finishMinting()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nmintingFinished = true\\n\\nIRs:\\nmintingFinished(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nMintFinished()\\n\\nIRs:\\nEmit MintFinished()\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, NIZIGEN.canMint()()\\\"];\\n5->1;\\n}\\n// Function: 3.sol-NIZIGEN-freezeAccounts(address[],bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->10;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(targets.length > 0)\\n\\nIRs:\\nREF_10 -> LENGTH targets\\nTMP_35(bool) = REF_10 > 0\\nTMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)\\\"];\\n1->4;\\n2[label=\\\"Node Type: BEGIN_LOOP 2\\n\\\"];\\n2->5;\\n3[label=\\\"Node Type: END_LOOP 3\\n\\\"];\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n4->2;\\n5[label=\\\"Node Type: IF_LOOP 5\\n\\nEXPRESSION:\\ni < targets.length\\n\\nIRs:\\nREF_11 -> LENGTH targets\\nTMP_37(bool) = i < REF_11\\nCONDITION TMP_37\\\"];\\n5->6[label=\\\"True\\\"];\\n5->3[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrequire(bool)(targets[i] != 0x0)\\n\\nIRs:\\nREF_12(address) -> targets[i]\\nTMP_38(bool) = REF_12 != 0\\nTMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nfrozenAccount[targets[i]] = isFrozen\\n\\nIRs:\\nREF_13(address) -> targets[i]\\nREF_14(bool) -> frozenAccount[REF_13]\\nREF_14(bool) (->frozenAccount) := isFrozen(bool)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nFrozenFunds(targets[i],isFrozen)\\n\\nIRs:\\nREF_15(address) -> targets[i]\\nEmit FrozenFunds(REF_15,isFrozen)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_41(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n9->5;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n10->1;\\n}\\n// Function: 3.sol-NIZIGEN-isContract(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n(length > 0)\\n\\nIRs:\\nTMP_105(bool) = length > 0\\nRETURN TMP_105\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nis_contract\\n\\nIRs:\\nRETURN is_contract\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-lockupAccounts(address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->10;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(targets.length > 0 && targets.length == unixTimes.length)\\n\\nIRs:\\nREF_16 -> LENGTH targets\\nTMP_43(bool) = REF_16 > 0\\nREF_17 -> LENGTH targets\\nREF_18 -> LENGTH unixTimes\\nTMP_44(bool) = REF_17 == REF_18\\nTMP_45(bool) = TMP_43 && TMP_44\\nTMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)\\\"];\\n1->4;\\n2[label=\\\"Node Type: BEGIN_LOOP 2\\n\\\"];\\n2->5;\\n3[label=\\\"Node Type: END_LOOP 3\\n\\\"];\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n4->2;\\n5[label=\\\"Node Type: IF_LOOP 5\\n\\nEXPRESSION:\\ni < targets.length\\n\\nIRs:\\nREF_19 -> LENGTH targets\\nTMP_47(bool) = i < REF_19\\nCONDITION TMP_47\\\"];\\n5->6[label=\\\"True\\\"];\\n5->3[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrequire(bool)(unlockUnixTime[targets[i]] < unixTimes[i])\\n\\nIRs:\\nREF_20(address) -> targets[i]\\nREF_21(uint256) -> unlockUnixTime[REF_20]\\nREF_22(uint256) -> unixTimes[i]\\nTMP_48(bool) = REF_21 < REF_22\\nTMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nunlockUnixTime[targets[i]] = unixTimes[i]\\n\\nIRs:\\nREF_23(address) -> targets[i]\\nREF_24(uint256) -> unlockUnixTime[REF_23]\\nREF_25(uint256) -> unixTimes[i]\\nREF_24(uint256) (->unlockUnixTime) := REF_25(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nLockedFunds(targets[i],unixTimes[i])\\n\\nIRs:\\nREF_26(address) -> targets[i]\\nREF_27(uint256) -> unixTimes[i]\\nEmit LockedFunds(REF_26,REF_27)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_51(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n9->5;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n10->1;\\n}\\n// Function: 3.sol-NIZIGEN-mint(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_unitAmount > 0)\\n\\nIRs:\\nTMP_135(bool) = _unitAmount > 0\\nTMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply = SafeMath.add(totalSupply,_unitAmount)\\n\\nIRs:\\nTMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply', '_unitAmount'] \\ntotalSupply(uint256) := TMP_137(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] = SafeMath.add(balances[_to],_unitAmount)\\n\\nIRs:\\nREF_60(uint256) -> balances[_to]\\nREF_62(uint256) -> balances[_to]\\nTMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_62', '_unitAmount'] \\nREF_60(uint256) (->balances) := TMP_138(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nMint(_to,_unitAmount)\\n\\nIRs:\\nEmit Mint(_to,_unitAmount)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(address(0),_to,_unitAmount)\\n\\nIRs:\\nTMP_140 = CONVERT 0 to address\\nEmit Transfer(TMP_140,_to,_unitAmount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, NIZIGEN.canMint()()\\\"];\\n8->1;\\n}\\n// Function: 3.sol-NIZIGEN-name()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nname\\n\\nIRs:\\nRETURN name\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n_name\\n\\nIRs:\\nRETURN _name\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_209(bool) = msg.sender == owner\\nTMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(msg.data.length >= size + 4)\\n\\nIRs:\\nREF_123 -> LENGTH msg.data\\nTMP_211(uint256) = size + 4\\nTMP_212(bool) = REF_123 >= TMP_211\\nTMP_213(None) = SOLIDITY_CALL assert(bool)(TMP_212)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-setDistributeAmount(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndistributeAmount = _unitAmount\\n\\nIRs:\\ndistributeAmount(uint256) := _unitAmount(uint256)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 3.sol-NIZIGEN-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = NIZIGEN\\n\\nIRs:\\nname(string) := NIZIGEN(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = 2D\\n\\nIRs:\\nsymbol(string) := 2D(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 8\\n\\nIRs:\\ndecimals(uint8) := 8(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\ninitialSupply = 50e9 * 1e8\\n\\nIRs:\\nTMP_208(uint256) = 50000000000 * 100000000\\ninitialSupply(uint256) := TMP_208(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\ndistributeAmount = 0\\n\\nIRs:\\ndistributeAmount(uint256) := 0(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: OTHER_ENTRYPOINT 5\\n\\nEXPRESSION:\\nmintingFinished = false\\n\\nIRs:\\nmintingFinished(bool) := False(bool)\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-symbol()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsymbol\\n\\nIRs:\\nRETURN symbol\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n_symbol\\n\\nIRs:\\nRETURN _symbol\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntotalSupply\\n\\nIRs:\\nRETURN totalSupply\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n_totalSupply\\n\\nIRs:\\nRETURN _totalSupply\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to])\\n\\nIRs:\\nTMP_92(bool) = _value > 0\\nREF_42(bool) -> frozenAccount[msg.sender]\\nTMP_93(bool) = REF_42 == False\\nTMP_94(bool) = TMP_92 && TMP_93\\nREF_43(bool) -> frozenAccount[_to]\\nTMP_95(bool) = REF_43 == False\\nTMP_96(bool) = TMP_94 && TMP_95\\nREF_44(uint256) -> unlockUnixTime[msg.sender]\\nTMP_97(bool) = now > REF_44\\nTMP_98(bool) = TMP_96 && TMP_97\\nREF_45(uint256) -> unlockUnixTime[_to]\\nTMP_99(bool) = now > REF_45\\nTMP_100(bool) = TMP_98 && TMP_99\\nTMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nisContract(_to)\\n\\nIRs:\\nTMP_102(bool) = INTERNAL_CALL, NIZIGEN.isContract(address)(_to)\\nCONDITION TMP_102\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntransferToContract(_to,_value,empty)\\n\\nIRs:\\nTMP_103(bool) = INTERNAL_CALL, NIZIGEN.transferToContract(address,uint256,bytes)(_to,_value,empty)\\nRETURN TMP_103\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntransferToAddress(_to,_value,empty)\\n\\nIRs:\\nTMP_104(bool) = INTERNAL_CALL, NIZIGEN.transferToAddress(address,uint256,bytes)(_to,_value,empty)\\nRETURN TMP_104\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-transfer(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to])\\n\\nIRs:\\nTMP_79(bool) = _value > 0\\nREF_38(bool) -> frozenAccount[msg.sender]\\nTMP_80(bool) = REF_38 == False\\nTMP_81(bool) = TMP_79 && TMP_80\\nREF_39(bool) -> frozenAccount[_to]\\nTMP_82(bool) = REF_39 == False\\nTMP_83(bool) = TMP_81 && TMP_82\\nREF_40(uint256) -> unlockUnixTime[msg.sender]\\nTMP_84(bool) = now > REF_40\\nTMP_85(bool) = TMP_83 && TMP_84\\nREF_41(uint256) -> unlockUnixTime[_to]\\nTMP_86(bool) = now > REF_41\\nTMP_87(bool) = TMP_85 && TMP_86\\nTMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nisContract(_to)\\n\\nIRs:\\nTMP_89(bool) = INTERNAL_CALL, NIZIGEN.isContract(address)(_to)\\nCONDITION TMP_89\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntransferToContract(_to,_value,_data)\\n\\nIRs:\\nTMP_90(bool) = INTERNAL_CALL, NIZIGEN.transferToContract(address,uint256,bytes)(_to,_value,_data)\\nRETURN TMP_90\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntransferToAddress(_to,_value,_data)\\n\\nIRs:\\nTMP_91(bool) = INTERNAL_CALL, NIZIGEN.transferToAddress(address,uint256,bytes)(_to,_value,_data)\\nRETURN TMP_91\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-transfer(address,uint256,bytes,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to])\\n\\nIRs:\\nTMP_53(bool) = _value > 0\\nREF_28(bool) -> frozenAccount[msg.sender]\\nTMP_54(bool) = REF_28 == False\\nTMP_55(bool) = TMP_53 && TMP_54\\nREF_29(bool) -> frozenAccount[_to]\\nTMP_56(bool) = REF_29 == False\\nTMP_57(bool) = TMP_55 && TMP_56\\nREF_30(uint256) -> unlockUnixTime[msg.sender]\\nTMP_58(bool) = now > REF_30\\nTMP_59(bool) = TMP_57 && TMP_58\\nREF_31(uint256) -> unlockUnixTime[_to]\\nTMP_60(bool) = now > REF_31\\nTMP_61(bool) = TMP_59 && TMP_60\\nTMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nisContract(_to)\\n\\nIRs:\\nTMP_63(bool) = INTERNAL_CALL, NIZIGEN.isContract(address)(_to)\\nCONDITION TMP_63\\\"];\\n2->3[label=\\\"True\\\"];\\n2->12[label=\\\"False\\\"];\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nbalanceOf(msg.sender) < _value\\n\\nIRs:\\nTMP_64(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(msg.sender)\\nTMP_65(bool) = TMP_64 < _value\\nCONDITION TMP_65\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_66(None) = SOLIDITY_CALL revert()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[msg.sender] = SafeMath.sub(balanceOf(msg.sender),_value)\\n\\nIRs:\\nREF_32(uint256) -> balances[msg.sender]\\nTMP_67(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(msg.sender)\\nTMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_67', '_value'] \\nREF_32(uint256) (->balances) := TMP_68(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalances[_to] = SafeMath.add(balanceOf(_to),_value)\\n\\nIRs:\\nREF_34(uint256) -> balances[_to]\\nTMP_69(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(_to)\\nTMP_70(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_69', '_value'] \\nREF_34(uint256) (->balances) := TMP_70(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nassert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data))\\n\\nIRs:\\nTMP_72(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback)\\nTMP_73 = CONVERT TMP_72 to bytes4\\nTMP_74(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_73', 'msg.sender', '_value', '_data'] value:0 \\nTMP_75(None) = SOLIDITY_CALL assert(bool)(TMP_74)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value,_data)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value,_data)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n10->11;\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n12[label=\\\"Node Type: RETURN 12\\n\\nEXPRESSION:\\ntransferToAddress(_to,_value,_data)\\n\\nIRs:\\nTMP_78(bool) = INTERNAL_CALL, NIZIGEN.transferToAddress(address,uint256,bytes)(_to,_value,_data)\\nRETURN TMP_78\\\"];\\n14[label=\\\"Node Type: RETURN 14\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_30 = CONVERT 0 to address\\nTMP_31(bool) = newOwner != TMP_30\\nTMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 3.sol-NIZIGEN-transferToAddress(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalanceOf(msg.sender) < _value\\n\\nIRs:\\nTMP_106(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(msg.sender)\\nTMP_107(bool) = TMP_106 < _value\\nCONDITION TMP_107\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_108(None) = SOLIDITY_CALL revert()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[msg.sender] = SafeMath.sub(balanceOf(msg.sender),_value)\\n\\nIRs:\\nREF_46(uint256) -> balances[msg.sender]\\nTMP_109(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(msg.sender)\\nTMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_109', '_value'] \\nREF_46(uint256) (->balances) := TMP_110(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = SafeMath.add(balanceOf(_to),_value)\\n\\nIRs:\\nREF_48(uint256) -> balances[_to]\\nTMP_111(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(_to)\\nTMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_111', '_value'] \\nREF_48(uint256) (->balances) := TMP_112(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value,_data)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value,_data)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 3.sol-NIZIGEN-transferToContract(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalanceOf(msg.sender) < _value\\n\\nIRs:\\nTMP_115(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(msg.sender)\\nTMP_116(bool) = TMP_115 < _value\\nCONDITION TMP_116\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_117(None) = SOLIDITY_CALL revert()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[msg.sender] = SafeMath.sub(balanceOf(msg.sender),_value)\\n\\nIRs:\\nREF_50(uint256) -> balances[msg.sender]\\nTMP_118(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(msg.sender)\\nTMP_119(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_118', '_value'] \\nREF_50(uint256) (->balances) := TMP_119(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = SafeMath.add(balanceOf(_to),_value)\\n\\nIRs:\\nREF_52(uint256) -> balances[_to]\\nTMP_120(uint256) = INTERNAL_CALL, NIZIGEN.balanceOf(address)(_to)\\nTMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_120', '_value'] \\nREF_52(uint256) (->balances) := TMP_121(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nreceiver = ContractReceiver(_to)\\n\\nIRs:\\nTMP_122 = CONVERT _to to ContractReceiver\\nreceiver(ContractReceiver) := TMP_122(ContractReceiver)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nreceiver.tokenFallback(msg.sender,_value,_data)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:receiver(ContractReceiver), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  \\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value,_data)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value,_data)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n9->10;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 3.sol-Ownable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 3.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_17(bool) = msg.sender == owner\\nTMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 3.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_12 = CONVERT 0 to address\\nTMP_13(bool) = newOwner != TMP_12\\nTMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 3.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 3.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nc(uint256) := TMP_5(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 3.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 3.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Reentrancy\", \"Unchecked External Call\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 4.sol-BaseContract-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 4.sol-BaseContract-onlyByOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_3(bool) = msg.sender == owner\\nTMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 4.sol-BaseContract-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nTokensAreFrozen = true\\n\\nIRs:\\nTokensAreFrozen(bool) := True(bool)\\\"];\\n}\\n// Function: 4.sol-BaseContract-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_0 = CONVERT 0 to address\\nTMP_1(bool) = newOwner != TMP_0\\nCONDITION TMP_1\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyByOwner()\\n\\nIRs:\\nMODIFIER_CALL, BaseContract.onlyByOwner()()\\\"];\\n4->1;\\n}\\n// Function: 4.sol-ERC20Contract-allowance(address,address)\\ndigraph{\\n}\\n// Function: 4.sol-ERC20Contract-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 4.sol-ERC20Contract-balanceOf(address)\\ndigraph{\\n}\\n// Function: 4.sol-ERC20Contract-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 4.sol-ERC20Contract-onlyByOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_8(bool) = msg.sender == owner\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 4.sol-ERC20Contract-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nTokensAreFrozen = true\\n\\nIRs:\\nTokensAreFrozen(bool) := True(bool)\\\"];\\n}\\n// Function: 4.sol-ERC20Contract-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 4.sol-ERC20Contract-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 4.sol-ERC20Contract-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_5 = CONVERT 0 to address\\nTMP_6(bool) = newOwner != TMP_5\\nCONDITION TMP_6\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyByOwner()\\n\\nIRs:\\nMODIFIER_CALL, BaseContract.onlyByOwner()()\\\"];\\n4->1;\\n}\\n// Function: 4.sol-Freedom-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_29(mapping(address => uint256)) -> allowed[_owner]\\nREF_30(uint256) -> REF_29[_spender]\\nRETURN REF_30\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 4.sol-Freedom-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! TokensAreFrozen)\\n\\nIRs:\\nTMP_51 = UnaryType.BANG TokensAreFrozen \\nTMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_spender != address(0))\\n\\nIRs:\\nTMP_53 = CONVERT 0 to address\\nTMP_54(bool) = _spender != TMP_53\\nTMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)((_value == 0) || (allowed[msg.sender][_spender] == 0))\\n\\nIRs:\\nTMP_56(bool) = _value == 0\\nREF_25(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_26(uint256) -> REF_25[_spender]\\nTMP_57(bool) = REF_26 == 0\\nTMP_58(bool) = TMP_56 || TMP_57\\nTMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_27(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_28(uint256) -> REF_27[_spender]\\nREF_28(uint256) (->allowed) := _value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 4.sol-Freedom-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalanceOf[_owner]\\n\\nIRs:\\nREF_24(uint256) -> balanceOf[_owner]\\nRETURN REF_24\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 4.sol-Freedom-burnTokens(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! TokensAreFrozen)\\n\\nIRs:\\nTMP_69 = UnaryType.BANG TokensAreFrozen \\nTMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_owner] >= _value)\\n\\nIRs:\\nREF_31(uint256) -> balanceOf[_owner]\\nTMP_71(bool) = REF_31 >= _value\\nTMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[_owner] -= _value\\n\\nIRs:\\nREF_32(uint256) -> balanceOf[_owner]\\nREF_32(-> balanceOf) = REF_32 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nBurnTokens(_owner,_value)\\n\\nIRs:\\nEmit BurnTokens(_owner,_value)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyByOwner()\\n\\nIRs:\\nMODIFIER_CALL, BaseContract.onlyByOwner()()\\\"];\\n6->1;\\n}\\n// Function: 4.sol-Freedom-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balanceOf[msg.sender]\\nREF_0(uint256) (->balanceOf) := totalSupply(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply = totalSupply\\n\\nIRs:\\ntotalSupply(uint256) := totalSupply(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndecimals = decimals\\n\\nIRs:\\ndecimals(uint8) := decimals(uint8)\\\"];\\n}\\n// Function: 4.sol-Freedom-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n}\\n// Function: 4.sol-Freedom-freezeTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(TokensAreFrozen == false)\\n\\nIRs:\\nTMP_61(bool) = TokensAreFrozen == False\\nTMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nTokensAreFrozen = true\\n\\nIRs:\\nTokensAreFrozen(bool) := True(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nFreezeTokensFrom(_owner)\\n\\nIRs:\\nEmit FreezeTokensFrom(_owner)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyByOwner()\\n\\nIRs:\\nMODIFIER_CALL, BaseContract.onlyByOwner()()\\\"];\\n4->1;\\n}\\n// Function: 4.sol-Freedom-onlyByOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_81(bool) = msg.sender == owner\\nTMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 4.sol-Freedom-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.data.length >= _size + 4)\\n\\nIRs:\\nREF_34 -> LENGTH msg.data\\nTMP_83(uint256) = _size + 4\\nTMP_84(bool) = REF_34 >= TMP_83\\nTMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 4.sol-Freedom-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nMAX_UINT256 = 2 ** 256 - 1\\n\\nIRs:\\nTMP_79(uint256) = 2 ** 256\\nTMP_80(uint256) = TMP_79 - 1\\nMAX_UINT256(uint256) := TMP_80(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\ntokenName = Freedom\\n\\nIRs:\\ntokenName(string) := Freedom(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ntokenSymbol = FREE\\n\\nIRs:\\ntokenSymbol(string) := FREE(string)\\\"];\\n}\\n// Function: 4.sol-Freedom-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nTokensAreFrozen = true\\n\\nIRs:\\nTokensAreFrozen(bool) := True(bool)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\ntotalSupply = 1000000000e8\\n\\nIRs:\\ntotalSupply(uint256) := 100000000000000000(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 8\\n\\nIRs:\\ndecimals(uint8) := 8(uint256)\\\"];\\n}\\n// Function: 4.sol-Freedom-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->10;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! TokensAreFrozen)\\n\\nIRs:\\nTMP_18 = UnaryType.BANG TokensAreFrozen \\nTMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_20(bool) = _to != 0\\nTMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_value > 0)\\n\\nIRs:\\nTMP_22(bool) = _value > 0\\nTMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[msg.sender] >= _value)\\n\\nIRs:\\nREF_1(uint256) -> balanceOf[msg.sender]\\nTMP_24(bool) = REF_1 >= _value\\nTMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_to] + _value >= balanceOf[_to])\\n\\nIRs:\\nREF_2(uint256) -> balanceOf[_to]\\nTMP_26(uint256) = REF_2 + _value\\nREF_3(uint256) -> balanceOf[_to]\\nTMP_27(bool) = TMP_26 >= REF_3\\nTMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = balanceOf[msg.sender].Sub(_value)\\n\\nIRs:\\nREF_4(uint256) -> balanceOf[msg.sender]\\nREF_5(uint256) -> balanceOf[msg.sender]\\nTMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.Sub(uint256,uint256), arguments:['REF_5', '_value'] \\nREF_4(uint256) (->balanceOf) := TMP_29(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalanceOf[_to] = balanceOf[_to].Add(_value)\\n\\nIRs:\\nREF_7(uint256) -> balanceOf[_to]\\nREF_8(uint256) -> balanceOf[_to]\\nTMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.Add(uint256,uint256), arguments:['REF_8', '_value'] \\nREF_7(uint256) (->balanceOf) := TMP_30(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n8->9;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_32(uint256) = 2 * 32\\nMODIFIER_CALL, Freedom.onlyPayloadSize(uint256)(TMP_32)\\\"];\\n10->1;\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 4.sol-Freedom-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nallowance = allowed[_from][msg.sender]\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowed[_from]\\nREF_11(uint256) -> REF_10[msg.sender]\\nallowance(uint256) := REF_11(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(! TokensAreFrozen)\\n\\nIRs:\\nTMP_34 = UnaryType.BANG TokensAreFrozen \\nTMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_36(bool) = _to != 0\\nTMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(_value > 0)\\n\\nIRs:\\nTMP_38(bool) = _value > 0\\nTMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value && allowance >= _value)\\n\\nIRs:\\nREF_12(uint256) -> balanceOf[_from]\\nTMP_40(bool) = REF_12 >= _value\\nTMP_41(bool) = allowance >= _value\\nTMP_42(bool) = TMP_40 && TMP_41\\nTMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[_to] = balanceOf[_to].Add(_value)\\n\\nIRs:\\nREF_13(uint256) -> balanceOf[_to]\\nREF_14(uint256) -> balanceOf[_to]\\nTMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.Add(uint256,uint256), arguments:['REF_14', '_value'] \\nREF_13(uint256) (->balanceOf) := TMP_44(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalanceOf[_from] = balanceOf[_from].Sub(_value)\\n\\nIRs:\\nREF_16(uint256) -> balanceOf[_from]\\nREF_17(uint256) -> balanceOf[_from]\\nTMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.Sub(uint256,uint256), arguments:['REF_17', '_value'] \\nREF_16(uint256) (->balanceOf) := TMP_45(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\nallowance < MAX_UINT256\\n\\nIRs:\\nTMP_46(bool) = allowance < MAX_UINT256\\nCONDITION TMP_46\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].Sub(_value)\\n\\nIRs:\\nREF_19(mapping(address => uint256)) -> allowed[_from]\\nREF_20(uint256) -> REF_19[msg.sender]\\nREF_21(mapping(address => uint256)) -> allowed[_from]\\nREF_22(uint256) -> REF_21[msg.sender]\\nTMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.Sub(uint256,uint256), arguments:['REF_22', '_value'] \\nREF_20(uint256) (->allowed) := TMP_47(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n11->12;\\n12[label=\\\"Node Type: RETURN 12\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyPayloadSize(3 * 32)\\n\\nIRs:\\nTMP_49(uint256) = 3 * 32\\nMODIFIER_CALL, Freedom.onlyPayloadSize(uint256)(TMP_49)\\\"];\\n13->1;\\n14[label=\\\"Node Type: RETURN 14\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 4.sol-Freedom-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_15 = CONVERT 0 to address\\nTMP_16(bool) = newOwner != TMP_15\\nCONDITION TMP_16\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyByOwner()\\n\\nIRs:\\nMODIFIER_CALL, BaseContract.onlyByOwner()()\\\"];\\n4->1;\\n}\\n// Function: 4.sol-Freedom-unfreezeTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(TokensAreFrozen == true)\\n\\nIRs:\\nTMP_65(bool) = TokensAreFrozen == True\\nTMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nTokensAreFrozen = false\\n\\nIRs:\\nTokensAreFrozen(bool) := False(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nUnfreezeTokensFrom(_owner)\\n\\nIRs:\\nEmit UnfreezeTokensFrom(_owner)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyByOwner()\\n\\nIRs:\\nMODIFIER_CALL, BaseContract.onlyByOwner()()\\\"];\\n4->1;\\n}\\n// Function: 4.sol-Freedom-withdraw()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner.transfer(address(this).balance)\\n\\nIRs:\\nTMP_75 = CONVERT this to address\\nTMP_76(uint256) = SOLIDITY_CALL balance(address)(TMP_75)\\nTransfer dest:owner value:TMP_76\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyByOwner()\\n\\nIRs:\\nMODIFIER_CALL, BaseContract.onlyByOwner()()\\\"];\\n2->1;\\n}\\n// Function: 4.sol-SafeMath-Add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_13(uint256) = a + b\\nc(uint256) := TMP_13(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 4.sol-SafeMath-Div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_14(uint256) = a / b\\nc(uint256) := TMP_14(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 4.sol-SafeMath-Mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_10(bool) = a == 0\\nCONDITION TMP_10\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_11(uint256) = a * b\\nc(uint256) := TMP_11(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 4.sol-SafeMath-Sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_12(uint256) = a - b\\nRETURN TMP_12\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 6.sol-REL-REL(uint256,string,uint8,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = initialSupply\\n\\nIRs:\\nREF_0(uint256) -> balanceOf[msg.sender]\\nREF_0(uint256) (->balanceOf) := initialSupply(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply = initialSupply\\n\\nIRs:\\ntotalSupply(uint256) := initialSupply(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = tokenName\\n\\nIRs:\\nname(string) := tokenName(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsymbol = tokenSymbol\\n\\nIRs:\\nsymbol(string) := tokenSymbol(string)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ndecimals = decimalUnits\\n\\nIRs:\\ndecimals(uint8) := decimalUnits(uint8)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 6.sol-REL-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_value <= 0\\n\\nIRs:\\nTMP_54(bool) = _value <= 0\\nCONDITION TMP_54\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowance[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowance[msg.sender]\\nREF_11(uint256) -> REF_10[_spender]\\nREF_11(uint256) (->allowance) := _value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 6.sol-REL-assert(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! assertion\\n\\nIRs:\\nTMP_45 = UnaryType.BANG assertion \\nCONDITION TMP_45\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 6.sol-REL-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] < _value\\n\\nIRs:\\nREF_28(uint256) -> balanceOf[msg.sender]\\nTMP_65(bool) = REF_28 < _value\\nCONDITION TMP_65\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n_value <= 0\\n\\nIRs:\\nTMP_66(bool) = _value <= 0\\nCONDITION TMP_66\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],_value)\\n\\nIRs:\\nREF_29(uint256) -> balanceOf[msg.sender]\\nREF_31(uint256) -> balanceOf[msg.sender]\\nTMP_67(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_31,_value)\\nREF_29(uint256) (->balanceOf) := TMP_67(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ntotalSupply = SafeMath.safeSub(totalSupply,_value)\\n\\nIRs:\\nTMP_68(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,_value)\\ntotalSupply(uint256) := TMP_68(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n9->10;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 6.sol-REL-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n}\\n// Function: 6.sol-REL-freeze(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] < _value\\n\\nIRs:\\nREF_33(uint256) -> balanceOf[msg.sender]\\nTMP_70(bool) = REF_33 < _value\\nCONDITION TMP_70\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n_value <= 0\\n\\nIRs:\\nTMP_71(bool) = _value <= 0\\nCONDITION TMP_71\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],_value)\\n\\nIRs:\\nREF_34(uint256) -> balanceOf[msg.sender]\\nREF_36(uint256) -> balanceOf[msg.sender]\\nTMP_72(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_36,_value)\\nREF_34(uint256) (->balanceOf) := TMP_72(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nfreezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender],_value)\\n\\nIRs:\\nREF_37(uint256) -> freezeOf[msg.sender]\\nREF_39(uint256) -> freezeOf[msg.sender]\\nTMP_73(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_39,_value)\\nREF_37(uint256) (->freezeOf) := TMP_73(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nFreeze(msg.sender,_value)\\n\\nIRs:\\nEmit Freeze(msg.sender,_value)\\\"];\\n9->10;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 6.sol-REL-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_40(uint256) = a + b\\nc(uint256) := TMP_40(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(c >= a && c >= b)\\n\\nIRs:\\nTMP_41(bool) = c >= a\\nTMP_42(bool) = c >= b\\nTMP_43(bool) = TMP_41 && TMP_42\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_43)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 6.sol-REL-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(b > 0)\\n\\nIRs:\\nTMP_29(bool) = b > 0\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_29)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_31(uint256) = a / b\\nc(uint256) := TMP_31(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(a == b * c + a % b)\\n\\nIRs:\\nTMP_32(uint256) = b * c\\nTMP_33(uint256) = a % b\\nTMP_34(uint256) = TMP_32 + TMP_33\\nTMP_35(bool) = a == TMP_34\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_35)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 6.sol-REL-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_23(uint256) = a * b\\nc(uint256) := TMP_23(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_24(bool) = a == 0\\nTMP_25(uint256) = c / a\\nTMP_26(bool) = TMP_25 == b\\nTMP_27(bool) = TMP_24 || TMP_26\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_27)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 6.sol-REL-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(b <= a)\\n\\nIRs:\\nTMP_37(bool) = b <= a\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_37)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_39(uint256) = a - b\\nRETURN TMP_39\\\"];\\n}\\n// Function: 6.sol-REL-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_to == 0x0\\n\\nIRs:\\nTMP_46(bool) = _to == 0\\nCONDITION TMP_46\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n_value <= 0\\n\\nIRs:\\nTMP_47(bool) = _value <= 0\\nCONDITION TMP_47\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] < _value\\n\\nIRs:\\nREF_1(uint256) -> balanceOf[msg.sender]\\nTMP_48(bool) = REF_1 < _value\\nCONDITION TMP_48\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: THROW 8\\n\\\"];\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\nbalanceOf[_to] + _value < balanceOf[_to]\\n\\nIRs:\\nREF_2(uint256) -> balanceOf[_to]\\nTMP_49(uint256) = REF_2 + _value\\nREF_3(uint256) -> balanceOf[_to]\\nTMP_50(bool) = TMP_49 < REF_3\\nCONDITION TMP_50\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: THROW 11\\n\\\"];\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],_value)\\n\\nIRs:\\nREF_4(uint256) -> balanceOf[msg.sender]\\nREF_6(uint256) -> balanceOf[msg.sender]\\nTMP_51(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_6,_value)\\nREF_4(uint256) (->balanceOf) := TMP_51(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nbalanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value)\\n\\nIRs:\\nREF_7(uint256) -> balanceOf[_to]\\nREF_9(uint256) -> balanceOf[_to]\\nTMP_52(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_9,_value)\\nREF_7(uint256) (->balanceOf) := TMP_52(uint256)\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n}\\n// Function: 6.sol-REL-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_to == 0x0\\n\\nIRs:\\nTMP_55(bool) = _to == 0\\nCONDITION TMP_55\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n_value <= 0\\n\\nIRs:\\nTMP_56(bool) = _value <= 0\\nCONDITION TMP_56\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\nbalanceOf[_from] < _value\\n\\nIRs:\\nREF_12(uint256) -> balanceOf[_from]\\nTMP_57(bool) = REF_12 < _value\\nCONDITION TMP_57\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: THROW 8\\n\\\"];\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\nbalanceOf[_to] + _value < balanceOf[_to]\\n\\nIRs:\\nREF_13(uint256) -> balanceOf[_to]\\nTMP_58(uint256) = REF_13 + _value\\nREF_14(uint256) -> balanceOf[_to]\\nTMP_59(bool) = TMP_58 < REF_14\\nCONDITION TMP_59\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: THROW 11\\n\\\"];\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: IF 13\\n\\nEXPRESSION:\\n_value > allowance[_from][msg.sender]\\n\\nIRs:\\nREF_15(mapping(address => uint256)) -> allowance[_from]\\nREF_16(uint256) -> REF_15[msg.sender]\\nTMP_60(bool) = _value > REF_16\\nCONDITION TMP_60\\\"];\\n13->14[label=\\\"True\\\"];\\n13->15[label=\\\"False\\\"];\\n14[label=\\\"Node Type: THROW 14\\n\\\"];\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nbalanceOf[_from] = SafeMath.safeSub(balanceOf[_from],_value)\\n\\nIRs:\\nREF_17(uint256) -> balanceOf[_from]\\nREF_19(uint256) -> balanceOf[_from]\\nTMP_61(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_19,_value)\\nREF_17(uint256) (->balanceOf) := TMP_61(uint256)\\\"];\\n16->17;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nbalanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value)\\n\\nIRs:\\nREF_20(uint256) -> balanceOf[_to]\\nREF_22(uint256) -> balanceOf[_to]\\nTMP_62(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_22,_value)\\nREF_20(uint256) (->balanceOf) := TMP_62(uint256)\\\"];\\n17->18;\\n18[label=\\\"Node Type: EXPRESSION 18\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender],_value)\\n\\nIRs:\\nREF_23(mapping(address => uint256)) -> allowance[_from]\\nREF_24(uint256) -> REF_23[msg.sender]\\nREF_26(mapping(address => uint256)) -> allowance[_from]\\nREF_27(uint256) -> REF_26[msg.sender]\\nTMP_63(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_27,_value)\\nREF_24(uint256) (->allowance) := TMP_63(uint256)\\\"];\\n18->19;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n19->20;\\n20[label=\\\"Node Type: RETURN 20\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n21[label=\\\"Node Type: RETURN 21\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 6.sol-REL-unfreeze(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nfreezeOf[msg.sender] < _value\\n\\nIRs:\\nREF_40(uint256) -> freezeOf[msg.sender]\\nTMP_75(bool) = REF_40 < _value\\nCONDITION TMP_75\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n_value <= 0\\n\\nIRs:\\nTMP_76(bool) = _value <= 0\\nCONDITION TMP_76\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nfreezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender],_value)\\n\\nIRs:\\nREF_41(uint256) -> freezeOf[msg.sender]\\nREF_43(uint256) -> freezeOf[msg.sender]\\nTMP_77(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_43,_value)\\nREF_41(uint256) (->freezeOf) := TMP_77(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender],_value)\\n\\nIRs:\\nREF_44(uint256) -> balanceOf[msg.sender]\\nREF_46(uint256) -> balanceOf[msg.sender]\\nTMP_78(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_46,_value)\\nREF_44(uint256) (->balanceOf) := TMP_78(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nUnfreeze(msg.sender,_value)\\n\\nIRs:\\nEmit Unfreeze(msg.sender,_value)\\\"];\\n9->10;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 6.sol-REL-withdrawEther(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender != owner\\n\\nIRs:\\nTMP_80(bool) = msg.sender != owner\\nCONDITION TMP_80\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nowner.transfer(amount)\\n\\nIRs:\\nTransfer dest:owner value:amount\\\"];\\n}\\n// Function: 6.sol-SafeMath-assert(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! assertion\\n\\nIRs:\\nTMP_22 = UnaryType.BANG assertion \\nCONDITION TMP_22\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 6.sol-SafeMath-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_17(uint256) = a + b\\nc(uint256) := TMP_17(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(c >= a && c >= b)\\n\\nIRs:\\nTMP_18(bool) = c >= a\\nTMP_19(bool) = c >= b\\nTMP_20(bool) = TMP_18 && TMP_19\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_20)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 6.sol-SafeMath-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(b > 0)\\n\\nIRs:\\nTMP_6(bool) = b > 0\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_8(uint256) = a / b\\nc(uint256) := TMP_8(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(a == b * c + a % b)\\n\\nIRs:\\nTMP_9(uint256) = b * c\\nTMP_10(uint256) = a % b\\nTMP_11(uint256) = TMP_9 + TMP_10\\nTMP_12(bool) = a == TMP_11\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_12)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 6.sol-SafeMath-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_0(uint256) = a * b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_1(bool) = a == 0\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(bool) = TMP_1 || TMP_3\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 6.sol-SafeMath-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(b <= a)\\n\\nIRs:\\nTMP_14(bool) = b <= a\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_14)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_16(uint256) = a - b\\nRETURN TMP_16\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 7.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)\\ndigraph{\\n}\\n// Function: 7.sol-ERC20Interface-allowance(address,address)\\ndigraph{\\n}\\n// Function: 7.sol-ERC20Interface-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 7.sol-ERC20Interface-balanceOf(address)\\ndigraph{\\n}\\n// Function: 7.sol-ERC20Interface-totalSupply()\\ndigraph{\\n}\\n// Function: 7.sol-ERC20Interface-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 7.sol-ERC20Interface-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 7.sol-Owned-Owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 7.sol-Owned-acceptOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == newOwner)\\n\\nIRs:\\nTMP_16(bool) = msg.sender == newOwner\\nTMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewOwner = address(0)\\n\\nIRs:\\nTMP_19 = CONVERT 0 to address\\nnewOwner(address) := TMP_19(address)\\\"];\\n}\\n// Function: 7.sol-Owned-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_20(bool) = msg.sender == owner\\nTMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 7.sol-Owned-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnewOwner = _newOwner\\n\\nIRs:\\nnewOwner(address) := _newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 7.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_0(uint256) = a + b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(c >= a)\\n\\nIRs:\\nTMP_1(bool) = c >= a\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 7.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b > 0)\\n\\nIRs:\\nTMP_12(bool) = b > 0\\nTMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_14(uint256) = a / b\\nc(uint256) := TMP_14(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 7.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_6(uint256) = a * b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_7(bool) = a == 0\\nTMP_8(uint256) = c / a\\nTMP_9(bool) = TMP_8 == b\\nTMP_10(bool) = TMP_7 || TMP_9\\nTMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 7.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b <= a)\\n\\nIRs:\\nTMP_3(bool) = b <= a\\nTMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a - b\\n\\nIRs:\\nTMP_5(uint256) = a - b\\nc(uint256) := TMP_5(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 7.sol-weR-Owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 7.sol-weR-acceptOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == newOwner)\\n\\nIRs:\\nTMP_23(bool) = msg.sender == newOwner\\nTMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewOwner = address(0)\\n\\nIRs:\\nTMP_26 = CONVERT 0 to address\\nnewOwner(address) := TMP_26(address)\\\"];\\n}\\n// Function: 7.sol-weR-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[tokenOwner][spender]\\n\\nIRs:\\nREF_22(mapping(address => uint256)) -> allowed[tokenOwner]\\nREF_23(uint256) -> REF_22[spender]\\nRETURN REF_23\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 7.sol-weR-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][spender] = tokens\\n\\nIRs:\\nREF_9(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_10(uint256) -> REF_9[spender]\\nREF_10(uint256) (->allowed) := tokens(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,spender,tokens)\\n\\nIRs:\\nEmit Approval(msg.sender,spender,tokens)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 7.sol-weR-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][spender] = tokens\\n\\nIRs:\\nREF_24(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_25(uint256) -> REF_24[spender]\\nREF_25(uint256) (->allowed) := tokens(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,spender,tokens)\\n\\nIRs:\\nEmit Approval(msg.sender,spender,tokens)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)\\n\\nIRs:\\nTMP_43 = CONVERT spender to ApproveAndCallFallBack\\nHIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 7.sol-weR-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[tokenOwner]\\n\\nIRs:\\nREF_2(uint256) -> balances[tokenOwner]\\nRETURN REF_2\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 7.sol-weR-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_45(None) = SOLIDITY_CALL revert()()\\\"];\\n}\\n// Function: 7.sol-weR-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_49(bool) = msg.sender == owner\\nTMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 7.sol-weR-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n_totalSupply - balances[address(0)]\\n\\nIRs:\\nTMP_32 = CONVERT 0 to address\\nREF_1(uint256) -> balances[TMP_32]\\nTMP_33(uint256) = _totalSupply - REF_1\\nRETURN TMP_33\\\"];\\n}\\n// Function: 7.sol-weR-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(tokens)\\n\\nIRs:\\nREF_3(uint256) -> balances[msg.sender]\\nREF_4(uint256) -> balances[msg.sender]\\nTMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_4', 'tokens'] \\nREF_3(uint256) (->balances) := TMP_34(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[to] = balances[to].add(tokens)\\n\\nIRs:\\nREF_6(uint256) -> balances[to]\\nREF_7(uint256) -> balances[to]\\nTMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_7', 'tokens'] \\nREF_6(uint256) (->balances) := TMP_35(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(msg.sender,to,tokens)\\n\\nIRs:\\nEmit Transfer(msg.sender,to,tokens)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 7.sol-weR-transferAnyERC20Token(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nERC20Interface(tokenAddress).transfer(owner,tokens)\\n\\nIRs:\\nTMP_46 = CONVERT tokenAddress to ERC20Interface\\nTMP_47(bool) = HIGH_LEVEL_CALL, dest:TMP_46(ERC20Interface), function:transfer, arguments:['owner', 'tokens']  \\nRETURN TMP_47\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 7.sol-weR-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[from] = balances[from].sub(tokens)\\n\\nIRs:\\nREF_11(uint256) -> balances[from]\\nREF_12(uint256) -> balances[from]\\nTMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_12', 'tokens'] \\nREF_11(uint256) (->balances) := TMP_38(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens)\\n\\nIRs:\\nREF_14(mapping(address => uint256)) -> allowed[from]\\nREF_15(uint256) -> REF_14[msg.sender]\\nREF_16(mapping(address => uint256)) -> allowed[from]\\nREF_17(uint256) -> REF_16[msg.sender]\\nTMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_17', 'tokens'] \\nREF_15(uint256) (->allowed) := TMP_39(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[to] = balances[to].add(tokens)\\n\\nIRs:\\nREF_19(uint256) -> balances[to]\\nREF_20(uint256) -> balances[to]\\nTMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_20', 'tokens'] \\nREF_19(uint256) (->balances) := TMP_40(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(from,to,tokens)\\n\\nIRs:\\nEmit Transfer(from,to,tokens)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 7.sol-weR-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnewOwner = _newOwner\\n\\nIRs:\\nnewOwner(address) := _newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 7.sol-weR-weR()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nsymbol = weR\\n\\nIRs:\\nsymbol(string) := weR(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = weR\\n\\nIRs:\\nname(string) := weR(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_totalSupply = 500000 * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_27 = CONVERT decimals to uint256\\nTMP_28(uint256) = 10 ** TMP_27\\nTMP_29(uint256) = 500000 * TMP_28\\n_totalSupply(uint256) := TMP_29(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[owner] = _totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balances[owner]\\nREF_0(uint256) (->balances) := _totalSupply(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTransfer(address(0),owner,_totalSupply)\\n\\nIRs:\\nTMP_30 = CONVERT 0 to address\\nEmit Transfer(TMP_30,owner,_totalSupply)\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 9.sol-WWW-WWW()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[msg.sender] = 100000000000000\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nREF_0(uint256) (->balances) := 100000000000000(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply = 100000000000000\\n\\nIRs:\\ntotalSupply(uint256) := 100000000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = WWW Chain\\n\\nIRs:\\nname(string) := WWW Chain(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ndecimals = 4\\n\\nIRs:\\ndecimals(uint8) := 4(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nsymbol = WWW\\n\\nIRs:\\nsymbol(string) := WWW(string)\\\"];\\n}\\n// Function: 9.sol-WWW-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_14(mapping(address => uint256)) -> allowed[_owner]\\nREF_15(uint256) -> REF_14[_spender]\\nRETURN REF_15\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 9.sol-WWW-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_12(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_13(uint256) -> REF_12[_spender]\\nREF_13(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 9.sol-WWW-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_11(uint256) -> balances[_owner]\\nRETURN REF_11\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 9.sol-WWW-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nMAX_UINT256 = 2 ** 256 - 1\\n\\nIRs:\\nTMP_11(uint256) = 2 ** 256\\nTMP_12(uint256) = TMP_11 - 1\\nMAX_UINT256(uint256) := TMP_12(uint256)\\\"];\\n}\\n// Function: 9.sol-WWW-test()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n2 + 3\\n\\nIRs:\\nTMP_9(uint256) = 2 + 3\\nRETURN TMP_9\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 9.sol-WWW-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balances[msg.sender] >= _value)\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nTMP_0(bool) = REF_1 >= _value\\nTMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] -= _value\\n\\nIRs:\\nREF_2(uint256) -> balances[msg.sender]\\nREF_2(-> balances) = REF_2 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] += _value\\n\\nIRs:\\nREF_3(uint256) -> balances[_to]\\nREF_3(-> balances) = REF_3 + _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 9.sol-WWW-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nallowance = allowed[_from][msg.sender]\\n\\nIRs:\\nREF_4(mapping(address => uint256)) -> allowed[_from]\\nREF_5(uint256) -> REF_4[msg.sender]\\nallowance(uint256) := REF_5(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balances[_from] >= _value && allowance >= _value)\\n\\nIRs:\\nREF_6(uint256) -> balances[_from]\\nTMP_3(bool) = REF_6 >= _value\\nTMP_4(bool) = allowance >= _value\\nTMP_5(bool) = TMP_3 && TMP_4\\nTMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] += _value\\n\\nIRs:\\nREF_7(uint256) -> balances[_to]\\nREF_7(-> balances) = REF_7 + _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] -= _value\\n\\nIRs:\\nREF_8(uint256) -> balances[_from]\\nREF_8(-> balances) = REF_8 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\nallowance < MAX_UINT256\\n\\nIRs:\\nTMP_7(bool) = allowance < MAX_UINT256\\nCONDITION TMP_7\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_9(mapping(address => uint256)) -> allowed[_from]\\nREF_10(uint256) -> REF_9[msg.sender]\\nREF_10(-> allowed) = REF_10 - _value\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n8->9;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 18.sol-ArkComChain-allowance(address,address)\\ndigraph{\\n}\\n// Function: 18.sol-ArkComChain-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-ArkComChain-balanceOf(address)\\ndigraph{\\n}\\n// Function: 18.sol-ArkComChain-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply_ = INITIAL_SUPPLY\\n\\nIRs:\\ntotalSupply_(uint256) := INITIAL_SUPPLY(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] = INITIAL_SUPPLY\\n\\nIRs:\\nREF_92(uint256) -> balances[msg.sender]\\nREF_92(uint256) (->balances) := INITIAL_SUPPLY(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(address(0),msg.sender,INITIAL_SUPPLY)\\n\\nIRs:\\nTMP_70 = CONVERT 0 to address\\nEmit Transfer(TMP_70,msg.sender,INITIAL_SUPPLY)\\\"];\\n}\\n// Function: 18.sol-ArkComChain-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_75(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_76(uint256) -> REF_75[_spender]\\noldValue(uint256) := REF_76(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_59(bool) = _subtractedValue > oldValue\\nCONDITION TMP_59\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_77(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_78(uint256) -> REF_77[_spender]\\nREF_78(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_79(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_80(uint256) -> REF_79[_spender]\\nTMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_80(uint256) (->allowed) := TMP_60(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_82(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_83(uint256) -> REF_82[_spender]\\nEmit Approval(msg.sender,_spender,REF_83)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 18.sol-ArkComChain-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))\\n\\nIRs:\\nREF_68(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_69(uint256) -> REF_68[_spender]\\nREF_70(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_71(uint256) -> REF_70[_spender]\\nTMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] \\nREF_69(uint256) (->allowed) := TMP_57(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_73(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_74(uint256) -> REF_73[_spender]\\nEmit Approval(msg.sender,_spender,REF_74)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 18.sol-ArkComChain-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = arkcomchain\\n\\nIRs:\\nname(string) := arkcomchain(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = AKC\\n\\nIRs:\\nsymbol(string) := AKC(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals))\\n\\nIRs:\\nTMP_72 = CONVERT decimals to uint256\\nTMP_73(uint256) = 10 ** TMP_72\\nTMP_74(uint256) = 50000000000 * TMP_73\\nINITIAL_SUPPLY(uint256) := TMP_74(uint256)\\\"];\\n}\\n// Function: 18.sol-ArkComChain-totalSupply()\\ndigraph{\\n}\\n// Function: 18.sol-ArkComChain-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-ArkComChain-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-BasicToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_7(uint256) -> balances[_owner]\\nRETURN REF_7\\\"];\\n}\\n// Function: 18.sol-BasicToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntotalSupply_\\n\\nIRs:\\nRETURN totalSupply_\\\"];\\n}\\n// Function: 18.sol-BasicToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_12 = CONVERT 0 to address\\nTMP_13(bool) = _to != TMP_12\\nTMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nTMP_15(bool) = _value <= REF_0\\nTMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] \\nREF_1(uint256) (->balances) := TMP_17(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_4(uint256) -> balances[_to]\\nREF_5(uint256) -> balances[_to]\\nTMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] \\nREF_4(uint256) (->balances) := TMP_18(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 18.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 18.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 18.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 18.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 18.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 18.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 18.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 18.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 18.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n// Function: 18.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_32(mapping(address => uint256)) -> allowed[_owner]\\nREF_33(uint256) -> REF_32[_spender]\\nRETURN REF_33\\\"];\\n}\\n// Function: 18.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_30(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_31(uint256) -> REF_30[_spender]\\nREF_31(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 18.sol-StandardToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 18.sol-StandardToken-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_41(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_42(uint256) -> REF_41[_spender]\\noldValue(uint256) := REF_42(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_42(bool) = _subtractedValue > oldValue\\nCONDITION TMP_42\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_43(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_44(uint256) -> REF_43[_spender]\\nREF_44(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_46(uint256) -> REF_45[_spender]\\nTMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_46(uint256) (->allowed) := TMP_43(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_49(uint256) -> REF_48[_spender]\\nEmit Approval(msg.sender,_spender,REF_49)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 18.sol-StandardToken-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))\\n\\nIRs:\\nREF_34(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_35(uint256) -> REF_34[_spender]\\nREF_36(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_37(uint256) -> REF_36[_spender]\\nTMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] \\nREF_35(uint256) (->allowed) := TMP_40(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_40(uint256) -> REF_39[_spender]\\nEmit Approval(msg.sender,_spender,REF_40)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 18.sol-StandardToken-totalSupply()\\ndigraph{\\n}\\n// Function: 18.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 18.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_28 = CONVERT 0 to address\\nTMP_29(bool) = _to != TMP_28\\nTMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_from])\\n\\nIRs:\\nREF_16(uint256) -> balances[_from]\\nTMP_31(bool) = _value <= REF_16\\nTMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_17(mapping(address => uint256)) -> allowed[_from]\\nREF_18(uint256) -> REF_17[msg.sender]\\nTMP_33(bool) = _value <= REF_18\\nTMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_19(uint256) -> balances[_from]\\nREF_20(uint256) -> balances[_from]\\nTMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] \\nREF_19(uint256) (->balances) := TMP_35(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_22(uint256) -> balances[_to]\\nREF_23(uint256) -> balances[_to]\\nTMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] \\nREF_22(uint256) (->balances) := TMP_36(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)\\n\\nIRs:\\nREF_25(mapping(address => uint256)) -> allowed[_from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nREF_27(mapping(address => uint256)) -> allowed[_from]\\nREF_28(uint256) -> REF_27[msg.sender]\\nTMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] \\nREF_26(uint256) (->allowed) := TMP_37(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 20.sol-BasicToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_7(uint256) -> balances[_owner]\\nRETURN REF_7\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 20.sol-BasicToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_13 = CONVERT 0 to address\\nTMP_14(bool) = _to != TMP_13\\nTMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nTMP_16(bool) = _value <= REF_0\\nTMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] \\nREF_1(uint256) (->balances) := TMP_18(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_4(uint256) -> balances[_to]\\nREF_5(uint256) -> balances[_to]\\nTMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] \\nREF_4(uint256) (->balances) := TMP_19(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 20.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 20.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 20.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 20.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 20.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 20.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 20.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 20.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_10(uint256) = a + b\\nc(uint256) := TMP_10(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_11(bool) = c >= a\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 20.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_6(uint256) = a / b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 20.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_0(uint256) = a * b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_1(bool) = a == 0\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(bool) = TMP_1 || TMP_3\\nTMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 20.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_7(bool) = b <= a\\nTMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_9(uint256) = a - b\\nRETURN TMP_9\\\"];\\n}\\n// Function: 20.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_32(mapping(address => uint256)) -> allowed[_owner]\\nREF_33(uint256) -> REF_32[_spender]\\nRETURN REF_33\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 20.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_30(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_31(uint256) -> REF_30[_spender]\\nREF_31(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 20.sol-StandardToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 20.sol-StandardToken-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_41(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_42(uint256) -> REF_41[_spender]\\noldValue(uint256) := REF_42(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_43(bool) = _subtractedValue > oldValue\\nCONDITION TMP_43\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_43(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_44(uint256) -> REF_43[_spender]\\nREF_44(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_46(uint256) -> REF_45[_spender]\\nTMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_46(uint256) (->allowed) := TMP_44(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_49(uint256) -> REF_48[_spender]\\nEmit Approval(msg.sender,_spender,REF_49)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 20.sol-StandardToken-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_34(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_35(uint256) -> REF_34[_spender]\\nREF_36(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_37(uint256) -> REF_36[_spender]\\nTMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] \\nREF_35(uint256) (->allowed) := TMP_41(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_40(uint256) -> REF_39[_spender]\\nEmit Approval(msg.sender,_spender,REF_40)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 20.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 20.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_29 = CONVERT 0 to address\\nTMP_30(bool) = _to != TMP_29\\nTMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_from])\\n\\nIRs:\\nREF_16(uint256) -> balances[_from]\\nTMP_32(bool) = _value <= REF_16\\nTMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_17(mapping(address => uint256)) -> allowed[_from]\\nREF_18(uint256) -> REF_17[msg.sender]\\nTMP_34(bool) = _value <= REF_18\\nTMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_19(uint256) -> balances[_from]\\nREF_20(uint256) -> balances[_from]\\nTMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] \\nREF_19(uint256) (->balances) := TMP_36(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_22(uint256) -> balances[_to]\\nREF_23(uint256) -> balances[_to]\\nTMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] \\nREF_22(uint256) (->balances) := TMP_37(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)\\n\\nIRs:\\nREF_25(mapping(address => uint256)) -> allowed[_from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nREF_27(mapping(address => uint256)) -> allowed[_from]\\nREF_28(uint256) -> REF_27[msg.sender]\\nTMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] \\nREF_26(uint256) (->allowed) := TMP_38(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 20.sol-WPAYReward-WPAYReward()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = INITIAL_SUPPLY\\n\\nIRs:\\ntotalSupply(uint256) := INITIAL_SUPPLY(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] = INITIAL_SUPPLY\\n\\nIRs:\\nREF_92(uint256) -> balances[msg.sender]\\nREF_92(uint256) (->balances) := INITIAL_SUPPLY(uint256)\\\"];\\n}\\n// Function: 20.sol-WPAYReward-allowance(address,address)\\ndigraph{\\n}\\n// Function: 20.sol-WPAYReward-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 20.sol-WPAYReward-balanceOf(address)\\ndigraph{\\n}\\n// Function: 20.sol-WPAYReward-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_75(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_76(uint256) -> REF_75[_spender]\\noldValue(uint256) := REF_76(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_60(bool) = _subtractedValue > oldValue\\nCONDITION TMP_60\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_77(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_78(uint256) -> REF_77[_spender]\\nREF_78(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_79(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_80(uint256) -> REF_79[_spender]\\nTMP_61(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_80(uint256) (->allowed) := TMP_61(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_82(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_83(uint256) -> REF_82[_spender]\\nEmit Approval(msg.sender,_spender,REF_83)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 20.sol-WPAYReward-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_68(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_69(uint256) -> REF_68[_spender]\\nREF_70(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_71(uint256) -> REF_70[_spender]\\nTMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] \\nREF_69(uint256) (->allowed) := TMP_58(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_73(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_74(uint256) -> REF_73[_spender]\\nEmit Approval(msg.sender,_spender,REF_74)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 20.sol-WPAYReward-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = WPAYReward\\n\\nIRs:\\nname(string) := WPAYReward(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = WRT\\n\\nIRs:\\nsymbol(string) := WRT(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 4\\n\\nIRs:\\ndecimals(uint8) := 4(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = 300000000 * (10 ** uint256(decimals))\\n\\nIRs:\\nTMP_71 = CONVERT decimals to uint256\\nTMP_72(uint256) = 10 ** TMP_71\\nTMP_73(uint256) = 300000000 * TMP_72\\nINITIAL_SUPPLY(uint256) := TMP_73(uint256)\\\"];\\n}\\n// Function: 20.sol-WPAYReward-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 20.sol-WPAYReward-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 21.sol-BasicToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_7(uint256) -> balances[_owner]\\nRETURN REF_7\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 21.sol-BasicToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_13 = CONVERT 0 to address\\nTMP_14(bool) = _to != TMP_13\\nTMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nTMP_16(bool) = _value <= REF_0\\nTMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] \\nREF_1(uint256) (->balances) := TMP_18(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_4(uint256) -> balances[_to]\\nREF_5(uint256) -> balances[_to]\\nTMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] \\nREF_4(uint256) (->balances) := TMP_19(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 21.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 21.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 21.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 21.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 21.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 21.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 21.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 21.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_10(uint256) = a + b\\nc(uint256) := TMP_10(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_11(bool) = c >= a\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 21.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_6(uint256) = a / b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 21.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_0(uint256) = a * b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_1(bool) = a == 0\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(bool) = TMP_1 || TMP_3\\nTMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 21.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_7(bool) = b <= a\\nTMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_9(uint256) = a - b\\nRETURN TMP_9\\\"];\\n}\\n// Function: 21.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_32(mapping(address => uint256)) -> allowed[_owner]\\nREF_33(uint256) -> REF_32[_spender]\\nRETURN REF_33\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 21.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_30(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_31(uint256) -> REF_30[_spender]\\nREF_31(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 21.sol-StandardToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 21.sol-StandardToken-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_41(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_42(uint256) -> REF_41[_spender]\\noldValue(uint256) := REF_42(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_43(bool) = _subtractedValue > oldValue\\nCONDITION TMP_43\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_43(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_44(uint256) -> REF_43[_spender]\\nREF_44(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_46(uint256) -> REF_45[_spender]\\nTMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_46(uint256) (->allowed) := TMP_44(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_49(uint256) -> REF_48[_spender]\\nEmit Approval(msg.sender,_spender,REF_49)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 21.sol-StandardToken-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_34(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_35(uint256) -> REF_34[_spender]\\nREF_36(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_37(uint256) -> REF_36[_spender]\\nTMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] \\nREF_35(uint256) (->allowed) := TMP_41(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_40(uint256) -> REF_39[_spender]\\nEmit Approval(msg.sender,_spender,REF_40)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 21.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 21.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_29 = CONVERT 0 to address\\nTMP_30(bool) = _to != TMP_29\\nTMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_from])\\n\\nIRs:\\nREF_16(uint256) -> balances[_from]\\nTMP_32(bool) = _value <= REF_16\\nTMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_17(mapping(address => uint256)) -> allowed[_from]\\nREF_18(uint256) -> REF_17[msg.sender]\\nTMP_34(bool) = _value <= REF_18\\nTMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_19(uint256) -> balances[_from]\\nREF_20(uint256) -> balances[_from]\\nTMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] \\nREF_19(uint256) (->balances) := TMP_36(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_22(uint256) -> balances[_to]\\nREF_23(uint256) -> balances[_to]\\nTMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] \\nREF_22(uint256) (->balances) := TMP_37(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)\\n\\nIRs:\\nREF_25(mapping(address => uint256)) -> allowed[_from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nREF_27(mapping(address => uint256)) -> allowed[_from]\\nREF_28(uint256) -> REF_27[msg.sender]\\nTMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] \\nREF_26(uint256) (->allowed) := TMP_38(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 21.sol-WPAYCoin-WPAYCoin()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = INITIAL_SUPPLY\\n\\nIRs:\\ntotalSupply(uint256) := INITIAL_SUPPLY(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] = INITIAL_SUPPLY\\n\\nIRs:\\nREF_92(uint256) -> balances[msg.sender]\\nREF_92(uint256) (->balances) := INITIAL_SUPPLY(uint256)\\\"];\\n}\\n// Function: 21.sol-WPAYCoin-allowance(address,address)\\ndigraph{\\n}\\n// Function: 21.sol-WPAYCoin-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 21.sol-WPAYCoin-balanceOf(address)\\ndigraph{\\n}\\n// Function: 21.sol-WPAYCoin-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_75(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_76(uint256) -> REF_75[_spender]\\noldValue(uint256) := REF_76(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_60(bool) = _subtractedValue > oldValue\\nCONDITION TMP_60\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_77(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_78(uint256) -> REF_77[_spender]\\nREF_78(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_79(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_80(uint256) -> REF_79[_spender]\\nTMP_61(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_80(uint256) (->allowed) := TMP_61(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_82(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_83(uint256) -> REF_82[_spender]\\nEmit Approval(msg.sender,_spender,REF_83)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 21.sol-WPAYCoin-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_68(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_69(uint256) -> REF_68[_spender]\\nREF_70(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_71(uint256) -> REF_70[_spender]\\nTMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] \\nREF_69(uint256) (->allowed) := TMP_58(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_73(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_74(uint256) -> REF_73[_spender]\\nEmit Approval(msg.sender,_spender,REF_74)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 21.sol-WPAYCoin-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = WPAYCoin\\n\\nIRs:\\nname(string) := WPAYCoin(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = WPY\\n\\nIRs:\\nsymbol(string) := WPY(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 6\\n\\nIRs:\\ndecimals(uint8) := 6(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = 600000000 * (10 ** uint256(decimals))\\n\\nIRs:\\nTMP_71 = CONVERT decimals to uint256\\nTMP_72(uint256) = 10 ** TMP_71\\nTMP_73(uint256) = 600000000 * TMP_72\\nINITIAL_SUPPLY(uint256) := TMP_73(uint256)\\\"];\\n}\\n// Function: 21.sol-WPAYCoin-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 21.sol-WPAYCoin-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 22.sol-BasicToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_7(uint256) -> balances[_owner]\\nRETURN REF_7\\\"];\\n}\\n// Function: 22.sol-BasicToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntotalSupply_\\n\\nIRs:\\nRETURN totalSupply_\\\"];\\n}\\n// Function: 22.sol-BasicToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nTMP_12(bool) = _value <= REF_0\\nTMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_14 = CONVERT 0 to address\\nTMP_15(bool) = _to != TMP_14\\nTMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] \\nREF_1(uint256) (->balances) := TMP_17(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_4(uint256) -> balances[_to]\\nREF_5(uint256) -> balances[_to]\\nTMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] \\nREF_4(uint256) (->balances) := TMP_18(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 22.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 22.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 22.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 22.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 22.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 22.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 22.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 22.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 22.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = _a + _b\\n\\nIRs:\\nTMP_9(uint256) = _a + _b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= _a)\\n\\nIRs:\\nTMP_10(bool) = c >= _a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 22.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n_a / _b\\n\\nIRs:\\nTMP_5(uint256) = _a / _b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 22.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_a == 0\\n\\nIRs:\\nTMP_0(bool) = _a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = _a * _b\\n\\nIRs:\\nTMP_1(uint256) = _a * _b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / _a == _b)\\n\\nIRs:\\nTMP_2(uint256) = c / _a\\nTMP_3(bool) = TMP_2 == _b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 22.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(_b <= _a)\\n\\nIRs:\\nTMP_6(bool) = _b <= _a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n_a - _b\\n\\nIRs:\\nTMP_8(uint256) = _a - _b\\nRETURN TMP_8\\\"];\\n}\\n// Function: 22.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_32(mapping(address => uint256)) -> allowed[_owner]\\nREF_33(uint256) -> REF_32[_spender]\\nRETURN REF_33\\\"];\\n}\\n// Function: 22.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_30(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_31(uint256) -> REF_30[_spender]\\nREF_31(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-StandardToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 22.sol-StandardToken-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_41(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_42(uint256) -> REF_41[_spender]\\noldValue(uint256) := REF_42(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue >= oldValue\\n\\nIRs:\\nTMP_42(bool) = _subtractedValue >= oldValue\\nCONDITION TMP_42\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_43(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_44(uint256) -> REF_43[_spender]\\nREF_44(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_46(uint256) -> REF_45[_spender]\\nTMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_46(uint256) (->allowed) := TMP_43(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_49(uint256) -> REF_48[_spender]\\nEmit Approval(msg.sender,_spender,REF_49)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-StandardToken-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))\\n\\nIRs:\\nREF_34(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_35(uint256) -> REF_34[_spender]\\nREF_36(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_37(uint256) -> REF_36[_spender]\\nTMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_37', '_addedValue'] \\nREF_35(uint256) (->allowed) := TMP_40(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_40(uint256) -> REF_39[_spender]\\nEmit Approval(msg.sender,_spender,REF_40)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-StandardToken-totalSupply()\\ndigraph{\\n}\\n// Function: 22.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 22.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_from])\\n\\nIRs:\\nREF_16(uint256) -> balances[_from]\\nTMP_28(bool) = _value <= REF_16\\nTMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_17(mapping(address => uint256)) -> allowed[_from]\\nREF_18(uint256) -> REF_17[msg.sender]\\nTMP_30(bool) = _value <= REF_18\\nTMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_32 = CONVERT 0 to address\\nTMP_33(bool) = _to != TMP_32\\nTMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_19(uint256) -> balances[_from]\\nREF_20(uint256) -> balances[_from]\\nTMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] \\nREF_19(uint256) (->balances) := TMP_35(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_22(uint256) -> balances[_to]\\nREF_23(uint256) -> balances[_to]\\nTMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] \\nREF_22(uint256) (->balances) := TMP_36(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)\\n\\nIRs:\\nREF_25(mapping(address => uint256)) -> allowed[_from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nREF_27(mapping(address => uint256)) -> allowed[_from]\\nREF_28(uint256) -> REF_27[msg.sender]\\nTMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] \\nREF_26(uint256) (->allowed) := TMP_37(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-allowance(address,address)\\ndigraph{\\n}\\n// Function: 22.sol-XinCoin-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_spender])\\n\\nIRs:\\nREF_164(uint256) -> balances[_spender]\\nTMP_168(bool) = _value <= REF_164\\nTMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_165(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_166(uint256) -> REF_165[_spender]\\nREF_166(uint256) (->allowed) := _value(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-balanceOf(address)\\ndigraph{\\n}\\n// Function: 22.sol-XinCoin-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_167(uint256) -> balances[msg.sender]\\nTMP_171(bool) = _value <= REF_167\\nTMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_168(uint256) -> balances[msg.sender]\\nREF_169(uint256) -> balances[msg.sender]\\nTMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_169', '_value'] \\nREF_168(uint256) (->balances) := TMP_173(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply_ = totalSupply_.sub(_value)\\n\\nIRs:\\nTMP_174(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] \\ntotalSupply_(uint256) := TMP_174(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = totalSupply_\\n\\nIRs:\\nINITIAL_SUPPLY(uint256) := totalSupply_(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-changeAdmin(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_72(bool) = msg.sender == admin\\nTMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_newAdmin != address(0))\\n\\nIRs:\\nTMP_74 = CONVERT 0 to address\\nTMP_75(bool) = _newAdmin != TMP_74\\nTMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_newAdmin] = balances[_newAdmin].add(balances[admin])\\n\\nIRs:\\nREF_93(uint256) -> balances[_newAdmin]\\nREF_94(uint256) -> balances[_newAdmin]\\nREF_96(uint256) -> balances[admin]\\nTMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_94', 'REF_96'] \\nREF_93(uint256) (->balances) := TMP_77(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[admin] = 0\\n\\nIRs:\\nREF_97(uint256) -> balances[admin]\\nREF_97(uint256) (->balances) := 0(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nadmin = _newAdmin\\n\\nIRs:\\nadmin(address) := _newAdmin(address)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply_ = INITIAL_SUPPLY\\n\\nIRs:\\ntotalSupply_(uint256) := INITIAL_SUPPLY(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nadmin = msg.sender\\n\\nIRs:\\nadmin(address) := msg.sender(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = INITIAL_SUPPLY\\n\\nIRs:\\nREF_92(uint256) -> balances[msg.sender]\\nREF_92(uint256) (->balances) := INITIAL_SUPPLY(uint256)\\\"];\\n}\\n// Function: 22.sol-XinCoin-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_75(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_76(uint256) -> REF_75[_spender]\\noldValue(uint256) := REF_76(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue >= oldValue\\n\\nIRs:\\nTMP_59(bool) = _subtractedValue >= oldValue\\nCONDITION TMP_59\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_77(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_78(uint256) -> REF_77[_spender]\\nREF_78(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_79(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_80(uint256) -> REF_79[_spender]\\nTMP_60(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_80(uint256) (->allowed) := TMP_60(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_82(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_83(uint256) -> REF_82[_spender]\\nEmit Approval(msg.sender,_spender,REF_83)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.value > 0)\\n\\nIRs:\\nTMP_70(bool) = msg.value > 0\\nTMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)\\\"];\\n}\\n// Function: 22.sol-XinCoin-freeze(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_88(bool) = msg.sender == admin\\nTMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_target != address(0))\\n\\nIRs:\\nTMP_90 = CONVERT 0 to address\\nTMP_91(bool) = _target != TMP_90\\nTMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nfrozenAccount[_target] = _freeze\\n\\nIRs:\\nREF_103(bool) -> frozenAccount[_target]\\nREF_103(bool) (->frozenAccount) := _freeze(bool)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-freezeWithTimestamp(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_93(bool) = msg.sender == admin\\nTMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_target != address(0))\\n\\nIRs:\\nTMP_95 = CONVERT 0 to address\\nTMP_96(bool) = _target != TMP_95\\nTMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nfrozenTimestamp[_target] = _timestamp\\n\\nIRs:\\nREF_104(uint256) -> frozenTimestamp[_target]\\nREF_104(uint256) (->frozenTimestamp) := _timestamp(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-generateToken(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_78(bool) = msg.sender == admin\\nTMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_target != address(0))\\n\\nIRs:\\nTMP_80 = CONVERT 0 to address\\nTMP_81(bool) = _target != TMP_80\\nTMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_target] = balances[_target].add(_amount)\\n\\nIRs:\\nREF_98(uint256) -> balances[_target]\\nREF_99(uint256) -> balances[_target]\\nTMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_99', '_amount'] \\nREF_98(uint256) (->balances) := TMP_83(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalSupply_ = totalSupply_.add(_amount)\\n\\nIRs:\\nTMP_84(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalSupply_', '_amount'] \\ntotalSupply_(uint256) := TMP_84(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = totalSupply_\\n\\nIRs:\\nINITIAL_SUPPLY(uint256) := totalSupply_(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-getBalance(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_174(uint256) -> balances[_owner]\\nRETURN REF_174\\\"];\\n}\\n// Function: 22.sol-XinCoin-getFrozenAccount(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_target != address(0))\\n\\nIRs:\\nTMP_179 = CONVERT 0 to address\\nTMP_180(bool) = _target != TMP_179\\nTMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nfrozenAccount[_target]\\n\\nIRs:\\nREF_173(bool) -> frozenAccount[_target]\\nRETURN REF_173\\\"];\\n}\\n// Function: 22.sol-XinCoin-getFrozenTimestamp(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_target != address(0))\\n\\nIRs:\\nTMP_176 = CONVERT 0 to address\\nTMP_177(bool) = _target != TMP_176\\nTMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nfrozenTimestamp[_target]\\n\\nIRs:\\nREF_172(uint256) -> frozenTimestamp[_target]\\nRETURN REF_172\\\"];\\n}\\n// Function: 22.sol-XinCoin-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue))\\n\\nIRs:\\nREF_68(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_69(uint256) -> REF_68[_spender]\\nREF_70(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_71(uint256) -> REF_70[_spender]\\nTMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] \\nREF_69(uint256) (->allowed) := TMP_57(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_73(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_74(uint256) -> REF_73[_spender]\\nEmit Approval(msg.sender,_spender,REF_74)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-kill()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_186(bool) = msg.sender == admin\\nTMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nselfdestruct(address)(admin)\\n\\nIRs:\\nTMP_188(None) = SOLIDITY_CALL selfdestruct(address)(admin)\\\"];\\n}\\n// Function: 22.sol-XinCoin-multiFreeze(address[],bool[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_98(bool) = msg.sender == admin\\nTMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_targets.length == _freezes.length)\\n\\nIRs:\\nREF_105 -> LENGTH _targets\\nREF_106 -> LENGTH _freezes\\nTMP_100(bool) = REF_105 == REF_106\\nTMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\nlen = _targets.length\\n\\nIRs:\\nREF_107 -> LENGTH _targets\\nlen(uint256) := REF_107(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(len > 0)\\n\\nIRs:\\nTMP_102(bool) = len > 0\\nTMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)\\\"];\\n4->7;\\n5[label=\\\"Node Type: BEGIN_LOOP 5\\n\\\"];\\n5->8;\\n6[label=\\\"Node Type: END_LOOP 6\\n\\\"];\\n6->14;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n7->5;\\n8[label=\\\"Node Type: IF_LOOP 8\\n\\nEXPRESSION:\\ni < len\\n\\nIRs:\\nTMP_104(bool) = i < len\\nCONDITION TMP_104\\\"];\\n8->9[label=\\\"True\\\"];\\n8->6[label=\\\"False\\\"];\\n9[label=\\\"Node Type: NEW VARIABLE 9\\n\\nEXPRESSION:\\n_target = _targets[i]\\n\\nIRs:\\nREF_108(address) -> _targets[i]\\n_target(address) := REF_108(address)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nrequire(bool)(_target != address(0))\\n\\nIRs:\\nTMP_105 = CONVERT 0 to address\\nTMP_106(bool) = _target != TMP_105\\nTMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)\\\"];\\n10->11;\\n11[label=\\\"Node Type: NEW VARIABLE 11\\n\\nEXPRESSION:\\n_freeze = _freezes[i]\\n\\nIRs:\\nREF_109(bool) -> _freezes[i]\\n_freeze(bool) := REF_109(bool)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nfrozenAccount[_target] = _freeze\\n\\nIRs:\\nREF_110(bool) -> frozenAccount[_target]\\nREF_110(bool) (->frozenAccount) := _freeze(bool)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\ni = i.add(1)\\n\\nIRs:\\nTMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['i', '1'] \\ni(uint256) := TMP_108(uint256)\\\"];\\n13->8;\\n14[label=\\\"Node Type: RETURN 14\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-multiFreezeWithTimestamp(address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_109(bool) = msg.sender == admin\\nTMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_targets.length == _timestamps.length)\\n\\nIRs:\\nREF_112 -> LENGTH _targets\\nREF_113 -> LENGTH _timestamps\\nTMP_111(bool) = REF_112 == REF_113\\nTMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\nlen = _targets.length\\n\\nIRs:\\nREF_114 -> LENGTH _targets\\nlen(uint256) := REF_114(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(len > 0)\\n\\nIRs:\\nTMP_113(bool) = len > 0\\nTMP_114(None) = SOLIDITY_CALL require(bool)(TMP_113)\\\"];\\n4->7;\\n5[label=\\\"Node Type: BEGIN_LOOP 5\\n\\\"];\\n5->8;\\n6[label=\\\"Node Type: END_LOOP 6\\n\\\"];\\n6->14;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n7->5;\\n8[label=\\\"Node Type: IF_LOOP 8\\n\\nEXPRESSION:\\ni < len\\n\\nIRs:\\nTMP_115(bool) = i < len\\nCONDITION TMP_115\\\"];\\n8->9[label=\\\"True\\\"];\\n8->6[label=\\\"False\\\"];\\n9[label=\\\"Node Type: NEW VARIABLE 9\\n\\nEXPRESSION:\\n_target = _targets[i]\\n\\nIRs:\\nREF_115(address) -> _targets[i]\\n_target(address) := REF_115(address)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nrequire(bool)(_target != address(0))\\n\\nIRs:\\nTMP_116 = CONVERT 0 to address\\nTMP_117(bool) = _target != TMP_116\\nTMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)\\\"];\\n10->11;\\n11[label=\\\"Node Type: NEW VARIABLE 11\\n\\nEXPRESSION:\\n_timestamp = _timestamps[i]\\n\\nIRs:\\nREF_116(uint256) -> _timestamps[i]\\n_timestamp(uint256) := REF_116(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nfrozenTimestamp[_target] = _timestamp\\n\\nIRs:\\nREF_117(uint256) -> frozenTimestamp[_target]\\nREF_117(uint256) (->frozenTimestamp) := _timestamp(uint256)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\ni = i.add(1)\\n\\nIRs:\\nTMP_119(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['i', '1'] \\ni(uint256) := TMP_119(uint256)\\\"];\\n13->8;\\n14[label=\\\"Node Type: RETURN 14\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-multiTransfer(address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[msg.sender])\\n\\nIRs:\\nREF_119(bool) -> frozenAccount[msg.sender]\\nTMP_120 = UnaryType.BANG REF_119 \\nTMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(now > frozenTimestamp[msg.sender])\\n\\nIRs:\\nREF_120(uint256) -> frozenTimestamp[msg.sender]\\nTMP_122(bool) = now > REF_120\\nTMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_tos.length == _values.length)\\n\\nIRs:\\nREF_121 -> LENGTH _tos\\nREF_122 -> LENGTH _values\\nTMP_124(bool) = REF_121 == REF_122\\nTMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nlen = _tos.length\\n\\nIRs:\\nREF_123 -> LENGTH _tos\\nlen(uint256) := REF_123(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(len > 0)\\n\\nIRs:\\nTMP_126(bool) = len > 0\\nTMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\namount = 0\\n\\nIRs:\\namount(uint256) := 0(uint256)\\\"];\\n6->9;\\n7[label=\\\"Node Type: BEGIN_LOOP 7\\n\\\"];\\n7->10;\\n8[label=\\\"Node Type: END_LOOP 8\\n\\\"];\\n8->13;\\n9[label=\\\"Node Type: NEW VARIABLE 9\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n9->7;\\n10[label=\\\"Node Type: IF_LOOP 10\\n\\nEXPRESSION:\\ni < len\\n\\nIRs:\\nTMP_128(bool) = i < len\\nCONDITION TMP_128\\\"];\\n10->11[label=\\\"True\\\"];\\n10->8[label=\\\"False\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\namount = amount.add(_values[i])\\n\\nIRs:\\nREF_125(uint256) -> _values[i]\\nTMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['amount', 'REF_125'] \\namount(uint256) := TMP_129(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ni = i.add(1)\\n\\nIRs:\\nTMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['i', '1'] \\ni(uint256) := TMP_130(uint256)\\\"];\\n12->10;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nrequire(bool)(amount <= balances[msg.sender])\\n\\nIRs:\\nREF_127(uint256) -> balances[msg.sender]\\nTMP_131(bool) = amount <= REF_127\\nTMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)\\\"];\\n13->16;\\n14[label=\\\"Node Type: BEGIN_LOOP 14\\n\\\"];\\n14->17;\\n15[label=\\\"Node Type: END_LOOP 15\\n\\\"];\\n15->24;\\n16[label=\\\"Node Type: NEW VARIABLE 16\\n\\nEXPRESSION:\\nj = 0\\n\\nIRs:\\nj(uint256) := 0(uint256)\\\"];\\n16->14;\\n17[label=\\\"Node Type: IF_LOOP 17\\n\\nEXPRESSION:\\nj < len\\n\\nIRs:\\nTMP_133(bool) = j < len\\nCONDITION TMP_133\\\"];\\n17->18[label=\\\"True\\\"];\\n17->15[label=\\\"False\\\"];\\n18[label=\\\"Node Type: NEW VARIABLE 18\\n\\nEXPRESSION:\\n_to = _tos[j]\\n\\nIRs:\\nREF_128(address) -> _tos[j]\\n_to(address) := REF_128(address)\\\"];\\n18->19;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_134 = CONVERT 0 to address\\nTMP_135(bool) = _to != TMP_134\\nTMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)\\\"];\\n19->20;\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_values[j])\\n\\nIRs:\\nREF_129(uint256) -> balances[_to]\\nREF_130(uint256) -> balances[_to]\\nREF_132(uint256) -> _values[j]\\nTMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_130', 'REF_132'] \\nREF_129(uint256) (->balances) := TMP_137(uint256)\\\"];\\n20->21;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_values[j])\\n\\nIRs:\\nREF_133(uint256) -> balances[msg.sender]\\nREF_134(uint256) -> balances[msg.sender]\\nREF_136(uint256) -> _values[j]\\nTMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_134', 'REF_136'] \\nREF_133(uint256) (->balances) := TMP_138(uint256)\\\"];\\n21->22;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_values[j])\\n\\nIRs:\\nREF_137(uint256) -> _values[j]\\nEmit Transfer(msg.sender,_to,REF_137)\\\"];\\n22->23;\\n23[label=\\\"Node Type: EXPRESSION 23\\n\\nEXPRESSION:\\nj = j.add(1)\\n\\nIRs:\\nTMP_140(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['j', '1'] \\nj(uint256) := TMP_140(uint256)\\\"];\\n23->17;\\n24[label=\\\"Node Type: RETURN 24\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-setName(string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_182(bool) = msg.sender == admin\\nTMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = _value\\n\\nIRs:\\nname(string) := _value(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-setSymbol(string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_184(bool) = msg.sender == admin\\nTMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nsymbol = _value\\n\\nIRs:\\nsymbol(string) := _value(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = XinCoin\\n\\nIRs:\\nname(string) := XinCoin(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = XC\\n\\nIRs:\\nsymbol(string) := XC(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 8\\n\\nIRs:\\ndecimals(uint8) := 8(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = 100000000000000000\\n\\nIRs:\\nINITIAL_SUPPLY(uint256) := 100000000000000000(uint256)\\\"];\\n}\\n// Function: 22.sol-XinCoin-totalSupply()\\ndigraph{\\n}\\n// Function: 22.sol-XinCoin-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[msg.sender])\\n\\nIRs:\\nREF_139(bool) -> frozenAccount[msg.sender]\\nTMP_141 = UnaryType.BANG REF_139 \\nTMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(now > frozenTimestamp[msg.sender])\\n\\nIRs:\\nREF_140(uint256) -> frozenTimestamp[msg.sender]\\nTMP_143(bool) = now > REF_140\\nTMP_144(None) = SOLIDITY_CALL require(bool)(TMP_143)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_145 = CONVERT 0 to address\\nTMP_146(bool) = _to != TMP_145\\nTMP_147(None) = SOLIDITY_CALL require(bool)(TMP_146)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_141(uint256) -> balances[msg.sender]\\nTMP_148(bool) = _value <= REF_141\\nTMP_149(None) = SOLIDITY_CALL require(bool)(TMP_148)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_142(uint256) -> balances[msg.sender]\\nREF_143(uint256) -> balances[msg.sender]\\nTMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_143', '_value'] \\nREF_142(uint256) (->balances) := TMP_150(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_145(uint256) -> balances[_to]\\nREF_146(uint256) -> balances[_to]\\nTMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_146', '_value'] \\nREF_145(uint256) (->balances) := TMP_151(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[_from])\\n\\nIRs:\\nREF_148(bool) -> frozenAccount[_from]\\nTMP_153 = UnaryType.BANG REF_148 \\nTMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(now > frozenTimestamp[msg.sender])\\n\\nIRs:\\nREF_149(uint256) -> frozenTimestamp[msg.sender]\\nTMP_155(bool) = now > REF_149\\nTMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_157 = CONVERT 0 to address\\nTMP_158(bool) = _to != TMP_157\\nTMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_from])\\n\\nIRs:\\nREF_150(uint256) -> balances[_from]\\nTMP_160(bool) = _value <= REF_150\\nTMP_161(None) = SOLIDITY_CALL require(bool)(TMP_160)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_151(mapping(address => uint256)) -> allowed[_from]\\nREF_152(uint256) -> REF_151[msg.sender]\\nTMP_162(bool) = _value <= REF_152\\nTMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_153(uint256) -> balances[_from]\\nREF_154(uint256) -> balances[_from]\\nTMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_154', '_value'] \\nREF_153(uint256) (->balances) := TMP_164(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_156(uint256) -> balances[_to]\\nREF_157(uint256) -> balances[_to]\\nTMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_157', '_value'] \\nREF_156(uint256) (->balances) := TMP_165(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)\\n\\nIRs:\\nREF_159(mapping(address => uint256)) -> allowed[_from]\\nREF_160(uint256) -> REF_159[msg.sender]\\nREF_161(mapping(address => uint256)) -> allowed[_from]\\nREF_162(uint256) -> REF_161[msg.sender]\\nTMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_162', '_value'] \\nREF_160(uint256) (->allowed) := TMP_166(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n9->10;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 22.sol-XinCoin-withdraw(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == admin)\\n\\nIRs:\\nTMP_85(bool) = msg.sender == admin\\nTMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nmsg.sender.transfer(_amount)\\n\\nIRs:\\nTransfer dest:msg.sender value:_amount\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 23.sol-BasicToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_7(uint256) -> balances[_owner]\\nRETURN REF_7\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 23.sol-BasicToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntotalSupply_\\n\\nIRs:\\nRETURN totalSupply_\\\"];\\n}\\n// Function: 23.sol-BasicToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_35 = CONVERT 0 to address\\nTMP_36(bool) = _to != TMP_35\\nTMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nTMP_38(bool) = _value <= REF_0\\nTMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] \\nREF_1(uint256) (->balances) := TMP_40(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_4(uint256) -> balances[_to]\\nREF_5(uint256) -> balances[_to]\\nTMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] \\nREF_4(uint256) (->balances) := TMP_41(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 23.sol-BurnableToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 23.sol-BurnableToken-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_16(uint256) -> balances[msg.sender]\\nTMP_51(bool) = _value <= REF_16\\nTMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nburner = msg.sender\\n\\nIRs:\\nburner(address) := msg.sender(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[burner] = balances[burner].sub(_value)\\n\\nIRs:\\nREF_17(uint256) -> balances[burner]\\nREF_18(uint256) -> balances[burner]\\nTMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_18', '_value'] \\nREF_17(uint256) (->balances) := TMP_53(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalSupply_ = totalSupply_.sub(_value)\\n\\nIRs:\\nTMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] \\ntotalSupply_(uint256) := TMP_54(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nBurn(burner,_value)\\n\\nIRs:\\nEmit Burn(burner,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTransfer(burner,address(0),_value)\\n\\nIRs:\\nTMP_56 = CONVERT 0 to address\\nEmit Transfer(burner,TMP_56,_value)\\\"];\\n}\\n// Function: 23.sol-BurnableToken-totalSupply()\\ndigraph{\\n}\\n// Function: 23.sol-BurnableToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 23.sol-Cloudbric-Cloudbric(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply_ = INITIAL_SUPPLY\\n\\nIRs:\\ntotalSupply_(uint256) := INITIAL_SUPPLY(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] = totalSupply_\\n\\nIRs:\\nREF_110(uint256) -> balances[msg.sender]\\nREF_110(uint256) (->balances) := totalSupply_(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(address(0x0),msg.sender,totalSupply_)\\n\\nIRs:\\nTMP_120 = CONVERT 0 to address\\nEmit Transfer(TMP_120,msg.sender,totalSupply_)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nadminAddr = _adminAddr\\n\\nIRs:\\nadminAddr(address) := _adminAddr(address)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\napprove(adminAddr,ADMIN_ALLOWANCE)\\n\\nIRs:\\nTMP_122(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(adminAddr,ADMIN_ALLOWANCE)\\\"];\\n}\\n// Function: 23.sol-Cloudbric-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 23.sol-Cloudbric-allowance(address,address)\\ndigraph{\\n}\\n// Function: 23.sol-Cloudbric-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 23.sol-Cloudbric-balanceOf(address)\\ndigraph{\\n}\\n// Function: 23.sol-Cloudbric-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(transferEnabled)\\n\\nIRs:\\nTMP_142(None) = SOLIDITY_CALL require(bool)(transferEnabled)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nsuper.burn(value)\\n\\nIRs:\\nINTERNAL_CALL, BurnableToken.burn(uint256)(value)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 23.sol-Cloudbric-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_101(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_102(uint256) -> REF_101[_spender]\\noldValue(uint256) := REF_102(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_117(bool) = _subtractedValue > oldValue\\nCONDITION TMP_117\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_103(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_104(uint256) -> REF_103[_spender]\\nREF_104(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_105(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_106(uint256) -> REF_105[_spender]\\nTMP_118(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_106(uint256) (->allowed) := TMP_118(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_108(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_109(uint256) -> REF_108[_spender]\\nEmit Approval(msg.sender,_spender,REF_109)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 23.sol-Cloudbric-disableTransfer()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntransferEnabled = false\\n\\nIRs:\\ntransferEnabled(bool) := False(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 23.sol-Cloudbric-enableTransfer()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntransferEnabled = true\\n\\nIRs:\\ntransferEnabled(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\napprove(tokenSaleAddr,0)\\n\\nIRs:\\nTMP_131(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(tokenSaleAddr,0)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 23.sol-Cloudbric-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_94(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_95(uint256) -> REF_94[_spender]\\nREF_96(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_97(uint256) -> REF_96[_spender]\\nTMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_97', '_addedValue'] \\nREF_95(uint256) (->allowed) := TMP_115(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_99(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_100(uint256) -> REF_99[_spender]\\nEmit Approval(msg.sender,_spender,REF_100)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 23.sol-Cloudbric-lockAccount(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(amount > 0)\\n\\nIRs:\\nTMP_145(bool) = amount > 0\\nTMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nlockedAccounts[addr] = amount\\n\\nIRs:\\nREF_111(uint256) -> lockedAccounts[addr]\\nREF_111(uint256) (->lockedAccounts) := amount(uint256)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyValidDestination(addr)\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyValidDestination(address)(addr)\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Cloudbric-onlyAllowedAmount(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balances[from].sub(amount) >= lockedAccounts[from])\\n\\nIRs:\\nREF_113(uint256) -> balances[from]\\nTMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_113', 'amount'] \\nREF_115(uint256) -> lockedAccounts[from]\\nTMP_182(bool) = TMP_181 >= REF_115\\nTMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Cloudbric-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_158(bool) = msg.sender == owner\\nTMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Cloudbric-onlyValidDestination(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(to != address(0x0) && to != address(this) && to != owner && to != adminAddr && to != tokenSaleAddr)\\n\\nIRs:\\nTMP_169 = CONVERT 0 to address\\nTMP_170(bool) = to != TMP_169\\nTMP_171 = CONVERT this to address\\nTMP_172(bool) = to != TMP_171\\nTMP_173(bool) = TMP_170 && TMP_172\\nTMP_174(bool) = to != owner\\nTMP_175(bool) = TMP_173 && TMP_174\\nTMP_176(bool) = to != adminAddr\\nTMP_177(bool) = TMP_175 && TMP_176\\nTMP_178(bool) = to != tokenSaleAddr\\nTMP_179(bool) = TMP_177 && TMP_178\\nTMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Cloudbric-onlyWhenTokenSaleAddrNotSet()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(tokenSaleAddr == address(0x0))\\n\\nIRs:\\nTMP_166 = CONVERT 0 to address\\nTMP_167(bool) = tokenSaleAddr == TMP_166\\nTMP_168(None) = SOLIDITY_CALL require(bool)(TMP_167)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Cloudbric-onlyWhenTransferAllowed()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(transferEnabled == true || msg.sender == adminAddr || msg.sender == tokenSaleAddr)\\n\\nIRs:\\nTMP_160(bool) = transferEnabled == True\\nTMP_161(bool) = msg.sender == adminAddr\\nTMP_162(bool) = TMP_160 || TMP_161\\nTMP_163(bool) = msg.sender == tokenSaleAddr\\nTMP_164(bool) = TMP_162 || TMP_163\\nTMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Cloudbric-setTokenSaleAmount(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! transferEnabled)\\n\\nIRs:\\nTMP_123 = UnaryType.BANG transferEnabled \\nTMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)\\\"];\\n1->8;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(amount <= TOKEN_SALE_ALLOWANCE)\\n\\nIRs:\\nTMP_125(bool) = amount <= TOKEN_SALE_ALLOWANCE\\nTMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\napprove(_tokenSaleAddr,amount)\\n\\nIRs:\\nTMP_127(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_tokenSaleAddr,amount)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntokenSaleAddr = _tokenSaleAddr\\n\\nIRs:\\ntokenSaleAddr(address) := _tokenSaleAddr(address)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyWhenTokenSaleAddrNotSet()\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyWhenTokenSaleAddrNotSet()()\\\"];\\n7->1;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\n(amountForSale == 0)\\n\\nIRs:\\nTMP_130(bool) = amountForSale == 0\\nCONDITION TMP_130\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\namount = TOKEN_SALE_ALLOWANCE\\n\\nIRs:\\namount(uint256) := TOKEN_SALE_ALLOWANCE(uint256)\\\"];\\n9->11;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\namount = amountForSale\\n\\nIRs:\\namount(uint256) := amountForSale(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->3;\\n}\\n// Function: 23.sol-Cloudbric-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nsymbol = CLB\\n\\nIRs:\\nsymbol(string) := CLB(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nname = Cloudbric\\n\\nIRs:\\nname(string) := Cloudbric(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals))\\n\\nIRs:\\nTMP_151 = CONVERT decimals to uint256\\nTMP_152(uint256) = 10 ** TMP_151\\nTMP_153(uint256) = 1000000000 * TMP_152\\nINITIAL_SUPPLY(uint256) := TMP_153(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nTOKEN_SALE_ALLOWANCE = 540000000 * (10 ** uint256(decimals))\\n\\nIRs:\\nTMP_154 = CONVERT decimals to uint256\\nTMP_155(uint256) = 10 ** TMP_154\\nTMP_156(uint256) = 540000000 * TMP_155\\nTOKEN_SALE_ALLOWANCE(uint256) := TMP_156(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: OTHER_ENTRYPOINT 5\\n\\nEXPRESSION:\\nADMIN_ALLOWANCE = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE\\n\\nIRs:\\nTMP_157(uint256) = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE\\nADMIN_ALLOWANCE(uint256) := TMP_157(uint256)\\\"];\\n}\\n// Function: 23.sol-Cloudbric-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ntransferEnabled = false\\n\\nIRs:\\ntransferEnabled(bool) := False(bool)\\\"];\\n}\\n// Function: 23.sol-Cloudbric-totalSupply()\\ndigraph{\\n}\\n// Function: 23.sol-Cloudbric-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transfer(to,value)\\n\\nIRs:\\nTMP_134(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(to,value)\\nRETURN TMP_134\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyWhenTransferAllowed()\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyWhenTransferAllowed()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyValidDestination(to)\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyValidDestination(address)(to)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyAllowedAmount(msg.sender,value)\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyAllowedAmount(address,uint256)(msg.sender,value)\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Cloudbric-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transferFrom(from,to,value)\\n\\nIRs:\\nTMP_138(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(from,to,value)\\nRETURN TMP_138\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyWhenTransferAllowed()\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyWhenTransferAllowed()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyValidDestination(to)\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyValidDestination(address)(to)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyAllowedAmount(from,value)\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyAllowedAmount(address,uint256)(from,value)\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Cloudbric-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_83 = CONVERT 0 to address\\nTMP_84(bool) = newOwner != TMP_83\\nTMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Cloudbric-unlockAccount(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nlockedAccounts[addr] = 0\\n\\nIRs:\\nREF_112(uint256) -> lockedAccounts[addr]\\nREF_112(uint256) (->lockedAccounts) := 0(uint256)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyValidDestination(addr)\\n\\nIRs:\\nMODIFIER_CALL, Cloudbric.onlyValidDestination(address)(addr)\\\"];\\n3->1;\\n}\\n// Function: 23.sol-CloudbricSale-CloudbricSale(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(fundAddress != address(0))\\n\\nIRs:\\nTMP_195 = CONVERT 0 to address\\nTMP_196(bool) = fundAddress != TMP_195\\nTMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(tokenAddress != address(0))\\n\\nIRs:\\nTMP_198 = CONVERT 0 to address\\nTMP_199(bool) = tokenAddress != TMP_198\\nTMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntoken = Cloudbric(tokenAddress)\\n\\nIRs:\\nTMP_201 = CONVERT tokenAddress to Cloudbric\\ntoken(Cloudbric) := TMP_201(Cloudbric)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nfundAddr = fundAddress\\n\\nIRs:\\nfundAddr(address) := fundAddress(address)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nstage = Stages.Ended\\n\\nIRs:\\nREF_116(CloudbricSale.Stages) -> Stages.Ended\\nstage(CloudbricSale.Stages) := REF_116(CloudbricSale.Stages)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nround = SaleRounds.EarlyInvestment\\n\\nIRs:\\nREF_117(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment\\nround(CloudbricSale.SaleRounds) := REF_117(CloudbricSale.SaleRounds)\\\"];\\n6->7;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\nroundIndex = uint8(round)\\n\\nIRs:\\nTMP_202 = CONVERT round to uint8\\nroundIndex(uint8) := TMP_202(uint8)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nroundInfos[roundIndex].minContribution = BASE_MIN_CONTRIBUTION\\n\\nIRs:\\nREF_118(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]\\nREF_119(uint256) -> REF_118.minContribution\\nREF_119(uint256) (->roundInfos) := BASE_MIN_CONTRIBUTION(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nroundInfos[roundIndex].maxContribution = UINT256_MAX\\n\\nIRs:\\nREF_120(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]\\nREF_121(uint256) -> REF_120.maxContribution\\nREF_121(uint256) (->roundInfos) := UINT256_MAX(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nroundInfos[roundIndex].hardCap = BASE_HARD_CAP_PER_ROUND\\n\\nIRs:\\nREF_122(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]\\nREF_123(uint256) -> REF_122.hardCap\\nREF_123(uint256) (->roundInfos) := BASE_HARD_CAP_PER_ROUND(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nroundInfos[roundIndex].weiRaised = 0\\n\\nIRs:\\nREF_124(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]\\nREF_125(uint256) -> REF_124.weiRaised\\nREF_125(uint256) (->roundInfos) := 0(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nroundInfos[roundIndex].rate = BASE_CLB_TO_ETH_RATE\\n\\nIRs:\\nREF_126(CloudbricSale.RoundInfo) -> roundInfos[roundIndex]\\nREF_127(uint256) -> REF_126.rate\\nREF_127(uint256) (->roundInfos) := BASE_CLB_TO_ETH_RATE(uint256)\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-addManyToAllocationList(address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->8;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(users.length == amounts.length)\\n\\nIRs:\\nREF_190 -> LENGTH users\\nREF_191 -> LENGTH amounts\\nTMP_285(bool) = REF_190 == REF_191\\nTMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)\\\"];\\n1->4;\\n2[label=\\\"Node Type: BEGIN_LOOP 2\\n\\\"];\\n2->5;\\n3[label=\\\"Node Type: END_LOOP 3\\n\\\"];\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint32) := 0(uint256)\\\"];\\n4->2;\\n5[label=\\\"Node Type: IF_LOOP 5\\n\\nEXPRESSION:\\ni < users.length\\n\\nIRs:\\nREF_192 -> LENGTH users\\nTMP_287(bool) = i < REF_192\\nCONDITION TMP_287\\\"];\\n5->6[label=\\\"True\\\"];\\n5->3[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\naddToAllocationList(users[i],amounts[i])\\n\\nIRs:\\nREF_193(address) -> users[i]\\nREF_194(uint256) -> amounts[i]\\nINTERNAL_CALL, CloudbricSale.addToAllocationList(address,uint256)(REF_193,REF_194)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_289(uint32) := i(uint32)\\ni(uint32) = i + 1\\\"];\\n7->5;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\natRound(SaleRounds.EarlyInvestment)\\n\\nIRs:\\nREF_195(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment\\nMODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_195)\\\"];\\n9->1;\\n}\\n// Function: 23.sol-CloudbricSale-addManyToWhitelist(address[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: BEGIN_LOOP 1\\n\\\"];\\n1->4;\\n2[label=\\\"Node Type: END_LOOP 2\\n\\\"];\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint32) := 0(uint256)\\\"];\\n3->1;\\n4[label=\\\"Node Type: IF_LOOP 4\\n\\nEXPRESSION:\\ni < users.length\\n\\nIRs:\\nREF_130 -> LENGTH users\\nTMP_206(bool) = i < REF_130\\nCONDITION TMP_206\\\"];\\n4->5[label=\\\"True\\\"];\\n4->2[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\naddToWhitelist(users[i])\\n\\nIRs:\\nREF_131(address) -> users[i]\\nINTERNAL_CALL, CloudbricSale.addToWhitelist(address)(REF_131)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_208(uint32) := i(uint32)\\ni(uint32) = i + 1\\\"];\\n6->4;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n7->3;\\n}\\n// Function: 23.sol-CloudbricSale-addToAllocationList(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallocationList[user].isAllowed = true\\n\\nIRs:\\nREF_185(CloudbricSale.AllocationInfo) -> allocationList[user]\\nREF_186(bool) -> REF_185.isAllowed\\nREF_186(bool) (->allocationList) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallocationList[user].allowedAmount = amount\\n\\nIRs:\\nREF_187(CloudbricSale.AllocationInfo) -> allocationList[user]\\nREF_188(uint256) -> REF_187.allowedAmount\\nREF_188(uint256) (->allocationList) := amount(uint256)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\natRound(SaleRounds.EarlyInvestment)\\n\\nIRs:\\nREF_189(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment\\nMODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_189)\\\"];\\n4->1;\\n}\\n// Function: 23.sol-CloudbricSale-addToWhitelist(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nwhitelist[user] = true\\n\\nIRs:\\nREF_132(bool) -> whitelist[user]\\nREF_132(bool) (->whitelist) := True(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 23.sol-CloudbricSale-allocateTokens(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(allocationList[to].isAllowed && tokenAmount <= allocationList[to].allowedAmount)\\n\\nIRs:\\nREF_202(CloudbricSale.AllocationInfo) -> allocationList[to]\\nREF_203(bool) -> REF_202.isAllowed\\nREF_204(CloudbricSale.AllocationInfo) -> allocationList[to]\\nREF_205(uint256) -> REF_204.allowedAmount\\nTMP_299(bool) = tokenAmount <= REF_205\\nTMP_300(bool) = REF_203 && TMP_299\\nTMP_301(None) = SOLIDITY_CALL require(bool)(TMP_300)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n! token.transferFrom(token.owner(),to,tokenAmount)\\n\\nIRs:\\nTMP_302(address) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:owner, arguments:[]  \\nTMP_303(bool) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:transferFrom, arguments:['TMP_302', 'to', 'tokenAmount']  \\nTMP_304 = UnaryType.BANG TMP_303 \\nCONDITION TMP_304\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_305(None) = SOLIDITY_CALL revert()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\natRound(SaleRounds.EarlyInvestment)\\n\\nIRs:\\nREF_208(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment\\nMODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_208)\\\"];\\n7->1;\\n}\\n// Function: 23.sol-CloudbricSale-allocateTokensToMany(address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(toList.length == tokenAmountList.length)\\n\\nIRs:\\nREF_209 -> LENGTH toList\\nREF_210 -> LENGTH tokenAmountList\\nTMP_308(bool) = REF_209 == REF_210\\nTMP_309(None) = SOLIDITY_CALL require(bool)(TMP_308)\\\"];\\n1->4;\\n2[label=\\\"Node Type: BEGIN_LOOP 2\\n\\\"];\\n2->5;\\n3[label=\\\"Node Type: END_LOOP 3\\n\\\"];\\n3->8;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint32) := 0(uint256)\\\"];\\n4->2;\\n5[label=\\\"Node Type: IF_LOOP 5\\n\\nEXPRESSION:\\ni < toList.length\\n\\nIRs:\\nREF_211 -> LENGTH toList\\nTMP_310(bool) = i < REF_211\\nCONDITION TMP_310\\\"];\\n5->6[label=\\\"True\\\"];\\n5->3[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallocateTokens(toList[i],tokenAmountList[i])\\n\\nIRs:\\nREF_212(address) -> toList[i]\\nREF_213(uint256) -> tokenAmountList[i]\\nTMP_311(bool) = INTERNAL_CALL, CloudbricSale.allocateTokens(address,uint256)(REF_212,REF_213)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_312(uint32) := i(uint32)\\ni(uint32) = i + 1\\\"];\\n7->5;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\natRound(SaleRounds.EarlyInvestment)\\n\\nIRs:\\nREF_214(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment\\nMODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_214)\\\"];\\n10->1;\\n}\\n// Function: 23.sol-CloudbricSale-atRound(CloudbricSale.SaleRounds)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(round == expectedRound)\\n\\nIRs:\\nTMP_326(bool) = round == expectedRound\\nTMP_327(None) = SOLIDITY_CALL require(bool)(TMP_326)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-atStage(CloudbricSale.Stages)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(stage == expectedStage)\\n\\nIRs:\\nTMP_324(bool) = stage == expectedStage\\nTMP_325(None) = SOLIDITY_CALL require(bool)(TMP_324)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-buy()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\npurchaser = msg.sender\\n\\nIRs:\\npurchaser(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ncontributionInWei = msg.value\\n\\nIRs:\\ncontributionInWei(uint256) := msg.value(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ntokenAmount = contributionInWei.mul(roundInfos[uint8(round)].rate)\\n\\nIRs:\\nTMP_265 = CONVERT round to uint8\\nREF_168(CloudbricSale.RoundInfo) -> roundInfos[TMP_265]\\nREF_169(uint256) -> REF_168.rate\\nTMP_266(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['contributionInWei', 'REF_169'] \\ntokenAmount(uint256) := TMP_266(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n! token.transferFrom(token.owner(),purchaser,tokenAmount)\\n\\nIRs:\\nTMP_267(address) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:owner, arguments:[]  \\nTMP_268(bool) = HIGH_LEVEL_CALL, dest:token(Cloudbric), function:transferFrom, arguments:['TMP_267', 'purchaser', 'tokenAmount']  \\nTMP_269 = UnaryType.BANG TMP_268 \\nCONDITION TMP_269\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_270(None) = SOLIDITY_CALL revert()()\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ntotalWeiRaised = totalWeiRaised.add(contributionInWei)\\n\\nIRs:\\nTMP_271(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalWeiRaised', 'contributionInWei'] \\ntotalWeiRaised(uint256) := TMP_271(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nroundInfos[uint8(round)].weiRaised = roundInfos[uint8(round)].weiRaised.add(contributionInWei)\\n\\nIRs:\\nTMP_272 = CONVERT round to uint8\\nREF_173(CloudbricSale.RoundInfo) -> roundInfos[TMP_272]\\nREF_174(uint256) -> REF_173.weiRaised\\nTMP_273 = CONVERT round to uint8\\nREF_175(CloudbricSale.RoundInfo) -> roundInfos[TMP_273]\\nREF_176(uint256) -> REF_175.weiRaised\\nTMP_274(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_176', 'contributionInWei'] \\nREF_174(uint256) (->roundInfos) := TMP_274(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ncontPerRound[purchaser][uint8(round)] = contPerRound[purchaser][uint8(round)].add(contributionInWei)\\n\\nIRs:\\nREF_178(mapping(uint8 => uint256)) -> contPerRound[purchaser]\\nTMP_275 = CONVERT round to uint8\\nREF_179(uint256) -> REF_178[TMP_275]\\nREF_180(mapping(uint8 => uint256)) -> contPerRound[purchaser]\\nTMP_276 = CONVERT round to uint8\\nREF_181(uint256) -> REF_180[TMP_276]\\nTMP_277(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_181', 'contributionInWei'] \\nREF_179(uint256) (->contPerRound) := TMP_277(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nfundAddr.transfer(contributionInWei)\\n\\nIRs:\\nTransfer dest:fundAddr value:contributionInWei\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nTokenPurchase(msg.sender,contributionInWei,tokenAmount)\\n\\nIRs:\\nEmit TokenPurchase(msg.sender,contributionInWei,tokenAmount)\\\"];\\n11->12;\\n12[label=\\\"Node Type: RETURN 12\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nwhenNotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenNotPaused()()\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\natStage(Stages.Started)\\n\\nIRs:\\nREF_184(CloudbricSale.Stages) -> Stages.Started\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_184)\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nonlyValidPurchase()\\n\\nIRs:\\nMODIFIER_CALL, CloudbricSale.onlyValidPurchase()()\\\"];\\n15->1;\\n}\\n// Function: 23.sol-CloudbricSale-endSale()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nendTime = now\\n\\nIRs:\\nendTime(uint256) := now(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstage = Stages.Ended\\n\\nIRs:\\nREF_165(CloudbricSale.Stages) -> Stages.Ended\\nstage(CloudbricSale.Stages) := REF_165(CloudbricSale.Stages)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nSaleEnded(endTime,totalWeiRaised,round)\\n\\nIRs:\\nEmit SaleEnded(endTime,totalWeiRaised,round)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\natStage(Stages.Started)\\n\\nIRs:\\nREF_166(CloudbricSale.Stages) -> Stages.Started\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_166)\\\"];\\n5->1;\\n}\\n// Function: 23.sol-CloudbricSale-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbuy()\\n\\nIRs:\\nTMP_203(bool) = INTERNAL_CALL, CloudbricSale.buy()()\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_322(bool) = msg.sender == owner\\nTMP_323(None) = SOLIDITY_CALL require(bool)(TMP_322)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-onlyValidPurchase()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(round <= SaleRounds.CrowdSale)\\n\\nIRs:\\nREF_215(CloudbricSale.SaleRounds) -> SaleRounds.CrowdSale\\nTMP_328(bool) = round <= REF_215\\nTMP_329(None) = SOLIDITY_CALL require(bool)(TMP_328)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(now >= startTime && now <= endTime)\\n\\nIRs:\\nTMP_330(bool) = now >= startTime\\nTMP_331(bool) = now <= endTime\\nTMP_332(bool) = TMP_330 && TMP_331\\nTMP_333(None) = SOLIDITY_CALL require(bool)(TMP_332)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ncontributionInWei = msg.value\\n\\nIRs:\\ncontributionInWei(uint256) := msg.value(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\npurchaser = msg.sender\\n\\nIRs:\\npurchaser(address) := msg.sender(address)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(whitelist[purchaser])\\n\\nIRs:\\nREF_216(bool) -> whitelist[purchaser]\\nTMP_334(None) = SOLIDITY_CALL require(bool)(REF_216)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrequire(bool)(purchaser != address(0))\\n\\nIRs:\\nTMP_335 = CONVERT 0 to address\\nTMP_336(bool) = purchaser != TMP_335\\nTMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrequire(bool)(contributionInWei >= roundInfos[uint8(round)].minContribution)\\n\\nIRs:\\nTMP_338 = CONVERT round to uint8\\nREF_217(CloudbricSale.RoundInfo) -> roundInfos[TMP_338]\\nREF_218(uint256) -> REF_217.minContribution\\nTMP_339(bool) = contributionInWei >= REF_218\\nTMP_340(None) = SOLIDITY_CALL require(bool)(TMP_339)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nrequire(bool)(contPerRound[purchaser][uint8(round)].add(contributionInWei) <= roundInfos[uint8(round)].maxContribution)\\n\\nIRs:\\nREF_219(mapping(uint8 => uint256)) -> contPerRound[purchaser]\\nTMP_341 = CONVERT round to uint8\\nREF_220(uint256) -> REF_219[TMP_341]\\nTMP_342(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_220', 'contributionInWei'] \\nTMP_343 = CONVERT round to uint8\\nREF_222(CloudbricSale.RoundInfo) -> roundInfos[TMP_343]\\nREF_223(uint256) -> REF_222.maxContribution\\nTMP_344(bool) = TMP_342 <= REF_223\\nTMP_345(None) = SOLIDITY_CALL require(bool)(TMP_344)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nrequire(bool)(roundInfos[uint8(round)].weiRaised.add(contributionInWei) <= roundInfos[uint8(round)].hardCap)\\n\\nIRs:\\nTMP_346 = CONVERT round to uint8\\nREF_224(CloudbricSale.RoundInfo) -> roundInfos[TMP_346]\\nREF_225(uint256) -> REF_224.weiRaised\\nTMP_347(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_225', 'contributionInWei'] \\nTMP_348 = CONVERT round to uint8\\nREF_227(CloudbricSale.RoundInfo) -> roundInfos[TMP_348]\\nREF_228(uint256) -> REF_227.hardCap\\nTMP_349(bool) = TMP_347 <= REF_228\\nTMP_350(None) = SOLIDITY_CALL require(bool)(TMP_349)\\\"];\\n9->10;\\n10[label=\\\"Node Type: _ 10\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-pause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = true\\n\\nIRs:\\npaused(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nPause()\\n\\nIRs:\\nEmit Pause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenNotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenNotPaused()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-CloudbricSale-removeFromAllocationList(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallocationList[user].isAllowed = false\\n\\nIRs:\\nREF_196(CloudbricSale.AllocationInfo) -> allocationList[user]\\nREF_197(bool) -> REF_196.isAllowed\\nREF_197(bool) (->allocationList) := False(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\natRound(SaleRounds.EarlyInvestment)\\n\\nIRs:\\nREF_198(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment\\nMODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_198)\\\"];\\n3->1;\\n}\\n// Function: 23.sol-CloudbricSale-removeFromWhitelist(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nwhitelist[user] = false\\n\\nIRs:\\nREF_135(bool) -> whitelist[user]\\nREF_135(bool) (->whitelist) := False(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 23.sol-CloudbricSale-removeManyFromAllocationList(address[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: BEGIN_LOOP 1\\n\\\"];\\n1->4;\\n2[label=\\\"Node Type: END_LOOP 2\\n\\\"];\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint32) := 0(uint256)\\\"];\\n3->1;\\n4[label=\\\"Node Type: IF_LOOP 4\\n\\nEXPRESSION:\\ni < users.length\\n\\nIRs:\\nREF_199 -> LENGTH users\\nTMP_294(bool) = i < REF_199\\nCONDITION TMP_294\\\"];\\n4->5[label=\\\"True\\\"];\\n4->2[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nremoveFromAllocationList(users[i])\\n\\nIRs:\\nREF_200(address) -> users[i]\\nINTERNAL_CALL, CloudbricSale.removeFromAllocationList(address)(REF_200)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_296(uint32) := i(uint32)\\ni(uint32) = i + 1\\\"];\\n6->4;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\natRound(SaleRounds.EarlyInvestment)\\n\\nIRs:\\nREF_201(CloudbricSale.SaleRounds) -> SaleRounds.EarlyInvestment\\nMODIFIER_CALL, CloudbricSale.atRound(CloudbricSale.SaleRounds)(REF_201)\\\"];\\n8->3;\\n}\\n// Function: 23.sol-CloudbricSale-removeManyFromWhitelist(address[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: BEGIN_LOOP 1\\n\\\"];\\n1->4;\\n2[label=\\\"Node Type: END_LOOP 2\\n\\\"];\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint32) := 0(uint256)\\\"];\\n3->1;\\n4[label=\\\"Node Type: IF_LOOP 4\\n\\nEXPRESSION:\\ni < users.length\\n\\nIRs:\\nREF_133 -> LENGTH users\\nTMP_211(bool) = i < REF_133\\nCONDITION TMP_211\\\"];\\n4->5[label=\\\"True\\\"];\\n4->2[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nremoveFromWhitelist(users[i])\\n\\nIRs:\\nREF_134(address) -> users[i]\\nINTERNAL_CALL, CloudbricSale.removeFromWhitelist(address)(REF_134)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_213(uint32) := i(uint32)\\ni(uint32) = i + 1\\\"];\\n6->4;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n7->3;\\n}\\n// Function: 23.sol-CloudbricSale-setHardCapForRound(CloudbricSale.SaleRounds,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(round <= _round)\\n\\nIRs:\\nTMP_230(bool) = round <= _round\\nTMP_231(None) = SOLIDITY_CALL require(bool)(TMP_230)\\\"];\\n1->5;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\natStage(Stages.SetUp)\\n\\nIRs:\\nREF_146(CloudbricSale.Stages) -> Stages.SetUp\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_146)\\\"];\\n4->1;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\n(_hardCap == 0)\\n\\nIRs:\\nTMP_234(bool) = _hardCap == 0\\nCONDITION TMP_234\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].hardCap = BASE_HARD_CAP_PER_ROUND\\n\\nIRs:\\nTMP_235 = CONVERT _round to uint8\\nREF_147(CloudbricSale.RoundInfo) -> roundInfos[TMP_235]\\nREF_148(uint256) -> REF_147.hardCap\\nREF_148(uint256) (->roundInfos) := BASE_HARD_CAP_PER_ROUND(uint256)\\\"];\\n6->8;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].hardCap = _hardCap\\n\\nIRs:\\nTMP_236 = CONVERT _round to uint8\\nREF_149(CloudbricSale.RoundInfo) -> roundInfos[TMP_236]\\nREF_150(uint256) -> REF_149.hardCap\\nREF_150(uint256) (->roundInfos) := _hardCap(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-setMaxContributionForRound(CloudbricSale.SaleRounds,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(round <= _round)\\n\\nIRs:\\nTMP_223(bool) = round <= _round\\nTMP_224(None) = SOLIDITY_CALL require(bool)(TMP_223)\\\"];\\n1->5;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\natStage(Stages.SetUp)\\n\\nIRs:\\nREF_141(CloudbricSale.Stages) -> Stages.SetUp\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_141)\\\"];\\n4->1;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\n(_maxContribution == 0)\\n\\nIRs:\\nTMP_227(bool) = _maxContribution == 0\\nCONDITION TMP_227\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].maxContribution = UINT256_MAX\\n\\nIRs:\\nTMP_228 = CONVERT _round to uint8\\nREF_142(CloudbricSale.RoundInfo) -> roundInfos[TMP_228]\\nREF_143(uint256) -> REF_142.maxContribution\\nREF_143(uint256) (->roundInfos) := UINT256_MAX(uint256)\\\"];\\n6->8;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].maxContribution = _maxContribution\\n\\nIRs:\\nTMP_229 = CONVERT _round to uint8\\nREF_144(CloudbricSale.RoundInfo) -> roundInfos[TMP_229]\\nREF_145(uint256) -> REF_144.maxContribution\\nREF_145(uint256) (->roundInfos) := _maxContribution(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-setMinContributionForRound(CloudbricSale.SaleRounds,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(round <= _round)\\n\\nIRs:\\nTMP_216(bool) = round <= _round\\nTMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)\\\"];\\n1->5;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\natStage(Stages.SetUp)\\n\\nIRs:\\nREF_136(CloudbricSale.Stages) -> Stages.SetUp\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_136)\\\"];\\n4->1;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\n(_minContribution == 0)\\n\\nIRs:\\nTMP_220(bool) = _minContribution == 0\\nCONDITION TMP_220\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].minContribution = BASE_MIN_CONTRIBUTION\\n\\nIRs:\\nTMP_221 = CONVERT _round to uint8\\nREF_137(CloudbricSale.RoundInfo) -> roundInfos[TMP_221]\\nREF_138(uint256) -> REF_137.minContribution\\nREF_138(uint256) (->roundInfos) := BASE_MIN_CONTRIBUTION(uint256)\\\"];\\n6->8;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].minContribution = _minContribution\\n\\nIRs:\\nTMP_222 = CONVERT _round to uint8\\nREF_139(CloudbricSale.RoundInfo) -> roundInfos[TMP_222]\\nREF_140(uint256) -> REF_139.minContribution\\nREF_140(uint256) (->roundInfos) := _minContribution(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-setRateForRound(CloudbricSale.SaleRounds,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(round <= _round)\\n\\nIRs:\\nTMP_237(bool) = round <= _round\\nTMP_238(None) = SOLIDITY_CALL require(bool)(TMP_237)\\\"];\\n1->5;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\natStage(Stages.SetUp)\\n\\nIRs:\\nREF_151(CloudbricSale.Stages) -> Stages.SetUp\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_151)\\\"];\\n4->1;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\n(_rate == 0)\\n\\nIRs:\\nTMP_241(bool) = _rate == 0\\nCONDITION TMP_241\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].rate = BASE_CLB_TO_ETH_RATE\\n\\nIRs:\\nTMP_242 = CONVERT _round to uint8\\nREF_152(CloudbricSale.RoundInfo) -> roundInfos[TMP_242]\\nREF_153(uint256) -> REF_152.rate\\nREF_153(uint256) (->roundInfos) := BASE_CLB_TO_ETH_RATE(uint256)\\\"];\\n6->8;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nroundInfos[uint8(_round)].rate = _rate\\n\\nIRs:\\nTMP_243 = CONVERT _round to uint8\\nREF_154(CloudbricSale.RoundInfo) -> roundInfos[TMP_243]\\nREF_155(uint256) -> REF_154.rate\\nREF_155(uint256) (->roundInfos) := _rate(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-setUpSale(CloudbricSale.SaleRounds,uint256,uint256,uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->8;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(round <= _round)\\n\\nIRs:\\nTMP_244(bool) = round <= _round\\nTMP_245(None) = SOLIDITY_CALL require(bool)(TMP_244)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstage = Stages.SetUp\\n\\nIRs:\\nREF_156(CloudbricSale.Stages) -> Stages.SetUp\\nstage(CloudbricSale.Stages) := REF_156(CloudbricSale.Stages)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nround = _round\\n\\nIRs:\\nround(CloudbricSale.SaleRounds) := _round(CloudbricSale.SaleRounds)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetMinContributionForRound(_round,_minContribution)\\n\\nIRs:\\nINTERNAL_CALL, CloudbricSale.setMinContributionForRound(CloudbricSale.SaleRounds,uint256)(_round,_minContribution)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nsetMaxContributionForRound(_round,_maxContribution)\\n\\nIRs:\\nINTERNAL_CALL, CloudbricSale.setMaxContributionForRound(CloudbricSale.SaleRounds,uint256)(_round,_maxContribution)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nsetHardCapForRound(_round,_hardCap)\\n\\nIRs:\\nINTERNAL_CALL, CloudbricSale.setHardCapForRound(CloudbricSale.SaleRounds,uint256)(_round,_hardCap)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nsetRateForRound(_round,_rate)\\n\\nIRs:\\nINTERNAL_CALL, CloudbricSale.setRateForRound(CloudbricSale.SaleRounds,uint256)(_round,_rate)\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\natStage(Stages.Ended)\\n\\nIRs:\\nREF_157(CloudbricSale.Stages) -> Stages.Ended\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_157)\\\"];\\n9->1;\\n}\\n// Function: 23.sol-CloudbricSale-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nBASE_HARD_CAP_PER_ROUND = 20000 * 1000000000000000000\\n\\nIRs:\\nTMP_315(uint256) = 20000 * 1000000000000000000\\nBASE_HARD_CAP_PER_ROUND(uint256) := TMP_315(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nUINT256_MAX = ~ uint256(0)\\n\\nIRs:\\nTMP_316 = CONVERT 0 to uint256\\nTMP_317 = UnaryType.TILD TMP_316 \\nUINT256_MAX(uint256) := TMP_317(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nBASE_CLB_TO_ETH_RATE = 10000\\n\\nIRs:\\nBASE_CLB_TO_ETH_RATE(uint256) := 10000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nBASE_MIN_CONTRIBUTION = 0.1 * 1000000000000000000\\n\\nIRs:\\nTMP_318(uint256) = 0 * 1000000000000000000\\nBASE_MIN_CONTRIBUTION(uint256) := TMP_318(uint256)\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-startSale(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(roundInfos[uint8(round)].minContribution > 0 && roundInfos[uint8(round)].hardCap > 0)\\n\\nIRs:\\nTMP_252 = CONVERT round to uint8\\nREF_158(CloudbricSale.RoundInfo) -> roundInfos[TMP_252]\\nREF_159(uint256) -> REF_158.minContribution\\nTMP_253(bool) = REF_159 > 0\\nTMP_254 = CONVERT round to uint8\\nREF_160(CloudbricSale.RoundInfo) -> roundInfos[TMP_254]\\nREF_161(uint256) -> REF_160.hardCap\\nTMP_255(bool) = REF_161 > 0\\nTMP_256(bool) = TMP_253 && TMP_255\\nTMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstage = Stages.Started\\n\\nIRs:\\nREF_162(CloudbricSale.Stages) -> Stages.Started\\nstage(CloudbricSale.Stages) := REF_162(CloudbricSale.Stages)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nstartTime = now\\n\\nIRs:\\nstartTime(uint256) := now(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nendTime = startTime.add(durationInSeconds)\\n\\nIRs:\\nTMP_258(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['startTime', 'durationInSeconds'] \\nendTime(uint256) := TMP_258(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nSaleStarted(startTime,endTime,round)\\n\\nIRs:\\nEmit SaleStarted(startTime,endTime,round)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\natStage(Stages.SetUp)\\n\\nIRs:\\nREF_164(CloudbricSale.Stages) -> Stages.SetUp\\nMODIFIER_CALL, CloudbricSale.atStage(CloudbricSale.Stages)(REF_164)\\\"];\\n7->1;\\n}\\n// Function: 23.sol-CloudbricSale-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_190 = CONVERT 0 to address\\nTMP_191(bool) = newOwner != TMP_190\\nTMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-CloudbricSale-unpause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nUnpause()\\n\\nIRs:\\nEmit Unpause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenPaused()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-CloudbricSale-whenNotPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! paused)\\n\\nIRs:\\nTMP_319 = UnaryType.BANG paused \\nTMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-whenPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(paused)\\n\\nIRs:\\nTMP_321(None) = SOLIDITY_CALL require(bool)(paused)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-CloudbricSale-withdraw()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nfundAddr.transfer(this.balance)\\n\\nIRs:\\nREF_129(uint256) = SOLIDITY_CALL balance(address)(this)\\nTransfer dest:fundAddr value:REF_129\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 23.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 23.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 23.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 23.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 23.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 23.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 23.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 23.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 23.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 23.sol-Ownable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 23.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_5(bool) = msg.sender == owner\\nTMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_0 = CONVERT 0 to address\\nTMP_1(bool) = newOwner != TMP_0\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Pausable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 23.sol-Pausable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_18(bool) = msg.sender == owner\\nTMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Pausable-pause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = true\\n\\nIRs:\\npaused(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nPause()\\n\\nIRs:\\nEmit Pause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenNotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenNotPaused()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Pausable-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n}\\n// Function: 23.sol-Pausable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_7 = CONVERT 0 to address\\nTMP_8(bool) = newOwner != TMP_7\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Pausable-unpause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nUnpause()\\n\\nIRs:\\nEmit Unpause()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nwhenPaused()\\n\\nIRs:\\nMODIFIER_CALL, Pausable.whenPaused()()\\\"];\\n4->1;\\n}\\n// Function: 23.sol-Pausable-whenNotPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! paused)\\n\\nIRs:\\nTMP_20 = UnaryType.BANG paused \\nTMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-Pausable-whenPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(paused)\\n\\nIRs:\\nTMP_22(None) = SOLIDITY_CALL require(bool)(paused)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 23.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_32(uint256) = a + b\\nc(uint256) := TMP_32(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_33(bool) = c >= a\\nTMP_34(None) = SOLIDITY_CALL assert(bool)(TMP_33)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 23.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_28(uint256) = a / b\\nc(uint256) := TMP_28(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 23.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_23(bool) = a == 0\\nCONDITION TMP_23\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_24(uint256) = a * b\\nc(uint256) := TMP_24(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_25(uint256) = c / a\\nTMP_26(bool) = TMP_25 == b\\nTMP_27(None) = SOLIDITY_CALL assert(bool)(TMP_26)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 23.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_29(bool) = b <= a\\nTMP_30(None) = SOLIDITY_CALL assert(bool)(TMP_29)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_31(uint256) = a - b\\nRETURN TMP_31\\\"];\\n}\\n// Function: 23.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowed[_owner]\\nREF_46(uint256) -> REF_45[_spender]\\nRETURN REF_46\\\"];\\n}\\n// Function: 23.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_43(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_44(uint256) -> REF_43[_spender]\\nREF_44(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 23.sol-StandardToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 23.sol-StandardToken-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_54(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_55(uint256) -> REF_54[_spender]\\noldValue(uint256) := REF_55(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_80(bool) = _subtractedValue > oldValue\\nCONDITION TMP_80\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_56(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_57(uint256) -> REF_56[_spender]\\nREF_57(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_58(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_59(uint256) -> REF_58[_spender]\\nTMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_59(uint256) (->allowed) := TMP_81(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_61(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_62(uint256) -> REF_61[_spender]\\nEmit Approval(msg.sender,_spender,REF_62)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 23.sol-StandardToken-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_47(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_48(uint256) -> REF_47[_spender]\\nREF_49(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_50(uint256) -> REF_49[_spender]\\nTMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_50', '_addedValue'] \\nREF_48(uint256) (->allowed) := TMP_78(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_52(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_53(uint256) -> REF_52[_spender]\\nEmit Approval(msg.sender,_spender,REF_53)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 23.sol-StandardToken-totalSupply()\\ndigraph{\\n}\\n// Function: 23.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 23.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_66 = CONVERT 0 to address\\nTMP_67(bool) = _to != TMP_66\\nTMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_from])\\n\\nIRs:\\nREF_29(uint256) -> balances[_from]\\nTMP_69(bool) = _value <= REF_29\\nTMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_30(mapping(address => uint256)) -> allowed[_from]\\nREF_31(uint256) -> REF_30[msg.sender]\\nTMP_71(bool) = _value <= REF_31\\nTMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_32(uint256) -> balances[_from]\\nREF_33(uint256) -> balances[_from]\\nTMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_33', '_value'] \\nREF_32(uint256) (->balances) := TMP_73(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_35(uint256) -> balances[_to]\\nREF_36(uint256) -> balances[_to]\\nTMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_36', '_value'] \\nREF_35(uint256) (->balances) := TMP_74(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)\\n\\nIRs:\\nREF_38(mapping(address => uint256)) -> allowed[_from]\\nREF_39(uint256) -> REF_38[msg.sender]\\nREF_40(mapping(address => uint256)) -> allowed[_from]\\nREF_41(uint256) -> REF_40[msg.sender]\\nTMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_41', '_value'] \\nREF_39(uint256) (->allowed) := TMP_75(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 27.sol-ROSCtoken-ROSCtoken(uint256,string,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nTokenERC20(initialSupply,tokenName,tokenSymbol)\\n\\nIRs:\\nINTERNAL_CALL, TokenERC20.TokenERC20(uint256,string,string)(initialSupply,tokenName,tokenSymbol)\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-TokenERC20(uint256,string,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = initialSupply * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_33 = CONVERT decimals to uint256\\nTMP_34(uint256) = 10 ** TMP_33\\nTMP_35(uint256) = initialSupply * TMP_34\\ntotalSupply(uint256) := TMP_35(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = totalSupply\\n\\nIRs:\\nREF_25(uint256) -> balanceOf[msg.sender]\\nREF_25(uint256) (->balanceOf) := totalSupply(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = tokenName\\n\\nIRs:\\nname(string) := tokenName(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsymbol = tokenSymbol\\n\\nIRs:\\nsymbol(string) := tokenSymbol(string)\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-_transfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_65(bool) = _to != 0\\nTMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_50(uint256) -> balanceOf[_from]\\nTMP_67(bool) = REF_50 >= _value\\nTMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_to] + _value > balanceOf[_to])\\n\\nIRs:\\nREF_51(uint256) -> balanceOf[_to]\\nTMP_69(uint256) = REF_51 + _value\\nREF_52(uint256) -> balanceOf[_to]\\nTMP_70(bool) = TMP_69 > REF_52\\nTMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[_from])\\n\\nIRs:\\nREF_53(bool) -> frozenAccount[_from]\\nTMP_72 = UnaryType.BANG REF_53 \\nTMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[_to])\\n\\nIRs:\\nREF_54(bool) -> frozenAccount[_to]\\nTMP_74 = UnaryType.BANG REF_54 \\nTMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_55(uint256) -> balanceOf[_from]\\nREF_55(-> balanceOf) = REF_55 - _value\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalanceOf[_to] += _value\\n\\nIRs:\\nREF_56(uint256) -> balanceOf[_to]\\nREF_56(-> balanceOf) = REF_56 + _value\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowance[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowance[msg.sender]\\nREF_40(uint256) -> REF_39[_spender]\\nREF_40(uint256) (->allowance) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nspender = tokenRecipient(_spender)\\n\\nIRs:\\nTMP_52 = CONVERT _spender to tokenRecipient\\nspender(tokenRecipient) := TMP_52(tokenRecipient)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\napprove(_spender,_value)\\n\\nIRs:\\nTMP_53(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)\\nCONDITION TMP_53\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nspender.receiveApproval(msg.sender,_value,this,_extraData)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[msg.sender] >= _value)\\n\\nIRs:\\nREF_42(uint256) -> balanceOf[msg.sender]\\nTMP_55(bool) = REF_42 >= _value\\nTMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] -= _value\\n\\nIRs:\\nREF_43(uint256) -> balanceOf[msg.sender]\\nREF_43(-> balanceOf) = REF_43 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-burnFrom(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_44(uint256) -> balanceOf[_from]\\nTMP_58(bool) = REF_44 >= _value\\nTMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowance[_from]\\nREF_46(uint256) -> REF_45[msg.sender]\\nTMP_60(bool) = _value <= REF_46\\nTMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_47(uint256) -> balanceOf[_from]\\nREF_47(-> balanceOf) = REF_47 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowance[_from]\\nREF_49(uint256) -> REF_48[msg.sender]\\nREF_49(-> allowance) = REF_49 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(_from,_value)\\n\\nIRs:\\nEmit Burn(_from,_value)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-buy()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\namount = msg.value / buyPrice\\n\\nIRs:\\nTMP_83(uint256) = msg.value / buyPrice\\namount(uint256) := TMP_83(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_transfer(this,msg.sender,amount)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(this,msg.sender,amount)\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-freezeAccount(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nfrozenAccount[target] = freeze\\n\\nIRs:\\nREF_58(bool) -> frozenAccount[target]\\nREF_58(bool) (->frozenAccount) := freeze(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nFrozenFunds(target,freeze)\\n\\nIRs:\\nEmit FrozenFunds(target,freeze)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 27.sol-ROSCtoken-mintToken(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalanceOf[target] += mintedAmount\\n\\nIRs:\\nREF_57(uint256) -> balanceOf[target]\\nREF_57(-> balanceOf) = REF_57 + mintedAmount\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply += mintedAmount\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply + mintedAmount\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(0,this,mintedAmount)\\n\\nIRs:\\nEmit Transfer(0,this,mintedAmount)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(this,target,mintedAmount)\\n\\nIRs:\\nEmit Transfer(this,target,mintedAmount)\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 27.sol-ROSCtoken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_91(bool) = msg.sender == owner\\nTMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-sell(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(this.balance >= amount * sellPrice)\\n\\nIRs:\\nREF_59(uint256) = SOLIDITY_CALL balance(address)(this)\\nTMP_85(uint256) = amount * sellPrice\\nTMP_86(bool) = REF_59 >= TMP_85\\nTMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_transfer(msg.sender,this,amount)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(msg.sender,this,amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nmsg.sender.transfer(amount * sellPrice)\\n\\nIRs:\\nTMP_89(uint256) = amount * sellPrice\\nTransfer dest:msg.sender value:TMP_89\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-setPrices(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nsellPrice = newSellPrice\\n\\nIRs:\\nsellPrice(uint256) := newSellPrice(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbuyPrice = newBuyPrice\\n\\nIRs:\\nbuyPrice(uint256) := newBuyPrice(uint256)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 27.sol-ROSCtoken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transfer(msg.sender,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(msg.sender,_to,_value)\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_35(mapping(address => uint256)) -> allowance[_from]\\nREF_36(uint256) -> REF_35[msg.sender]\\nTMP_49(bool) = _value <= REF_36\\nTMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_37(mapping(address => uint256)) -> allowance[_from]\\nREF_38(uint256) -> REF_37[msg.sender]\\nREF_38(-> allowance) = REF_38 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_transfer(_from,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(_from,_to,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-ROSCtoken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 27.sol-TokenERC20-TokenERC20(uint256,string,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = initialSupply * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_3 = CONVERT decimals to uint256\\nTMP_4(uint256) = 10 ** TMP_3\\nTMP_5(uint256) = initialSupply * TMP_4\\ntotalSupply(uint256) := TMP_5(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balanceOf[msg.sender]\\nREF_0(uint256) (->balanceOf) := totalSupply(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = tokenName\\n\\nIRs:\\nname(string) := tokenName(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsymbol = tokenSymbol\\n\\nIRs:\\nsymbol(string) := tokenSymbol(string)\\\"];\\n}\\n// Function: 27.sol-TokenERC20-_transfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_6(bool) = _to != 0\\nTMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_1(uint256) -> balanceOf[_from]\\nTMP_8(bool) = REF_1 >= _value\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_to] + _value > balanceOf[_to])\\n\\nIRs:\\nREF_2(uint256) -> balanceOf[_to]\\nTMP_10(uint256) = REF_2 + _value\\nREF_3(uint256) -> balanceOf[_to]\\nTMP_11(bool) = TMP_10 > REF_3\\nTMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\npreviousBalances = balanceOf[_from] + balanceOf[_to]\\n\\nIRs:\\nREF_4(uint256) -> balanceOf[_from]\\nREF_5(uint256) -> balanceOf[_to]\\nTMP_13(uint256) = REF_4 + REF_5\\npreviousBalances(uint256) := TMP_13(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_6(uint256) -> balanceOf[_from]\\nREF_6(-> balanceOf) = REF_6 - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[_to] += _value\\n\\nIRs:\\nREF_7(uint256) -> balanceOf[_to]\\nREF_7(-> balanceOf) = REF_7 + _value\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nassert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)\\n\\nIRs:\\nREF_8(uint256) -> balanceOf[_from]\\nREF_9(uint256) -> balanceOf[_to]\\nTMP_15(uint256) = REF_8 + REF_9\\nTMP_16(bool) = TMP_15 == previousBalances\\nTMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)\\\"];\\n}\\n// Function: 27.sol-TokenERC20-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowance[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_14(mapping(address => uint256)) -> allowance[msg.sender]\\nREF_15(uint256) -> REF_14[_spender]\\nREF_15(uint256) (->allowance) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-TokenERC20-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nspender = tokenRecipient(_spender)\\n\\nIRs:\\nTMP_22 = CONVERT _spender to tokenRecipient\\nspender(tokenRecipient) := TMP_22(tokenRecipient)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\napprove(_spender,_value)\\n\\nIRs:\\nTMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)\\nCONDITION TMP_23\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nspender.receiveApproval(msg.sender,_value,this,_extraData)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-TokenERC20-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[msg.sender] >= _value)\\n\\nIRs:\\nREF_17(uint256) -> balanceOf[msg.sender]\\nTMP_25(bool) = REF_17 >= _value\\nTMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] -= _value\\n\\nIRs:\\nREF_18(uint256) -> balanceOf[msg.sender]\\nREF_18(-> balanceOf) = REF_18 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-TokenERC20-burnFrom(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_19(uint256) -> balanceOf[_from]\\nTMP_28(bool) = REF_19 >= _value\\nTMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_20(mapping(address => uint256)) -> allowance[_from]\\nREF_21(uint256) -> REF_20[msg.sender]\\nTMP_30(bool) = _value <= REF_21\\nTMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_22(uint256) -> balanceOf[_from]\\nREF_22(-> balanceOf) = REF_22 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_23(mapping(address => uint256)) -> allowance[_from]\\nREF_24(uint256) -> REF_23[msg.sender]\\nREF_24(-> allowance) = REF_24 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(_from,_value)\\n\\nIRs:\\nEmit Burn(_from,_value)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-TokenERC20-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n}\\n// Function: 27.sol-TokenERC20-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transfer(msg.sender,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, TokenERC20._transfer(address,address,uint256)(msg.sender,_to,_value)\\\"];\\n}\\n// Function: 27.sol-TokenERC20-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowance[_from]\\nREF_11(uint256) -> REF_10[msg.sender]\\nTMP_19(bool) = _value <= REF_11\\nTMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_12(mapping(address => uint256)) -> allowance[_from]\\nREF_13(uint256) -> REF_12[msg.sender]\\nREF_13(-> allowance) = REF_13 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_transfer(_from,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, TokenERC20._transfer(address,address,uint256)(_from,_to,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 27.sol-owned-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_1(bool) = msg.sender == owner\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 27.sol-owned-owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 27.sol-owned-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 27.sol-tokenRecipient-receiveApproval(address,uint256,address,bytes)\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 28.sol-MyShareToken-MyShareToken()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nTokenSBT()\\n\\nIRs:\\nINTERNAL_CALL, TokenSBT.TokenSBT()()\\\"];\\n}\\n// Function: 28.sol-MyShareToken-TokenSBT()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndecimals = 8\\n\\nIRs:\\ndecimals(uint8) := 8(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply = 10000000000 * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_33 = CONVERT decimals to uint256\\nTMP_34(uint256) = 10 ** TMP_33\\nTMP_35(uint256) = 10000000000 * TMP_34\\ntotalSupply(uint256) := TMP_35(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = totalSupply\\n\\nIRs:\\nREF_25(uint256) -> balanceOf[msg.sender]\\nREF_25(uint256) (->balanceOf) := totalSupply(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nname = Sobit Token\\n\\nIRs:\\nname(string) := Sobit Token(string)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nsymbol = SBT\\n\\nIRs:\\nsymbol(string) := SBT(string)\\\"];\\n}\\n// Function: 28.sol-MyShareToken-_transfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_65(bool) = _to != 0\\nTMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_50(uint256) -> balanceOf[_from]\\nTMP_67(bool) = REF_50 >= _value\\nTMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_to] + _value > balanceOf[_to])\\n\\nIRs:\\nREF_51(uint256) -> balanceOf[_to]\\nTMP_69(uint256) = REF_51 + _value\\nREF_52(uint256) -> balanceOf[_to]\\nTMP_70(bool) = TMP_69 > REF_52\\nTMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[_from])\\n\\nIRs:\\nREF_53(bool) -> frozenAccount[_from]\\nTMP_72 = UnaryType.BANG REF_53 \\nTMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[_to])\\n\\nIRs:\\nREF_54(bool) -> frozenAccount[_to]\\nTMP_74 = UnaryType.BANG REF_54 \\nTMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_55(uint256) -> balanceOf[_from]\\nREF_55(-> balanceOf) = REF_55 - _value\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalanceOf[_to] += _value\\n\\nIRs:\\nREF_56(uint256) -> balanceOf[_to]\\nREF_56(-> balanceOf) = REF_56 + _value\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n}\\n// Function: 28.sol-MyShareToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowance[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowance[msg.sender]\\nREF_40(uint256) -> REF_39[_spender]\\nREF_40(uint256) (->allowance) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-MyShareToken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nspender = tokenRecipient(_spender)\\n\\nIRs:\\nTMP_52 = CONVERT _spender to tokenRecipient\\nspender(tokenRecipient) := TMP_52(tokenRecipient)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\napprove(_spender,_value)\\n\\nIRs:\\nTMP_53(bool) = INTERNAL_CALL, TokenSBT.approve(address,uint256)(_spender,_value)\\nCONDITION TMP_53\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nspender.receiveApproval(msg.sender,_value,this,_extraData)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-MyShareToken-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[msg.sender] >= _value)\\n\\nIRs:\\nREF_42(uint256) -> balanceOf[msg.sender]\\nTMP_55(bool) = REF_42 >= _value\\nTMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] -= _value\\n\\nIRs:\\nREF_43(uint256) -> balanceOf[msg.sender]\\nREF_43(-> balanceOf) = REF_43 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-MyShareToken-burnFrom(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_44(uint256) -> balanceOf[_from]\\nTMP_58(bool) = REF_44 >= _value\\nTMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowance[_from]\\nREF_46(uint256) -> REF_45[msg.sender]\\nTMP_60(bool) = _value <= REF_46\\nTMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_47(uint256) -> balanceOf[_from]\\nREF_47(-> balanceOf) = REF_47 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowance[_from]\\nREF_49(uint256) -> REF_48[msg.sender]\\nREF_49(-> allowance) = REF_49 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(_from,_value)\\n\\nIRs:\\nEmit Burn(_from,_value)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-MyShareToken-buy()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\namount = msg.value / buyPrice\\n\\nIRs:\\nTMP_83(uint256) = msg.value / buyPrice\\namount(uint256) := TMP_83(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_transfer(this,msg.sender,amount)\\n\\nIRs:\\nINTERNAL_CALL, MyShareToken._transfer(address,address,uint256)(this,msg.sender,amount)\\\"];\\n}\\n// Function: 28.sol-MyShareToken-freezeAccount(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nfrozenAccount[target] = freeze\\n\\nIRs:\\nREF_58(bool) -> frozenAccount[target]\\nREF_58(bool) (->frozenAccount) := freeze(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nFrozenFunds(target,freeze)\\n\\nIRs:\\nEmit FrozenFunds(target,freeze)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 28.sol-MyShareToken-mintToken(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalanceOf[target] += mintedAmount\\n\\nIRs:\\nREF_57(uint256) -> balanceOf[target]\\nREF_57(-> balanceOf) = REF_57 + mintedAmount\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply += mintedAmount\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply + mintedAmount\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(0,this,mintedAmount)\\n\\nIRs:\\nEmit Transfer(0,this,mintedAmount)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(this,target,mintedAmount)\\n\\nIRs:\\nEmit Transfer(this,target,mintedAmount)\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 28.sol-MyShareToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_91(bool) = msg.sender == owner\\nTMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 28.sol-MyShareToken-owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 28.sol-MyShareToken-sell(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(this.balance >= amount * sellPrice)\\n\\nIRs:\\nREF_59(uint256) = SOLIDITY_CALL balance(address)(this)\\nTMP_85(uint256) = amount * sellPrice\\nTMP_86(bool) = REF_59 >= TMP_85\\nTMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_transfer(msg.sender,this,amount)\\n\\nIRs:\\nINTERNAL_CALL, MyShareToken._transfer(address,address,uint256)(msg.sender,this,amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nmsg.sender.transfer(amount * sellPrice)\\n\\nIRs:\\nTMP_89(uint256) = amount * sellPrice\\nTransfer dest:msg.sender value:TMP_89\\\"];\\n}\\n// Function: 28.sol-MyShareToken-setPrices(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nsellPrice = newSellPrice\\n\\nIRs:\\nsellPrice(uint256) := newSellPrice(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbuyPrice = newBuyPrice\\n\\nIRs:\\nbuyPrice(uint256) := newBuyPrice(uint256)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 28.sol-MyShareToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transfer(msg.sender,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, MyShareToken._transfer(address,address,uint256)(msg.sender,_to,_value)\\\"];\\n}\\n// Function: 28.sol-MyShareToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_35(mapping(address => uint256)) -> allowance[_from]\\nREF_36(uint256) -> REF_35[msg.sender]\\nTMP_49(bool) = _value <= REF_36\\nTMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_37(mapping(address => uint256)) -> allowance[_from]\\nREF_38(uint256) -> REF_37[msg.sender]\\nREF_38(-> allowance) = REF_38 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_transfer(_from,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, MyShareToken._transfer(address,address,uint256)(_from,_to,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-MyShareToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 28.sol-TokenSBT-TokenSBT()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndecimals = 8\\n\\nIRs:\\ndecimals(uint8) := 8(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply = 10000000000 * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_3 = CONVERT decimals to uint256\\nTMP_4(uint256) = 10 ** TMP_3\\nTMP_5(uint256) = 10000000000 * TMP_4\\ntotalSupply(uint256) := TMP_5(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balanceOf[msg.sender]\\nREF_0(uint256) (->balanceOf) := totalSupply(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nname = Sobit Token\\n\\nIRs:\\nname(string) := Sobit Token(string)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nsymbol = SBT\\n\\nIRs:\\nsymbol(string) := SBT(string)\\\"];\\n}\\n// Function: 28.sol-TokenSBT-_transfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_6(bool) = _to != 0\\nTMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_1(uint256) -> balanceOf[_from]\\nTMP_8(bool) = REF_1 >= _value\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_to] + _value > balanceOf[_to])\\n\\nIRs:\\nREF_2(uint256) -> balanceOf[_to]\\nTMP_10(uint256) = REF_2 + _value\\nREF_3(uint256) -> balanceOf[_to]\\nTMP_11(bool) = TMP_10 > REF_3\\nTMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\npreviousBalances = balanceOf[_from] + balanceOf[_to]\\n\\nIRs:\\nREF_4(uint256) -> balanceOf[_from]\\nREF_5(uint256) -> balanceOf[_to]\\nTMP_13(uint256) = REF_4 + REF_5\\npreviousBalances(uint256) := TMP_13(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_6(uint256) -> balanceOf[_from]\\nREF_6(-> balanceOf) = REF_6 - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[_to] += _value\\n\\nIRs:\\nREF_7(uint256) -> balanceOf[_to]\\nREF_7(-> balanceOf) = REF_7 + _value\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nassert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)\\n\\nIRs:\\nREF_8(uint256) -> balanceOf[_from]\\nREF_9(uint256) -> balanceOf[_to]\\nTMP_15(uint256) = REF_8 + REF_9\\nTMP_16(bool) = TMP_15 == previousBalances\\nTMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)\\\"];\\n}\\n// Function: 28.sol-TokenSBT-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowance[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_14(mapping(address => uint256)) -> allowance[msg.sender]\\nREF_15(uint256) -> REF_14[_spender]\\nREF_15(uint256) (->allowance) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-TokenSBT-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nspender = tokenRecipient(_spender)\\n\\nIRs:\\nTMP_22 = CONVERT _spender to tokenRecipient\\nspender(tokenRecipient) := TMP_22(tokenRecipient)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\napprove(_spender,_value)\\n\\nIRs:\\nTMP_23(bool) = INTERNAL_CALL, TokenSBT.approve(address,uint256)(_spender,_value)\\nCONDITION TMP_23\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nspender.receiveApproval(msg.sender,_value,this,_extraData)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-TokenSBT-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[msg.sender] >= _value)\\n\\nIRs:\\nREF_17(uint256) -> balanceOf[msg.sender]\\nTMP_25(bool) = REF_17 >= _value\\nTMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] -= _value\\n\\nIRs:\\nREF_18(uint256) -> balanceOf[msg.sender]\\nREF_18(-> balanceOf) = REF_18 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-TokenSBT-burnFrom(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_19(uint256) -> balanceOf[_from]\\nTMP_28(bool) = REF_19 >= _value\\nTMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_20(mapping(address => uint256)) -> allowance[_from]\\nREF_21(uint256) -> REF_20[msg.sender]\\nTMP_30(bool) = _value <= REF_21\\nTMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_22(uint256) -> balanceOf[_from]\\nREF_22(-> balanceOf) = REF_22 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_23(mapping(address => uint256)) -> allowance[_from]\\nREF_24(uint256) -> REF_23[msg.sender]\\nREF_24(-> allowance) = REF_24 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(_from,_value)\\n\\nIRs:\\nEmit Burn(_from,_value)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-TokenSBT-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transfer(msg.sender,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, TokenSBT._transfer(address,address,uint256)(msg.sender,_to,_value)\\\"];\\n}\\n// Function: 28.sol-TokenSBT-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowance[_from]\\nREF_11(uint256) -> REF_10[msg.sender]\\nTMP_19(bool) = _value <= REF_11\\nTMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_12(mapping(address => uint256)) -> allowance[_from]\\nREF_13(uint256) -> REF_12[msg.sender]\\nREF_13(-> allowance) = REF_13 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_transfer(_from,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, TokenSBT._transfer(address,address,uint256)(_from,_to,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 28.sol-owned-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_1(bool) = msg.sender == owner\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 28.sol-owned-owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 28.sol-owned-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 28.sol-tokenRecipient-receiveApproval(address,uint256,address,bytes)\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 30.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)\\ndigraph{\\n}\\n// Function: 30.sol-Bitdepositary-Bitdepositary()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nsymbol = BDT\\n\\nIRs:\\nsymbol(string) := BDT(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = Bitdepositary\\n\\nIRs:\\nname(string) := Bitdepositary(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbonusEnds = now + 907200000\\n\\nIRs:\\nTMP_42(uint256) = now + 907200000\\nbonusEnds(uint256) := TMP_42(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nendDate = now + 4536000000\\n\\nIRs:\\nTMP_43(uint256) = now + 4536000000\\nendDate(uint256) := TMP_43(uint256)\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-Owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-acceptOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == newOwner)\\n\\nIRs:\\nTMP_38(bool) = msg.sender == newOwner\\nTMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewOwner = address(0)\\n\\nIRs:\\nTMP_41 = CONVERT 0 to address\\nnewOwner(address) := TMP_41(address)\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[tokenOwner][spender]\\n\\nIRs:\\nREF_16(mapping(address => uint256)) -> allowed[tokenOwner]\\nREF_17(uint256) -> REF_16[spender]\\nRETURN REF_17\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][spender] = tokens\\n\\nIRs:\\nREF_6(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_7(uint256) -> REF_6[spender]\\nREF_7(uint256) (->allowed) := tokens(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,spender,tokens)\\n\\nIRs:\\nEmit Approval(msg.sender,spender,tokens)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][spender] = tokens\\n\\nIRs:\\nREF_18(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_19(uint256) -> REF_18[spender]\\nREF_19(uint256) (->allowed) := tokens(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,spender,tokens)\\n\\nIRs:\\nEmit Approval(msg.sender,spender,tokens)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)\\n\\nIRs:\\nTMP_55 = CONVERT spender to ApproveAndCallFallBack\\nHIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[tokenOwner]\\n\\nIRs:\\nREF_1(uint256) -> balances[tokenOwner]\\nRETURN REF_1\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(now >= startDate && now <= endDate)\\n\\nIRs:\\nTMP_57(bool) = now >= startDate\\nTMP_58(bool) = now <= endDate\\nTMP_59(bool) = TMP_57 && TMP_58\\nTMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nnow <= bonusEnds\\n\\nIRs:\\nTMP_61(bool) = now <= bonusEnds\\nCONDITION TMP_61\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntokens = msg.value * 500000001\\n\\nIRs:\\nTMP_62(uint256) = msg.value * 500000001\\ntokens(uint256) := TMP_62(uint256)\\\"];\\n4->6;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntokens = msg.value * 14000000000000000000000\\n\\nIRs:\\nTMP_63(uint256) = msg.value * 14000000000000000000000\\ntokens(uint256) := TMP_63(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalances[msg.sender] = safeAdd(balances[msg.sender],tokens)\\n\\nIRs:\\nREF_21(uint256) -> balances[msg.sender]\\nREF_22(uint256) -> balances[msg.sender]\\nTMP_64(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_22,tokens)\\nREF_21(uint256) (->balances) := TMP_64(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\n_totalSupply = safeAdd(_totalSupply,tokens)\\n\\nIRs:\\nTMP_65(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(_totalSupply,tokens)\\n_totalSupply(uint256) := TMP_65(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nTransfer(address(0),msg.sender,tokens)\\n\\nIRs:\\nTMP_66 = CONVERT 0 to address\\nEmit Transfer(TMP_66,msg.sender,tokens)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nowner.transfer(msg.value)\\n\\nIRs:\\nTransfer dest:owner value:msg.value\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_72(bool) = msg.sender == owner\\nTMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_22(uint256) = a + b\\nc(uint256) := TMP_22(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(c >= a)\\n\\nIRs:\\nTMP_23(bool) = c >= a\\nTMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b > 0)\\n\\nIRs:\\nTMP_34(bool) = b > 0\\nTMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_36(uint256) = a / b\\nc(uint256) := TMP_36(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_28(uint256) = a * b\\nc(uint256) := TMP_28(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_29(bool) = a == 0\\nTMP_30(uint256) = c / a\\nTMP_31(bool) = TMP_30 == b\\nTMP_32(bool) = TMP_29 || TMP_31\\nTMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b <= a)\\n\\nIRs:\\nTMP_25(bool) = b <= a\\nTMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a - b\\n\\nIRs:\\nTMP_27(uint256) = a - b\\nc(uint256) := TMP_27(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n_totalSupply - balances[address(0)]\\n\\nIRs:\\nTMP_44 = CONVERT 0 to address\\nREF_0(uint256) -> balances[TMP_44]\\nTMP_45(uint256) = _totalSupply - REF_0\\nRETURN TMP_45\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[msg.sender] = safeSub(balances[msg.sender],tokens)\\n\\nIRs:\\nREF_2(uint256) -> balances[msg.sender]\\nREF_3(uint256) -> balances[msg.sender]\\nTMP_46(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_3,tokens)\\nREF_2(uint256) (->balances) := TMP_46(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[to] = safeAdd(balances[to],tokens)\\n\\nIRs:\\nREF_4(uint256) -> balances[to]\\nREF_5(uint256) -> balances[to]\\nTMP_47(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_5,tokens)\\nREF_4(uint256) (->balances) := TMP_47(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(msg.sender,to,tokens)\\n\\nIRs:\\nEmit Transfer(msg.sender,to,tokens)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-transferAnyERC20Token(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nERC20Interface(tokenAddress).transfer(owner,tokens)\\n\\nIRs:\\nTMP_69 = CONVERT tokenAddress to ERC20Interface\\nTMP_70(bool) = HIGH_LEVEL_CALL, dest:TMP_69(ERC20Interface), function:transfer, arguments:['owner', 'tokens']  \\nRETURN TMP_70\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[from] = safeSub(balances[from],tokens)\\n\\nIRs:\\nREF_8(uint256) -> balances[from]\\nREF_9(uint256) -> balances[from]\\nTMP_50(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_9,tokens)\\nREF_8(uint256) (->balances) := TMP_50(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowed[from][msg.sender] = safeSub(allowed[from][msg.sender],tokens)\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowed[from]\\nREF_11(uint256) -> REF_10[msg.sender]\\nREF_12(mapping(address => uint256)) -> allowed[from]\\nREF_13(uint256) -> REF_12[msg.sender]\\nTMP_51(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_13,tokens)\\nREF_11(uint256) (->allowed) := TMP_51(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[to] = safeAdd(balances[to],tokens)\\n\\nIRs:\\nREF_14(uint256) -> balances[to]\\nREF_15(uint256) -> balances[to]\\nTMP_52(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_15,tokens)\\nREF_14(uint256) (->balances) := TMP_52(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(from,to,tokens)\\n\\nIRs:\\nEmit Transfer(from,to,tokens)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 30.sol-Bitdepositary-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnewOwner = _newOwner\\n\\nIRs:\\nnewOwner(address) := _newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 30.sol-ERC20Interface-allowance(address,address)\\ndigraph{\\n}\\n// Function: 30.sol-ERC20Interface-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 30.sol-ERC20Interface-balanceOf(address)\\ndigraph{\\n}\\n// Function: 30.sol-ERC20Interface-totalSupply()\\ndigraph{\\n}\\n// Function: 30.sol-ERC20Interface-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 30.sol-ERC20Interface-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 30.sol-Owned-Owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 30.sol-Owned-acceptOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == newOwner)\\n\\nIRs:\\nTMP_16(bool) = msg.sender == newOwner\\nTMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewOwner = address(0)\\n\\nIRs:\\nTMP_19 = CONVERT 0 to address\\nnewOwner(address) := TMP_19(address)\\\"];\\n}\\n// Function: 30.sol-Owned-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_20(bool) = msg.sender == owner\\nTMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 30.sol-Owned-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnewOwner = _newOwner\\n\\nIRs:\\nnewOwner(address) := _newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 30.sol-SafeMath-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_0(uint256) = a + b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(c >= a)\\n\\nIRs:\\nTMP_1(bool) = c >= a\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 30.sol-SafeMath-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b > 0)\\n\\nIRs:\\nTMP_12(bool) = b > 0\\nTMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_14(uint256) = a / b\\nc(uint256) := TMP_14(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 30.sol-SafeMath-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_6(uint256) = a * b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_7(bool) = a == 0\\nTMP_8(uint256) = c / a\\nTMP_9(bool) = TMP_8 == b\\nTMP_10(bool) = TMP_7 || TMP_9\\nTMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 30.sol-SafeMath-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b <= a)\\n\\nIRs:\\nTMP_3(bool) = b <= a\\nTMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a - b\\n\\nIRs:\\nTMP_5(uint256) = a - b\\nc(uint256) := TMP_5(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 31.sol-Crowdsale-Crowdsale()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\noffChainTokens = 0\\n\\nIRs:\\noffChainTokens(uint256) := 0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\namountRaised = 0\\n\\nIRs:\\namountRaised(uint256) := 0(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntokenBalance = 30000000\\n\\nIRs:\\ntokenBalance(uint256) := 30000000(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nminimumSpend = 0.01 * 1000000000000000000\\n\\nIRs:\\nTMP_17(uint256) = 0 * 1000000000000000000\\nminimumSpend(uint256) := TMP_17(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbeneficiary = 0x0677f6a5383b10dc4ac253b4d56d8f69df76f548\\n\\nIRs:\\nbeneficiary(address) := 36929219147241391525258227582894326545072452936(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nstart_time = now\\n\\nIRs:\\nstart_time(uint256) := now(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ntokenReward = token(0xfACfB7aaD014f30f06E67cBeE8d3308C69aeD37a)\\n\\nIRs:\\nTMP_18 = CONVERT 1431879946634971807609783859358207627022232900474 to token\\ntokenReward(token) := TMP_18(token)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nmaster = 0x69F8C1604f27475AF9f872E07c2E6a56b485DAcf\\n\\nIRs:\\nmaster(address) := 604991461189243757224746077525852260209111980751(address)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nprice = 953584813430000\\n\\nIRs:\\nprice(uint256) := 953584813430000(uint256)\\\"];\\n}\\n// Function: 31.sol-Crowdsale-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\namount = msg.value\\n\\nIRs:\\namount(uint256) := msg.value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\namountRaised += amount\\n\\nIRs:\\namountRaised(uint256) = amountRaised + amount\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntokenBalance = SafeMath.sub(tokenBalance,SafeMath.div(amount,price))\\n\\nIRs:\\nTMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['amount', 'price'] \\nTMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokenBalance', 'TMP_19'] \\ntokenBalance(uint256) := TMP_20(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\ntokenBalance < offChainTokens\\n\\nIRs:\\nTMP_21(bool) = tokenBalance < offChainTokens\\nCONDITION TMP_21\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_22(None) = SOLIDITY_CALL revert()()\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\namount < minimumSpend\\n\\nIRs:\\nTMP_23(bool) = amount < minimumSpend\\nCONDITION TMP_23\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_24(None) = SOLIDITY_CALL revert()()\\\"];\\n8->9;\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ntokenReward.transfer(msg.sender,SafeMath.div(amount * 1000000000000000000,price))\\n\\nIRs:\\nTMP_25(uint256) = amount * 1000000000000000000\\nTMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_25', 'price'] \\nHIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'TMP_26']  \\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nFundTransfer(msg.sender,amount,true)\\n\\nIRs:\\nEmit FundTransfer(msg.sender,amount,True)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] += amount\\n\\nIRs:\\nREF_4(uint256) -> balanceOf[msg.sender]\\nREF_4(-> balanceOf) = REF_4 + amount\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nnotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.notPaused()()\\\"];\\n13->1;\\n}\\n// Function: 31.sol-Crowdsale-isMaster()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender == master\\n\\nIRs:\\nTMP_44(bool) = msg.sender == master\\nCONDITION TMP_44\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 31.sol-Crowdsale-isPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\npaused == true\\n\\nIRs:\\nTMP_42(bool) = paused == True\\nCONDITION TMP_42\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 31.sol-Crowdsale-notPaused()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\npaused == false\\n\\nIRs:\\nTMP_43(bool) = paused == False\\nCONDITION TMP_43\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 31.sol-Crowdsale-pause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = true\\n\\nIRs:\\npaused(bool) := True(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nnotPaused()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.notPaused()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nisMaster()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.isMaster()()\\\"];\\n3->1;\\n}\\n// Function: 31.sol-Crowdsale-safeWithdrawal()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbeneficiary.send(amountRaised)\\n\\nIRs:\\nTMP_30 = SEND dest:beneficiary value:amountRaised\\nCONDITION TMP_30\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nFundTransfer(beneficiary,amountRaised,false)\\n\\nIRs:\\nEmit FundTransfer(beneficiary,amountRaised,False)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntokenReward.transfer(beneficiary,tokenReward.balanceOf(this))\\n\\nIRs:\\nTMP_32(uint256) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:balanceOf, arguments:['this']  \\nHIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'TMP_32']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntokenBalance = 0\\n\\nIRs:\\ntokenBalance(uint256) := 0(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nisMaster()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.isMaster()()\\\"];\\n6->1;\\n}\\n// Function: 31.sol-Crowdsale-unPause()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\npaused = false\\n\\nIRs:\\npaused(bool) := False(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nisPaused()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.isPaused()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nisMaster()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.isMaster()()\\\"];\\n3->1;\\n}\\n// Function: 31.sol-Crowdsale-updateMinSpend(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nminimumSpend = _minimumSpend\\n\\nIRs:\\nminimumSpend(uint256) := _minimumSpend(uint256)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nisMaster()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.isMaster()()\\\"];\\n2->1;\\n}\\n// Function: 31.sol-Crowdsale-updateOffChainTokens(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\noffChainTokens = _offChainTokens\\n\\nIRs:\\noffChainTokens(uint256) := _offChainTokens(uint256)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nisMaster()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.isMaster()()\\\"];\\n2->1;\\n}\\n// Function: 31.sol-Crowdsale-updatePrice(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nprice = _price\\n\\nIRs:\\nprice(uint256) := _price(uint256)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nisMaster()\\n\\nIRs:\\nMODIFIER_CALL, Crowdsale.isMaster()()\\\"];\\n2->1;\\n}\\n// Function: 31.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_10(uint256) = a + b\\nc(uint256) := TMP_10(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_11(bool) = c >= a\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 31.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_6(uint256) = a / b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 31.sol-SafeMath-max256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_15(bool) = a >= b\\nCONDITION TMP_15\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 31.sol-SafeMath-max64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_13(bool) = a >= b\\nCONDITION TMP_13\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 31.sol-SafeMath-min256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_16(bool) = a < b\\nCONDITION TMP_16\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 31.sol-SafeMath-min64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_14(bool) = a < b\\nCONDITION TMP_14\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 31.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_0(uint256) = a * b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_1(bool) = a == 0\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(bool) = TMP_1 || TMP_3\\nTMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 31.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_7(bool) = b <= a\\nTMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_9(uint256) = a - b\\nRETURN TMP_9\\\"];\\n}\\n// Function: 31.sol-token-balanceOf(address)\\ndigraph{\\n}\\n// Function: 31.sol-token-transfer(address,uint256)\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 32.sol-ROSCtoken-ROSCtoken(uint256,string,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nTokenERC20(initialSupply,tokenName,tokenSymbol)\\n\\nIRs:\\nINTERNAL_CALL, TokenERC20.TokenERC20(uint256,string,string)(initialSupply,tokenName,tokenSymbol)\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-TokenERC20(uint256,string,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = initialSupply * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_33 = CONVERT decimals to uint256\\nTMP_34(uint256) = 10 ** TMP_33\\nTMP_35(uint256) = initialSupply * TMP_34\\ntotalSupply(uint256) := TMP_35(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = totalSupply\\n\\nIRs:\\nREF_25(uint256) -> balanceOf[msg.sender]\\nREF_25(uint256) (->balanceOf) := totalSupply(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = tokenName\\n\\nIRs:\\nname(string) := tokenName(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsymbol = tokenSymbol\\n\\nIRs:\\nsymbol(string) := tokenSymbol(string)\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-_transfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_65(bool) = _to != 0\\nTMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_50(uint256) -> balanceOf[_from]\\nTMP_67(bool) = REF_50 >= _value\\nTMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_to] + _value > balanceOf[_to])\\n\\nIRs:\\nREF_51(uint256) -> balanceOf[_to]\\nTMP_69(uint256) = REF_51 + _value\\nREF_52(uint256) -> balanceOf[_to]\\nTMP_70(bool) = TMP_69 > REF_52\\nTMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[_from])\\n\\nIRs:\\nREF_53(bool) -> frozenAccount[_from]\\nTMP_72 = UnaryType.BANG REF_53 \\nTMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(! frozenAccount[_to])\\n\\nIRs:\\nREF_54(bool) -> frozenAccount[_to]\\nTMP_74 = UnaryType.BANG REF_54 \\nTMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_55(uint256) -> balanceOf[_from]\\nREF_55(-> balanceOf) = REF_55 - _value\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalanceOf[_to] += _value\\n\\nIRs:\\nREF_56(uint256) -> balanceOf[_to]\\nREF_56(-> balanceOf) = REF_56 + _value\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowance[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowance[msg.sender]\\nREF_40(uint256) -> REF_39[_spender]\\nREF_40(uint256) (->allowance) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nspender = tokenRecipient(_spender)\\n\\nIRs:\\nTMP_52 = CONVERT _spender to tokenRecipient\\nspender(tokenRecipient) := TMP_52(tokenRecipient)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\napprove(_spender,_value)\\n\\nIRs:\\nTMP_53(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)\\nCONDITION TMP_53\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nspender.receiveApproval(msg.sender,_value,this,_extraData)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[msg.sender] >= _value)\\n\\nIRs:\\nREF_42(uint256) -> balanceOf[msg.sender]\\nTMP_55(bool) = REF_42 >= _value\\nTMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] -= _value\\n\\nIRs:\\nREF_43(uint256) -> balanceOf[msg.sender]\\nREF_43(-> balanceOf) = REF_43 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-burnFrom(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_44(uint256) -> balanceOf[_from]\\nTMP_58(bool) = REF_44 >= _value\\nTMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowance[_from]\\nREF_46(uint256) -> REF_45[msg.sender]\\nTMP_60(bool) = _value <= REF_46\\nTMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_47(uint256) -> balanceOf[_from]\\nREF_47(-> balanceOf) = REF_47 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_48(mapping(address => uint256)) -> allowance[_from]\\nREF_49(uint256) -> REF_48[msg.sender]\\nREF_49(-> allowance) = REF_49 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(_from,_value)\\n\\nIRs:\\nEmit Burn(_from,_value)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-buy()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\namount = msg.value / buyPrice\\n\\nIRs:\\nTMP_83(uint256) = msg.value / buyPrice\\namount(uint256) := TMP_83(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_transfer(this,msg.sender,amount)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(this,msg.sender,amount)\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-freezeAccount(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nfrozenAccount[target] = freeze\\n\\nIRs:\\nREF_58(bool) -> frozenAccount[target]\\nREF_58(bool) (->frozenAccount) := freeze(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nFrozenFunds(target,freeze)\\n\\nIRs:\\nEmit FrozenFunds(target,freeze)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 32.sol-ROSCtoken-mintToken(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalanceOf[target] += mintedAmount\\n\\nIRs:\\nREF_57(uint256) -> balanceOf[target]\\nREF_57(-> balanceOf) = REF_57 + mintedAmount\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply += mintedAmount\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply + mintedAmount\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(0,this,mintedAmount)\\n\\nIRs:\\nEmit Transfer(0,this,mintedAmount)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(this,target,mintedAmount)\\n\\nIRs:\\nEmit Transfer(this,target,mintedAmount)\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 32.sol-ROSCtoken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_91(bool) = msg.sender == owner\\nTMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-sell(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(this.balance >= amount * sellPrice)\\n\\nIRs:\\nREF_59(uint256) = SOLIDITY_CALL balance(address)(this)\\nTMP_85(uint256) = amount * sellPrice\\nTMP_86(bool) = REF_59 >= TMP_85\\nTMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_transfer(msg.sender,this,amount)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(msg.sender,this,amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nmsg.sender.transfer(amount * sellPrice)\\n\\nIRs:\\nTMP_89(uint256) = amount * sellPrice\\nTransfer dest:msg.sender value:TMP_89\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-setPrices(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nsellPrice = newSellPrice\\n\\nIRs:\\nsellPrice(uint256) := newSellPrice(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbuyPrice = newBuyPrice\\n\\nIRs:\\nbuyPrice(uint256) := newBuyPrice(uint256)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 32.sol-ROSCtoken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transfer(msg.sender,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(msg.sender,_to,_value)\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_35(mapping(address => uint256)) -> allowance[_from]\\nREF_36(uint256) -> REF_35[msg.sender]\\nTMP_49(bool) = _value <= REF_36\\nTMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_37(mapping(address => uint256)) -> allowance[_from]\\nREF_38(uint256) -> REF_37[msg.sender]\\nREF_38(-> allowance) = REF_38 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_transfer(_from,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, ROSCtoken._transfer(address,address,uint256)(_from,_to,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-ROSCtoken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 32.sol-TokenERC20-TokenERC20(uint256,string,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = initialSupply * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_3 = CONVERT decimals to uint256\\nTMP_4(uint256) = 10 ** TMP_3\\nTMP_5(uint256) = initialSupply * TMP_4\\ntotalSupply(uint256) := TMP_5(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] = totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balanceOf[msg.sender]\\nREF_0(uint256) (->balanceOf) := totalSupply(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = tokenName\\n\\nIRs:\\nname(string) := tokenName(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsymbol = tokenSymbol\\n\\nIRs:\\nsymbol(string) := tokenSymbol(string)\\\"];\\n}\\n// Function: 32.sol-TokenERC20-_transfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_6(bool) = _to != 0\\nTMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_1(uint256) -> balanceOf[_from]\\nTMP_8(bool) = REF_1 >= _value\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_to] + _value > balanceOf[_to])\\n\\nIRs:\\nREF_2(uint256) -> balanceOf[_to]\\nTMP_10(uint256) = REF_2 + _value\\nREF_3(uint256) -> balanceOf[_to]\\nTMP_11(bool) = TMP_10 > REF_3\\nTMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\npreviousBalances = balanceOf[_from] + balanceOf[_to]\\n\\nIRs:\\nREF_4(uint256) -> balanceOf[_from]\\nREF_5(uint256) -> balanceOf[_to]\\nTMP_13(uint256) = REF_4 + REF_5\\npreviousBalances(uint256) := TMP_13(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_6(uint256) -> balanceOf[_from]\\nREF_6(-> balanceOf) = REF_6 - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalanceOf[_to] += _value\\n\\nIRs:\\nREF_7(uint256) -> balanceOf[_to]\\nREF_7(-> balanceOf) = REF_7 + _value\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nassert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)\\n\\nIRs:\\nREF_8(uint256) -> balanceOf[_from]\\nREF_9(uint256) -> balanceOf[_to]\\nTMP_15(uint256) = REF_8 + REF_9\\nTMP_16(bool) = TMP_15 == previousBalances\\nTMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)\\\"];\\n}\\n// Function: 32.sol-TokenERC20-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowance[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_14(mapping(address => uint256)) -> allowance[msg.sender]\\nREF_15(uint256) -> REF_14[_spender]\\nREF_15(uint256) (->allowance) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-TokenERC20-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nspender = tokenRecipient(_spender)\\n\\nIRs:\\nTMP_22 = CONVERT _spender to tokenRecipient\\nspender(tokenRecipient) := TMP_22(tokenRecipient)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\napprove(_spender,_value)\\n\\nIRs:\\nTMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)\\nCONDITION TMP_23\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nspender.receiveApproval(msg.sender,_value,this,_extraData)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-TokenERC20-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[msg.sender] >= _value)\\n\\nIRs:\\nREF_17(uint256) -> balanceOf[msg.sender]\\nTMP_25(bool) = REF_17 >= _value\\nTMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalanceOf[msg.sender] -= _value\\n\\nIRs:\\nREF_18(uint256) -> balanceOf[msg.sender]\\nREF_18(-> balanceOf) = REF_18 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nBurn(msg.sender,_value)\\n\\nIRs:\\nEmit Burn(msg.sender,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-TokenERC20-burnFrom(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balanceOf[_from] >= _value)\\n\\nIRs:\\nREF_19(uint256) -> balanceOf[_from]\\nTMP_28(bool) = REF_19 >= _value\\nTMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_20(mapping(address => uint256)) -> allowance[_from]\\nREF_21(uint256) -> REF_20[msg.sender]\\nTMP_30(bool) = _value <= REF_21\\nTMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalanceOf[_from] -= _value\\n\\nIRs:\\nREF_22(uint256) -> balanceOf[_from]\\nREF_22(-> balanceOf) = REF_22 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_23(mapping(address => uint256)) -> allowance[_from]\\nREF_24(uint256) -> REF_23[msg.sender]\\nREF_24(-> allowance) = REF_24 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalSupply -= _value\\n\\nIRs:\\ntotalSupply(uint256) = totalSupply - _value\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(_from,_value)\\n\\nIRs:\\nEmit Burn(_from,_value)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-TokenERC20-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n}\\n// Function: 32.sol-TokenERC20-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transfer(msg.sender,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, TokenERC20._transfer(address,address,uint256)(msg.sender,_to,_value)\\\"];\\n}\\n// Function: 32.sol-TokenERC20-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowance[_from][msg.sender])\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowance[_from]\\nREF_11(uint256) -> REF_10[msg.sender]\\nTMP_19(bool) = _value <= REF_11\\nTMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowance[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_12(mapping(address => uint256)) -> allowance[_from]\\nREF_13(uint256) -> REF_12[msg.sender]\\nREF_13(-> allowance) = REF_13 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_transfer(_from,_to,_value)\\n\\nIRs:\\nINTERNAL_CALL, TokenERC20._transfer(address,address,uint256)(_from,_to,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 32.sol-owned-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_1(bool) = msg.sender == owner\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 32.sol-owned-owned()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 32.sol-owned-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 32.sol-tokenRecipient-receiveApproval(address,uint256,address,bytes)\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 35.sol-BEECASHBACKHOME-BEECASHBACKHOME()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[msg.sender] = _totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nREF_0(uint256) (->balances) := _totalSupply(uint256)\\\"];\\n}\\n// Function: 35.sol-BEECASHBACKHOME-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_14(mapping(address => uint256)) -> allowed[_owner]\\nREF_15(uint256) -> REF_14[_spender]\\nRETURN REF_15\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 35.sol-BEECASHBACKHOME-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_12(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_13(uint256) -> REF_12[_spender]\\nREF_13(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 35.sol-BEECASHBACKHOME-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_1(uint256) -> balances[_owner]\\nRETURN REF_1\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 35.sol-BEECASHBACKHOME-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\n_totalSupply = 50000000000000000000000000\\n\\nIRs:\\n_totalSupply(uint256) := 50000000000000000000000000(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = BCH\\n\\nIRs:\\nsymbol(string) := BCH(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nname = BEE CASHBACK HOME\\n\\nIRs:\\nname(string) := BEE CASHBACK HOME(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n}\\n// Function: 35.sol-BEECASHBACKHOME-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n_totalSupply\\n\\nIRs:\\nRETURN _totalSupply\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntotalSupply\\n\\nIRs:\\nRETURN totalSupply\\\"];\\n}\\n// Function: 35.sol-BEECASHBACKHOME-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(balances[msg.sender] >= _value && _value > 0)\\n\\nIRs:\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_0(bool) = REF_2 >= _value\\nTMP_1(bool) = _value > 0\\nTMP_2(bool) = TMP_0 && TMP_1\\nTMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] -= _value\\n\\nIRs:\\nREF_3(uint256) -> balances[msg.sender]\\nREF_3(-> balances) = REF_3 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] += _value\\n\\nIRs:\\nREF_4(uint256) -> balances[_to]\\nREF_4(-> balances) = REF_4 + _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 35.sol-BEECASHBACKHOME-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0)\\n\\nIRs:\\nREF_5(mapping(address => uint256)) -> allowed[_from]\\nREF_6(uint256) -> REF_5[msg.sender]\\nTMP_5(bool) = REF_6 >= _value\\nREF_7(uint256) -> balances[_from]\\nTMP_6(bool) = REF_7 >= _value\\nTMP_7(bool) = TMP_5 && TMP_6\\nTMP_8(bool) = _value > 0\\nTMP_9(bool) = TMP_7 && TMP_8\\nTMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[_from] -= _value\\n\\nIRs:\\nREF_8(uint256) -> balances[_from]\\nREF_8(-> balances) = REF_8 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] += _value\\n\\nIRs:\\nREF_9(uint256) -> balances[_to]\\nREF_9(-> balances) = REF_9 + _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowed[_from]\\nREF_11(uint256) -> REF_10[msg.sender]\\nREF_11(-> allowed) = REF_11 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 36.sol-AirDropForERC223-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-constructor(uint256,uint256,uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_startTime >= now && _endTime >= _startTime && _airDropAmount > 0 && _tokenAddress != address(0))\\n\\nIRs:\\nTMP_24(bool) = _startTime >= now\\nTMP_25(bool) = _endTime >= _startTime\\nTMP_26(bool) = TMP_24 && TMP_25\\nTMP_27(bool) = _airDropAmount > 0\\nTMP_28(bool) = TMP_26 && TMP_27\\nTMP_29 = CONVERT 0 to address\\nTMP_30(bool) = _tokenAddress != TMP_29\\nTMP_31(bool) = TMP_28 && TMP_30\\nTMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstartTime = _startTime\\n\\nIRs:\\nstartTime(uint256) := _startTime(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nendTime = _endTime\\n\\nIRs:\\nendTime(uint256) := _endTime(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nerc20 = ERC223Interface(_tokenAddress)\\n\\nIRs:\\nTMP_33 = CONVERT _tokenAddress to ERC223Interface\\nerc20(ERC223Interface) := TMP_33(ERC223Interface)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ntokenDecimals = erc20.decimals()\\n\\nIRs:\\nTMP_34(uint8) = HIGH_LEVEL_CALL, dest:erc20(ERC223Interface), function:decimals, arguments:[]  \\ntokenDecimals(uint256) := TMP_34(uint8)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nairDropAmount = _airDropAmount.mul(10 ** tokenDecimals)\\n\\nIRs:\\nTMP_35(uint256) = 10 ** tokenDecimals\\nTMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_airDropAmount', 'TMP_35'] \\nairDropAmount(uint256) := TMP_36(uint256)\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-getRemainingToken()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nerc20.balanceOf(this)\\n\\nIRs:\\nTMP_90(uint256) = HIGH_LEVEL_CALL, dest:erc20(ERC223Interface), function:balanceOf, arguments:['this']  \\nRETURN TMP_90\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-getTotalAirDroppedAmount()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nairDropAmount.mul(arrayAirDropReceivers.length)\\n\\nIRs:\\nREF_14 -> LENGTH arrayAirDropReceivers\\nTMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['airDropAmount', 'REF_14'] \\nRETURN TMP_91\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-getTotalNumberOfAddressesReceivedAirDrop()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\narrayAirDropReceivers.length\\n\\nIRs:\\nREF_11 -> LENGTH arrayAirDropReceivers\\nRETURN REF_11\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-isValidAirDropForAll()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nvalidNotStop = ! stop\\n\\nIRs:\\nTMP_37 = UnaryType.BANG stop \\nvalidNotStop(bool) := TMP_37(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nvalidAmount = getRemainingToken() >= airDropAmount\\n\\nIRs:\\nTMP_38(uint256) = INTERNAL_CALL, AirDropForERC223.getRemainingToken()()\\nTMP_39(bool) = TMP_38 >= airDropAmount\\nvalidAmount(bool) := TMP_39(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\nvalidPeriod = now >= startTime && now <= endTime\\n\\nIRs:\\nTMP_40(bool) = now >= startTime\\nTMP_41(bool) = now <= endTime\\nTMP_42(bool) = TMP_40 && TMP_41\\nvalidPeriod(bool) := TMP_42(bool)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nvalidNotStop && validAmount && validPeriod\\n\\nIRs:\\nTMP_43(bool) = validNotStop && validAmount\\nTMP_44(bool) = TMP_43 && validPeriod\\nRETURN TMP_44\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-isValidAirDropForIndividual()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nvalidNotStop = ! stop\\n\\nIRs:\\nTMP_45 = UnaryType.BANG stop \\nvalidNotStop(bool) := TMP_45(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nvalidAmount = getRemainingToken() >= airDropAmount\\n\\nIRs:\\nTMP_46(uint256) = INTERNAL_CALL, AirDropForERC223.getRemainingToken()()\\nTMP_47(bool) = TMP_46 >= airDropAmount\\nvalidAmount(bool) := TMP_47(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\nvalidPeriod = now >= startTime && now <= endTime\\n\\nIRs:\\nTMP_48(bool) = now >= startTime\\nTMP_49(bool) = now <= endTime\\nTMP_50(bool) = TMP_48 && TMP_49\\nvalidPeriod(bool) := TMP_50(bool)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nvalidReceiveAirDropForIndividual = ! invalidAirDrop[msg.sender]\\n\\nIRs:\\nREF_2(bool) -> invalidAirDrop[msg.sender]\\nTMP_51 = UnaryType.BANG REF_2 \\nvalidReceiveAirDropForIndividual(bool) := TMP_51(bool)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nvalidNotStop && validAmount && validPeriod && validReceiveAirDropForIndividual\\n\\nIRs:\\nTMP_52(bool) = validNotStop && validAmount\\nTMP_53(bool) = TMP_52 && validPeriod\\nTMP_54(bool) = TMP_53 && validReceiveAirDropForIndividual\\nRETURN TMP_54\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_92(bool) = msg.sender == owner\\nTMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-receiveAirDrop()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(isValidAirDropForIndividual())\\n\\nIRs:\\nTMP_55(bool) = INTERNAL_CALL, AirDropForERC223.isValidAirDropForIndividual()()\\nTMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ninvalidAirDrop[msg.sender] = true\\n\\nIRs:\\nREF_3(bool) -> invalidAirDrop[msg.sender]\\nREF_3(bool) (->invalidAirDrop) := True(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narrayAirDropReceivers.push(msg.sender)\\n\\nIRs:\\nREF_5 -> LENGTH arrayAirDropReceivers\\nTMP_58(uint256) := REF_5(uint256)\\nTMP_59(uint256) = TMP_58 + 1\\nREF_5(uint256) (->arrayAirDropReceivers) := TMP_59(uint256)\\nREF_6(address) -> arrayAirDropReceivers[TMP_58]\\nREF_6(address) (->arrayAirDropReceivers) := msg.sender(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nerc20.transfer(msg.sender,airDropAmount)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:erc20(ERC223Interface), function:transfer, arguments:['msg.sender', 'airDropAmount']  \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nLogAirDrop(msg.sender,airDropAmount)\\n\\nIRs:\\nEmit LogAirDrop(msg.sender,airDropAmount)\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nstop = false\\n\\nIRs:\\nstop(bool) := False(bool)\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-toggle()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nstop = ! stop\\n\\nIRs:\\nTMP_62 = UnaryType.BANG stop \\nstop(bool) := TMP_62(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nstop\\n\\nIRs:\\nCONDITION stop\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nLogStop()\\n\\nIRs:\\nEmit LogStop()\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nLogStart()\\n\\nIRs:\\nEmit LogStart()\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 36.sol-AirDropForERC223-tokenFallback(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n}\\n// Function: 36.sol-AirDropForERC223-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_19 = CONVERT 0 to address\\nTMP_20(bool) = newOwner != TMP_19\\nTMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 36.sol-AirDropForERC223-updateInfo(uint256,uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->8;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(stop || now > endTime)\\n\\nIRs:\\nTMP_76(bool) = now > endTime\\nTMP_77(bool) = stop || TMP_76\\nTMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_startTime >= now && _endTime >= _startTime && _airDropAmount > 0)\\n\\nIRs:\\nTMP_79(bool) = _startTime >= now\\nTMP_80(bool) = _endTime >= _startTime\\nTMP_81(bool) = TMP_79 && TMP_80\\nTMP_82(bool) = _airDropAmount > 0\\nTMP_83(bool) = TMP_81 && TMP_82\\nTMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nstartTime = _startTime\\n\\nIRs:\\nstartTime(uint256) := _startTime(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nendTime = _endTime\\n\\nIRs:\\nendTime(uint256) := _endTime(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ntokenDecimals = erc20.decimals()\\n\\nIRs:\\nTMP_85(uint8) = HIGH_LEVEL_CALL, dest:erc20(ERC223Interface), function:decimals, arguments:[]  \\ntokenDecimals(uint256) := TMP_85(uint8)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nairDropAmount = _airDropAmount.mul(10 ** tokenDecimals)\\n\\nIRs:\\nTMP_86(uint256) = 10 ** tokenDecimals\\nTMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_airDropAmount', 'TMP_86'] \\nairDropAmount(uint256) := TMP_87(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nLogInfoUpdate(startTime,endTime,airDropAmount)\\n\\nIRs:\\nEmit LogInfoUpdate(startTime,endTime,airDropAmount)\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n8->1;\\n}\\n// Function: 36.sol-AirDropForERC223-withdraw(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(stop || now > endTime)\\n\\nIRs:\\nTMP_66(bool) = now > endTime\\nTMP_67(bool) = stop || TMP_66\\nTMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_address != address(0))\\n\\nIRs:\\nTMP_69 = CONVERT 0 to address\\nTMP_70(bool) = _address != TMP_69\\nTMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ntokenBalanceOfContract = getRemainingToken()\\n\\nIRs:\\nTMP_72(uint256) = INTERNAL_CALL, AirDropForERC223.getRemainingToken()()\\ntokenBalanceOfContract(uint256) := TMP_72(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nerc20.transfer(_address,tokenBalanceOfContract)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:erc20(ERC223Interface), function:transfer, arguments:['_address', 'tokenBalanceOfContract']  \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nLogWithdrawal(_address,tokenBalanceOfContract)\\n\\nIRs:\\nEmit LogWithdrawal(_address,tokenBalanceOfContract)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 36.sol-ERC223Interface-balanceOf(address)\\ndigraph{\\n}\\n// Function: 36.sol-ERC223Interface-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 36.sol-ERC223Interface-transfer(address,uint256,bytes)\\ndigraph{\\n}\\n// Function: 36.sol-ERC223ReceivingContract-tokenFallback(address,uint256,bytes)\\ndigraph{\\n}\\n// Function: 36.sol-Ownable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 36.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_5(bool) = msg.sender == owner\\nTMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 36.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_0 = CONVERT 0 to address\\nTMP_1(bool) = newOwner != TMP_0\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 36.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_16(uint256) = a + b\\nc(uint256) := TMP_16(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_17(bool) = c >= a\\nTMP_18(None) = SOLIDITY_CALL assert(bool)(TMP_17)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 36.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_12(uint256) = a / b\\nRETURN TMP_12\\\"];\\n}\\n// Function: 36.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_7(bool) = a == 0\\nCONDITION TMP_7\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_8(uint256) = a * b\\nc(uint256) := TMP_8(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_9(uint256) = c / a\\nTMP_10(bool) = TMP_9 == b\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 36.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_13(bool) = b <= a\\nTMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_15(uint256) = a - b\\nRETURN TMP_15\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 37.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 37.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 37.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 37.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 37.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 37.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 37.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 37.sol-ForeignToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 37.sol-ForeignToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 37.sol-LUMA-LUMA()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nvalue = 100e8\\n\\nIRs:\\nvalue(uint256) := 10000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndistr(owner,totalDistributed)\\n\\nIRs:\\nTMP_13(bool) = INTERNAL_CALL, LUMA.distr(address,uint256)(owner,totalDistributed)\\\"];\\n}\\n// Function: 37.sol-LUMA-airdrop(address[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(addresses.length <= 255)\\n\\nIRs:\\nREF_11 -> LENGTH addresses\\nTMP_34(bool) = REF_11 <= 255\\nTMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(value <= totalRemaining)\\n\\nIRs:\\nTMP_36(bool) = value <= totalRemaining\\nTMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->10;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < addresses.length\\n\\nIRs:\\nREF_12 -> LENGTH addresses\\nTMP_38(bool) = i < REF_12\\nCONDITION TMP_38\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrequire(bool)(value <= totalRemaining)\\n\\nIRs:\\nTMP_39(bool) = value <= totalRemaining\\nTMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ndistr(addresses[i],value)\\n\\nIRs:\\nREF_13(address) -> addresses[i]\\nTMP_41(bool) = INTERNAL_CALL, LUMA.distr(address,uint256)(REF_13,value)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_42(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n9->6;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_43(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_43\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n11->12;\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.canDistr()()\\\"];\\n14->1;\\n}\\n// Function: 37.sol-LUMA-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_53(mapping(address => uint256)) -> allowed[_owner]\\nREF_54(uint256) -> REF_53[_spender]\\nRETURN REF_54\\\"];\\n}\\n// Function: 37.sol-LUMA-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_value != 0 && allowed[msg.sender][_spender] != 0\\n\\nIRs:\\nTMP_104(bool) = _value != 0\\nREF_49(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_50(uint256) -> REF_49[_spender]\\nTMP_105(bool) = REF_50 != 0\\nTMP_106(bool) = TMP_104 && TMP_105\\nCONDITION TMP_106\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_51(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_52(uint256) -> REF_51[_spender]\\nREF_52(uint256) (->allowed) := _value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 37.sol-LUMA-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_27(uint256) -> balances[_owner]\\nRETURN REF_27\\\"];\\n}\\n// Function: 37.sol-LUMA-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_58(uint256) -> balances[msg.sender]\\nTMP_112(bool) = _value <= REF_58\\nTMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nburner = msg.sender\\n\\nIRs:\\nburner(address) := msg.sender(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[burner] = balances[burner].sub(_value)\\n\\nIRs:\\nREF_59(uint256) -> balances[burner]\\nREF_60(uint256) -> balances[burner]\\nTMP_114(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_60', '_value'] \\nREF_59(uint256) (->balances) := TMP_114(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalSupply = totalSupply.sub(_value)\\n\\nIRs:\\nTMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] \\ntotalSupply(uint256) := TMP_115(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.sub(_value)\\n\\nIRs:\\nTMP_116(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDistributed', '_value'] \\ntotalDistributed(uint256) := TMP_116(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(burner,_value)\\n\\nIRs:\\nEmit Burn(burner,_value)\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n7->1;\\n}\\n// Function: 37.sol-LUMA-canDistr()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! distributionFinished)\\n\\nIRs:\\nTMP_125 = UnaryType.BANG distributionFinished \\nTMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 37.sol-LUMA-disableWhitelist(address[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: BEGIN_LOOP 1\\n\\\"];\\n1->4;\\n2[label=\\\"Node Type: END_LOOP 2\\n\\\"];\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n3->1;\\n4[label=\\\"Node Type: IF_LOOP 4\\n\\nEXPRESSION:\\ni < addresses.length\\n\\nIRs:\\nREF_3 -> LENGTH addresses\\nTMP_20(bool) = i < REF_3\\nCONDITION TMP_20\\\"];\\n4->5[label=\\\"True\\\"];\\n4->2[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nblacklist[addresses[i]] = true\\n\\nIRs:\\nREF_4(address) -> addresses[i]\\nREF_5(bool) -> blacklist[REF_4]\\nREF_5(bool) (->blacklist) := True(bool)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_21(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n6->4;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n7->3;\\n}\\n// Function: 37.sol-LUMA-distr(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->10;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.add(_amount)\\n\\nIRs:\\nTMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDistributed', '_amount'] \\ntotalDistributed(uint256) := TMP_26(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalRemaining = totalRemaining.sub(_amount)\\n\\nIRs:\\nTMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalRemaining', '_amount'] \\ntotalRemaining(uint256) := TMP_27(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_8(uint256) -> balances[_to]\\nREF_9(uint256) -> balances[_to]\\nTMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_9', '_amount'] \\nREF_8(uint256) (->balances) := TMP_28(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nDistr(_to,_amount)\\n\\nIRs:\\nEmit Distr(_to,_amount)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(address(0),_to,_amount)\\n\\nIRs:\\nTMP_30 = CONVERT 0 to address\\nEmit Transfer(TMP_30,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_32(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_32\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n8->9;\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.canDistr()()\\\"];\\n10->1;\\n}\\n// Function: 37.sol-LUMA-distributeAmounts(address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(addresses.length <= 255)\\n\\nIRs:\\nREF_17 -> LENGTH addresses\\nTMP_58(bool) = REF_17 <= 255\\nTMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(addresses.length == amounts.length)\\n\\nIRs:\\nREF_18 -> LENGTH addresses\\nREF_19 -> LENGTH amounts\\nTMP_60(bool) = REF_18 == REF_19\\nTMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint8) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < addresses.length\\n\\nIRs:\\nREF_20 -> LENGTH addresses\\nTMP_62(bool) = i < REF_20\\nCONDITION TMP_62\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrequire(bool)(amounts[i] <= totalRemaining)\\n\\nIRs:\\nREF_21(uint256) -> amounts[i]\\nTMP_63(bool) = REF_21 <= totalRemaining\\nTMP_64(None) = SOLIDITY_CALL require(bool)(TMP_63)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ndistr(addresses[i],amounts[i])\\n\\nIRs:\\nREF_22(address) -> addresses[i]\\nREF_23(uint256) -> amounts[i]\\nTMP_65(bool) = INTERNAL_CALL, LUMA.distr(address,uint256)(REF_22,REF_23)\\\"];\\n8->9;\\n9[label=\\\"Node Type: IF 9\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_66(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_66\\\"];\\n9->10[label=\\\"True\\\"];\\n9->11[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_67(uint8) := i(uint8)\\ni(uint8) = i + 1\\\"];\\n12->6;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.canDistr()()\\\"];\\n14->1;\\n}\\n// Function: 37.sol-LUMA-distribution(address[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(addresses.length <= 255)\\n\\nIRs:\\nREF_14 -> LENGTH addresses\\nTMP_46(bool) = REF_14 <= 255\\nTMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(amount <= totalRemaining)\\n\\nIRs:\\nTMP_48(bool) = amount <= totalRemaining\\nTMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->10;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < addresses.length\\n\\nIRs:\\nREF_15 -> LENGTH addresses\\nTMP_50(bool) = i < REF_15\\nCONDITION TMP_50\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrequire(bool)(amount <= totalRemaining)\\n\\nIRs:\\nTMP_51(bool) = amount <= totalRemaining\\nTMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ndistr(addresses[i],amount)\\n\\nIRs:\\nREF_16(address) -> addresses[i]\\nTMP_53(bool) = INTERNAL_CALL, LUMA.distr(address,uint256)(REF_16,amount)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_54(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n9->6;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_55(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_55\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n11->12;\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.canDistr()()\\\"];\\n14->1;\\n}\\n// Function: 37.sol-LUMA-enableWhitelist(address[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: BEGIN_LOOP 1\\n\\\"];\\n1->4;\\n2[label=\\\"Node Type: END_LOOP 2\\n\\\"];\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n3->1;\\n4[label=\\\"Node Type: IF_LOOP 4\\n\\nEXPRESSION:\\ni < addresses.length\\n\\nIRs:\\nREF_0 -> LENGTH addresses\\nTMP_17(bool) = i < REF_0\\nCONDITION TMP_17\\\"];\\n4->5[label=\\\"True\\\"];\\n4->2[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nblacklist[addresses[i]] = false\\n\\nIRs:\\nREF_1(address) -> addresses[i]\\nREF_2(bool) -> blacklist[REF_1]\\nREF_2(bool) (->blacklist) := False(bool)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_18(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n6->4;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n7->3;\\n}\\n// Function: 37.sol-LUMA-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ngetTokens()\\n\\nIRs:\\nINTERNAL_CALL, LUMA.getTokens()()\\\"];\\n}\\n// Function: 37.sol-LUMA-finishDistribution()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nDistrFinished()\\n\\nIRs:\\nEmit DistrFinished()\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.canDistr()()\\\"];\\n5->1;\\n}\\n// Function: 37.sol-LUMA-getTokenBalance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nt = ForeignToken(tokenAddress)\\n\\nIRs:\\nTMP_108 = CONVERT tokenAddress to ForeignToken\\nt(ForeignToken) := TMP_108(ForeignToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nbal = t.balanceOf(who)\\n\\nIRs:\\nTMP_109(uint256) = HIGH_LEVEL_CALL, dest:t(ForeignToken), function:balanceOf, arguments:['who']  \\nbal(uint256) := TMP_109(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nbal\\n\\nIRs:\\nRETURN bal\\\"];\\n}\\n// Function: 37.sol-LUMA-getTokens()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->15;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nvalue > totalRemaining\\n\\nIRs:\\nTMP_71(bool) = value > totalRemaining\\nCONDITION TMP_71\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nvalue = totalRemaining\\n\\nIRs:\\nvalue(uint256) := totalRemaining(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(value <= totalRemaining)\\n\\nIRs:\\nTMP_72(bool) = value <= totalRemaining\\nTMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ninvestor = msg.sender\\n\\nIRs:\\ninvestor(address) := msg.sender(address)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\ntoGive = value\\n\\nIRs:\\ntoGive(uint256) := value(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ndistr(investor,toGive)\\n\\nIRs:\\nTMP_74(bool) = INTERNAL_CALL, LUMA.distr(address,uint256)(investor,toGive)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\ntoGive > 0\\n\\nIRs:\\nTMP_75(bool) = toGive > 0\\nCONDITION TMP_75\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nblacklist[investor] = true\\n\\nIRs:\\nREF_24(bool) -> blacklist[investor]\\nREF_24(bool) (->blacklist) := True(bool)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: IF 11\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_76(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_76\\\"];\\n11->12[label=\\\"True\\\"];\\n11->13[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n12->13;\\n13[label=\\\"Node Type: END_IF 13\\n\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nvalue = value.div(100000).mul(99999)\\n\\nIRs:\\nTMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['value', '100000'] \\nTMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_77', '99999'] \\nvalue(uint256) := TMP_78(uint256)\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.canDistr()()\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nonlyWhitelist()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyWhitelist()()\\\"];\\n16->1;\\n}\\n// Function: 37.sol-LUMA-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_127(bool) = msg.sender == owner\\nTMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 37.sol-LUMA-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(msg.data.length >= size + 4)\\n\\nIRs:\\nREF_68 -> LENGTH msg.data\\nTMP_131(uint256) = size + 4\\nTMP_132(bool) = REF_68 >= TMP_131\\nTMP_133(None) = SOLIDITY_CALL assert(bool)(TMP_132)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 37.sol-LUMA-onlyWhitelist()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(blacklist[msg.sender] == false)\\n\\nIRs:\\nREF_67(bool) -> blacklist[msg.sender]\\nTMP_129(bool) = REF_67 == False\\nTMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 37.sol-LUMA-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = LUMA\\n\\nIRs:\\nname(string) := LUMA(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = LUMA\\n\\nIRs:\\nsymbol(string) := LUMA(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 8\\n\\nIRs:\\ndecimals(uint256) := 8(uint256)\\\"];\\n}\\n// Function: 37.sol-LUMA-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ntotalSupply = 500000000e8\\n\\nIRs:\\ntotalSupply(uint256) := 50000000000000000(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ntotalDistributed = 50000000e8\\n\\nIRs:\\ntotalDistributed(uint256) := 5000000000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\ntotalRemaining = totalSupply.sub(totalDistributed)\\n\\nIRs:\\nTMP_124(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', 'totalDistributed'] \\ntotalRemaining(uint256) := TMP_124(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\ndistributionFinished = false\\n\\nIRs:\\ndistributionFinished(bool) := False(bool)\\\"];\\n}\\n// Function: 37.sol-LUMA-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_81 = CONVERT 0 to address\\nTMP_82(bool) = _to != TMP_81\\nTMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[msg.sender])\\n\\nIRs:\\nREF_28(uint256) -> balances[msg.sender]\\nTMP_84(bool) = _amount <= REF_28\\nTMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_amount)\\n\\nIRs:\\nREF_29(uint256) -> balances[msg.sender]\\nREF_30(uint256) -> balances[msg.sender]\\nTMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_30', '_amount'] \\nREF_29(uint256) (->balances) := TMP_86(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_32(uint256) -> balances[_to]\\nREF_33(uint256) -> balances[_to]\\nTMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_33', '_amount'] \\nREF_32(uint256) (->balances) := TMP_87(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_amount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_89(uint256) = 2 * 32\\nMODIFIER_CALL, LUMA.onlyPayloadSize(uint256)(TMP_89)\\\"];\\n7->1;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 37.sol-LUMA-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_91 = CONVERT 0 to address\\nTMP_92(bool) = _to != TMP_91\\nTMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[_from])\\n\\nIRs:\\nREF_35(uint256) -> balances[_from]\\nTMP_94(bool) = _amount <= REF_35\\nTMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_36(mapping(address => uint256)) -> allowed[_from]\\nREF_37(uint256) -> REF_36[msg.sender]\\nTMP_96(bool) = _amount <= REF_37\\nTMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_amount)\\n\\nIRs:\\nREF_38(uint256) -> balances[_from]\\nREF_39(uint256) -> balances[_from]\\nTMP_98(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_39', '_amount'] \\nREF_38(uint256) (->balances) := TMP_98(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount)\\n\\nIRs:\\nREF_41(mapping(address => uint256)) -> allowed[_from]\\nREF_42(uint256) -> REF_41[msg.sender]\\nREF_43(mapping(address => uint256)) -> allowed[_from]\\nREF_44(uint256) -> REF_43[msg.sender]\\nTMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_44', '_amount'] \\nREF_42(uint256) (->allowed) := TMP_99(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_46(uint256) -> balances[_to]\\nREF_47(uint256) -> balances[_to]\\nTMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_47', '_amount'] \\nREF_46(uint256) (->balances) := TMP_100(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyPayloadSize(3 * 32)\\n\\nIRs:\\nTMP_102(uint256) = 3 * 32\\nMODIFIER_CALL, LUMA.onlyPayloadSize(uint256)(TMP_102)\\\"];\\n9->1;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 37.sol-LUMA-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_14 = CONVERT 0 to address\\nTMP_15(bool) = newOwner != TMP_14\\nCONDITION TMP_15\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 37.sol-LUMA-withdraw()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\netherBalance = this.balance\\n\\nIRs:\\nREF_56(uint256) = SOLIDITY_CALL balance(address)(this)\\netherBalance(uint256) := REF_56([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x7ff9e42842e0>])\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner.transfer(etherBalance)\\n\\nIRs:\\nTransfer dest:owner value:etherBalance\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 37.sol-LUMA-withdrawForeignTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntoken = ForeignToken(_tokenContract)\\n\\nIRs:\\nTMP_119 = CONVERT _tokenContract to ForeignToken\\ntoken(ForeignToken) := TMP_119(ForeignToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\namount = token.balanceOf(address(this))\\n\\nIRs:\\nTMP_120 = CONVERT this to address\\nTMP_121(uint256) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:balanceOf, arguments:['TMP_120']  \\namount(uint256) := TMP_121(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntoken.transfer(owner,amount)\\n\\nIRs:\\nTMP_122(bool) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:transfer, arguments:['owner', 'amount']  \\nRETURN TMP_122\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, LUMA.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 37.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_10(uint256) = a + b\\nc(uint256) := TMP_10(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_11(bool) = c >= a\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 37.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_6(uint256) = a / b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 37.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_0(uint256) = a * b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_1(bool) = a == 0\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(bool) = TMP_1 || TMP_3\\nTMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 37.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_7(bool) = b <= a\\nTMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_9(uint256) = a - b\\nRETURN TMP_9\\\"];\\n}\\n// Function: 37.sol-Token-balanceOf(address)\\ndigraph{\\n}\\n// Function: 37.sol-Token-distr(address,uint256)\\ndigraph{\\n}\\n// Function: 37.sol-Token-totalSupply()\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 39.sol-BasicToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_7(uint256) -> balances[_owner]\\nRETURN REF_7\\\"];\\n}\\n// Function: 39.sol-BasicToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntotalSupply_\\n\\nIRs:\\nRETURN totalSupply_\\\"];\\n}\\n// Function: 39.sol-BasicToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_22 = CONVERT 0 to address\\nTMP_23(bool) = _to != TMP_22\\nTMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nTMP_25(bool) = _value <= REF_0\\nTMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_value)\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] \\nREF_1(uint256) (->balances) := TMP_27(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_4(uint256) -> balances[_to]\\nREF_5(uint256) -> balances[_to]\\nTMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] \\nREF_4(uint256) (->balances) := TMP_28(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 39.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 39.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 39.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 39.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 39.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 39.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 39.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 39.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 39.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 39.sol-Ownable-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 39.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_8(bool) = msg.sender == owner\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 39.sol-Ownable-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_6 = CONVERT 0 to address\\nowner(address) := TMP_6(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 39.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_0 = CONVERT 0 to address\\nTMP_1(bool) = newOwner != TMP_0\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 39.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_19(uint256) = a + b\\nc(uint256) := TMP_19(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_20(bool) = c >= a\\nTMP_21(None) = SOLIDITY_CALL assert(bool)(TMP_20)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 39.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_15(uint256) = a / b\\nRETURN TMP_15\\\"];\\n}\\n// Function: 39.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_10(bool) = a == 0\\nCONDITION TMP_10\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_11(uint256) = a * b\\nc(uint256) := TMP_11(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_12(uint256) = c / a\\nTMP_13(bool) = TMP_12 == b\\nTMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 39.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_16(bool) = b <= a\\nTMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_18(uint256) = a - b\\nRETURN TMP_18\\\"];\\n}\\n// Function: 39.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_34(mapping(address => uint256)) -> allowed[_owner]\\nREF_35(uint256) -> REF_34[_spender]\\nRETURN REF_35\\\"];\\n}\\n// Function: 39.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)((_value == 0) || (allowed[msg.sender][_spender] == 0))\\n\\nIRs:\\nTMP_49(bool) = _value == 0\\nREF_30(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_31(uint256) -> REF_30[_spender]\\nTMP_50(bool) = REF_31 == 0\\nTMP_51(bool) = TMP_49 || TMP_50\\nTMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_32(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_33(uint256) -> REF_32[_spender]\\nREF_33(uint256) (->allowed) := _value(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 39.sol-StandardToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 39.sol-StandardToken-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_43(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_44(uint256) -> REF_43[_spender]\\noldValue(uint256) := REF_44(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_56(bool) = _subtractedValue > oldValue\\nCONDITION TMP_56\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_45(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_46(uint256) -> REF_45[_spender]\\nREF_46(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_47(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_48(uint256) -> REF_47[_spender]\\nTMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_48(uint256) (->allowed) := TMP_57(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_50(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_51(uint256) -> REF_50[_spender]\\nEmit Approval(msg.sender,_spender,REF_51)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 39.sol-StandardToken-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_36(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_37(uint256) -> REF_36[_spender]\\nREF_38(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_39(uint256) -> REF_38[_spender]\\nTMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_39', '_addedValue'] \\nREF_37(uint256) (->allowed) := TMP_54(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_41(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_42(uint256) -> REF_41[_spender]\\nEmit Approval(msg.sender,_spender,REF_42)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 39.sol-StandardToken-totalSupply()\\ndigraph{\\n}\\n// Function: 39.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 39.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_38 = CONVERT 0 to address\\nTMP_39(bool) = _to != TMP_38\\nTMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[_from])\\n\\nIRs:\\nREF_16(uint256) -> balances[_from]\\nTMP_41(bool) = _value <= REF_16\\nTMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_value <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_17(mapping(address => uint256)) -> allowed[_from]\\nREF_18(uint256) -> REF_17[msg.sender]\\nTMP_43(bool) = _value <= REF_18\\nTMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_value)\\n\\nIRs:\\nREF_19(uint256) -> balances[_from]\\nREF_20(uint256) -> balances[_from]\\nTMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_value'] \\nREF_19(uint256) (->balances) := TMP_45(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_value)\\n\\nIRs:\\nREF_22(uint256) -> balances[_to]\\nREF_23(uint256) -> balances[_to]\\nTMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', '_value'] \\nREF_22(uint256) (->balances) := TMP_46(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value)\\n\\nIRs:\\nREF_25(mapping(address => uint256)) -> allowed[_from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nREF_27(mapping(address => uint256)) -> allowed[_from]\\nREF_28(uint256) -> REF_27[msg.sender]\\nTMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_value'] \\nREF_26(uint256) (->allowed) := TMP_47(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 39.sol-TokenContract-allowance(address,address)\\ndigraph{\\n}\\n// Function: 39.sol-TokenContract-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 39.sol-TokenContract-balanceOf(address)\\ndigraph{\\n}\\n// Function: 39.sol-TokenContract-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply_ = INITIAL_SUPPLY\\n\\nIRs:\\ntotalSupply_(uint256) := INITIAL_SUPPLY(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[holder] = INITIAL_SUPPLY\\n\\nIRs:\\nREF_96(uint256) -> balances[holder]\\nREF_96(uint256) (->balances) := INITIAL_SUPPLY(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(0x0,holder,INITIAL_SUPPLY)\\n\\nIRs:\\nEmit Transfer(0,holder,INITIAL_SUPPLY)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTokenContract()\\n\\nIRs:\\nINTERNAL_CALL, TokenContract.constructor()()\\\"];\\n4->1;\\n}\\n// Function: 39.sol-TokenContract-decreaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\noldValue = allowed[msg.sender][_spender]\\n\\nIRs:\\nREF_79(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_80(uint256) -> REF_79[_spender]\\noldValue(uint256) := REF_80(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_subtractedValue > oldValue\\n\\nIRs:\\nTMP_77(bool) = _subtractedValue > oldValue\\nCONDITION TMP_77\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = 0\\n\\nIRs:\\nREF_81(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_82(uint256) -> REF_81[_spender]\\nREF_82(uint256) (->allowed) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue)\\n\\nIRs:\\nREF_83(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_84(uint256) -> REF_83[_spender]\\nTMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['oldValue', '_subtractedValue'] \\nREF_84(uint256) (->allowed) := TMP_78(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_86(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_87(uint256) -> REF_86[_spender]\\nEmit Approval(msg.sender,_spender,REF_87)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 39.sol-TokenContract-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrevert()()\\n\\nIRs:\\nTMP_90(None) = SOLIDITY_CALL revert()()\\\"];\\n}\\n// Function: 39.sol-TokenContract-increaseApproval(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)\\n\\nIRs:\\nREF_72(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_73(uint256) -> REF_72[_spender]\\nREF_74(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_75(uint256) -> REF_74[_spender]\\nTMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_75', '_addedValue'] \\nREF_73(uint256) (->allowed) := TMP_75(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,allowed[msg.sender][_spender])\\n\\nIRs:\\nREF_77(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_78(uint256) -> REF_77[_spender]\\nEmit Approval(msg.sender,_spender,REF_78)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 39.sol-TokenContract-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = SDKTOKEN\\n\\nIRs:\\nname(string) := SDKTOKEN(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = SDK\\n\\nIRs:\\nsymbol(string) := SDK(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nINITIAL_SUPPLY = 100000000000000000000\\n\\nIRs:\\nINITIAL_SUPPLY(uint256) := 100000000000000000000(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nMAX_SUPPLY = 100 * 10000 * 10000 * (10 ** uint256(decimals))\\n\\nIRs:\\nTMP_91(uint256) = 100 * 10000\\nTMP_92(uint256) = TMP_91 * 10000\\nTMP_93 = CONVERT decimals to uint256\\nTMP_94(uint256) = 10 ** TMP_93\\nTMP_95(uint256) = TMP_92 * TMP_94\\nMAX_SUPPLY(uint256) := TMP_95(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: OTHER_ENTRYPOINT 5\\n\\nEXPRESSION:\\nholder = 0x968c9f1e66f40e2851de40e84e37d62566aab393\\n\\nIRs:\\nholder(address) := 859484581150152836533899141844855314259215299475(uint256)\\\"];\\n}\\n// Function: 39.sol-TokenContract-totalSupply()\\ndigraph{\\n}\\n// Function: 39.sol-TokenContract-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 39.sol-TokenContract-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 43.sol-Presale-close()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender == fiduciary\\n\\nIRs:\\nTMP_14(bool) = msg.sender == fiduciary\\nCONDITION TMP_14\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nmsg.sender.transfer(this.balance)\\n\\nIRs:\\nREF_10(uint256) = SOLIDITY_CALL balance(address)(this)\\nTransfer dest:msg.sender value:REF_10\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 43.sol-Presale-deposit()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.value >= 500000000000000000 && msg.sender != 0x0\\n\\nIRs:\\nTMP_0(bool) = msg.value >= 500000000000000000\\nTMP_1(bool) = msg.sender != 0\\nTMP_2(bool) = TMP_0 && TMP_1\\nCONDITION TMP_2\\\"];\\n1->2[label=\\\"True\\\"];\\n1->7[label=\\\"False\\\"];\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nnewDeposit.buyer = msg.sender\\n\\nIRs:\\nREF_0(address) -> newDeposit.buyer\\nREF_0(address) (->newDeposit) := msg.sender(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewDeposit.amount = msg.value\\n\\nIRs:\\nREF_1(uint256) -> newDeposit.amount\\nREF_1(uint256) (->newDeposit) := msg.value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nDeposits.push(newDeposit)\\n\\nIRs:\\nREF_3 -> LENGTH Deposits\\nTMP_4(uint256) := REF_3(uint256)\\nTMP_5(uint256) = TMP_4 + 1\\nREF_3(uint256) (->Deposits) := TMP_5(uint256)\\nREF_4(Presale.Deposit) -> Deposits[TMP_4]\\nREF_4(Presale.Deposit) (->Deposits) := newDeposit(Presale.Deposit)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ntotal[msg.sender] += msg.value\\n\\nIRs:\\nREF_5(uint256) -> total[msg.sender]\\nREF_5(-> total) = REF_5 + msg.value\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\nthis.balance >= 100000000000000000000\\n\\nIRs:\\nREF_6(uint256) = SOLIDITY_CALL balance(address)(this)\\nTMP_6(bool) = REF_6 >= 100000000000000000000\\nCONDITION TMP_6\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nisClosed = true\\n\\nIRs:\\nisClosed(bool) := True(bool)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n}\\n// Function: 43.sol-Presale-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n}\\n// Function: 43.sol-Presale-init(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrefundDate = date\\n\\nIRs:\\nrefundDate(uint256) := date(uint256)\\\"];\\n}\\n// Function: 43.sol-Presale-refund(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnow >= refundDate && isClosed == false\\n\\nIRs:\\nTMP_7(bool) = now >= refundDate\\nTMP_8(bool) = isClosed == False\\nTMP_9(bool) = TMP_7 && TMP_8\\nCONDITION TMP_9\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\namount <= total[msg.sender] && amount > 0\\n\\nIRs:\\nREF_7(uint256) -> total[msg.sender]\\nTMP_10(bool) = amount <= REF_7\\nTMP_11(bool) = amount > 0\\nTMP_12(bool) = TMP_10 && TMP_11\\nCONDITION TMP_12\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nmsg.sender.transfer(amount)\\n\\nIRs:\\nTransfer dest:msg.sender value:amount\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n}\\n// Function: 43.sol-Presale-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nfiduciary = msg.sender\\n\\nIRs:\\nfiduciary(address) := msg.sender(address)\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 45.sol-FlatPricingExt-FlatPricingExt(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_oneTokenInWei > 0)\\n\\nIRs:\\nTMP_39(bool) = _oneTokenInWei > 0\\nTMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\noneTokenInWei = _oneTokenInWei\\n\\nIRs:\\noneTokenInWei(uint256) := _oneTokenInWei(uint256)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 45.sol-FlatPricingExt-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 45.sol-FlatPricingExt-calculatePrice(uint256,uint256,uint256,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nmultiplier = 10 ** decimals\\n\\nIRs:\\nTMP_44(uint256) = 10 ** decimals\\nmultiplier(uint256) := TMP_44(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nvalue.times(multiplier) / oneTokenInWei\\n\\nIRs:\\nTMP_45(uint256) = LIBRARY_CALL, dest:SafeMathLibExt, function:SafeMathLibExt.times(uint256,uint256), arguments:['value', 'multiplier'] \\nTMP_46(uint256) = TMP_45 / oneTokenInWei\\nRETURN TMP_46\\\"];\\n}\\n// Function: 45.sol-FlatPricingExt-isPresalePurchase(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n}\\n// Function: 45.sol-FlatPricingExt-isPricingStrategy()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 45.sol-FlatPricingExt-isSane(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 45.sol-FlatPricingExt-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_47(bool) = msg.sender == owner\\nTMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 45.sol-FlatPricingExt-onlyTier()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender != address(tier)\\n\\nIRs:\\nTMP_49 = CONVERT tier to address\\nTMP_50(bool) = msg.sender != TMP_49\\nCONDITION TMP_50\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 45.sol-FlatPricingExt-setTier(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(_tier != address(0))\\n\\nIRs:\\nTMP_32 = CONVERT 0 to address\\nTMP_33(bool) = _tier != TMP_32\\nTMP_34(None) = SOLIDITY_CALL assert(bool)(TMP_33)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(tier == address(0))\\n\\nIRs:\\nTMP_35 = CONVERT 0 to address\\nTMP_36(bool) = tier == TMP_35\\nTMP_37(None) = SOLIDITY_CALL assert(bool)(TMP_36)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntier = _tier\\n\\nIRs:\\ntier(address) := _tier(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 45.sol-FlatPricingExt-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_27 = CONVERT 0 to address\\nTMP_28(bool) = newOwner != TMP_27\\nTMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 45.sol-FlatPricingExt-updateRate(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\noneTokenInWei = newOneTokenInWei\\n\\nIRs:\\noneTokenInWei(uint256) := newOneTokenInWei(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nRateChanged(newOneTokenInWei)\\n\\nIRs:\\nEmit RateChanged(newOneTokenInWei)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyTier()\\n\\nIRs:\\nMODIFIER_CALL, FlatPricingExt.onlyTier()()\\\"];\\n3->1;\\n}\\n// Function: 45.sol-Ownable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 45.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_5(bool) = msg.sender == owner\\nTMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 45.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_0 = CONVERT 0 to address\\nTMP_1(bool) = newOwner != TMP_0\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 45.sol-PricingStrategy-calculatePrice(uint256,uint256,uint256,address,uint256)\\ndigraph{\\n}\\n// Function: 45.sol-PricingStrategy-isPresalePurchase(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n}\\n// Function: 45.sol-PricingStrategy-isPricingStrategy()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 45.sol-PricingStrategy-isSane(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 45.sol-PricingStrategy-updateRate(uint256)\\ndigraph{\\n}\\n// Function: 45.sol-SafeMathLibExt-divides(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b > 0)\\n\\nIRs:\\nTMP_13(bool) = b > 0\\nTMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_15(uint256) = a / b\\nc(uint256) := TMP_15(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(a == b * c + a % b)\\n\\nIRs:\\nTMP_16(uint256) = b * c\\nTMP_17(uint256) = a % b\\nTMP_18(uint256) = TMP_16 + TMP_17\\nTMP_19(bool) = a == TMP_18\\nTMP_20(None) = SOLIDITY_CALL assert(bool)(TMP_19)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 45.sol-SafeMathLibExt-minus(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_21(bool) = b <= a\\nTMP_22(None) = SOLIDITY_CALL assert(bool)(TMP_21)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_23(uint256) = a - b\\nRETURN TMP_23\\\"];\\n}\\n// Function: 45.sol-SafeMathLibExt-plus(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_24(uint256) = a + b\\nc(uint256) := TMP_24(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_25(bool) = c >= a\\nTMP_26(None) = SOLIDITY_CALL assert(bool)(TMP_25)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 45.sol-SafeMathLibExt-times(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_7(uint256) = a * b\\nc(uint256) := TMP_7(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_8(bool) = a == 0\\nTMP_9(uint256) = c / a\\nTMP_10(bool) = TMP_9 == b\\nTMP_11(bool) = TMP_8 || TMP_10\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 47.sol-batchTransfer-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(myAddresses.length > 0)\\n\\nIRs:\\nREF_0 -> LENGTH myAddresses\\nTMP_0(bool) = REF_0 > 0\\nTMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ndistr = msg.value / myAddresses.length\\n\\nIRs:\\nREF_1 -> LENGTH myAddresses\\nTMP_2(uint256) = msg.value / REF_1\\ndistr(uint256) := TMP_2(uint256)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < myAddresses.length\\n\\nIRs:\\nREF_2 -> LENGTH myAddresses\\nTMP_3(bool) = i < REF_2\\nCONDITION TMP_3\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nmyAddresses[i].transfer(distr)\\n\\nIRs:\\nREF_3(address) -> myAddresses[i]\\nTransfer dest:REF_3 value:distr\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_5(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n8->6;\\n}\\n// Function: 47.sol-batchTransfer-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nmyAddresses = (0xEd08013f164dE7b7F008364850bc63662A2fBf23,0x94a1B74DB77eeF267EAb3541089Bdf20C8e519A1,0x4d12e1a980436F591B23A111306CB6A6c78Dd5D1,0x55cE473c9B262b3753dc23BF602f71D7E5d18C22,0x55AEcae2dFAE29EB9A0ca673b9c5d566b8218805,0x1485e03b520214Ca0E9a48E94e9b33F0Ca817E16,0x9aae67b59fc95FEa0010704776290836D94d7cFA,0xB2b78F6FA006bE85AD06425ceE0c87178D6aa952,0x0211BD8eC7BDf3Baf90b8bEb6C46d7DE1d8F03d4,0x8bb44cD72d8672b47b27399621d44262a3EF6Ea4,0xe86ca3b24F2428A9d4D951D38839CE3B7d22ADe8,0x2670362B6eF336dA3968bDC8A61dA4146855a7Bf,0xe94A7689Ef1033380907eE3DA547192075466cfE,0x097D31d05877aC409A38ee83205e5e574bef1fCB,0xdf7a4c36623c56d806930580158b825173C3A699,0x187feaEedD9a96603E6CDf97bcea5F4128ff65Fd,0xcEB05D550eF408Ded280f0992a8E6BfB832F49db,0x6AD07e1AE0baE076D33C816481d9b0B1b5E6a040,0xB0924f74700CbDe6ccA651d09976E21bC0D29DC3,0x7396b0A94F3976795C72715D9310Bf8C726e1ef7,0xEEfc87152ba264804Eb96c0DfF925C396cc4E701,0xeB84Ff451E865eb3946b492D49D38C91067e101b,0x747E4c5745fa31470e28c55a9a5d64E795022788,0xB0efA9d6B68F367EcdA9665DA74DB37A704ce9d5,0xA0430c674667d6859CE01210E6E4A8Ead55B747C,0xFEc6AfA0d2eBaB703E5920B7614b105F610e330a,0x9a0a6b4Aa07fc4b785BF074a1d040D9fC34E731a,0x79D907151A02592c204d69e4109F1dAe61AE9DE2,0xC98a75195ad0ee1c518a8e2d819ca1B321FF3845,0xDb1f214A72f80E114C3a9171e4F8F296FC3D3F92,0x007Cf59fa7078B31dE57d0DdA9957038Fe5A816F,0x2Ec8f3ea67b5F1f590072Eb544E4fE8A1C7D9998,0x97a3faa97Edcaef6aC5919283B9e19d05FE9B5d0,0x9720B0a5d366Edee5de6fD5DB8ad124fD460533B,0x478B26eB159a23Fd70e9a6b04f447C97C0161fA2,0x1910990502ADd9dDe6B933f9Eba0ff64802E8f3C,0xF0376B7cB58Db3D45BE371c2Df22b747b2ba5EEa,0x7Ba0b792e63DC26db7579102e62F208713972992,0x916fb7641328E54614754D5c98580CE378C8FAb0,0x44DD9c27edd39C8334730e68EFE6df95AeE30C9B,0x4c81397D4E62DC6f357C07d6D9c8c233BaDdbB20,0x7e74cDcad5B35ba98B9EB4fFca46fAfe6e6bb11F,0x7E5764071881E71c9cc8BC45E7534BF66A28cF32,0x231D5743e868BF40babd51c16eF7b58b6Fe2352e,0xE04CD6106278ED8B37E10828DA594a6c4c0fbe0b,0xd909659bCF62EC3406CDA3552c19B94fd732Dc9B,0x5E97c0d8FCE18fc24D6334B552f3837654660795,0x30b1eBF0f93DD5132Eae21b45502Ae6B2DcD4d1E,0xcd801049A95DAA4CCeA937D95DA628721F58c005,0x87A18c6b6433b1d2D2f0a8Fe36413a13DF06f337,0x0a064D62B8c67268A595c81c13376100417E4B1F,0xC77cf23bF4B03122256BC2e3987C42B1fa2cA387,0xeeE7935276cDA74e916DD1d3CF9D065711E96FfA,0xF10ab787daa75D5e4a0c8178a7937677a288C242,0x7D9D555B53936A5c358924146E07383172598550,0x937179645d90B7B1b9a0c00fe80712E85b166CDE,0x5a2B8315268158A9D85f66afA1bC1898e23D62f8,0x90ef731acd486Cf6C9bb51591A109538cc8A94B5,0xb82293EF17964dB37296A4cC417d138fF4e77856,0xa8397a554e3CADc47dB4a9e950101366d28C2d10,0xffffcd76b24A78F0a1fBc82fE74A79a5FD6F9fe8,0xf0d22491c3c5db9A8dEf861939C9965e7d452f0E,0x30Fcae99F0174d18478E0450554E640E5C2Ffc3a,0x181F3a55dd14C4CE7b0C868036C738984f027776,0x018a398089E5C83c13377124593D846881c8c4d2,0xC2027a38d61FB14359586D53CEFdA4dB12f32De4,0x219dC53E7DC5c29960b87Ed7073D2c98B2265cbE,0x25808D3004BFd7071c075ed0140fa37905F09bfC,0xE4b26Fd14858D04a9a091EE9D372758D62FBabBb,0xbDBA873C20c13180b7de0142b284481bdDf879bF,0x08d9916FeCb55046ab50110b3A949a42287224BA,0xfC571Da17A9d3c04Dd0a39DEA7E03e5D2629A7CA,0xC81534B70B7B61aF516dB6d1ac33C2139304C37A,0x1Db51B53F67077d5A463664aa675485384Ca089B,0x59c69F83e0fc83200c966937DD4D93f1c288b45A,0x28a565D50493eacdD67E9A611A62C1b748db5aFa,0x575A736f196CA5457c92DEC7a104763B33B4A5c0,0xa7bA2528637d8836D5Fec116E00ea72A16Afa8d0,0x0030aAc0FB60272A5aE4f3038e729E45b69aAbAa,0xB7bC4db261d4F8c492a42cff9cd7B4Bc973e9D49,0x62a5C6b6643857195ABB5075944135932fc289A3,0x45c6ba2400F2440FC892C652e1d99260b12Ec263,0xc0408a4FB1175d4D858bfd1eC39302DdccC885E5,0xD3791835189d7C1a34616d6aC4eE22862a4bF28d,0x8b9dbbC2f79aC8A2d0a0230B5Fad1d8452304192,0xdB2E3377bE2C5B34F0EB27B1bA72C9E983C3FEc5,0x2120e52b0ab220ad74Db8ab139da5cE0994fa425,0xdE25F401024cc0d7915a3E4Bef83d18ddf9bE5ca,0x9A365AA5EDf519b16cf09DB968808752CB37c0D2,0x6D715BB64B3Bd31a709F2Beea4A315E63d7fAdB5,0xf3a2bb5deB2F30F08839C3e34c6959703106a10C,0x5DeCF60C259C5fD02FEe56BEa42133f11f971B01,0xDF97f6b4F917D9547FC3Df2098A024CaC2d3F5F7,0x38b3B4Cf3362C91bb5e46aa00E734F3010968826,0x6d97509b96D0BC26e174746E07F9033fF5409876,0xE3D64e497cc1c8cD2Fa9983d7e224FB98333f662,0x96a0b95Fa91578267Fc1735c39DffaAFE0aA08f3,0x20E82D96586A9C624677cc7b751109c326275d18,0x07ea7DA3e2683882046c275803Af0949bCa46E35,0xe7c4Be518EA3Afe0D864615463d6Ed95c7C80C4f,0xD3D148a048e7Fb2C2C17E7bF4626c548e9BEa6be,0x3537925B962B61F50aE4AE1b7f3457bcC915c453,0x60BEcE33bEC4de1e71C27B61dD5b474FE3178A16,0xA50f2582a202C091CB9393B3dD1ED44eb7B0F905,0x25438cd57C75Cd3118C01D6ad5CD2eD06Ba7e2B8,0xC2ab18709d09E337600Ffb4b0E59405B1E525Ed6,0xce6F79184A7E98557CE1Fe840Bfbb0f40C6c2562)\\n\\nIRs:\\nmyAddresses(address[]) = ['1353209327226560782582791074283777677798434389795(address)', '848537022052867248128273093761044801016994011553(address)', '440013360709555176033758239781741434052407055825(address)', '489864374626395361315194873041248846308489399330(address)', '489162219067465980646869030248070530649471158277(address)', '117165347865597227897985697354847959267571498518(address)', '883073942740367847520487233720760839455588056314(address)', '1020293888618917006643297088833515179357258819922(address)', '11813607017662563808259401202419717593407357908(address)', '797570545035202261897641242645131487164570234532(address)', '1326908599290637024874357897529140156825753267688(address)', '219444051596601344578974318925161880580139624383(address)', '1331855430932839697721263253311142099624476962046(address)', '54172849485567300066098332641281877123106021323(address)', '1275832271847493220237658123272821611378260551321(address)', '139868438696658947572984714534131701062320481789(address)', '1179985160331121465935193413954693924618580740571(address)', '609802562002707691863187716893888252188182356032(address)', '1008045205956264093883485856592319504991286107587(address)', '659894439799872513727548742862164747033338846967(address)', '1364371358608634011088523454797986933474284857089(address)', '1344578766662778775283988852645843967575288844315(address)', '665059473541892784618714753786797195359663826824(address)', '1010127048806856662738516281853546180809786714581(address)', '914933753750215966910331950220061396503719801980(address)', '1454514502714142613992040193842135450016721810186(address)', '879416932567686334378205963583293125492611117850(address)', '695627761944269076429973784811867671657934921186(address)', '1150594848538217506161040771318785214099341916229(address)', '1250963201950726171826633677299484788628154826642(address)', '2786689241587663539211943015049813997957841263(address)', '267094972547013216795997301295359314820679440792(address)', '865714463609591790892052239763503036040336750032(address)', '862786618430668827064618046576429838625247613755(address)', '408441538573024127738841794449020274557209419682(address)', '143094911078493014210332133187699631102679224124(address)', '1371393689434574895101750443033420869411242925802(address)', '705789975578691356384450125591400657338158754194(address)', '830295020088523508419855922289004110345000254128(address)', '393153440208639803966405810394331138283838573723(address)', '436765102753009329382695175840868534998630513440(address)', '721937650606544304589834943099069318785087025439(address)', '721281715599221654435041946165325276686800441138(address)', '200469000466311191227617767733790655000357254446(address)', '1280527436904227885385809048314708915891431521803(address)', '1239060555335869763887489611287015976065905646747(address)', '540029344378445829772107942314411094687340693397(address)', '277999342285945064874278081219090075122045635870(address)', '1173199022266612584612791223281041946511914090501(address)', '774316406301616686480181422218390366334885491511(address)', '57230453418726629260226098356092502176297798431(address)', '1138875557373663468669034815901961363254923797383(address)', '1363904109164037154732222340375174008760475152378(address)', '1376105770997616388414376333161988069716721713730(address)', '717132498970240186318059304933769443568143402320(address)', '841752202257742425678373760605323142544282250462(address)', '514779520324251408351233902536828786672351929080(address)', '827434576134173197355684541547904013433194583221(address)', '1051225414033206840900937778077396186544346724438(address)', '960392248701600994527316837452179794072244595984(address)', '1461497234994628961273134060139812517523577872360(address)', '1374844127132876459332590648248204256112443469582(address)', '279666554709663984866645945182228668246859447354(address)', '137712183331379052990060655516884969869728184182(address)', '8791502747959474376642925582955099303298254034(address)', '1107599458069537498893182204683513109631789641188(address)', '191915094818371646893240395914275756308659854526(address)', '214099453078076974523022544403444024293832301564(address)', '1305629169072092536779685112201188559311188241339(address)', '1083158974911713582068988993236330075978496244159(address)', '50523857242113935803904955958142603403633763514(address)', '1440608420284615043060758357691312262955986954186(address)', '1142271061939740787748260238540535160490118398842(address)', '169599547837556055700393427609963410460819196059(address)', '512529621882142186959956271032022452136267265114(address)', '232048124617819337745830874198338081814012975866(address)', '498699319847561495401781708847696912188183979456(address)', '957552634232627419860203818167569539634740308176(address)', '1085310526487799783029654644823593158927100842(address)', '1048944619504405375688143400499903071777730764105(address)', '563178028795714429113827093565442420965283891619(address)', '398352125872760423407887312517900215777418461795(address)', '1097565524304043388689666564275900996015666791909(address)', '1207297551575399333669539292746886990422283645581(address)', '797067290482054421586351054720160823154240930194(address)', '1251299296562521077990433900925419104958582881989(address)', '189130282643377006515472357467841489404689359909(address)', '1268242334436344705711616746410569771852028962250(address)', '880396715516216009607297972628246477301505048786(address)', '624807967476645765231387000894280063069349457333(address)', '1390913799988697937725368910324482794182469394700(address)', '536220551309191296364198840917391421344750967553(address)', '1276493845622961198543742858565172036280587122167(address)', '323711067274893216215000049832430730525913024550(address)', '625654428471886059088741342441670361938701359222(address)', '1300720084214243045390430232050812120556729792098(address)', '859932883179814067933442042382667489428703414515(address)', '187865448765169555634309671413284856382710308120(address)', '45192254574936992665197968259095115564195278389(address)', '1323164393206017974301634023049989690227692145743(address)', '1209264235016997764593018429744261616974813898430(address)', '303815801398633560799208728399178721598851368019(address)', '552318218325687582792335088436670604491267475990(address)', '942321255970547881381322724283451205405669128453(address)', '212739076814394146735119209423981239617184064184(address)', '1111359765984001196153677401225924755588318912214(address)', '1178538030359142581044667551254108470774286001506(address)']\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 48.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 48.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 48.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 48.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 48.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 48.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 48.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 48.sol-ForeignToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 48.sol-ForeignToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 48.sol-OoredooChain-OOREDOOCHAIN()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[owner] = totalDistributed\\n\\nIRs:\\nREF_0(uint256) -> balances[owner]\\nREF_0(uint256) (->balances) := totalDistributed(uint256)\\\"];\\n}\\n// Function: 48.sol-OoredooChain-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_35(mapping(address => uint256)) -> allowed[_owner]\\nREF_36(uint256) -> REF_35[_spender]\\nRETURN REF_36\\\"];\\n}\\n// Function: 48.sol-OoredooChain-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_value != 0 && allowed[msg.sender][_spender] != 0\\n\\nIRs:\\nTMP_61(bool) = _value != 0\\nREF_31(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_32(uint256) -> REF_31[_spender]\\nTMP_62(bool) = REF_32 != 0\\nTMP_63(bool) = TMP_61 && TMP_62\\nCONDITION TMP_63\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_33(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_34(uint256) -> REF_33[_spender]\\nREF_34(uint256) (->allowed) := _value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 48.sol-OoredooChain-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_9(uint256) -> balances[_owner]\\nRETURN REF_9\\\"];\\n}\\n// Function: 48.sol-OoredooChain-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_39(uint256) -> balances[msg.sender]\\nTMP_71(bool) = _value <= REF_39\\nTMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nburner = msg.sender\\n\\nIRs:\\nburner(address) := msg.sender(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[burner] = balances[burner].sub(_value)\\n\\nIRs:\\nREF_40(uint256) -> balances[burner]\\nREF_41(uint256) -> balances[burner]\\nTMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_41', '_value'] \\nREF_40(uint256) (->balances) := TMP_73(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalSupply = totalSupply.sub(_value)\\n\\nIRs:\\nTMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] \\ntotalSupply(uint256) := TMP_74(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.sub(_value)\\n\\nIRs:\\nTMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDistributed', '_value'] \\ntotalDistributed(uint256) := TMP_75(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(burner,_value)\\n\\nIRs:\\nEmit Burn(burner,_value)\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.onlyOwner()()\\\"];\\n7->1;\\n}\\n// Function: 48.sol-OoredooChain-canDistr()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! distributionFinished)\\n\\nIRs:\\nTMP_84 = UnaryType.BANG distributionFinished \\nTMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 48.sol-OoredooChain-distr(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->10;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.add(_amount)\\n\\nIRs:\\nTMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDistributed', '_amount'] \\ntotalDistributed(uint256) := TMP_19(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalRemaining = totalRemaining.sub(_amount)\\n\\nIRs:\\nTMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalRemaining', '_amount'] \\ntotalRemaining(uint256) := TMP_20(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_3(uint256) -> balances[_to]\\nREF_4(uint256) -> balances[_to]\\nTMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_4', '_amount'] \\nREF_3(uint256) (->balances) := TMP_21(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nDistr(_to,_amount)\\n\\nIRs:\\nEmit Distr(_to,_amount)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(address(0),_to,_amount)\\n\\nIRs:\\nTMP_23 = CONVERT 0 to address\\nEmit Transfer(TMP_23,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_25(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_25\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n8->9;\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.canDistr()()\\\"];\\n10->1;\\n}\\n// Function: 48.sol-OoredooChain-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ngetTokens()\\n\\nIRs:\\nINTERNAL_CALL, OoredooChain.getTokens()()\\\"];\\n}\\n// Function: 48.sol-OoredooChain-finishDistribution()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nDistrFinished()\\n\\nIRs:\\nEmit DistrFinished()\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.onlyOwner()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.canDistr()()\\\"];\\n5->1;\\n}\\n// Function: 48.sol-OoredooChain-getTokenBalance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nt = ForeignToken(tokenAddress)\\n\\nIRs:\\nTMP_65 = CONVERT tokenAddress to ForeignToken\\nt(ForeignToken) := TMP_65(ForeignToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nbal = t.balanceOf(who)\\n\\nIRs:\\nTMP_66(uint256) = HIGH_LEVEL_CALL, dest:t(ForeignToken), function:balanceOf, arguments:['who']  \\nbal(uint256) := TMP_66(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nbal\\n\\nIRs:\\nRETURN bal\\\"];\\n}\\n// Function: 48.sol-OoredooChain-getTokens()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->15;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nvalue > totalRemaining\\n\\nIRs:\\nTMP_28(bool) = value > totalRemaining\\nCONDITION TMP_28\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nvalue = totalRemaining\\n\\nIRs:\\nvalue(uint256) := totalRemaining(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(value <= totalRemaining)\\n\\nIRs:\\nTMP_29(bool) = value <= totalRemaining\\nTMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ninvestor = msg.sender\\n\\nIRs:\\ninvestor(address) := msg.sender(address)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\ntoGive = value\\n\\nIRs:\\ntoGive(uint256) := value(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ndistr(investor,toGive)\\n\\nIRs:\\nTMP_31(bool) = INTERNAL_CALL, OoredooChain.distr(address,uint256)(investor,toGive)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\ntoGive > 0\\n\\nIRs:\\nTMP_32(bool) = toGive > 0\\nCONDITION TMP_32\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nblacklist[investor] = true\\n\\nIRs:\\nREF_6(bool) -> blacklist[investor]\\nREF_6(bool) (->blacklist) := True(bool)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: IF 11\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_33(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_33\\\"];\\n11->12[label=\\\"True\\\"];\\n11->13[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n12->13;\\n13[label=\\\"Node Type: END_IF 13\\n\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nvalue = value.div(100000).mul(99999)\\n\\nIRs:\\nTMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['value', '100000'] \\nTMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_34', '99999'] \\nvalue(uint256) := TMP_35(uint256)\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.canDistr()()\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nonlyWhitelist()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.onlyWhitelist()()\\\"];\\n16->1;\\n}\\n// Function: 48.sol-OoredooChain-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_86(bool) = msg.sender == owner\\nTMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 48.sol-OoredooChain-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(msg.data.length >= size + 4)\\n\\nIRs:\\nREF_49 -> LENGTH msg.data\\nTMP_90(uint256) = size + 4\\nTMP_91(bool) = REF_49 >= TMP_90\\nTMP_92(None) = SOLIDITY_CALL assert(bool)(TMP_91)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 48.sol-OoredooChain-onlyWhitelist()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(blacklist[msg.sender] == false)\\n\\nIRs:\\nREF_48(bool) -> blacklist[msg.sender]\\nTMP_88(bool) = REF_48 == False\\nTMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 48.sol-OoredooChain-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = Ooredoo Chain\\n\\nIRs:\\nname(string) := Ooredoo Chain(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = ORED\\n\\nIRs:\\nsymbol(string) := ORED(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint256) := 18(uint256)\\\"];\\n}\\n// Function: 48.sol-OoredooChain-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ntotalSupply = 1000000000e18\\n\\nIRs:\\ntotalSupply(uint256) := 1000000000000000000000000000(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ntotalDistributed = 500000000e18\\n\\nIRs:\\ntotalDistributed(uint256) := 500000000000000000000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\ntotalRemaining = totalSupply.sub(totalDistributed)\\n\\nIRs:\\nTMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', 'totalDistributed'] \\ntotalRemaining(uint256) := TMP_83(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nvalue = 10000e18\\n\\nIRs:\\nvalue(uint256) := 10000000000000000000000(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: OTHER_ENTRYPOINT 5\\n\\nEXPRESSION:\\ndistributionFinished = false\\n\\nIRs:\\ndistributionFinished(bool) := False(bool)\\\"];\\n}\\n// Function: 48.sol-OoredooChain-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_38 = CONVERT 0 to address\\nTMP_39(bool) = _to != TMP_38\\nTMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[msg.sender])\\n\\nIRs:\\nREF_10(uint256) -> balances[msg.sender]\\nTMP_41(bool) = _amount <= REF_10\\nTMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_amount)\\n\\nIRs:\\nREF_11(uint256) -> balances[msg.sender]\\nREF_12(uint256) -> balances[msg.sender]\\nTMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_12', '_amount'] \\nREF_11(uint256) (->balances) := TMP_43(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_14(uint256) -> balances[_to]\\nREF_15(uint256) -> balances[_to]\\nTMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_15', '_amount'] \\nREF_14(uint256) (->balances) := TMP_44(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_amount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_46(uint256) = 2 * 32\\nMODIFIER_CALL, OoredooChain.onlyPayloadSize(uint256)(TMP_46)\\\"];\\n7->1;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 48.sol-OoredooChain-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_48 = CONVERT 0 to address\\nTMP_49(bool) = _to != TMP_48\\nTMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[_from])\\n\\nIRs:\\nREF_17(uint256) -> balances[_from]\\nTMP_51(bool) = _amount <= REF_17\\nTMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_18(mapping(address => uint256)) -> allowed[_from]\\nREF_19(uint256) -> REF_18[msg.sender]\\nTMP_53(bool) = _amount <= REF_19\\nTMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_amount)\\n\\nIRs:\\nREF_20(uint256) -> balances[_from]\\nREF_21(uint256) -> balances[_from]\\nTMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_21', '_amount'] \\nREF_20(uint256) (->balances) := TMP_55(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount)\\n\\nIRs:\\nREF_23(mapping(address => uint256)) -> allowed[_from]\\nREF_24(uint256) -> REF_23[msg.sender]\\nREF_25(mapping(address => uint256)) -> allowed[_from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nTMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_26', '_amount'] \\nREF_24(uint256) (->allowed) := TMP_56(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_28(uint256) -> balances[_to]\\nREF_29(uint256) -> balances[_to]\\nTMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_29', '_amount'] \\nREF_28(uint256) (->balances) := TMP_57(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyPayloadSize(3 * 32)\\n\\nIRs:\\nTMP_59(uint256) = 3 * 32\\nMODIFIER_CALL, OoredooChain.onlyPayloadSize(uint256)(TMP_59)\\\"];\\n9->1;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 48.sol-OoredooChain-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_13 = CONVERT 0 to address\\nTMP_14(bool) = newOwner != TMP_13\\nCONDITION TMP_14\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 48.sol-OoredooChain-withdraw()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\netherBalance = address(this).balance\\n\\nIRs:\\nTMP_67 = CONVERT this to address\\nTMP_68(uint256) = SOLIDITY_CALL balance(address)(TMP_67)\\netherBalance(uint256) := TMP_68(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner.transfer(etherBalance)\\n\\nIRs:\\nTransfer dest:owner value:etherBalance\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 48.sol-OoredooChain-withdrawForeignTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntoken = ForeignToken(_tokenContract)\\n\\nIRs:\\nTMP_78 = CONVERT _tokenContract to ForeignToken\\ntoken(ForeignToken) := TMP_78(ForeignToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\namount = token.balanceOf(address(this))\\n\\nIRs:\\nTMP_79 = CONVERT this to address\\nTMP_80(uint256) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:balanceOf, arguments:['TMP_79']  \\namount(uint256) := TMP_80(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntoken.transfer(owner,amount)\\n\\nIRs:\\nTMP_81(bool) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:transfer, arguments:['owner', 'amount']  \\nRETURN TMP_81\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, OoredooChain.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 48.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_10(uint256) = a + b\\nc(uint256) := TMP_10(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_11(bool) = c >= a\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 48.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_6(uint256) = a / b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 48.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_0(uint256) = a * b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_1(bool) = a == 0\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(bool) = TMP_1 || TMP_3\\nTMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 48.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_7(bool) = b <= a\\nTMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_9(uint256) = a - b\\nRETURN TMP_9\\\"];\\n}\\n// Function: 48.sol-Token-balanceOf(address)\\ndigraph{\\n}\\n// Function: 48.sol-Token-distr(address,uint256)\\ndigraph{\\n}\\n// Function: 48.sol-Token-totalSupply()\\ndigraph{\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 51.sol-CrowdsaleTokenExt-CrowdsaleTokenExt(string,string,uint256,uint256,bool,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->17;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = _name\\n\\nIRs:\\nname(string) := _name(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsymbol = _symbol\\n\\nIRs:\\nsymbol(string) := _symbol(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalSupply = _initialSupply\\n\\nIRs:\\ntotalSupply(uint256) := _initialSupply(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ndecimals = _decimals\\n\\nIRs:\\ndecimals(uint256) := _decimals(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nminCap = _globalMinCap\\n\\nIRs:\\nminCap(uint256) := _globalMinCap(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbalances[owner] = totalSupply\\n\\nIRs:\\nREF_170(uint256) -> balances[owner]\\nREF_170(uint256) (->balances) := totalSupply(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\ntotalSupply > 0\\n\\nIRs:\\nTMP_377(bool) = totalSupply > 0\\nCONDITION TMP_377\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nMinted(owner,totalSupply)\\n\\nIRs:\\nEmit Minted(owner,totalSupply)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: IF 11\\n\\nEXPRESSION:\\n! _mintable\\n\\nIRs:\\nTMP_379 = UnaryType.BANG _mintable \\nCONDITION TMP_379\\\"];\\n11->12[label=\\\"True\\\"];\\n11->16[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nmintingFinished = true\\n\\nIRs:\\nmintingFinished(bool) := True(bool)\\\"];\\n12->13;\\n13[label=\\\"Node Type: IF 13\\n\\nEXPRESSION:\\ntotalSupply == 0\\n\\nIRs:\\nTMP_380(bool) = totalSupply == 0\\nCONDITION TMP_380\\\"];\\n13->14[label=\\\"True\\\"];\\n13->15[label=\\\"False\\\"];\\n14[label=\\\"Node Type: THROW 14\\n\\\"];\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: END_IF 16\\n\\\"];\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nUpgradeableToken(msg.sender)\\n\\nIRs:\\nINTERNAL_CALL, UpgradeableToken.UpgradeableToken(address)(msg.sender)\\\"];\\n17->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-UpgradeableToken(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nupgradeMaster = _upgradeMaster\\n\\nIRs:\\nupgradeMaster(address) := _upgradeMaster(address)\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-allowance(address,address)\\ndigraph{\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-areTokensDistributedForAddress(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].isDistributed\\n\\nIRs:\\nREF_140(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_141(bool) -> REF_140.isDistributed\\nRETURN REF_141\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nisDistributed\\n\\nIRs:\\nRETURN isDistributed\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-balanceOf(address)\\ndigraph{\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-canMint()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmintingFinished\\n\\nIRs:\\nCONDITION mintingFinished\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-canTransfer(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! released\\n\\nIRs:\\nTMP_399 = UnaryType.BANG released \\nCONDITION TMP_399\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n! transferAgents[_sender]\\n\\nIRs:\\nREF_174(bool) -> transferAgents[_sender]\\nTMP_400 = UnaryType.BANG REF_174 \\nCONDITION TMP_400\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: THROW 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: _ 6\\n\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-canUpgrade()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreleased && super.canUpgrade()\\n\\nIRs:\\nTMP_384(bool) = INTERNAL_CALL, UpgradeableToken.canUpgrade()()\\nTMP_385(bool) = released && TMP_384\\nRETURN TMP_385\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-claimTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_token != address(0))\\n\\nIRs:\\nTMP_388 = CONVERT 0 to address\\nTMP_389(bool) = _token != TMP_388\\nTMP_390(None) = SOLIDITY_CALL require(bool)(TMP_389)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ntoken = ERC20(_token)\\n\\nIRs:\\nTMP_391 = CONVERT _token to ERC20\\ntoken(ERC20) := TMP_391(ERC20)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_392(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_392(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntoken.transfer(owner,balance)\\n\\nIRs:\\nTMP_393(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['owner', 'balance']  \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nClaimedTokens(_token,owner,balance)\\n\\nIRs:\\nEmit ClaimedTokens(_token,owner,balance)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-finalizeReservedAddress(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nreservedTokensData = reservedTokensList[addr]\\n\\nIRs:\\nREF_136(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nreservedTokensData(MintableTokenExt.ReservedTokensData) := REF_136(MintableTokenExt.ReservedTokensData)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nreservedTokensData.isDistributed = true\\n\\nIRs:\\nREF_137(bool) -> reservedTokensData.isDistributed\\nREF_137(bool) (->reservedTokensData) := True(bool)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyMintAgent()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.onlyMintAgent()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-getReservedPercentageDecimals(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].inPercentageDecimals\\n\\nIRs:\\nREF_146(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_147(uint256) -> REF_146.inPercentageDecimals\\nRETURN REF_147\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ninPercentageDecimals\\n\\nIRs:\\nRETURN inPercentageDecimals\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-getReservedPercentageUnit(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].inPercentageUnit\\n\\nIRs:\\nREF_144(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_145(uint256) -> REF_144.inPercentageUnit\\nRETURN REF_145\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ninPercentageUnit\\n\\nIRs:\\nRETURN inPercentageUnit\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-getReservedTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].inTokens\\n\\nIRs:\\nREF_142(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_143(uint256) -> REF_142.inTokens\\nRETURN REF_143\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ninTokens\\n\\nIRs:\\nRETURN inTokens\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-getUpgradeState()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! canUpgrade()\\n\\nIRs:\\nTMP_282(bool) = INTERNAL_CALL, CrowdsaleTokenExt.canUpgrade()()\\nTMP_283 = UnaryType.BANG TMP_282 \\nCONDITION TMP_283\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nUpgradeState.NotAllowed\\n\\nIRs:\\nREF_113(UpgradeableToken.UpgradeState) -> UpgradeState.NotAllowed\\nRETURN REF_113\\\"];\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\naddress(upgradeAgent) == 0x00\\n\\nIRs:\\nTMP_284 = CONVERT upgradeAgent to address\\nTMP_285(bool) = TMP_284 == 0\\nCONDITION TMP_285\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nUpgradeState.WaitingForAgent\\n\\nIRs:\\nREF_114(UpgradeableToken.UpgradeState) -> UpgradeState.WaitingForAgent\\nRETURN REF_114\\\"];\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\ntotalUpgraded == 0\\n\\nIRs:\\nTMP_286(bool) = totalUpgraded == 0\\nCONDITION TMP_286\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nUpgradeState.ReadyToUpgrade\\n\\nIRs:\\nREF_115(UpgradeableToken.UpgradeState) -> UpgradeState.ReadyToUpgrade\\nRETURN REF_115\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nUpgradeState.Upgrading\\n\\nIRs:\\nREF_116(UpgradeableToken.UpgradeState) -> UpgradeState.Upgrading\\nRETURN REF_116\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-inReleaseState(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nreleaseState != released\\n\\nIRs:\\nTMP_401(bool) = releaseState != released\\nCONDITION TMP_401\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-isAddressReserved(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].isReserved\\n\\nIRs:\\nREF_138(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_139(bool) -> REF_138.isReserved\\nRETURN REF_139\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nisReserved\\n\\nIRs:\\nRETURN isReserved\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-isToken()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nweAre\\n\\nIRs:\\nRETURN weAre\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-max256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_324(bool) = a >= b\\nCONDITION TMP_324\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-max64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_322(bool) = a >= b\\nCONDITION TMP_322\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-min256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_325(bool) = a < b\\nCONDITION TMP_325\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-min64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_323(bool) = a < b\\nCONDITION TMP_323\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-mint(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = totalSupply.plus(amount)\\n\\nIRs:\\nTMP_343(uint256) = LIBRARY_CALL, dest:SafeMathLibExt, function:SafeMathLibExt.plus(uint256,uint256), arguments:['totalSupply', 'amount'] \\ntotalSupply(uint256) := TMP_343(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[receiver] = balances[receiver].plus(amount)\\n\\nIRs:\\nREF_161(uint256) -> balances[receiver]\\nREF_162(uint256) -> balances[receiver]\\nTMP_344(uint256) = LIBRARY_CALL, dest:SafeMathLibExt, function:SafeMathLibExt.plus(uint256,uint256), arguments:['REF_162', 'amount'] \\nREF_161(uint256) (->balances) := TMP_344(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(0,receiver,amount)\\n\\nIRs:\\nEmit Transfer(0,receiver,amount)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyMintAgent()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.onlyMintAgent()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n5->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-onlyMintAgent()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! mintAgents[msg.sender]\\n\\nIRs:\\nREF_173(bool) -> mintAgents[msg.sender]\\nTMP_396 = UnaryType.BANG REF_173 \\nCONDITION TMP_396\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_397(bool) = msg.sender == owner\\nTMP_398(None) = SOLIDITY_CALL require(bool)(TMP_397)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-onlyReleaseAgent()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender != releaseAgent\\n\\nIRs:\\nTMP_402(bool) = msg.sender != releaseAgent\\nCONDITION TMP_402\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-releaseTokenTransfer()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nmintingFinished = true\\n\\nIRs:\\nmintingFinished(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nsuper.releaseTokenTransfer()\\n\\nIRs:\\nINTERNAL_CALL, ReleasableToken.releaseTokenTransfer()()\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyReleaseAgent()\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.onlyReleaseAgent()()\\\"];\\n3->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_317(uint256) = a + b\\nc(uint256) := TMP_317(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a && c >= b)\\n\\nIRs:\\nTMP_318(bool) = c >= a\\nTMP_319(bool) = c >= b\\nTMP_320(bool) = TMP_318 && TMP_319\\nTMP_321(None) = SOLIDITY_CALL assert(bool)(TMP_320)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b > 0)\\n\\nIRs:\\nTMP_306(bool) = b > 0\\nTMP_307(None) = SOLIDITY_CALL assert(bool)(TMP_306)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_308(uint256) = a / b\\nc(uint256) := TMP_308(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(a == b * c + a % b)\\n\\nIRs:\\nTMP_309(uint256) = b * c\\nTMP_310(uint256) = a % b\\nTMP_311(uint256) = TMP_309 + TMP_310\\nTMP_312(bool) = a == TMP_311\\nTMP_313(None) = SOLIDITY_CALL assert(bool)(TMP_312)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_300(uint256) = a * b\\nc(uint256) := TMP_300(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_301(bool) = a == 0\\nTMP_302(uint256) = c / a\\nTMP_303(bool) = TMP_302 == b\\nTMP_304(bool) = TMP_301 || TMP_303\\nTMP_305(None) = SOLIDITY_CALL assert(bool)(TMP_304)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_314(bool) = b <= a\\nTMP_315(None) = SOLIDITY_CALL assert(bool)(TMP_314)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_316(uint256) = a - b\\nRETURN TMP_316\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setMintAgent(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nmintAgents[addr] = state\\n\\nIRs:\\nREF_164(bool) -> mintAgents[addr]\\nREF_164(bool) (->mintAgents) := state(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nMintingAgentChanged(addr,state)\\n\\nIRs:\\nEmit MintingAgentChanged(addr,state)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setReleaseAgent(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nreleaseAgent = addr\\n\\nIRs:\\nreleaseAgent(address) := addr(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ninReleaseState(false)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.inReleaseState(bool)(False)\\\"];\\n3->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setReservedTokensList(address,uint256,uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(addr != address(0))\\n\\nIRs:\\nTMP_351 = CONVERT 0 to address\\nTMP_352(bool) = addr != TMP_351\\nTMP_353(None) = SOLIDITY_CALL assert(bool)(TMP_352)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n! isAddressReserved(addr)\\n\\nIRs:\\nTMP_354(bool) = INTERNAL_CALL, MintableTokenExt.isAddressReserved(address)(addr)\\nTMP_355 = UnaryType.BANG TMP_354 \\nCONDITION TMP_355\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nreservedTokensDestinations.push(addr)\\n\\nIRs:\\nREF_166 -> LENGTH reservedTokensDestinations\\nTMP_357(uint256) := REF_166(uint256)\\nTMP_358(uint256) = TMP_357 + 1\\nREF_166(uint256) (->reservedTokensDestinations) := TMP_358(uint256)\\nREF_167(address) -> reservedTokensDestinations[TMP_357]\\nREF_167(address) (->reservedTokensDestinations) := addr(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nreservedTokensDestinationsLen ++\\n\\nIRs:\\nTMP_359(uint256) := reservedTokensDestinationsLen(uint256)\\nreservedTokensDestinationsLen(uint256) = reservedTokensDestinationsLen + 1\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nreservedTokensList[addr] = ReservedTokensData(inTokens,inPercentageUnit,inPercentageDecimals,true,false)\\n\\nIRs:\\nREF_168(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nTMP_360(MintableTokenExt.ReservedTokensData) = new ReservedTokensData(inTokens,inPercentageUnit,inPercentageDecimals,True,False)\\nREF_168(MintableTokenExt.ReservedTokensData) (->reservedTokensList) := TMP_360(MintableTokenExt.ReservedTokensData)\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n8->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setReservedTokensListMultiple(address[],uint256[],uint256[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->14;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(! reservedTokensDestinationsAreSet)\\n\\nIRs:\\nTMP_328 = UnaryType.BANG reservedTokensDestinationsAreSet \\nTMP_329(None) = SOLIDITY_CALL assert(bool)(TMP_328)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(addrs.length == inTokens.length)\\n\\nIRs:\\nREF_148 -> LENGTH addrs\\nREF_149 -> LENGTH inTokens\\nTMP_330(bool) = REF_148 == REF_149\\nTMP_331(None) = SOLIDITY_CALL assert(bool)(TMP_330)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(inTokens.length == inPercentageUnit.length)\\n\\nIRs:\\nREF_150 -> LENGTH inTokens\\nREF_151 -> LENGTH inPercentageUnit\\nTMP_332(bool) = REF_150 == REF_151\\nTMP_333(None) = SOLIDITY_CALL assert(bool)(TMP_332)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nassert(bool)(inPercentageUnit.length == inPercentageDecimals.length)\\n\\nIRs:\\nREF_152 -> LENGTH inPercentageUnit\\nREF_153 -> LENGTH inPercentageDecimals\\nTMP_334(bool) = REF_152 == REF_153\\nTMP_335(None) = SOLIDITY_CALL assert(bool)(TMP_334)\\\"];\\n4->7;\\n5[label=\\\"Node Type: BEGIN_LOOP 5\\n\\\"];\\n5->8;\\n6[label=\\\"Node Type: END_LOOP 6\\n\\\"];\\n6->13;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\niterator = 0\\n\\nIRs:\\niterator(uint256) := 0(uint256)\\\"];\\n7->5;\\n8[label=\\\"Node Type: IF_LOOP 8\\n\\nEXPRESSION:\\niterator < addrs.length\\n\\nIRs:\\nREF_154 -> LENGTH addrs\\nTMP_336(bool) = iterator < REF_154\\nCONDITION TMP_336\\\"];\\n8->9[label=\\\"True\\\"];\\n8->6[label=\\\"False\\\"];\\n9[label=\\\"Node Type: IF 9\\n\\nEXPRESSION:\\naddrs[iterator] != address(0)\\n\\nIRs:\\nREF_155(address) -> addrs[iterator]\\nTMP_337 = CONVERT 0 to address\\nTMP_338(bool) = REF_155 != TMP_337\\nCONDITION TMP_338\\\"];\\n9->10[label=\\\"True\\\"];\\n9->11[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nsetReservedTokensList(addrs[iterator],inTokens[iterator],inPercentageUnit[iterator],inPercentageDecimals[iterator])\\n\\nIRs:\\nREF_156(address) -> addrs[iterator]\\nREF_157(uint256) -> inTokens[iterator]\\nREF_158(uint256) -> inPercentageUnit[iterator]\\nREF_159(uint256) -> inPercentageDecimals[iterator]\\nINTERNAL_CALL, MintableTokenExt.setReservedTokensList(address,uint256,uint256,uint256)(REF_156,REF_157,REF_158,REF_159)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\niterator ++\\n\\nIRs:\\nTMP_340(uint256) := iterator(uint256)\\niterator(uint256) = iterator + 1\\\"];\\n12->8;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nreservedTokensDestinationsAreSet = true\\n\\nIRs:\\nreservedTokensDestinationsAreSet(bool) := True(bool)\\\"];\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n15->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setTokenInformation(string,string)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nname = _name\\n\\nIRs:\\nname(string) := _name(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nsymbol = _symbol\\n\\nIRs:\\nsymbol(string) := _symbol(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nUpdatedTokenInformation(name,symbol)\\n\\nIRs:\\nEmit UpdatedTokenInformation(name,symbol)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setTransferAgent(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntransferAgents[addr] = state\\n\\nIRs:\\nREF_169(bool) -> transferAgents[addr]\\nREF_169(bool) (->transferAgents) := state(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ninReleaseState(false)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.inReleaseState(bool)(False)\\\"];\\n3->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setUpgradeAgent(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! canUpgrade()\\n\\nIRs:\\nTMP_270(bool) = INTERNAL_CALL, CrowdsaleTokenExt.canUpgrade()()\\nTMP_271 = UnaryType.BANG TMP_270 \\nCONDITION TMP_271\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nagent == 0x0\\n\\nIRs:\\nTMP_272(bool) = agent == 0\\nCONDITION TMP_272\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\nmsg.sender != upgradeMaster\\n\\nIRs:\\nTMP_273(bool) = msg.sender != upgradeMaster\\nCONDITION TMP_273\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: THROW 8\\n\\\"];\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\ngetUpgradeState() == UpgradeState.Upgrading\\n\\nIRs:\\nTMP_274(UpgradeableToken.UpgradeState) = INTERNAL_CALL, UpgradeableToken.getUpgradeState()()\\nREF_110(UpgradeableToken.UpgradeState) -> UpgradeState.Upgrading\\nTMP_275(bool) = TMP_274 == REF_110\\nCONDITION TMP_275\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: THROW 11\\n\\\"];\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nupgradeAgent = UpgradeAgent(agent)\\n\\nIRs:\\nTMP_276 = CONVERT agent to UpgradeAgent\\nupgradeAgent(UpgradeAgent) := TMP_276(UpgradeAgent)\\\"];\\n13->14;\\n14[label=\\\"Node Type: IF 14\\n\\nEXPRESSION:\\n! upgradeAgent.isUpgradeAgent()\\n\\nIRs:\\nTMP_277(bool) = HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:isUpgradeAgent, arguments:[]  \\nTMP_278 = UnaryType.BANG TMP_277 \\nCONDITION TMP_278\\\"];\\n14->15[label=\\\"True\\\"];\\n14->16[label=\\\"False\\\"];\\n15[label=\\\"Node Type: THROW 15\\n\\\"];\\n16[label=\\\"Node Type: END_IF 16\\n\\\"];\\n16->17;\\n17[label=\\\"Node Type: IF 17\\n\\nEXPRESSION:\\nupgradeAgent.originalSupply() != totalSupply\\n\\nIRs:\\nTMP_279(uint256) = HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:originalSupply, arguments:[]  \\nTMP_280(bool) = TMP_279 != totalSupply\\nCONDITION TMP_280\\\"];\\n17->18[label=\\\"True\\\"];\\n17->19[label=\\\"False\\\"];\\n18[label=\\\"Node Type: THROW 18\\n\\\"];\\n19[label=\\\"Node Type: END_IF 19\\n\\\"];\\n19->20;\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\nUpgradeAgentSet(upgradeAgent)\\n\\nIRs:\\nEmit UpgradeAgentSet(upgradeAgent)\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-setUpgradeMaster(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmaster == 0x0\\n\\nIRs:\\nTMP_287(bool) = master == 0\\nCONDITION TMP_287\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nmsg.sender != upgradeMaster\\n\\nIRs:\\nTMP_288(bool) = msg.sender != upgradeMaster\\nCONDITION TMP_288\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nupgradeMaster = master\\n\\nIRs:\\nupgradeMaster(address) := master(address)\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nreleased = false\\n\\nIRs:\\nreleased(bool) := False(bool)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nmintingFinished = false\\n\\nIRs:\\nmintingFinished(bool) := False(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nreservedTokensDestinationsLen = 0\\n\\nIRs:\\nreservedTokensDestinationsLen(uint256) := 0(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nreservedTokensDestinationsAreSet = false\\n\\nIRs:\\nreservedTokensDestinationsAreSet(bool) := False(bool)\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transfer(_to,_value)\\n\\nIRs:\\nTMP_373(bool) = INTERNAL_CALL, ERC20Basic.transfer(address,uint256)(_to,_value)\\nRETURN TMP_373\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncanTransfer(msg.sender)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.canTransfer(address)(msg.sender)\\\"];\\n2->1;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transferFrom(_from,_to,_value)\\n\\nIRs:\\nTMP_375(bool) = INTERNAL_CALL, ERC20.transferFrom(address,address,uint256)(_from,_to,_value)\\nRETURN TMP_375\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncanTransfer(_from)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.canTransfer(address)(_from)\\\"];\\n2->1;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_363 = CONVERT 0 to address\\nTMP_364(bool) = newOwner != TMP_363\\nTMP_365(None) = SOLIDITY_CALL require(bool)(TMP_364)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-CrowdsaleTokenExt-upgrade(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nstate = getUpgradeState()\\n\\nIRs:\\nTMP_259(UpgradeableToken.UpgradeState) = INTERNAL_CALL, UpgradeableToken.getUpgradeState()()\\nstate(UpgradeableToken.UpgradeState) := TMP_259(UpgradeableToken.UpgradeState)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n! (state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)\\n\\nIRs:\\nREF_105(UpgradeableToken.UpgradeState) -> UpgradeState.ReadyToUpgrade\\nTMP_260(bool) = state == REF_105\\nREF_106(UpgradeableToken.UpgradeState) -> UpgradeState.Upgrading\\nTMP_261(bool) = state == REF_106\\nTMP_262(bool) = TMP_260 || TMP_261\\nTMP_263 = UnaryType.BANG TMP_262 \\nCONDITION TMP_263\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: THROW 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\nvalue == 0\\n\\nIRs:\\nTMP_264(bool) = value == 0\\nCONDITION TMP_264\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: THROW 6\\n\\\"];\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nbalances[msg.sender] = safeSub(balances[msg.sender],value)\\n\\nIRs:\\nREF_107(uint256) -> balances[msg.sender]\\nREF_108(uint256) -> balances[msg.sender]\\nTMP_265(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_108,value)\\nREF_107(uint256) (->balances) := TMP_265(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ntotalSupply = safeSub(totalSupply,value)\\n\\nIRs:\\nTMP_266(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,value)\\ntotalSupply(uint256) := TMP_266(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ntotalUpgraded = safeAdd(totalUpgraded,value)\\n\\nIRs:\\nTMP_267(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalUpgraded,value)\\ntotalUpgraded(uint256) := TMP_267(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nupgradeAgent.upgradeFrom(msg.sender,value)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:upgradeFrom, arguments:['msg.sender', 'value']  \\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nUpgrade(msg.sender,upgradeAgent,value)\\n\\nIRs:\\nEmit Upgrade(msg.sender,upgradeAgent,value)\\\"];\\n}\\n// Function: 51.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 51.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 51.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 51.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-MintableTokenExt-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-allowance(address,address)\\ndigraph{\\n}\\n// Function: 51.sol-MintableTokenExt-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-MintableTokenExt-areTokensDistributedForAddress(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].isDistributed\\n\\nIRs:\\nREF_75(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_76(bool) -> REF_75.isDistributed\\nRETURN REF_76\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nisDistributed\\n\\nIRs:\\nRETURN isDistributed\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-balanceOf(address)\\ndigraph{\\n}\\n// Function: 51.sol-MintableTokenExt-canMint()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmintingFinished\\n\\nIRs:\\nCONDITION mintingFinished\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-finalizeReservedAddress(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nreservedTokensData = reservedTokensList[addr]\\n\\nIRs:\\nREF_71(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nreservedTokensData(MintableTokenExt.ReservedTokensData) := REF_71(MintableTokenExt.ReservedTokensData)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nreservedTokensData.isDistributed = true\\n\\nIRs:\\nREF_72(bool) -> reservedTokensData.isDistributed\\nREF_72(bool) (->reservedTokensData) := True(bool)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyMintAgent()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.onlyMintAgent()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-MintableTokenExt-getReservedPercentageDecimals(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].inPercentageDecimals\\n\\nIRs:\\nREF_81(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_82(uint256) -> REF_81.inPercentageDecimals\\nRETURN REF_82\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ninPercentageDecimals\\n\\nIRs:\\nRETURN inPercentageDecimals\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-getReservedPercentageUnit(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].inPercentageUnit\\n\\nIRs:\\nREF_79(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_80(uint256) -> REF_79.inPercentageUnit\\nRETURN REF_80\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ninPercentageUnit\\n\\nIRs:\\nRETURN inPercentageUnit\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-getReservedTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].inTokens\\n\\nIRs:\\nREF_77(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_78(uint256) -> REF_77.inTokens\\nRETURN REF_78\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ninTokens\\n\\nIRs:\\nRETURN inTokens\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-isAddressReserved(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nreservedTokensList[addr].isReserved\\n\\nIRs:\\nREF_73(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nREF_74(bool) -> REF_73.isReserved\\nRETURN REF_74\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nisReserved\\n\\nIRs:\\nRETURN isReserved\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-isToken()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nweAre\\n\\nIRs:\\nRETURN weAre\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-max256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_217(bool) = a >= b\\nCONDITION TMP_217\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-max64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_215(bool) = a >= b\\nCONDITION TMP_215\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-min256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_218(bool) = a < b\\nCONDITION TMP_218\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-min64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_216(bool) = a < b\\nCONDITION TMP_216\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-mint(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalSupply = totalSupply.plus(amount)\\n\\nIRs:\\nTMP_236(uint256) = LIBRARY_CALL, dest:SafeMathLibExt, function:SafeMathLibExt.plus(uint256,uint256), arguments:['totalSupply', 'amount'] \\ntotalSupply(uint256) := TMP_236(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[receiver] = balances[receiver].plus(amount)\\n\\nIRs:\\nREF_96(uint256) -> balances[receiver]\\nREF_97(uint256) -> balances[receiver]\\nTMP_237(uint256) = LIBRARY_CALL, dest:SafeMathLibExt, function:SafeMathLibExt.plus(uint256,uint256), arguments:['REF_97', 'amount'] \\nREF_96(uint256) (->balances) := TMP_237(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(0,receiver,amount)\\n\\nIRs:\\nEmit Transfer(0,receiver,amount)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyMintAgent()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.onlyMintAgent()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n5->1;\\n}\\n// Function: 51.sol-MintableTokenExt-onlyMintAgent()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! mintAgents[msg.sender]\\n\\nIRs:\\nREF_104(bool) -> mintAgents[msg.sender]\\nTMP_258 = UnaryType.BANG REF_104 \\nCONDITION TMP_258\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_256(bool) = msg.sender == owner\\nTMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_210(uint256) = a + b\\nc(uint256) := TMP_210(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a && c >= b)\\n\\nIRs:\\nTMP_211(bool) = c >= a\\nTMP_212(bool) = c >= b\\nTMP_213(bool) = TMP_211 && TMP_212\\nTMP_214(None) = SOLIDITY_CALL assert(bool)(TMP_213)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b > 0)\\n\\nIRs:\\nTMP_199(bool) = b > 0\\nTMP_200(None) = SOLIDITY_CALL assert(bool)(TMP_199)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_201(uint256) = a / b\\nc(uint256) := TMP_201(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(a == b * c + a % b)\\n\\nIRs:\\nTMP_202(uint256) = b * c\\nTMP_203(uint256) = a % b\\nTMP_204(uint256) = TMP_202 + TMP_203\\nTMP_205(bool) = a == TMP_204\\nTMP_206(None) = SOLIDITY_CALL assert(bool)(TMP_205)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_193(uint256) = a * b\\nc(uint256) := TMP_193(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_194(bool) = a == 0\\nTMP_195(uint256) = c / a\\nTMP_196(bool) = TMP_195 == b\\nTMP_197(bool) = TMP_194 || TMP_196\\nTMP_198(None) = SOLIDITY_CALL assert(bool)(TMP_197)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_207(bool) = b <= a\\nTMP_208(None) = SOLIDITY_CALL assert(bool)(TMP_207)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_209(uint256) = a - b\\nRETURN TMP_209\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-setMintAgent(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nmintAgents[addr] = state\\n\\nIRs:\\nREF_99(bool) -> mintAgents[addr]\\nREF_99(bool) (->mintAgents) := state(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nMintingAgentChanged(addr,state)\\n\\nIRs:\\nEmit MintingAgentChanged(addr,state)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-MintableTokenExt-setReservedTokensList(address,uint256,uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(addr != address(0))\\n\\nIRs:\\nTMP_244 = CONVERT 0 to address\\nTMP_245(bool) = addr != TMP_244\\nTMP_246(None) = SOLIDITY_CALL assert(bool)(TMP_245)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n! isAddressReserved(addr)\\n\\nIRs:\\nTMP_247(bool) = INTERNAL_CALL, MintableTokenExt.isAddressReserved(address)(addr)\\nTMP_248 = UnaryType.BANG TMP_247 \\nCONDITION TMP_248\\\"];\\n2->3[label=\\\"True\\\"];\\n2->5[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nreservedTokensDestinations.push(addr)\\n\\nIRs:\\nREF_101 -> LENGTH reservedTokensDestinations\\nTMP_250(uint256) := REF_101(uint256)\\nTMP_251(uint256) = TMP_250 + 1\\nREF_101(uint256) (->reservedTokensDestinations) := TMP_251(uint256)\\nREF_102(address) -> reservedTokensDestinations[TMP_250]\\nREF_102(address) (->reservedTokensDestinations) := addr(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nreservedTokensDestinationsLen ++\\n\\nIRs:\\nTMP_252(uint256) := reservedTokensDestinationsLen(uint256)\\nreservedTokensDestinationsLen(uint256) = reservedTokensDestinationsLen + 1\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nreservedTokensList[addr] = ReservedTokensData(inTokens,inPercentageUnit,inPercentageDecimals,true,false)\\n\\nIRs:\\nREF_103(MintableTokenExt.ReservedTokensData) -> reservedTokensList[addr]\\nTMP_253(MintableTokenExt.ReservedTokensData) = new ReservedTokensData(inTokens,inPercentageUnit,inPercentageDecimals,True,False)\\nREF_103(MintableTokenExt.ReservedTokensData) (->reservedTokensList) := TMP_253(MintableTokenExt.ReservedTokensData)\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n8->1;\\n}\\n// Function: 51.sol-MintableTokenExt-setReservedTokensListMultiple(address[],uint256[],uint256[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->14;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(! reservedTokensDestinationsAreSet)\\n\\nIRs:\\nTMP_221 = UnaryType.BANG reservedTokensDestinationsAreSet \\nTMP_222(None) = SOLIDITY_CALL assert(bool)(TMP_221)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(addrs.length == inTokens.length)\\n\\nIRs:\\nREF_83 -> LENGTH addrs\\nREF_84 -> LENGTH inTokens\\nTMP_223(bool) = REF_83 == REF_84\\nTMP_224(None) = SOLIDITY_CALL assert(bool)(TMP_223)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(inTokens.length == inPercentageUnit.length)\\n\\nIRs:\\nREF_85 -> LENGTH inTokens\\nREF_86 -> LENGTH inPercentageUnit\\nTMP_225(bool) = REF_85 == REF_86\\nTMP_226(None) = SOLIDITY_CALL assert(bool)(TMP_225)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nassert(bool)(inPercentageUnit.length == inPercentageDecimals.length)\\n\\nIRs:\\nREF_87 -> LENGTH inPercentageUnit\\nREF_88 -> LENGTH inPercentageDecimals\\nTMP_227(bool) = REF_87 == REF_88\\nTMP_228(None) = SOLIDITY_CALL assert(bool)(TMP_227)\\\"];\\n4->7;\\n5[label=\\\"Node Type: BEGIN_LOOP 5\\n\\\"];\\n5->8;\\n6[label=\\\"Node Type: END_LOOP 6\\n\\\"];\\n6->13;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\niterator = 0\\n\\nIRs:\\niterator(uint256) := 0(uint256)\\\"];\\n7->5;\\n8[label=\\\"Node Type: IF_LOOP 8\\n\\nEXPRESSION:\\niterator < addrs.length\\n\\nIRs:\\nREF_89 -> LENGTH addrs\\nTMP_229(bool) = iterator < REF_89\\nCONDITION TMP_229\\\"];\\n8->9[label=\\\"True\\\"];\\n8->6[label=\\\"False\\\"];\\n9[label=\\\"Node Type: IF 9\\n\\nEXPRESSION:\\naddrs[iterator] != address(0)\\n\\nIRs:\\nREF_90(address) -> addrs[iterator]\\nTMP_230 = CONVERT 0 to address\\nTMP_231(bool) = REF_90 != TMP_230\\nCONDITION TMP_231\\\"];\\n9->10[label=\\\"True\\\"];\\n9->11[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nsetReservedTokensList(addrs[iterator],inTokens[iterator],inPercentageUnit[iterator],inPercentageDecimals[iterator])\\n\\nIRs:\\nREF_91(address) -> addrs[iterator]\\nREF_92(uint256) -> inTokens[iterator]\\nREF_93(uint256) -> inPercentageUnit[iterator]\\nREF_94(uint256) -> inPercentageDecimals[iterator]\\nINTERNAL_CALL, MintableTokenExt.setReservedTokensList(address,uint256,uint256,uint256)(REF_91,REF_92,REF_93,REF_94)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\niterator ++\\n\\nIRs:\\nTMP_233(uint256) := iterator(uint256)\\niterator(uint256) = iterator + 1\\\"];\\n12->8;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nreservedTokensDestinationsAreSet = true\\n\\nIRs:\\nreservedTokensDestinationsAreSet(bool) := True(bool)\\\"];\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ncanMint()\\n\\nIRs:\\nMODIFIER_CALL, MintableTokenExt.canMint()()\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n15->1;\\n}\\n// Function: 51.sol-MintableTokenExt-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nmintingFinished = false\\n\\nIRs:\\nmintingFinished(bool) := False(bool)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nreservedTokensDestinationsLen = 0\\n\\nIRs:\\nreservedTokensDestinationsLen(uint256) := 0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nreservedTokensDestinationsAreSet = false\\n\\nIRs:\\nreservedTokensDestinationsAreSet(bool) := False(bool)\\\"];\\n}\\n// Function: 51.sol-MintableTokenExt-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-MintableTokenExt-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-MintableTokenExt-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_177 = CONVERT 0 to address\\nTMP_178(bool) = newOwner != TMP_177\\nTMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-Ownable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 51.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_5(bool) = msg.sender == owner\\nTMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 51.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_0 = CONVERT 0 to address\\nTMP_1(bool) = newOwner != TMP_0\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-ReleasableToken-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 51.sol-ReleasableToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-ReleasableToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 51.sol-ReleasableToken-canTransfer(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! released\\n\\nIRs:\\nTMP_153 = UnaryType.BANG released \\nCONDITION TMP_153\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n! transferAgents[_sender]\\n\\nIRs:\\nREF_51(bool) -> transferAgents[_sender]\\nTMP_154 = UnaryType.BANG REF_51 \\nCONDITION TMP_154\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: THROW 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: _ 6\\n\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-inReleaseState(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nreleaseState != released\\n\\nIRs:\\nTMP_155(bool) = releaseState != released\\nCONDITION TMP_155\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_151(bool) = msg.sender == owner\\nTMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-onlyReleaseAgent()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender != releaseAgent\\n\\nIRs:\\nTMP_156(bool) = msg.sender != releaseAgent\\nCONDITION TMP_156\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: _ 4\\n\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-releaseTokenTransfer()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nreleased = true\\n\\nIRs:\\nreleased(bool) := True(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyReleaseAgent()\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.onlyReleaseAgent()()\\\"];\\n2->1;\\n}\\n// Function: 51.sol-ReleasableToken-setReleaseAgent(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nreleaseAgent = addr\\n\\nIRs:\\nreleaseAgent(address) := addr(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ninReleaseState(false)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.inReleaseState(bool)(False)\\\"];\\n3->1;\\n}\\n// Function: 51.sol-ReleasableToken-setTransferAgent(address,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntransferAgents[addr] = state\\n\\nIRs:\\nREF_50(bool) -> transferAgents[addr]\\nREF_50(bool) (->transferAgents) := state(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ninReleaseState(false)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.inReleaseState(bool)(False)\\\"];\\n3->1;\\n}\\n// Function: 51.sol-ReleasableToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nreleased = false\\n\\nIRs:\\nreleased(bool) := False(bool)\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transfer(_to,_value)\\n\\nIRs:\\nTMP_147(bool) = INTERNAL_CALL, ERC20Basic.transfer(address,uint256)(_to,_value)\\nRETURN TMP_147\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncanTransfer(msg.sender)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.canTransfer(address)(msg.sender)\\\"];\\n2->1;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transferFrom(_from,_to,_value)\\n\\nIRs:\\nTMP_149(bool) = INTERNAL_CALL, ERC20.transferFrom(address,address,uint256)(_from,_to,_value)\\nRETURN TMP_149\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncanTransfer(_from)\\n\\nIRs:\\nMODIFIER_CALL, ReleasableToken.canTransfer(address)(_from)\\\"];\\n2->1;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 51.sol-ReleasableToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(newOwner != address(0))\\n\\nIRs:\\nTMP_137 = CONVERT 0 to address\\nTMP_138(bool) = newOwner != TMP_137\\nTMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 51.sol-SafeMath-max256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_31(bool) = a >= b\\nCONDITION TMP_31\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-SafeMath-max64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_29(bool) = a >= b\\nCONDITION TMP_29\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-SafeMath-min256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_32(bool) = a < b\\nCONDITION TMP_32\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-SafeMath-min64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_30(bool) = a < b\\nCONDITION TMP_30\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-SafeMath-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_24(uint256) = a + b\\nc(uint256) := TMP_24(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a && c >= b)\\n\\nIRs:\\nTMP_25(bool) = c >= a\\nTMP_26(bool) = c >= b\\nTMP_27(bool) = TMP_25 && TMP_26\\nTMP_28(None) = SOLIDITY_CALL assert(bool)(TMP_27)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-SafeMath-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b > 0)\\n\\nIRs:\\nTMP_13(bool) = b > 0\\nTMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_15(uint256) = a / b\\nc(uint256) := TMP_15(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(a == b * c + a % b)\\n\\nIRs:\\nTMP_16(uint256) = b * c\\nTMP_17(uint256) = a % b\\nTMP_18(uint256) = TMP_16 + TMP_17\\nTMP_19(bool) = a == TMP_18\\nTMP_20(None) = SOLIDITY_CALL assert(bool)(TMP_19)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-SafeMath-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_7(uint256) = a * b\\nc(uint256) := TMP_7(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_8(bool) = a == 0\\nTMP_9(uint256) = c / a\\nTMP_10(bool) = TMP_9 == b\\nTMP_11(bool) = TMP_8 || TMP_10\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-SafeMath-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_21(bool) = b <= a\\nTMP_22(None) = SOLIDITY_CALL assert(bool)(TMP_21)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_23(uint256) = a - b\\nRETURN TMP_23\\\"];\\n}\\n// Function: 51.sol-SafeMathLibExt-divides(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b > 0)\\n\\nIRs:\\nTMP_163(bool) = b > 0\\nTMP_164(None) = SOLIDITY_CALL assert(bool)(TMP_163)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_165(uint256) = a / b\\nc(uint256) := TMP_165(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(a == b * c + a % b)\\n\\nIRs:\\nTMP_166(uint256) = b * c\\nTMP_167(uint256) = a % b\\nTMP_168(uint256) = TMP_166 + TMP_167\\nTMP_169(bool) = a == TMP_168\\nTMP_170(None) = SOLIDITY_CALL assert(bool)(TMP_169)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-SafeMathLibExt-minus(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_171(bool) = b <= a\\nTMP_172(None) = SOLIDITY_CALL assert(bool)(TMP_171)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_173(uint256) = a - b\\nRETURN TMP_173\\\"];\\n}\\n// Function: 51.sol-SafeMathLibExt-plus(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_174(uint256) = a + b\\nc(uint256) := TMP_174(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_175(bool) = c >= a\\nTMP_176(None) = SOLIDITY_CALL assert(bool)(TMP_175)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-SafeMathLibExt-times(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_157(uint256) = a * b\\nc(uint256) := TMP_157(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_158(bool) = a == 0\\nTMP_159(uint256) = c / a\\nTMP_160(bool) = TMP_159 == b\\nTMP_161(bool) = TMP_158 || TMP_160\\nTMP_162(None) = SOLIDITY_CALL assert(bool)(TMP_161)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_17(mapping(address => uint256)) -> allowed[_owner]\\nREF_18(uint256) -> REF_17[_spender]\\nRETURN REF_18\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 51.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n(_value != 0) && (allowed[msg.sender][_spender] != 0)\\n\\nIRs:\\nTMP_66(bool) = _value != 0\\nREF_13(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_14(uint256) -> REF_13[_spender]\\nTMP_67(bool) = REF_14 != 0\\nTMP_68(bool) = TMP_66 && TMP_67\\nCONDITION TMP_68\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_15(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_16(uint256) -> REF_15[_spender]\\nREF_16(uint256) (->allowed) := _value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 51.sol-StandardToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_12(uint256) -> balances[_owner]\\nRETURN REF_12\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 51.sol-StandardToken-isToken()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nweAre\\n\\nIRs:\\nRETURN weAre\\\"];\\n}\\n// Function: 51.sol-StandardToken-max256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_57(bool) = a >= b\\nCONDITION TMP_57\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-StandardToken-max64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_55(bool) = a >= b\\nCONDITION TMP_55\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-StandardToken-min256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_58(bool) = a < b\\nCONDITION TMP_58\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-StandardToken-min64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_56(bool) = a < b\\nCONDITION TMP_56\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-StandardToken-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_50(uint256) = a + b\\nc(uint256) := TMP_50(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a && c >= b)\\n\\nIRs:\\nTMP_51(bool) = c >= a\\nTMP_52(bool) = c >= b\\nTMP_53(bool) = TMP_51 && TMP_52\\nTMP_54(None) = SOLIDITY_CALL assert(bool)(TMP_53)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-StandardToken-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b > 0)\\n\\nIRs:\\nTMP_39(bool) = b > 0\\nTMP_40(None) = SOLIDITY_CALL assert(bool)(TMP_39)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_41(uint256) = a / b\\nc(uint256) := TMP_41(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(a == b * c + a % b)\\n\\nIRs:\\nTMP_42(uint256) = b * c\\nTMP_43(uint256) = a % b\\nTMP_44(uint256) = TMP_42 + TMP_43\\nTMP_45(bool) = a == TMP_44\\nTMP_46(None) = SOLIDITY_CALL assert(bool)(TMP_45)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-StandardToken-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_33(uint256) = a * b\\nc(uint256) := TMP_33(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_34(bool) = a == 0\\nTMP_35(uint256) = c / a\\nTMP_36(bool) = TMP_35 == b\\nTMP_37(bool) = TMP_34 || TMP_36\\nTMP_38(None) = SOLIDITY_CALL assert(bool)(TMP_37)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-StandardToken-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_47(bool) = b <= a\\nTMP_48(None) = SOLIDITY_CALL assert(bool)(TMP_47)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_49(uint256) = a - b\\nRETURN TMP_49\\\"];\\n}\\n// Function: 51.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[msg.sender] = safeSub(balances[msg.sender],_value)\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nREF_1(uint256) -> balances[msg.sender]\\nTMP_59(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_1,_value)\\nREF_0(uint256) (->balances) := TMP_59(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[_to] = safeAdd(balances[_to],_value)\\n\\nIRs:\\nREF_2(uint256) -> balances[_to]\\nREF_3(uint256) -> balances[_to]\\nTMP_60(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_3,_value)\\nREF_2(uint256) (->balances) := TMP_60(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 51.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\n_allowance = allowed[_from][msg.sender]\\n\\nIRs:\\nREF_4(mapping(address => uint256)) -> allowed[_from]\\nREF_5(uint256) -> REF_4[msg.sender]\\n_allowance(uint256) := REF_5(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[_to] = safeAdd(balances[_to],_value)\\n\\nIRs:\\nREF_6(uint256) -> balances[_to]\\nREF_7(uint256) -> balances[_to]\\nTMP_62(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_7,_value)\\nREF_6(uint256) (->balances) := TMP_62(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_from] = safeSub(balances[_from],_value)\\n\\nIRs:\\nREF_8(uint256) -> balances[_from]\\nREF_9(uint256) -> balances[_from]\\nTMP_63(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_9,_value)\\nREF_8(uint256) (->balances) := TMP_63(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = safeSub(_allowance,_value)\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowed[_from]\\nREF_11(uint256) -> REF_10[msg.sender]\\nTMP_64(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(_allowance,_value)\\nREF_11(uint256) (->allowed) := TMP_64(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 51.sol-UpgradeAgent-isUpgradeAgent()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 51.sol-UpgradeAgent-upgradeFrom(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-UpgradeableToken-UpgradeableToken(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nupgradeMaster = _upgradeMaster\\n\\nIRs:\\nupgradeMaster(address) := _upgradeMaster(address)\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 51.sol-UpgradeableToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-UpgradeableToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 51.sol-UpgradeableToken-canUpgrade()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-getUpgradeState()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! canUpgrade()\\n\\nIRs:\\nTMP_130(bool) = INTERNAL_CALL, UpgradeableToken.canUpgrade()()\\nTMP_131 = UnaryType.BANG TMP_130 \\nCONDITION TMP_131\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nUpgradeState.NotAllowed\\n\\nIRs:\\nREF_46(UpgradeableToken.UpgradeState) -> UpgradeState.NotAllowed\\nRETURN REF_46\\\"];\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\naddress(upgradeAgent) == 0x00\\n\\nIRs:\\nTMP_132 = CONVERT upgradeAgent to address\\nTMP_133(bool) = TMP_132 == 0\\nCONDITION TMP_133\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nUpgradeState.WaitingForAgent\\n\\nIRs:\\nREF_47(UpgradeableToken.UpgradeState) -> UpgradeState.WaitingForAgent\\nRETURN REF_47\\\"];\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\ntotalUpgraded == 0\\n\\nIRs:\\nTMP_134(bool) = totalUpgraded == 0\\nCONDITION TMP_134\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nUpgradeState.ReadyToUpgrade\\n\\nIRs:\\nREF_48(UpgradeableToken.UpgradeState) -> UpgradeState.ReadyToUpgrade\\nRETURN REF_48\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nUpgradeState.Upgrading\\n\\nIRs:\\nREF_49(UpgradeableToken.UpgradeState) -> UpgradeState.Upgrading\\nRETURN REF_49\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-isToken()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nweAre\\n\\nIRs:\\nRETURN weAre\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-max256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_105(bool) = a >= b\\nCONDITION TMP_105\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-max64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_103(bool) = a >= b\\nCONDITION TMP_103\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-min256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_106(bool) = a < b\\nCONDITION TMP_106\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-min64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_104(bool) = a < b\\nCONDITION TMP_104\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-safeAdd(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_98(uint256) = a + b\\nc(uint256) := TMP_98(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a && c >= b)\\n\\nIRs:\\nTMP_99(bool) = c >= a\\nTMP_100(bool) = c >= b\\nTMP_101(bool) = TMP_99 && TMP_100\\nTMP_102(None) = SOLIDITY_CALL assert(bool)(TMP_101)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-safeDiv(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b > 0)\\n\\nIRs:\\nTMP_87(bool) = b > 0\\nTMP_88(None) = SOLIDITY_CALL assert(bool)(TMP_87)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_89(uint256) = a / b\\nc(uint256) := TMP_89(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nassert(bool)(a == b * c + a % b)\\n\\nIRs:\\nTMP_90(uint256) = b * c\\nTMP_91(uint256) = a % b\\nTMP_92(uint256) = TMP_90 + TMP_91\\nTMP_93(bool) = a == TMP_92\\nTMP_94(None) = SOLIDITY_CALL assert(bool)(TMP_93)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-safeMul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_81(uint256) = a * b\\nc(uint256) := TMP_81(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_82(bool) = a == 0\\nTMP_83(uint256) = c / a\\nTMP_84(bool) = TMP_83 == b\\nTMP_85(bool) = TMP_82 || TMP_84\\nTMP_86(None) = SOLIDITY_CALL assert(bool)(TMP_85)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-safeSub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_95(bool) = b <= a\\nTMP_96(None) = SOLIDITY_CALL assert(bool)(TMP_95)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_97(uint256) = a - b\\nRETURN TMP_97\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-setUpgradeAgent(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n! canUpgrade()\\n\\nIRs:\\nTMP_118(bool) = INTERNAL_CALL, UpgradeableToken.canUpgrade()()\\nTMP_119 = UnaryType.BANG TMP_118 \\nCONDITION TMP_119\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nagent == 0x0\\n\\nIRs:\\nTMP_120(bool) = agent == 0\\nCONDITION TMP_120\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\nmsg.sender != upgradeMaster\\n\\nIRs:\\nTMP_121(bool) = msg.sender != upgradeMaster\\nCONDITION TMP_121\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: THROW 8\\n\\\"];\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\ngetUpgradeState() == UpgradeState.Upgrading\\n\\nIRs:\\nTMP_122(UpgradeableToken.UpgradeState) = INTERNAL_CALL, UpgradeableToken.getUpgradeState()()\\nREF_43(UpgradeableToken.UpgradeState) -> UpgradeState.Upgrading\\nTMP_123(bool) = TMP_122 == REF_43\\nCONDITION TMP_123\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: THROW 11\\n\\\"];\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nupgradeAgent = UpgradeAgent(agent)\\n\\nIRs:\\nTMP_124 = CONVERT agent to UpgradeAgent\\nupgradeAgent(UpgradeAgent) := TMP_124(UpgradeAgent)\\\"];\\n13->14;\\n14[label=\\\"Node Type: IF 14\\n\\nEXPRESSION:\\n! upgradeAgent.isUpgradeAgent()\\n\\nIRs:\\nTMP_125(bool) = HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:isUpgradeAgent, arguments:[]  \\nTMP_126 = UnaryType.BANG TMP_125 \\nCONDITION TMP_126\\\"];\\n14->15[label=\\\"True\\\"];\\n14->16[label=\\\"False\\\"];\\n15[label=\\\"Node Type: THROW 15\\n\\\"];\\n16[label=\\\"Node Type: END_IF 16\\n\\\"];\\n16->17;\\n17[label=\\\"Node Type: IF 17\\n\\nEXPRESSION:\\nupgradeAgent.originalSupply() != totalSupply\\n\\nIRs:\\nTMP_127(uint256) = HIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:originalSupply, arguments:[]  \\nTMP_128(bool) = TMP_127 != totalSupply\\nCONDITION TMP_128\\\"];\\n17->18[label=\\\"True\\\"];\\n17->19[label=\\\"False\\\"];\\n18[label=\\\"Node Type: THROW 18\\n\\\"];\\n19[label=\\\"Node Type: END_IF 19\\n\\\"];\\n19->20;\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\nUpgradeAgentSet(upgradeAgent)\\n\\nIRs:\\nEmit UpgradeAgentSet(upgradeAgent)\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-setUpgradeMaster(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmaster == 0x0\\n\\nIRs:\\nTMP_135(bool) = master == 0\\nCONDITION TMP_135\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: THROW 2\\n\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nmsg.sender != upgradeMaster\\n\\nIRs:\\nTMP_136(bool) = msg.sender != upgradeMaster\\nCONDITION TMP_136\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: THROW 5\\n\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nupgradeMaster = master\\n\\nIRs:\\nupgradeMaster(address) := master(address)\\\"];\\n}\\n// Function: 51.sol-UpgradeableToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-UpgradeableToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 51.sol-UpgradeableToken-upgrade(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nstate = getUpgradeState()\\n\\nIRs:\\nTMP_107(UpgradeableToken.UpgradeState) = INTERNAL_CALL, UpgradeableToken.getUpgradeState()()\\nstate(UpgradeableToken.UpgradeState) := TMP_107(UpgradeableToken.UpgradeState)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n! (state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)\\n\\nIRs:\\nREF_38(UpgradeableToken.UpgradeState) -> UpgradeState.ReadyToUpgrade\\nTMP_108(bool) = state == REF_38\\nREF_39(UpgradeableToken.UpgradeState) -> UpgradeState.Upgrading\\nTMP_109(bool) = state == REF_39\\nTMP_110(bool) = TMP_108 || TMP_109\\nTMP_111 = UnaryType.BANG TMP_110 \\nCONDITION TMP_111\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: THROW 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\nvalue == 0\\n\\nIRs:\\nTMP_112(bool) = value == 0\\nCONDITION TMP_112\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: THROW 6\\n\\\"];\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nbalances[msg.sender] = safeSub(balances[msg.sender],value)\\n\\nIRs:\\nREF_40(uint256) -> balances[msg.sender]\\nREF_41(uint256) -> balances[msg.sender]\\nTMP_113(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_41,value)\\nREF_40(uint256) (->balances) := TMP_113(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ntotalSupply = safeSub(totalSupply,value)\\n\\nIRs:\\nTMP_114(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalSupply,value)\\ntotalSupply(uint256) := TMP_114(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ntotalUpgraded = safeAdd(totalUpgraded,value)\\n\\nIRs:\\nTMP_115(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalUpgraded,value)\\ntotalUpgraded(uint256) := TMP_115(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nupgradeAgent.upgradeFrom(msg.sender,value)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:upgradeAgent(UpgradeAgent), function:upgradeFrom, arguments:['msg.sender', 'value']  \\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nUpgrade(msg.sender,upgradeAgent,value)\\n\\nIRs:\\nEmit Upgrade(msg.sender,upgradeAgent,value)\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 53.sol-PundiXCash-PundiXCash()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[msg.sender] = 11000000000000000000000000000\\n\\nIRs:\\nREF_30(uint256) -> balances[msg.sender]\\nREF_30(uint256) (->balances) := 11000000000000000000000000000(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalSupply = 11000000000000000000000000000\\n\\nIRs:\\ntotalSupply(uint256) := 11000000000000000000000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = PundiXCash\\n\\nIRs:\\nname(string) := PundiXCash(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nsymbol = NPXC\\n\\nIRs:\\nsymbol(string) := NPXC(string)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nunitsOneEthCanBuy = 10000000\\n\\nIRs:\\nunitsOneEthCanBuy(uint256) := 10000000(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nfundsWallet = msg.sender\\n\\nIRs:\\nfundsWallet(address) := msg.sender(address)\\\"];\\n}\\n// Function: 53.sol-PundiXCash-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 53.sol-PundiXCash-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-PundiXCash-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_37(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_38(uint256) -> REF_37[_spender]\\nREF_38(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\n! _spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)\\n\\nIRs:\\nTMP_31(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes))\\nTMP_32 = CONVERT TMP_31 to bytes32\\nTMP_33 = CONVERT TMP_32 to bytes4\\nTMP_34(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_33', 'msg.sender', '_value', 'this', '_extraData']  \\nTMP_35 = UnaryType.BANG TMP_34 \\nCONDITION TMP_35\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: THROW 4\\n\\\"];\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-PundiXCash-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 53.sol-PundiXCash-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalEthInWei = totalEthInWei + msg.value\\n\\nIRs:\\nTMP_22(uint256) = totalEthInWei + msg.value\\ntotalEthInWei(uint256) := TMP_22(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\namount = msg.value * unitsOneEthCanBuy\\n\\nIRs:\\nTMP_23(uint256) = msg.value * unitsOneEthCanBuy\\namount(uint256) := TMP_23(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balances[fundsWallet] >= amount)\\n\\nIRs:\\nREF_31(uint256) -> balances[fundsWallet]\\nTMP_24(bool) = REF_31 >= amount\\nTMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[fundsWallet] = balances[fundsWallet] - amount\\n\\nIRs:\\nREF_32(uint256) -> balances[fundsWallet]\\nREF_33(uint256) -> balances[fundsWallet]\\nTMP_26(uint256) = REF_33 - amount\\nREF_32(uint256) (->balances) := TMP_26(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender] + amount\\n\\nIRs:\\nREF_34(uint256) -> balances[msg.sender]\\nREF_35(uint256) -> balances[msg.sender]\\nTMP_27(uint256) = REF_35 + amount\\nREF_34(uint256) (->balances) := TMP_27(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTransfer(fundsWallet,msg.sender,amount)\\n\\nIRs:\\nEmit Transfer(fundsWallet,msg.sender,amount)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nfundsWallet.transfer(msg.value)\\n\\nIRs:\\nTransfer dest:fundsWallet value:msg.value\\\"];\\n}\\n// Function: 53.sol-PundiXCash-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nversion = H1.0\\n\\nIRs:\\nversion(string) := H1.0(string)\\\"];\\n}\\n// Function: 53.sol-PundiXCash-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsupply\\n\\nIRs:\\nRETURN supply\\\"];\\n}\\n// Function: 53.sol-PundiXCash-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-PundiXCash-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-StandardToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_13(mapping(address => uint256)) -> allowed[_owner]\\nREF_14(uint256) -> REF_13[_spender]\\nRETURN REF_14\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 53.sol-StandardToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_11(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_12(uint256) -> REF_11[_spender]\\nREF_12(uint256) (->allowed) := _value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-StandardToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_10(uint256) -> balances[_owner]\\nRETURN REF_10\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 53.sol-StandardToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsupply\\n\\nIRs:\\nRETURN supply\\\"];\\n}\\n// Function: 53.sol-StandardToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalances[msg.sender] >= _value && _value > 0\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nTMP_0(bool) = REF_0 >= _value\\nTMP_1(bool) = _value > 0\\nTMP_2(bool) = TMP_0 && TMP_1\\nCONDITION TMP_2\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] -= _value\\n\\nIRs:\\nREF_1(uint256) -> balances[msg.sender]\\nREF_1(-> balances) = REF_1 - _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] += _value\\n\\nIRs:\\nREF_2(uint256) -> balances[_to]\\nREF_2(-> balances) = REF_2 + _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_value)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-StandardToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0\\n\\nIRs:\\nREF_3(uint256) -> balances[_from]\\nTMP_4(bool) = REF_3 >= _value\\nREF_4(mapping(address => uint256)) -> allowed[_from]\\nREF_5(uint256) -> REF_4[msg.sender]\\nTMP_5(bool) = REF_5 >= _value\\nTMP_6(bool) = TMP_4 && TMP_5\\nTMP_7(bool) = _value > 0\\nTMP_8(bool) = TMP_6 && TMP_7\\nCONDITION TMP_8\\\"];\\n1->2[label=\\\"True\\\"];\\n1->7[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[_to] += _value\\n\\nIRs:\\nREF_6(uint256) -> balances[_to]\\nREF_6(-> balances) = REF_6 + _value\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_from] -= _value\\n\\nIRs:\\nREF_7(uint256) -> balances[_from]\\nREF_7(-> balances) = REF_7 - _value\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] -= _value\\n\\nIRs:\\nREF_8(mapping(address => uint256)) -> allowed[_from]\\nREF_9(uint256) -> REF_8[msg.sender]\\nREF_9(-> allowed) = REF_9 - _value\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(_from,_to,_value)\\n\\nIRs:\\nEmit Transfer(_from,_to,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-Token-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 53.sol-Token-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-Token-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 53.sol-Token-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsupply\\n\\nIRs:\\nRETURN supply\\\"];\\n}\\n// Function: 53.sol-Token-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 53.sol-Token-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Reentrancy\", \"Unchecked External Call\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 55.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 55.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 55.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 55.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 55.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 55.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 55.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 55.sol-ForeignToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 55.sol-ForeignToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 55.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_10(uint256) = a + b\\nc(uint256) := TMP_10(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_11(bool) = c >= a\\nTMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 55.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_6(uint256) = a / b\\nc(uint256) := TMP_6(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 55.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_0(uint256) = a * b\\nc(uint256) := TMP_0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_1(bool) = a == 0\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(bool) = TMP_1 || TMP_3\\nTMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 55.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_7(bool) = b <= a\\nTMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_9(uint256) = a - b\\nRETURN TMP_9\\\"];\\n}\\n// Function: 55.sol-Token-balanceOf(address)\\ndigraph{\\n}\\n// Function: 55.sol-Token-distr(address,uint256)\\ndigraph{\\n}\\n// Function: 55.sol-Token-totalSupply()\\ndigraph{\\n}\\n// Function: 55.sol-UnlimitedChain-BITDINERO()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[owner] = totalDistributed\\n\\nIRs:\\nREF_0(uint256) -> balances[owner]\\nREF_0(uint256) (->balances) := totalDistributed(uint256)\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_35(mapping(address => uint256)) -> allowed[_owner]\\nREF_36(uint256) -> REF_35[_spender]\\nRETURN REF_36\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_value != 0 && allowed[msg.sender][_spender] != 0\\n\\nIRs:\\nTMP_61(bool) = _value != 0\\nREF_31(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_32(uint256) -> REF_31[_spender]\\nTMP_62(bool) = REF_32 != 0\\nTMP_63(bool) = TMP_61 && TMP_62\\nCONDITION TMP_63\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_33(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_34(uint256) -> REF_33[_spender]\\nREF_34(uint256) (->allowed) := _value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_9(uint256) -> balances[_owner]\\nRETURN REF_9\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-burn(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value <= balances[msg.sender])\\n\\nIRs:\\nREF_39(uint256) -> balances[msg.sender]\\nTMP_71(bool) = _value <= REF_39\\nTMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nburner = msg.sender\\n\\nIRs:\\nburner(address) := msg.sender(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[burner] = balances[burner].sub(_value)\\n\\nIRs:\\nREF_40(uint256) -> balances[burner]\\nREF_41(uint256) -> balances[burner]\\nTMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_41', '_value'] \\nREF_40(uint256) (->balances) := TMP_73(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalSupply = totalSupply.sub(_value)\\n\\nIRs:\\nTMP_74(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', '_value'] \\ntotalSupply(uint256) := TMP_74(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.sub(_value)\\n\\nIRs:\\nTMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDistributed', '_value'] \\ntotalDistributed(uint256) := TMP_75(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nBurn(burner,_value)\\n\\nIRs:\\nEmit Burn(burner,_value)\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.onlyOwner()()\\\"];\\n7->1;\\n}\\n// Function: 55.sol-UnlimitedChain-canDistr()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! distributionFinished)\\n\\nIRs:\\nTMP_84 = UnaryType.BANG distributionFinished \\nTMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-distr(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->10;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.add(_amount)\\n\\nIRs:\\nTMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDistributed', '_amount'] \\ntotalDistributed(uint256) := TMP_19(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntotalRemaining = totalRemaining.sub(_amount)\\n\\nIRs:\\nTMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalRemaining', '_amount'] \\ntotalRemaining(uint256) := TMP_20(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_3(uint256) -> balances[_to]\\nREF_4(uint256) -> balances[_to]\\nTMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_4', '_amount'] \\nREF_3(uint256) (->balances) := TMP_21(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nDistr(_to,_amount)\\n\\nIRs:\\nEmit Distr(_to,_amount)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(address(0),_to,_amount)\\n\\nIRs:\\nTMP_23 = CONVERT 0 to address\\nEmit Transfer(TMP_23,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_25(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_25\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n8->9;\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.canDistr()()\\\"];\\n10->1;\\n}\\n// Function: 55.sol-UnlimitedChain-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ngetTokens()\\n\\nIRs:\\nINTERNAL_CALL, UnlimitedChain.getTokens()()\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-finishDistribution()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nDistrFinished()\\n\\nIRs:\\nEmit DistrFinished()\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.onlyOwner()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.canDistr()()\\\"];\\n5->1;\\n}\\n// Function: 55.sol-UnlimitedChain-getTokenBalance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nt = ForeignToken(tokenAddress)\\n\\nIRs:\\nTMP_65 = CONVERT tokenAddress to ForeignToken\\nt(ForeignToken) := TMP_65(ForeignToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nbal = t.balanceOf(who)\\n\\nIRs:\\nTMP_66(uint256) = HIGH_LEVEL_CALL, dest:t(ForeignToken), function:balanceOf, arguments:['who']  \\nbal(uint256) := TMP_66(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nbal\\n\\nIRs:\\nRETURN bal\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-getTokens()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->15;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nvalue > totalRemaining\\n\\nIRs:\\nTMP_28(bool) = value > totalRemaining\\nCONDITION TMP_28\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nvalue = totalRemaining\\n\\nIRs:\\nvalue(uint256) := totalRemaining(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(value <= totalRemaining)\\n\\nIRs:\\nTMP_29(bool) = value <= totalRemaining\\nTMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ninvestor = msg.sender\\n\\nIRs:\\ninvestor(address) := msg.sender(address)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\ntoGive = value\\n\\nIRs:\\ntoGive(uint256) := value(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ndistr(investor,toGive)\\n\\nIRs:\\nTMP_31(bool) = INTERNAL_CALL, UnlimitedChain.distr(address,uint256)(investor,toGive)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\ntoGive > 0\\n\\nIRs:\\nTMP_32(bool) = toGive > 0\\nCONDITION TMP_32\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nblacklist[investor] = true\\n\\nIRs:\\nREF_6(bool) -> blacklist[investor]\\nREF_6(bool) (->blacklist) := True(bool)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: IF 11\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_33(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_33\\\"];\\n11->12[label=\\\"True\\\"];\\n11->13[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n12->13;\\n13[label=\\\"Node Type: END_IF 13\\n\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nvalue = value.div(100000).mul(99999)\\n\\nIRs:\\nTMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['value', '100000'] \\nTMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_34', '99999'] \\nvalue(uint256) := TMP_35(uint256)\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.canDistr()()\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nonlyWhitelist()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.onlyWhitelist()()\\\"];\\n16->1;\\n}\\n// Function: 55.sol-UnlimitedChain-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_86(bool) = msg.sender == owner\\nTMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(msg.data.length >= size + 4)\\n\\nIRs:\\nREF_49 -> LENGTH msg.data\\nTMP_90(uint256) = size + 4\\nTMP_91(bool) = REF_49 >= TMP_90\\nTMP_92(None) = SOLIDITY_CALL assert(bool)(TMP_91)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-onlyWhitelist()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(blacklist[msg.sender] == false)\\n\\nIRs:\\nREF_48(bool) -> blacklist[msg.sender]\\nTMP_88(bool) = REF_48 == False\\nTMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = Unlimited Chain\\n\\nIRs:\\nname(string) := Unlimited Chain(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = UNC\\n\\nIRs:\\nsymbol(string) := UNC(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint256) := 18(uint256)\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ntotalSupply = 10000000000e18\\n\\nIRs:\\ntotalSupply(uint256) := 10000000000000000000000000000(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ntotalDistributed = 5000000000e18\\n\\nIRs:\\ntotalDistributed(uint256) := 5000000000000000000000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\ntotalRemaining = totalSupply.sub(totalDistributed)\\n\\nIRs:\\nTMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', 'totalDistributed'] \\ntotalRemaining(uint256) := TMP_83(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nvalue = 10000e18\\n\\nIRs:\\nvalue(uint256) := 10000000000000000000000(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: OTHER_ENTRYPOINT 5\\n\\nEXPRESSION:\\ndistributionFinished = false\\n\\nIRs:\\ndistributionFinished(bool) := False(bool)\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_38 = CONVERT 0 to address\\nTMP_39(bool) = _to != TMP_38\\nTMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[msg.sender])\\n\\nIRs:\\nREF_10(uint256) -> balances[msg.sender]\\nTMP_41(bool) = _amount <= REF_10\\nTMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_amount)\\n\\nIRs:\\nREF_11(uint256) -> balances[msg.sender]\\nREF_12(uint256) -> balances[msg.sender]\\nTMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_12', '_amount'] \\nREF_11(uint256) (->balances) := TMP_43(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_14(uint256) -> balances[_to]\\nREF_15(uint256) -> balances[_to]\\nTMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_15', '_amount'] \\nREF_14(uint256) (->balances) := TMP_44(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_amount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_46(uint256) = 2 * 32\\nMODIFIER_CALL, UnlimitedChain.onlyPayloadSize(uint256)(TMP_46)\\\"];\\n7->1;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_48 = CONVERT 0 to address\\nTMP_49(bool) = _to != TMP_48\\nTMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[_from])\\n\\nIRs:\\nREF_17(uint256) -> balances[_from]\\nTMP_51(bool) = _amount <= REF_17\\nTMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_18(mapping(address => uint256)) -> allowed[_from]\\nREF_19(uint256) -> REF_18[msg.sender]\\nTMP_53(bool) = _amount <= REF_19\\nTMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_amount)\\n\\nIRs:\\nREF_20(uint256) -> balances[_from]\\nREF_21(uint256) -> balances[_from]\\nTMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_21', '_amount'] \\nREF_20(uint256) (->balances) := TMP_55(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount)\\n\\nIRs:\\nREF_23(mapping(address => uint256)) -> allowed[_from]\\nREF_24(uint256) -> REF_23[msg.sender]\\nREF_25(mapping(address => uint256)) -> allowed[_from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nTMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_26', '_amount'] \\nREF_24(uint256) (->allowed) := TMP_56(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_28(uint256) -> balances[_to]\\nREF_29(uint256) -> balances[_to]\\nTMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_29', '_amount'] \\nREF_28(uint256) (->balances) := TMP_57(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyPayloadSize(3 * 32)\\n\\nIRs:\\nTMP_59(uint256) = 3 * 32\\nMODIFIER_CALL, UnlimitedChain.onlyPayloadSize(uint256)(TMP_59)\\\"];\\n9->1;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 55.sol-UnlimitedChain-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_13 = CONVERT 0 to address\\nTMP_14(bool) = newOwner != TMP_13\\nCONDITION TMP_14\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 55.sol-UnlimitedChain-withdraw()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\netherBalance = address(this).balance\\n\\nIRs:\\nTMP_67 = CONVERT this to address\\nTMP_68(uint256) = SOLIDITY_CALL balance(address)(TMP_67)\\netherBalance(uint256) := TMP_68(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner.transfer(etherBalance)\\n\\nIRs:\\nTransfer dest:owner value:etherBalance\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 55.sol-UnlimitedChain-withdrawForeignTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntoken = ForeignToken(_tokenContract)\\n\\nIRs:\\nTMP_78 = CONVERT _tokenContract to ForeignToken\\ntoken(ForeignToken) := TMP_78(ForeignToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\namount = token.balanceOf(address(this))\\n\\nIRs:\\nTMP_79 = CONVERT this to address\\nTMP_80(uint256) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:balanceOf, arguments:['TMP_79']  \\namount(uint256) := TMP_80(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntoken.transfer(owner,amount)\\n\\nIRs:\\nTMP_81(bool) = HIGH_LEVEL_CALL, dest:token(ForeignToken), function:transfer, arguments:['owner', 'amount']  \\nRETURN TMP_81\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, UnlimitedChain.onlyOwner()()\\\"];\\n4->1;\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 56.sol-batchTransfer-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(myAddresses.length > 0)\\n\\nIRs:\\nREF_0 -> LENGTH myAddresses\\nTMP_0(bool) = REF_0 > 0\\nTMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ndistr = msg.value / myAddresses.length\\n\\nIRs:\\nREF_1 -> LENGTH myAddresses\\nTMP_2(uint256) = msg.value / REF_1\\ndistr(uint256) := TMP_2(uint256)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < myAddresses.length\\n\\nIRs:\\nREF_2 -> LENGTH myAddresses\\nTMP_3(bool) = i < REF_2\\nCONDITION TMP_3\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nmyAddresses[i].transfer(distr)\\n\\nIRs:\\nREF_3(address) -> myAddresses[i]\\nTransfer dest:REF_3 value:distr\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_5(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n8->6;\\n}\\n// Function: 56.sol-batchTransfer-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nmyAddresses = (0x3aa37a1A58e630bc7F3c42ef784671D0f4374f70,0xD5A69Fa72e14165952a60ae95797D3B12f9F8f4B,0xADfA4B56e9921B2D78474CF6C58f322f8B869eE1,0x83Ee659d700daF65D50E254045AC6f5d15077E63,0x563d38e4Ad54cE080b23194d5Fd6bE4B9E8bBd10,0xE9f2E3ef9Ac5438494185AB47a0441E48494b155,0xc7332373794BB5eDd295E435B1310f9b93140317,0x6c75699CcFedf2F5eF9E5AA403630aA5Dda2B083,0x98ec0b8965d3de711EbE063bf1e05D1D890c51B4,0x06288BC3763335fe00211cA1365c56F19Fd46941,0xF9e702A2b2de526b5b3BA8674e48Df5e7C07eC93,0xd73E27Aca109e4732d5c58B0C558D39AE328aDB5,0xf0A730e613F47B2D557B86A37EcFdDBb6b0B5ad9,0xfeE2aD7478669c3693a53c3d2EED8AeeecE1dDe4,0xB8F190121B5115e632532da04Ca7aC651FFb02d0,0x7158335be63B812fa2e768306FBA015E292a5f8b,0xF86E7DD43C9E4b839dE9A063cdBEfceaB03459ef,0x22025030AA7EBCff5a3d3D7DAF077bE1d5e0c8d0,0x4f09B86C290C6AD005Fe573dfA0235bFd52FeEEd,0x22315f9D6A9C484712D899475736F440b9de1152,0xc6c55d9847210764D062ec412C8238604Ad9380B,0x3D9a646d2255574f3Cba0A36F5372e6e8f241522,0x97969fCF97EE86D5959bE20c55C200bd23e80b1D,0xCAE9DD69676a6475552B1b39D5e9f43F3e01Bd89,0x5DD4c856D9B486fE5AAac3Ce39EAdb23C07d0b2e,0x44103485213Bdd0FF9c230aC628b6CF9f5F606e9,0xCB0f8cCEC09ADD312ABB4A183eA013d03ff49145,0x345080ff41dA758dE4D971a958af1c526E230647,0x88D05292Da94274079483416da63a373175373eF,0x6C0Fd7965aC57b04BE0E88dB2BDDB29F1411EE49,0x3b58ce44FE5Ac577045320AFa728C49752156ae1,0x870C1BE658E48A35723613d53cF677c1d9956f2c,0x14893173FB5f1af998226503bf2105c4882CD45b,0x30735070B87beFd95695716Da872EBF6DfDAf00c,0xf82769dc8c6F58e57184AD98a05C723dCBf9bFDf,0x2C164d86eA898bcA668f1154373032f1d7819c19,0xbb5555Ebc51Ad4B406aEB46Ee3a2dB477A32D2CE,0x70c3cF05D7612038d7021Bd0c3e45300D8A8432F,0x2c4B4be22c2E20779C4bf1Cc453a6948525B6EcD,0xC4a514778599d66dAdd5E61cA3a4a92cfDF61f1e,0x03EcDaCc4aC333Ca6Fa01fd3b1F6E8EfE364BCE6,0x4Bc62d1fE163A64798dA30f45119bC49cB080Ea4,0x3FAf722976D8d8bcb8615788073C982053ea2475,0xA0d6252C8C91eC1EAe222b3b137B2D09c0eADE5C,0xC77Cd3D6C1AedFdD5898504E0318382A1bb64113,0x7412cB12C41d2E8C3225d3E8636932e0eF8B0E25,0x151EE9694C3Aa05f13dD42CFEE120104A2C2C702,0xc6B2C6962d3e7847bca347cCD8217F3Fb54Ee8e8,0xED387a4fd01594704A114f93feab6C15E3451C06,0xaAd53a2D4F55D913B0c636A186eC9842F62e7c8D,0xe223a0Ee8357eD3A4E401E4C075F6fB81e0B5d0C,0x3a4294206d62b127D7B6b35e61Cadf3616b9ce3b,0x46D78473e67914f00926AE8b042A26Cb8356337e,0x2A3Fc7d151089c1AccaDA92112e95038BF1aa2a5,0x0f5A8A6F630B4bbf4C86c1Ba68fde59ff78C312a,0x4c606C1533B5D5ADAa09f2bBDc1A65cdd0844139,0x1a45021279815649E8A770006a8f5e9d7D9cfcF6,0x7B1D1ffAeE89EA4C97E1775d8b01fd38d16B30A9,0x90DE4aD384E55f837AE3c6b7F8fA6415a9348420,0x379a7d894d278924Bc4237d102556afB1bbE46E8,0x521fAfbb76ca1dd4e8C613c38208C2657e5C4c9E,0x96b96F1D083B939c1a0FefF7aB4256F998d5C5dD,0xcc7BB905537057317d54C67edd1Ecd3f5c26920B,0xc4cdE8Cf225F3E40C5F1BbaAA5495e4b244b2e6E,0xb9d5DcEC14A112F78c1da45Fec623915b4844F03,0xc9518a7b2969feD8245Bcc42c908979CD8759631,0xBbc28008bc8450eEBd89399c7C74dC56071D10D7,0xa22Faa7ab6CD0AD52122901eDa399a97deEE9377,0xcb9D9C110512b001BC731e7B8B3E857c25a9C835,0x54928D8d66135bCaFCc8108D4fCA7D5e0e678F06,0x779708dCf9692BF766F9B42CaA309a2e173b94AF,0x65018fE8B7d302539F6877a4dde67e9ef926c115,0xEd1D1cDCD7641743958172Fe1F1E0b5D20d1032a,0xAf75D510765f174b46e3Cb9da5fEE87fE95919CD,0x9baf18558b2ad27e4A699FE47AD063e7Ff1d80DE,0x0F3D8d269EB2B81273Ce048Ec22185652F90513B,0xceb5E1510b0C5aa57A4ea1Ba8cEC2C3c7e363664,0x5499e01b7c512729e060269574e19A3b306C801A,0xa520c91171f8fDc35C07139bD18371b48B87cdD3,0xE8Bd6cA6c7E23a318a4bAF02E3320FaC3c6dA43D,0x2ecf29C7b56F387B5C78250eB66a65b655664Ac1,0x0E7388154F5057477322F5e7F46B40Ff1d166dC4,0xB2939d0E78D0279BFc9b64e1b463a58eA986c453,0x5b172c0Daa91286602196C7Ddc9e538f7Ec763d1,0xD09836B189b0Fc011F452c1F0026266Accc26aE7,0x3e8D5cF9A877b5df2A1cBd0131E47A732Ee8b620,0x7c44E253164615e09f86805DC1890EB02E5EaEAe,0xC2A65214dD838d19Ee1B72172655B4C01c38960e,0xc5B8BEfF14E9ada8DBB02c18C7F03388e9bF1a8a,0x6BdCA97c1b07A6488288E78766174A83435A4d95,0xd1eFa3E2F6784BA4167E36da181377792935DE17,0xa393aA9f6640e27eea432054FCcC522000bd162a,0x1fEd516452aFa36261761D071cefEB573693aeb5,0x266eA623A817373173A20801c7BfC2Bd4B70Fdc7,0x4a317F01307143736E99f8E973B1BbA4fdf72e2C,0x10a1fFdB05aD73F01dc1C0E80c978BC7516ED6b8,0x772234828db64a01397aaD101b4c333fCe450AB8,0xF5d7607c359f8405029de96a6BDc10D6611e590B,0xe36A11D28Ac29Bf74572C3f4fe666eD125493875,0xFC3114b149e5976F251D07FabeB84e854698eD9e,0xB7AAd3280aEc9dC1C3b9E2caCC349319C05624E1)\\n\\nIRs:\\nmyAddresses(address[]) = ['334767122839535679068552188176290653458623057776(address)', '1219730865630301114812267861619705203481039048523(address)', '993237152648354080283706668390982228900621754081(address)', '753194220249328573231211413178101560481354841699(address)', '492338507850749178664023723782606319746496052496(address)', '1335611485962116586884258244750865821203256619349(address)', '1137229589622778634331920652664369401879386653463(address)', '619189390587660523328170008839317496963621105795(address)', '873030578021258466144778908498815476532712853940(address)', '35158149552805132062452199203303325710358440257(address)', '1426690403664068865007817854161159079653592788115(address)', '1228819118051209916903701138445871159107394252213(address)', '1373886269127069966869776651493967235387642043097(address)', '1455138734262384059490410701248397323428050361828(address)', '1055841331754999306788805949170587905817063391952(address)', '647082896678873875402942594693993805395828301707(address)', '1418293754392329422084398294987803221946147297775(address)', '194157273241462580106713639503634024149299546320(address)', '451227043067539991175643883613545240151406407405(address)', '195206751955943299996288434123546173129900298578(address)', '1134781572687288867703866232489241992894214649867(address)', '351691500145835965286092422435998886358753219874(address)', '865416639668044392924554641500949040893056781085(address)', '1158431497019975569369985197398360560801786477961(address)', '535681351679555301624488409818292939011299019566(address)', '388572759479796182689556772531311867173860148969(address)', '1159271903729431290129150614481738795393702203717(address)', '298662816930859059987425411938872106669433882183(address)', '781068493012549478844674418535821785326473671663(address)', '616924294731438891771988530149908091905783230025(address)', '338810889664275342711653812049775316890379709153(address)', '770983793418423963111462029017218823514022571820(address)', '117239325477288380276182409536123613263881360475(address)', '276603150037096423242534370744780141414737178636(address)', '1416708662065868521136311561448087347943519666143(address)', '251692963866224056694171760893468685937663908889(address)', '1069484322258590749062055992551043056344897868494(address)', '643773645876871532631920782765314482909120840495(address)', '252874760190124077936123778365320899899858579149(address)', '1122643596956136492348733707989876771690875592478(address)', '22409008174637141256340466303038712517816007910(address)', '432593786262311040452801591023523893283591294628(address)', '363578993881792849079546990301600065851132355701(address)', '918214121118153088413788790403909415440575290972(address)', '1138872909568768988438877849822537214521513492755(address)', '662662033008945895815599462262564512504591617573(address)', '120578161536852909154957772774937978120423261954(address)', '1134367004603567825175244322823423225047655835880(address)', '1354290309274149815693800694235429946527779724294(address)', '975283557698085055128229808775368148455194000525(address)', '1291026459415674121934505376348264757367577206028(address)', '332606217543637645295248809794876758044475772475(address)', '404435552435919170548427473410772542263343330174(address)', '241199965893735968253552079338070108819630498469(address)', '87653988028678883269575691627023478498530177322(address)', '436033585463215846538419616151317968673078264121(address)', '149972691971281052651823873745648602414369799414(address)', '702855372290617624172664807174390087899771777193(address)', '827051954718094129073308831609112160685868221472(address)', '317439742912866464849533902182307545419974854376(address)', '468843874749448315089494282107729268753217375390(address)', '860483932828174323373552753431873070794381051357(address)', '1167393226492700969229199699561598134663673975307(address)', '1123554124381645728204701535865170202594181328494(address)', '1060932596366661819714033527919961231775276224259(address)', '1149325568701911146888697128204010027844743042609(address)', '1071918772058013020500754623695748399947509993687(address)', '925919490743834241608647725535926551862039188343(address)', '1162439938781557494670999030903224267698743134261(address)', '482823464495999876053317249656527773441920044806(address)', '682738086344947058031979801530650884979296015535(address)', '576642904845148034999564617304404848402296652053(address)', '1353680048588437887837315631092534821249881277226(address)', '1001701132601163979479564296539781683736567421389(address)', '888798319691286573025551560867770347583338021086(address)', '87007502993460267665719363331649719642207834427(address)', '1180108161512537005475456501936289438521619789412(address)', '482986761269495968391467383958893652246138748954(address)', '942714616538054622976742454130335313354190998995(address)', '1328710164553097606934226932710951634114595103805(address)', '267233469275074434318876052463861242071125215937(address)', '82502311011607365379951532715423446358256152004(address)', '1019492248304260020780450332672079642702400373843(address)', '520034914875509830166753567299352115267638879185(address)', '1190864558077977726743195852994955420901467908839(address)', '357109932148617829036863474132631271291186886176(address)', '709451021905320136046615259982866005639198322350(address)', '1111253283550317133732802394137962476761528178190(address)', '1128791157102954507537062820557096568423557569162(address)', '615782940629092406451159939960525865327821213077(address)', '1198523225738667777315063913709870622054190276119(address)', '933858568517892740171781012497443676192396613162(address)', '182271080740896609041491002628190063837603671733(address)', '219409204035922630470324948799869204667674197447(address)', '423569117220678867209052505258810439237337820716(address)', '94956560472442576098459767112792149902196922040(address)', '680132701328730742254636471782733981350266997432(address)', '1403505804115265051244723921938423641098092960011(address)', '1298306336520657643748408828966778854129294456949(address)', '1439760213336258891974294039524386132143027842462(address)', '1048554832062659978824688193723377949808696632545(address)']\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 58.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)\\ndigraph{\\n}\\n// Function: 58.sol-AywakeToken-AywakeToken(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nchangeController(_controller)\\n\\nIRs:\\nINTERNAL_CALL, Controlled.changeController(address)(_controller)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nMiniMeToken(_tokenFactory,0x0,0,AywakeToken,18,AWK,true)\\n\\nIRs:\\nINTERNAL_CALL, MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)(_tokenFactory,0,0,AywakeToken,18,AWK,True)\\\"];\\n2->1;\\n}\\n// Function: 58.sol-AywakeToken-Controlled()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = msg.sender\\n\\nIRs:\\ncontroller(address) := msg.sender(address)\\\"];\\n}\\n// Function: 58.sol-AywakeToken-MiniMeToken(address,address,uint256,string,uint8,string,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntokenFactory = MiniMeTokenFactory(_tokenFactory)\\n\\nIRs:\\nTMP_247 = CONVERT _tokenFactory to MiniMeTokenFactory\\ntokenFactory(MiniMeTokenFactory) := TMP_247(MiniMeTokenFactory)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = _tokenName\\n\\nIRs:\\nname(string) := _tokenName(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndecimals = _decimalUnits\\n\\nIRs:\\ndecimals(uint8) := _decimalUnits(uint8)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsymbol = _tokenSymbol\\n\\nIRs:\\nsymbol(string) := _tokenSymbol(string)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nparentToken = MiniMeToken(_parentToken)\\n\\nIRs:\\nTMP_248 = CONVERT _parentToken to MiniMeToken\\nparentToken(MiniMeToken) := TMP_248(MiniMeToken)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nparentSnapShotBlock = _parentSnapShotBlock\\n\\nIRs:\\nparentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ntransfersEnabled = _transfersEnabled\\n\\nIRs:\\ntransfersEnabled(bool) := _transfersEnabled(bool)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ncreationBlock = block.number\\n\\nIRs:\\ncreationBlock(uint256) := block.number(uint256)\\\"];\\n}\\n// Function: 58.sol-AywakeToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_131(mapping(address => uint256)) -> allowed[_owner]\\nREF_132(uint256) -> REF_131[_spender]\\nRETURN REF_132\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 58.sol-AywakeToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(transfersEnabled)\\n\\nIRs:\\nTMP_282(None) = SOLIDITY_CALL require(bool)(transfersEnabled)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)((_amount == 0) || (allowed[msg.sender][_spender] == 0))\\n\\nIRs:\\nTMP_283(bool) = _amount == 0\\nREF_126(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_127(uint256) -> REF_126[_spender]\\nTMP_284(bool) = REF_127 == 0\\nTMP_285(bool) = TMP_283 || TMP_284\\nTMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nisContract(controller)\\n\\nIRs:\\nTMP_287(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)\\nCONDITION TMP_287\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))\\n\\nIRs:\\nTMP_288 = CONVERT controller to TokenController\\nTMP_289(bool) = HIGH_LEVEL_CALL, dest:TMP_288(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  \\nTMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _amount\\n\\nIRs:\\nREF_129(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_130(uint256) -> REF_129[_spender]\\nREF_130(uint256) (->allowed) := _amount(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_amount)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-AywakeToken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(approve(_spender,_amount))\\n\\nIRs:\\nTMP_292(bool) = INTERNAL_CALL, MiniMeToken.approve(address,uint256)(_spender,_amount)\\nTMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)\\n\\nIRs:\\nTMP_294 = CONVERT _spender to ApproveAndCallFallBack\\nHIGH_LEVEL_CALL, dest:TMP_294(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  \\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-AywakeToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalanceOfAt(_owner,block.number)\\n\\nIRs:\\nTMP_281(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_owner,block.number)\\nRETURN TMP_281\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 58.sol-AywakeToken-balanceOfAt(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)\\n\\nIRs:\\nREF_134(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nREF_135 -> LENGTH REF_134\\nTMP_297(bool) = REF_135 == 0\\nREF_136(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nREF_137(MiniMeToken.Checkpoint) -> REF_136[0]\\nREF_138(uint128) -> REF_137.fromBlock\\nTMP_298(bool) = REF_138 > _blockNumber\\nTMP_299(bool) = TMP_297 || TMP_298\\nCONDITION TMP_299\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\naddress(parentToken) != 0\\n\\nIRs:\\nTMP_300 = CONVERT parentToken to address\\nTMP_301(bool) = TMP_300 != 0\\nCONDITION TMP_301\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nparentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))\\n\\nIRs:\\nTMP_302(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)\\nTMP_303(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:balanceOfAt, arguments:['_owner', 'TMP_302']  \\nRETURN TMP_303\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ngetValueAt(balances[_owner],_blockNumber)\\n\\nIRs:\\nREF_140(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nTMP_304(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(REF_140,_blockNumber)\\nRETURN TMP_304\\\"];\\n}\\n// Function: 58.sol-AywakeToken-changeController(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = _newController\\n\\nIRs:\\ncontroller(address) := _newController(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n2->1;\\n}\\n// Function: 58.sol-AywakeToken-claimTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_token == 0x0\\n\\nIRs:\\nTMP_376(bool) = _token == 0\\nCONDITION TMP_376\\\"];\\n1->2[label=\\\"True\\\"];\\n1->4[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncontroller.transfer(this.balance)\\n\\nIRs:\\nREF_177(uint256) = SOLIDITY_CALL balance(address)(this)\\nTransfer dest:controller value:REF_177\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ntoken = MiniMeToken(_token)\\n\\nIRs:\\nTMP_378 = CONVERT _token to MiniMeToken\\ntoken(MiniMeToken) := TMP_378(MiniMeToken)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_379(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_379(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ntoken.transfer(controller,balance)\\n\\nIRs:\\nTMP_380(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  \\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nClaimedTokens(_token,controller,balance)\\n\\nIRs:\\nEmit ClaimedTokens(_token,controller,balance)\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n9->1;\\n}\\n// Function: 58.sol-AywakeToken-createCloneToken(string,uint8,string,uint256,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_snapshotBlock == 0\\n\\nIRs:\\nTMP_313(bool) = _snapshotBlock == 0\\nCONDITION TMP_313\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_snapshotBlock = block.number\\n\\nIRs:\\n_snapshotBlock(uint256) := block.number(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ncloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)\\n\\nIRs:\\nTMP_314(MiniMeToken) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  \\ncloneToken(MiniMeToken) := TMP_314(MiniMeToken)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncloneToken.changeController(msg.sender)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:cloneToken(MiniMeToken), function:changeController, arguments:['msg.sender']  \\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nNewCloneToken(address(cloneToken),_snapshotBlock)\\n\\nIRs:\\nTMP_316 = CONVERT cloneToken to address\\nEmit NewCloneToken(TMP_316,_snapshotBlock)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\naddress(cloneToken)\\n\\nIRs:\\nTMP_318 = CONVERT cloneToken to address\\nRETURN TMP_318\\\"];\\n}\\n// Function: 58.sol-AywakeToken-destroyTokens(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ncurTotalSupply = totalSupply()\\n\\nIRs:\\nTMP_333(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()\\ncurTotalSupply(uint256) := TMP_333(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(curTotalSupply >= _amount)\\n\\nIRs:\\nTMP_334(bool) = curTotalSupply >= _amount\\nTMP_335(None) = SOLIDITY_CALL require(bool)(TMP_334)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\npreviousBalanceFrom = balanceOf(_owner)\\n\\nIRs:\\nTMP_336(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)\\npreviousBalanceFrom(uint256) := TMP_336(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceFrom >= _amount)\\n\\nIRs:\\nTMP_337(bool) = previousBalanceFrom >= _amount\\nTMP_338(None) = SOLIDITY_CALL require(bool)(TMP_337)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nupdateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)\\n\\nIRs:\\nTMP_339(uint256) = curTotalSupply - _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_339)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_owner],previousBalanceFrom - _amount)\\n\\nIRs:\\nREF_148(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nTMP_341(uint256) = previousBalanceFrom - _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_148,TMP_341)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_owner,0,_amount)\\n\\nIRs:\\nEmit Transfer(_owner,0,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n9->1;\\n}\\n// Function: 58.sol-AywakeToken-doTransfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_amount == 0\\n\\nIRs:\\nTMP_256(bool) = _amount == 0\\nCONDITION TMP_256\\\"];\\n1->2[label=\\\"True\\\"];\\n1->4[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(parentSnapShotBlock < block.number)\\n\\nIRs:\\nTMP_258(bool) = parentSnapShotBlock < block.number\\nTMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrequire(bool)((_to != 0) && (_to != address(this)))\\n\\nIRs:\\nTMP_260(bool) = _to != 0\\nTMP_261 = CONVERT this to address\\nTMP_262(bool) = _to != TMP_261\\nTMP_263(bool) = TMP_260 && TMP_262\\nTMP_264(None) = SOLIDITY_CALL require(bool)(TMP_263)\\\"];\\n6->7;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\npreviousBalanceFrom = balanceOfAt(_from,block.number)\\n\\nIRs:\\nTMP_265(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_from,block.number)\\npreviousBalanceFrom(uint256) := TMP_265(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceFrom >= _amount)\\n\\nIRs:\\nTMP_266(bool) = previousBalanceFrom >= _amount\\nTMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266)\\\"];\\n8->9;\\n9[label=\\\"Node Type: IF 9\\n\\nEXPRESSION:\\nisContract(controller)\\n\\nIRs:\\nTMP_268(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)\\nCONDITION TMP_268\\\"];\\n9->10[label=\\\"True\\\"];\\n9->11[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nrequire(bool)(TokenController(controller).onTransfer(_from,_to,_amount))\\n\\nIRs:\\nTMP_269 = CONVERT controller to TokenController\\nTMP_270(bool) = HIGH_LEVEL_CALL, dest:TMP_269(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  \\nTMP_271(None) = SOLIDITY_CALL require(bool)(TMP_270)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_from],previousBalanceFrom - _amount)\\n\\nIRs:\\nREF_124(MiniMeToken.Checkpoint[]) -> balances[_from]\\nTMP_272(uint256) = previousBalanceFrom - _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_124,TMP_272)\\\"];\\n12->13;\\n13[label=\\\"Node Type: NEW VARIABLE 13\\n\\nEXPRESSION:\\npreviousBalanceTo = balanceOfAt(_to,block.number)\\n\\nIRs:\\nTMP_274(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_to,block.number)\\npreviousBalanceTo(uint256) := TMP_274(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceTo + _amount >= previousBalanceTo)\\n\\nIRs:\\nTMP_275(uint256) = previousBalanceTo + _amount\\nTMP_276(bool) = TMP_275 >= previousBalanceTo\\nTMP_277(None) = SOLIDITY_CALL require(bool)(TMP_276)\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_to],previousBalanceTo + _amount)\\n\\nIRs:\\nREF_125(MiniMeToken.Checkpoint[]) -> balances[_to]\\nTMP_278(uint256) = previousBalanceTo + _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_125,TMP_278)\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n}\\n// Function: 58.sol-AywakeToken-enableTransfers(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntransfersEnabled = _transfersEnabled\\n\\nIRs:\\ntransfersEnabled(bool) := _transfersEnabled(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n2->1;\\n}\\n// Function: 58.sol-AywakeToken-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(isContract(controller))\\n\\nIRs:\\nTMP_370(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)\\nTMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\\n\\nIRs:\\nTMP_372 = CONVERT controller to TokenController\\nTMP_374(bool) = HIGH_LEVEL_CALL, dest:TMP_372(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value \\nTMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)\\\"];\\n}\\n// Function: 58.sol-AywakeToken-generateTokens(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ncurTotalSupply = totalSupply()\\n\\nIRs:\\nTMP_319(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()\\ncurTotalSupply(uint256) := TMP_319(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(curTotalSupply + _amount >= curTotalSupply)\\n\\nIRs:\\nTMP_320(uint256) = curTotalSupply + _amount\\nTMP_321(bool) = TMP_320 >= curTotalSupply\\nTMP_322(None) = SOLIDITY_CALL require(bool)(TMP_321)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\npreviousBalanceTo = balanceOf(_owner)\\n\\nIRs:\\nTMP_323(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)\\npreviousBalanceTo(uint256) := TMP_323(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceTo + _amount >= previousBalanceTo)\\n\\nIRs:\\nTMP_324(uint256) = previousBalanceTo + _amount\\nTMP_325(bool) = TMP_324 >= previousBalanceTo\\nTMP_326(None) = SOLIDITY_CALL require(bool)(TMP_325)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nupdateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)\\n\\nIRs:\\nTMP_327(uint256) = curTotalSupply + _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_327)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_owner],previousBalanceTo + _amount)\\n\\nIRs:\\nREF_147(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nTMP_329(uint256) = previousBalanceTo + _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_147,TMP_329)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(0,_owner,_amount)\\n\\nIRs:\\nEmit Transfer(0,_owner,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n9->1;\\n}\\n// Function: 58.sol-AywakeToken-getValueAt(MiniMeToken.Checkpoint[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncheckpoints.length == 0\\n\\nIRs:\\nREF_149 -> LENGTH checkpoints\\nTMP_346(bool) = REF_149 == 0\\nCONDITION TMP_346\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n_block >= checkpoints[checkpoints.length - 1].fromBlock\\n\\nIRs:\\nREF_150 -> LENGTH checkpoints\\nTMP_347(uint256) = REF_150 - 1\\nREF_151(MiniMeToken.Checkpoint) -> checkpoints[TMP_347]\\nREF_152(uint128) -> REF_151.fromBlock\\nTMP_348(bool) = _block >= REF_152\\nCONDITION TMP_348\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ncheckpoints[checkpoints.length - 1].value\\n\\nIRs:\\nREF_153 -> LENGTH checkpoints\\nTMP_349(uint256) = REF_153 - 1\\nREF_154(MiniMeToken.Checkpoint) -> checkpoints[TMP_349]\\nREF_155(uint128) -> REF_154.value\\nRETURN REF_155\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\n_block < checkpoints[0].fromBlock\\n\\nIRs:\\nREF_156(MiniMeToken.Checkpoint) -> checkpoints[0]\\nREF_157(uint128) -> REF_156.fromBlock\\nTMP_350(bool) = _block < REF_157\\nCONDITION TMP_350\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\nmin = 0\\n\\nIRs:\\nmin(uint256) := 0(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: NEW VARIABLE 11\\n\\nEXPRESSION:\\nmax = checkpoints.length - 1\\n\\nIRs:\\nREF_158 -> LENGTH checkpoints\\nTMP_351(uint256) = REF_158 - 1\\nmax(uint256) := TMP_351(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: BEGIN_LOOP 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: IF_LOOP 13\\n\\nEXPRESSION:\\nmax > min\\n\\nIRs:\\nTMP_352(bool) = max > min\\nCONDITION TMP_352\\\"];\\n13->14[label=\\\"True\\\"];\\n13->19[label=\\\"False\\\"];\\n14[label=\\\"Node Type: NEW VARIABLE 14\\n\\nEXPRESSION:\\nmid = (max + min + 1) / 2\\n\\nIRs:\\nTMP_353(uint256) = max + min\\nTMP_354(uint256) = TMP_353 + 1\\nTMP_355(uint256) = TMP_354 / 2\\nmid(uint256) := TMP_355(uint256)\\\"];\\n14->15;\\n15[label=\\\"Node Type: IF 15\\n\\nEXPRESSION:\\ncheckpoints[mid].fromBlock <= _block\\n\\nIRs:\\nREF_159(MiniMeToken.Checkpoint) -> checkpoints[mid]\\nREF_160(uint128) -> REF_159.fromBlock\\nTMP_356(bool) = REF_160 <= _block\\nCONDITION TMP_356\\\"];\\n15->16[label=\\\"True\\\"];\\n15->17[label=\\\"False\\\"];\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nmin = mid\\n\\nIRs:\\nmin(uint256) := mid(uint256)\\\"];\\n16->18;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nmax = mid - 1\\n\\nIRs:\\nTMP_357(uint256) = mid - 1\\nmax(uint256) := TMP_357(uint256)\\\"];\\n17->18;\\n18[label=\\\"Node Type: END_IF 18\\n\\\"];\\n18->13;\\n19[label=\\\"Node Type: END_LOOP 19\\n\\\"];\\n19->20;\\n20[label=\\\"Node Type: RETURN 20\\n\\nEXPRESSION:\\ncheckpoints[min].value\\n\\nIRs:\\nREF_161(MiniMeToken.Checkpoint) -> checkpoints[min]\\nREF_162(uint128) -> REF_161.value\\nRETURN REF_162\\\"];\\n}\\n// Function: 58.sol-AywakeToken-isContract(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_addr == 0\\n\\nIRs:\\nTMP_367(bool) = _addr == 0\\nCONDITION TMP_367\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: END INLINE ASM 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsize > 0\\n\\nIRs:\\nTMP_368(bool) = size > 0\\nRETURN TMP_368\\\"];\\n}\\n// Function: 58.sol-AywakeToken-min(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_369(bool) = a < b\\nCONDITION TMP_369\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 58.sol-AywakeToken-onlyController()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == controller)\\n\\nIRs:\\nTMP_386(bool) = msg.sender == controller\\nTMP_387(None) = SOLIDITY_CALL require(bool)(TMP_386)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 58.sol-AywakeToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nversion = MMT_0.2\\n\\nIRs:\\nversion(string) := MMT_0.2(string)\\\"];\\n}\\n// Function: 58.sol-AywakeToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntotalSupplyAt(block.number)\\n\\nIRs:\\nTMP_296(uint256) = INTERNAL_CALL, MiniMeToken.totalSupplyAt(uint256)(block.number)\\nRETURN TMP_296\\\"];\\n}\\n// Function: 58.sol-AywakeToken-totalSupplyAt(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)\\n\\nIRs:\\nREF_141 -> LENGTH totalSupplyHistory\\nTMP_305(bool) = REF_141 == 0\\nREF_142(MiniMeToken.Checkpoint) -> totalSupplyHistory[0]\\nREF_143(uint128) -> REF_142.fromBlock\\nTMP_306(bool) = REF_143 > _blockNumber\\nTMP_307(bool) = TMP_305 || TMP_306\\nCONDITION TMP_307\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\naddress(parentToken) != 0\\n\\nIRs:\\nTMP_308 = CONVERT parentToken to address\\nTMP_309(bool) = TMP_308 != 0\\nCONDITION TMP_309\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nparentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))\\n\\nIRs:\\nTMP_310(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)\\nTMP_311(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:totalSupplyAt, arguments:['TMP_310']  \\nRETURN TMP_311\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ngetValueAt(totalSupplyHistory,_blockNumber)\\n\\nIRs:\\nTMP_312(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)\\nRETURN TMP_312\\\"];\\n}\\n// Function: 58.sol-AywakeToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(transfersEnabled)\\n\\nIRs:\\nTMP_249(None) = SOLIDITY_CALL require(bool)(transfersEnabled)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ndoTransfer(msg.sender,_to,_amount)\\n\\nIRs:\\nINTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(msg.sender,_to,_amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-AywakeToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender != controller\\n\\nIRs:\\nTMP_251(bool) = msg.sender != controller\\nCONDITION TMP_251\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(transfersEnabled)\\n\\nIRs:\\nTMP_252(None) = SOLIDITY_CALL require(bool)(transfersEnabled)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(allowed[_from][msg.sender] >= _amount)\\n\\nIRs:\\nREF_119(mapping(address => uint256)) -> allowed[_from]\\nREF_120(uint256) -> REF_119[msg.sender]\\nTMP_253(bool) = REF_120 >= _amount\\nTMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] -= _amount\\n\\nIRs:\\nREF_121(mapping(address => uint256)) -> allowed[_from]\\nREF_122(uint256) -> REF_121[msg.sender]\\nREF_122(-> allowed) = REF_122 - _amount\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ndoTransfer(_from,_to,_amount)\\n\\nIRs:\\nINTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(_from,_to,_amount)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-AywakeToken-updateValueAtNow(MiniMeToken.Checkpoint[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)\\n\\nIRs:\\nREF_163 -> LENGTH checkpoints\\nTMP_358(bool) = REF_163 == 0\\nREF_164 -> LENGTH checkpoints\\nTMP_359(uint256) = REF_164 - 1\\nREF_165(MiniMeToken.Checkpoint) -> checkpoints[TMP_359]\\nREF_166(uint128) -> REF_165.fromBlock\\nTMP_360(bool) = REF_166 < block.number\\nTMP_361(bool) = TMP_358 || TMP_360\\nCONDITION TMP_361\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nnewCheckPoint = checkpoints[checkpoints.length ++]\\n\\nIRs:\\nREF_167 -> LENGTH checkpoints\\nTMP_362(uint256) := REF_167(uint256)\\nREF_167(-> checkpoints) = REF_167 + 1\\nREF_168(MiniMeToken.Checkpoint) -> checkpoints[TMP_362]\\nnewCheckPoint(MiniMeToken.Checkpoint) := REF_168(MiniMeToken.Checkpoint)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nnewCheckPoint.fromBlock = uint128(block.number)\\n\\nIRs:\\nREF_169(uint128) -> newCheckPoint.fromBlock\\nTMP_363 = CONVERT block.number to uint128\\nREF_169(uint128) (->newCheckPoint) := TMP_363(uint128)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewCheckPoint.value = uint128(_value)\\n\\nIRs:\\nREF_170(uint128) -> newCheckPoint.value\\nTMP_364 = CONVERT _value to uint128\\nREF_170(uint128) (->newCheckPoint) := TMP_364(uint128)\\\"];\\n4->7;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\noldCheckPoint = checkpoints[checkpoints.length - 1]\\n\\nIRs:\\nREF_171 -> LENGTH checkpoints\\nTMP_365(uint256) = REF_171 - 1\\nREF_172(MiniMeToken.Checkpoint) -> checkpoints[TMP_365]\\noldCheckPoint(MiniMeToken.Checkpoint) := REF_172(MiniMeToken.Checkpoint)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\noldCheckPoint.value = uint128(_value)\\n\\nIRs:\\nREF_173(uint128) -> oldCheckPoint.value\\nTMP_366 = CONVERT _value to uint128\\nREF_173(uint128) (->oldCheckPoint) := TMP_366(uint128)\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n}\\n// Function: 58.sol-Controlled-Controlled()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = msg.sender\\n\\nIRs:\\ncontroller(address) := msg.sender(address)\\\"];\\n}\\n// Function: 58.sol-Controlled-changeController(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = _newController\\n\\nIRs:\\ncontroller(address) := _newController(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n2->1;\\n}\\n// Function: 58.sol-Controlled-onlyController()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == controller)\\n\\nIRs:\\nTMP_1(bool) = msg.sender == controller\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 58.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20-approveAndCall(address,uint256,bytes)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20-doTransfer(address,address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 58.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 58.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 58.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-LimitedTransferToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 58.sol-LimitedTransferToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-LimitedTransferToken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n}\\n// Function: 58.sol-LimitedTransferToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 58.sol-LimitedTransferToken-canTransfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value < transferableTokens(_sender,uint64(now)))\\n\\nIRs:\\nTMP_168 = CONVERT now to uint64\\nTMP_169(uint256) = INTERNAL_CALL, LimitedTransferToken.transferableTokens(address,uint64)(_sender,TMP_168)\\nTMP_170(bool) = _value < TMP_169\\nTMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 58.sol-LimitedTransferToken-doTransfer(address,address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-LimitedTransferToken-totalSupply()\\ndigraph{\\n}\\n// Function: 58.sol-LimitedTransferToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transfer(_to,_value)\\n\\nIRs:\\nTMP_163(bool) = INTERNAL_CALL, ERC20Basic.transfer(address,uint256)(_to,_value)\\nRETURN TMP_163\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncanTransfer(msg.sender,_value)\\n\\nIRs:\\nMODIFIER_CALL, LimitedTransferToken.canTransfer(address,uint256)(msg.sender,_value)\\\"];\\n2->1;\\n}\\n// Function: 58.sol-LimitedTransferToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nsuper.transferFrom(_from,_to,_value)\\n\\nIRs:\\nTMP_165(bool) = INTERNAL_CALL, ERC20.transferFrom(address,address,uint256)(_from,_to,_value)\\nRETURN TMP_165\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncanTransfer(_from,_value)\\n\\nIRs:\\nMODIFIER_CALL, LimitedTransferToken.canTransfer(address,uint256)(_from,_value)\\\"];\\n2->1;\\n}\\n// Function: 58.sol-LimitedTransferToken-transferableTokens(address,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalanceOf(holder)\\n\\nIRs:\\nTMP_167(uint256) = INTERNAL_CALL, ERC20Basic.balanceOf(address)(holder)\\nRETURN TMP_167\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-Controlled()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = msg.sender\\n\\nIRs:\\ncontroller(address) := msg.sender(address)\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-MiniMeToken(address,address,uint256,string,uint8,string,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntokenFactory = MiniMeTokenFactory(_tokenFactory)\\n\\nIRs:\\nTMP_22 = CONVERT _tokenFactory to MiniMeTokenFactory\\ntokenFactory(MiniMeTokenFactory) := TMP_22(MiniMeTokenFactory)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = _tokenName\\n\\nIRs:\\nname(string) := _tokenName(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndecimals = _decimalUnits\\n\\nIRs:\\ndecimals(uint8) := _decimalUnits(uint8)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsymbol = _tokenSymbol\\n\\nIRs:\\nsymbol(string) := _tokenSymbol(string)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nparentToken = MiniMeToken(_parentToken)\\n\\nIRs:\\nTMP_23 = CONVERT _parentToken to MiniMeToken\\nparentToken(MiniMeToken) := TMP_23(MiniMeToken)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nparentSnapShotBlock = _parentSnapShotBlock\\n\\nIRs:\\nparentSnapShotBlock(uint256) := _parentSnapShotBlock(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ntransfersEnabled = _transfersEnabled\\n\\nIRs:\\ntransfersEnabled(bool) := _transfersEnabled(bool)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ncreationBlock = block.number\\n\\nIRs:\\ncreationBlock(uint256) := block.number(uint256)\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_12(mapping(address => uint256)) -> allowed[_owner]\\nREF_13(uint256) -> REF_12[_spender]\\nRETURN REF_13\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(transfersEnabled)\\n\\nIRs:\\nTMP_57(None) = SOLIDITY_CALL require(bool)(transfersEnabled)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)((_amount == 0) || (allowed[msg.sender][_spender] == 0))\\n\\nIRs:\\nTMP_58(bool) = _amount == 0\\nREF_7(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_8(uint256) -> REF_7[_spender]\\nTMP_59(bool) = REF_8 == 0\\nTMP_60(bool) = TMP_58 || TMP_59\\nTMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nisContract(controller)\\n\\nIRs:\\nTMP_62(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)\\nCONDITION TMP_62\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(TokenController(controller).onApprove(msg.sender,_spender,_amount))\\n\\nIRs:\\nTMP_63 = CONVERT controller to TokenController\\nTMP_64(bool) = HIGH_LEVEL_CALL, dest:TMP_63(TokenController), function:onApprove, arguments:['msg.sender', '_spender', '_amount']  \\nTMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _amount\\n\\nIRs:\\nREF_10(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_11(uint256) -> REF_10[_spender]\\nREF_11(uint256) (->allowed) := _amount(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_amount)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(approve(_spender,_amount))\\n\\nIRs:\\nTMP_67(bool) = INTERNAL_CALL, MiniMeToken.approve(address,uint256)(_spender,_amount)\\nTMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_amount,this,_extraData)\\n\\nIRs:\\nTMP_69 = CONVERT _spender to ApproveAndCallFallBack\\nHIGH_LEVEL_CALL, dest:TMP_69(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  \\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalanceOfAt(_owner,block.number)\\n\\nIRs:\\nTMP_56(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_owner,block.number)\\nRETURN TMP_56\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-balanceOfAt(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n(balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)\\n\\nIRs:\\nREF_15(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nREF_16 -> LENGTH REF_15\\nTMP_72(bool) = REF_16 == 0\\nREF_17(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nREF_18(MiniMeToken.Checkpoint) -> REF_17[0]\\nREF_19(uint128) -> REF_18.fromBlock\\nTMP_73(bool) = REF_19 > _blockNumber\\nTMP_74(bool) = TMP_72 || TMP_73\\nCONDITION TMP_74\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\naddress(parentToken) != 0\\n\\nIRs:\\nTMP_75 = CONVERT parentToken to address\\nTMP_76(bool) = TMP_75 != 0\\nCONDITION TMP_76\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nparentToken.balanceOfAt(_owner,min(_blockNumber,parentSnapShotBlock))\\n\\nIRs:\\nTMP_77(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)\\nTMP_78(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:balanceOfAt, arguments:['_owner', 'TMP_77']  \\nRETURN TMP_78\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ngetValueAt(balances[_owner],_blockNumber)\\n\\nIRs:\\nREF_21(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nTMP_79(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(REF_21,_blockNumber)\\nRETURN TMP_79\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-changeController(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = _newController\\n\\nIRs:\\ncontroller(address) := _newController(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n2->1;\\n}\\n// Function: 58.sol-MiniMeToken-claimTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_token == 0x0\\n\\nIRs:\\nTMP_151(bool) = _token == 0\\nCONDITION TMP_151\\\"];\\n1->2[label=\\\"True\\\"];\\n1->4[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ncontroller.transfer(this.balance)\\n\\nIRs:\\nREF_58(uint256) = SOLIDITY_CALL balance(address)(this)\\nTransfer dest:controller value:REF_58\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ntoken = MiniMeToken(_token)\\n\\nIRs:\\nTMP_153 = CONVERT _token to MiniMeToken\\ntoken(MiniMeToken) := TMP_153(MiniMeToken)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_154(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_154(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ntoken.transfer(controller,balance)\\n\\nIRs:\\nTMP_155(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  \\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nClaimedTokens(_token,controller,balance)\\n\\nIRs:\\nEmit ClaimedTokens(_token,controller,balance)\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n9->1;\\n}\\n// Function: 58.sol-MiniMeToken-createCloneToken(string,uint8,string,uint256,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_snapshotBlock == 0\\n\\nIRs:\\nTMP_88(bool) = _snapshotBlock == 0\\nCONDITION TMP_88\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_snapshotBlock = block.number\\n\\nIRs:\\n_snapshotBlock(uint256) := block.number(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ncloneToken = tokenFactory.createCloneToken(this,_snapshotBlock,_cloneTokenName,_cloneDecimalUnits,_cloneTokenSymbol,_transfersEnabled)\\n\\nIRs:\\nTMP_89(MiniMeToken) = HIGH_LEVEL_CALL, dest:tokenFactory(MiniMeTokenFactory), function:createCloneToken, arguments:['this', '_snapshotBlock', '_cloneTokenName', '_cloneDecimalUnits', '_cloneTokenSymbol', '_transfersEnabled']  \\ncloneToken(MiniMeToken) := TMP_89(MiniMeToken)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncloneToken.changeController(msg.sender)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:cloneToken(MiniMeToken), function:changeController, arguments:['msg.sender']  \\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nNewCloneToken(address(cloneToken),_snapshotBlock)\\n\\nIRs:\\nTMP_91 = CONVERT cloneToken to address\\nEmit NewCloneToken(TMP_91,_snapshotBlock)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\naddress(cloneToken)\\n\\nIRs:\\nTMP_93 = CONVERT cloneToken to address\\nRETURN TMP_93\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-destroyTokens(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ncurTotalSupply = totalSupply()\\n\\nIRs:\\nTMP_108(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()\\ncurTotalSupply(uint256) := TMP_108(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(curTotalSupply >= _amount)\\n\\nIRs:\\nTMP_109(bool) = curTotalSupply >= _amount\\nTMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\npreviousBalanceFrom = balanceOf(_owner)\\n\\nIRs:\\nTMP_111(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)\\npreviousBalanceFrom(uint256) := TMP_111(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceFrom >= _amount)\\n\\nIRs:\\nTMP_112(bool) = previousBalanceFrom >= _amount\\nTMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nupdateValueAtNow(totalSupplyHistory,curTotalSupply - _amount)\\n\\nIRs:\\nTMP_114(uint256) = curTotalSupply - _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_114)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_owner],previousBalanceFrom - _amount)\\n\\nIRs:\\nREF_29(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nTMP_116(uint256) = previousBalanceFrom - _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_29,TMP_116)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_owner,0,_amount)\\n\\nIRs:\\nEmit Transfer(_owner,0,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n9->1;\\n}\\n// Function: 58.sol-MiniMeToken-doTransfer(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_amount == 0\\n\\nIRs:\\nTMP_31(bool) = _amount == 0\\nCONDITION TMP_31\\\"];\\n1->2[label=\\\"True\\\"];\\n1->4[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool)(parentSnapShotBlock < block.number)\\n\\nIRs:\\nTMP_33(bool) = parentSnapShotBlock < block.number\\nTMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrequire(bool)((_to != 0) && (_to != address(this)))\\n\\nIRs:\\nTMP_35(bool) = _to != 0\\nTMP_36 = CONVERT this to address\\nTMP_37(bool) = _to != TMP_36\\nTMP_38(bool) = TMP_35 && TMP_37\\nTMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)\\\"];\\n6->7;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\npreviousBalanceFrom = balanceOfAt(_from,block.number)\\n\\nIRs:\\nTMP_40(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_from,block.number)\\npreviousBalanceFrom(uint256) := TMP_40(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceFrom >= _amount)\\n\\nIRs:\\nTMP_41(bool) = previousBalanceFrom >= _amount\\nTMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)\\\"];\\n8->9;\\n9[label=\\\"Node Type: IF 9\\n\\nEXPRESSION:\\nisContract(controller)\\n\\nIRs:\\nTMP_43(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)\\nCONDITION TMP_43\\\"];\\n9->10[label=\\\"True\\\"];\\n9->11[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nrequire(bool)(TokenController(controller).onTransfer(_from,_to,_amount))\\n\\nIRs:\\nTMP_44 = CONVERT controller to TokenController\\nTMP_45(bool) = HIGH_LEVEL_CALL, dest:TMP_44(TokenController), function:onTransfer, arguments:['_from', '_to', '_amount']  \\nTMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_from],previousBalanceFrom - _amount)\\n\\nIRs:\\nREF_5(MiniMeToken.Checkpoint[]) -> balances[_from]\\nTMP_47(uint256) = previousBalanceFrom - _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_5,TMP_47)\\\"];\\n12->13;\\n13[label=\\\"Node Type: NEW VARIABLE 13\\n\\nEXPRESSION:\\npreviousBalanceTo = balanceOfAt(_to,block.number)\\n\\nIRs:\\nTMP_49(uint256) = INTERNAL_CALL, MiniMeToken.balanceOfAt(address,uint256)(_to,block.number)\\npreviousBalanceTo(uint256) := TMP_49(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceTo + _amount >= previousBalanceTo)\\n\\nIRs:\\nTMP_50(uint256) = previousBalanceTo + _amount\\nTMP_51(bool) = TMP_50 >= previousBalanceTo\\nTMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_to],previousBalanceTo + _amount)\\n\\nIRs:\\nREF_6(MiniMeToken.Checkpoint[]) -> balances[_to]\\nTMP_53(uint256) = previousBalanceTo + _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_6,TMP_53)\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-enableTransfers(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntransfersEnabled = _transfersEnabled\\n\\nIRs:\\ntransfersEnabled(bool) := _transfersEnabled(bool)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n2->1;\\n}\\n// Function: 58.sol-MiniMeToken-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(isContract(controller))\\n\\nIRs:\\nTMP_145(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)\\nTMP_146(None) = SOLIDITY_CALL require(bool)(TMP_145)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\\n\\nIRs:\\nTMP_147 = CONVERT controller to TokenController\\nTMP_149(bool) = HIGH_LEVEL_CALL, dest:TMP_147(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value \\nTMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-generateTokens(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ncurTotalSupply = totalSupply()\\n\\nIRs:\\nTMP_94(uint256) = INTERNAL_CALL, MiniMeToken.totalSupply()()\\ncurTotalSupply(uint256) := TMP_94(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(curTotalSupply + _amount >= curTotalSupply)\\n\\nIRs:\\nTMP_95(uint256) = curTotalSupply + _amount\\nTMP_96(bool) = TMP_95 >= curTotalSupply\\nTMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\npreviousBalanceTo = balanceOf(_owner)\\n\\nIRs:\\nTMP_98(uint256) = INTERNAL_CALL, MiniMeToken.balanceOf(address)(_owner)\\npreviousBalanceTo(uint256) := TMP_98(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(previousBalanceTo + _amount >= previousBalanceTo)\\n\\nIRs:\\nTMP_99(uint256) = previousBalanceTo + _amount\\nTMP_100(bool) = TMP_99 >= previousBalanceTo\\nTMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nupdateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)\\n\\nIRs:\\nTMP_102(uint256) = curTotalSupply + _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,TMP_102)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nupdateValueAtNow(balances[_owner],previousBalanceTo + _amount)\\n\\nIRs:\\nREF_28(MiniMeToken.Checkpoint[]) -> balances[_owner]\\nTMP_104(uint256) = previousBalanceTo + _amount\\nINTERNAL_CALL, MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)(REF_28,TMP_104)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(0,_owner,_amount)\\n\\nIRs:\\nEmit Transfer(0,_owner,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n9->1;\\n}\\n// Function: 58.sol-MiniMeToken-getValueAt(MiniMeToken.Checkpoint[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncheckpoints.length == 0\\n\\nIRs:\\nREF_30 -> LENGTH checkpoints\\nTMP_121(bool) = REF_30 == 0\\nCONDITION TMP_121\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\n_block >= checkpoints[checkpoints.length - 1].fromBlock\\n\\nIRs:\\nREF_31 -> LENGTH checkpoints\\nTMP_122(uint256) = REF_31 - 1\\nREF_32(MiniMeToken.Checkpoint) -> checkpoints[TMP_122]\\nREF_33(uint128) -> REF_32.fromBlock\\nTMP_123(bool) = _block >= REF_33\\nCONDITION TMP_123\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ncheckpoints[checkpoints.length - 1].value\\n\\nIRs:\\nREF_34 -> LENGTH checkpoints\\nTMP_124(uint256) = REF_34 - 1\\nREF_35(MiniMeToken.Checkpoint) -> checkpoints[TMP_124]\\nREF_36(uint128) -> REF_35.value\\nRETURN REF_36\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\n_block < checkpoints[0].fromBlock\\n\\nIRs:\\nREF_37(MiniMeToken.Checkpoint) -> checkpoints[0]\\nREF_38(uint128) -> REF_37.fromBlock\\nTMP_125(bool) = _block < REF_38\\nCONDITION TMP_125\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\nmin = 0\\n\\nIRs:\\nmin(uint256) := 0(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: NEW VARIABLE 11\\n\\nEXPRESSION:\\nmax = checkpoints.length - 1\\n\\nIRs:\\nREF_39 -> LENGTH checkpoints\\nTMP_126(uint256) = REF_39 - 1\\nmax(uint256) := TMP_126(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: BEGIN_LOOP 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: IF_LOOP 13\\n\\nEXPRESSION:\\nmax > min\\n\\nIRs:\\nTMP_127(bool) = max > min\\nCONDITION TMP_127\\\"];\\n13->14[label=\\\"True\\\"];\\n13->19[label=\\\"False\\\"];\\n14[label=\\\"Node Type: NEW VARIABLE 14\\n\\nEXPRESSION:\\nmid = (max + min + 1) / 2\\n\\nIRs:\\nTMP_128(uint256) = max + min\\nTMP_129(uint256) = TMP_128 + 1\\nTMP_130(uint256) = TMP_129 / 2\\nmid(uint256) := TMP_130(uint256)\\\"];\\n14->15;\\n15[label=\\\"Node Type: IF 15\\n\\nEXPRESSION:\\ncheckpoints[mid].fromBlock <= _block\\n\\nIRs:\\nREF_40(MiniMeToken.Checkpoint) -> checkpoints[mid]\\nREF_41(uint128) -> REF_40.fromBlock\\nTMP_131(bool) = REF_41 <= _block\\nCONDITION TMP_131\\\"];\\n15->16[label=\\\"True\\\"];\\n15->17[label=\\\"False\\\"];\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nmin = mid\\n\\nIRs:\\nmin(uint256) := mid(uint256)\\\"];\\n16->18;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nmax = mid - 1\\n\\nIRs:\\nTMP_132(uint256) = mid - 1\\nmax(uint256) := TMP_132(uint256)\\\"];\\n17->18;\\n18[label=\\\"Node Type: END_IF 18\\n\\\"];\\n18->13;\\n19[label=\\\"Node Type: END_LOOP 19\\n\\\"];\\n19->20;\\n20[label=\\\"Node Type: RETURN 20\\n\\nEXPRESSION:\\ncheckpoints[min].value\\n\\nIRs:\\nREF_42(MiniMeToken.Checkpoint) -> checkpoints[min]\\nREF_43(uint128) -> REF_42.value\\nRETURN REF_43\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-isContract(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_addr == 0\\n\\nIRs:\\nTMP_142(bool) = _addr == 0\\nCONDITION TMP_142\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: END INLINE ASM 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsize > 0\\n\\nIRs:\\nTMP_143(bool) = size > 0\\nRETURN TMP_143\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-min(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_144(bool) = a < b\\nCONDITION TMP_144\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-onlyController()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == controller)\\n\\nIRs:\\nTMP_158(bool) = msg.sender == controller\\nTMP_159(None) = SOLIDITY_CALL require(bool)(TMP_158)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nversion = MMT_0.2\\n\\nIRs:\\nversion(string) := MMT_0.2(string)\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntotalSupplyAt(block.number)\\n\\nIRs:\\nTMP_71(uint256) = INTERNAL_CALL, MiniMeToken.totalSupplyAt(uint256)(block.number)\\nRETURN TMP_71\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-totalSupplyAt(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n(totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)\\n\\nIRs:\\nREF_22 -> LENGTH totalSupplyHistory\\nTMP_80(bool) = REF_22 == 0\\nREF_23(MiniMeToken.Checkpoint) -> totalSupplyHistory[0]\\nREF_24(uint128) -> REF_23.fromBlock\\nTMP_81(bool) = REF_24 > _blockNumber\\nTMP_82(bool) = TMP_80 || TMP_81\\nCONDITION TMP_82\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\naddress(parentToken) != 0\\n\\nIRs:\\nTMP_83 = CONVERT parentToken to address\\nTMP_84(bool) = TMP_83 != 0\\nCONDITION TMP_84\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nparentToken.totalSupplyAt(min(_blockNumber,parentSnapShotBlock))\\n\\nIRs:\\nTMP_85(uint256) = INTERNAL_CALL, MiniMeToken.min(uint256,uint256)(_blockNumber,parentSnapShotBlock)\\nTMP_86(uint256) = HIGH_LEVEL_CALL, dest:parentToken(MiniMeToken), function:totalSupplyAt, arguments:['TMP_85']  \\nRETURN TMP_86\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ngetValueAt(totalSupplyHistory,_blockNumber)\\n\\nIRs:\\nTMP_87(uint256) = INTERNAL_CALL, MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)(totalSupplyHistory,_blockNumber)\\nRETURN TMP_87\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(transfersEnabled)\\n\\nIRs:\\nTMP_24(None) = SOLIDITY_CALL require(bool)(transfersEnabled)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ndoTransfer(msg.sender,_to,_amount)\\n\\nIRs:\\nINTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(msg.sender,_to,_amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nmsg.sender != controller\\n\\nIRs:\\nTMP_26(bool) = msg.sender != controller\\nCONDITION TMP_26\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(transfersEnabled)\\n\\nIRs:\\nTMP_27(None) = SOLIDITY_CALL require(bool)(transfersEnabled)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(allowed[_from][msg.sender] >= _amount)\\n\\nIRs:\\nREF_0(mapping(address => uint256)) -> allowed[_from]\\nREF_1(uint256) -> REF_0[msg.sender]\\nTMP_28(bool) = REF_1 >= _amount\\nTMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] -= _amount\\n\\nIRs:\\nREF_2(mapping(address => uint256)) -> allowed[_from]\\nREF_3(uint256) -> REF_2[msg.sender]\\nREF_3(-> allowed) = REF_3 - _amount\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ndoTransfer(_from,_to,_amount)\\n\\nIRs:\\nINTERNAL_CALL, MiniMeToken.doTransfer(address,address,uint256)(_from,_to,_amount)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 58.sol-MiniMeToken-updateValueAtNow(MiniMeToken.Checkpoint[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n(checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)\\n\\nIRs:\\nREF_44 -> LENGTH checkpoints\\nTMP_133(bool) = REF_44 == 0\\nREF_45 -> LENGTH checkpoints\\nTMP_134(uint256) = REF_45 - 1\\nREF_46(MiniMeToken.Checkpoint) -> checkpoints[TMP_134]\\nREF_47(uint128) -> REF_46.fromBlock\\nTMP_135(bool) = REF_47 < block.number\\nTMP_136(bool) = TMP_133 || TMP_135\\nCONDITION TMP_136\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nnewCheckPoint = checkpoints[checkpoints.length ++]\\n\\nIRs:\\nREF_48 -> LENGTH checkpoints\\nTMP_137(uint256) := REF_48(uint256)\\nREF_48(-> checkpoints) = REF_48 + 1\\nREF_49(MiniMeToken.Checkpoint) -> checkpoints[TMP_137]\\nnewCheckPoint(MiniMeToken.Checkpoint) := REF_49(MiniMeToken.Checkpoint)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nnewCheckPoint.fromBlock = uint128(block.number)\\n\\nIRs:\\nREF_50(uint128) -> newCheckPoint.fromBlock\\nTMP_138 = CONVERT block.number to uint128\\nREF_50(uint128) (->newCheckPoint) := TMP_138(uint128)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewCheckPoint.value = uint128(_value)\\n\\nIRs:\\nREF_51(uint128) -> newCheckPoint.value\\nTMP_139 = CONVERT _value to uint128\\nREF_51(uint128) (->newCheckPoint) := TMP_139(uint128)\\\"];\\n4->7;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\noldCheckPoint = checkpoints[checkpoints.length - 1]\\n\\nIRs:\\nREF_52 -> LENGTH checkpoints\\nTMP_140(uint256) = REF_52 - 1\\nREF_53(MiniMeToken.Checkpoint) -> checkpoints[TMP_140]\\noldCheckPoint(MiniMeToken.Checkpoint) := REF_53(MiniMeToken.Checkpoint)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\noldCheckPoint.value = uint128(_value)\\n\\nIRs:\\nREF_54(uint128) -> oldCheckPoint.value\\nTMP_141 = CONVERT _value to uint128\\nREF_54(uint128) (->oldCheckPoint) := TMP_141(uint128)\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n}\\n// Function: 58.sol-MiniMeTokenFactory-createCloneToken(address,uint256,string,uint8,string,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nnewToken = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled)\\n\\nIRs:\\nTMP_161(MiniMeToken) = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) \\nnewToken(MiniMeToken) := TMP_161(MiniMeToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nnewToken.changeController(msg.sender)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:newToken(MiniMeToken), function:changeController, arguments:['msg.sender']  \\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nnewToken\\n\\nIRs:\\nRETURN newToken\\\"];\\n}\\n// Function: 58.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_13(uint256) = a + b\\nc(uint256) := TMP_13(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(c >= a)\\n\\nIRs:\\nTMP_14(bool) = c >= a\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_14)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 58.sol-SafeMath-assert(bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(assertion)\\n\\nIRs:\\nTMP_20(None) = SOLIDITY_CALL require(bool)(assertion)\\\"];\\n}\\n// Function: 58.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_9(uint256) = a / b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 58.sol-SafeMath-max256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_18(bool) = a >= b\\nCONDITION TMP_18\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 58.sol-SafeMath-max64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na >= b\\n\\nIRs:\\nTMP_16(bool) = a >= b\\nCONDITION TMP_16\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 58.sol-SafeMath-min256(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_19(bool) = a < b\\nCONDITION TMP_19\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 58.sol-SafeMath-min64(uint64,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\na < b\\n\\nIRs:\\nTMP_17(bool) = a < b\\nCONDITION TMP_17\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\na\\n\\nIRs:\\nRETURN a\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nb\\n\\nIRs:\\nRETURN b\\\"];\\n}\\n// Function: 58.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_3(uint256) = a * b\\nc(uint256) := TMP_3(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_4(bool) = a == 0\\nTMP_5(uint256) = c / a\\nTMP_6(bool) = TMP_5 == b\\nTMP_7(bool) = TMP_4 || TMP_6\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_7)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 58.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(b <= a)\\n\\nIRs:\\nTMP_10(bool) = b <= a\\nINTERNAL_CALL, SafeMath.assert(bool)(TMP_10)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_12(uint256) = a - b\\nRETURN TMP_12\\\"];\\n}\\n// Function: 58.sol-TokenController-onApprove(address,address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-TokenController-onTransfer(address,address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-TokenController-proxyPayment(address)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-Controlled()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = msg.sender\\n\\nIRs:\\ncontroller(address) := msg.sender(address)\\\"];\\n}\\n// Function: 58.sol-VestedToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-calculateVestedTokens(uint256,uint256,uint256,uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ntime < cliff\\n\\nIRs:\\nTMP_222(bool) = time < cliff\\nCONDITION TMP_222\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\ntime >= vesting\\n\\nIRs:\\nTMP_223(bool) = time >= vesting\\nCONDITION TMP_223\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntokens\\n\\nIRs:\\nRETURN tokens\\\"];\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\nvestedTokens = SafeMath.div(SafeMath.mul(tokens,SafeMath.sub(time,start)),SafeMath.sub(vesting,start))\\n\\nIRs:\\nTMP_224(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['time', 'start'] \\nTMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'TMP_224'] \\nTMP_226(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['vesting', 'start'] \\nTMP_227(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_225', 'TMP_226'] \\nvestedTokens(uint256) := TMP_227(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nvestedTokens\\n\\nIRs:\\nRETURN vestedTokens\\\"];\\n}\\n// Function: 58.sol-VestedToken-canTransfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_value < transferableTokens(_sender,uint64(now)))\\n\\nIRs:\\nTMP_243 = CONVERT now to uint64\\nTMP_244(uint256) = INTERNAL_CALL, VestedToken.transferableTokens(address,uint64)(_sender,TMP_243)\\nTMP_245(bool) = _value < TMP_244\\nTMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 58.sol-VestedToken-changeController(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ncontroller = _newController\\n\\nIRs:\\ncontroller(address) := _newController(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n2->1;\\n}\\n// Function: 58.sol-VestedToken-doTransfer(address,address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-grantVestedTokens(address,uint256,uint64,uint64,uint64,bool,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_cliff > _start && _vesting > _cliff)\\n\\nIRs:\\nTMP_178(bool) = _cliff > _start\\nTMP_179(bool) = _vesting > _cliff\\nTMP_180(bool) = TMP_178 && TMP_179\\nTMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(tokenGrantsCount(_to) < MAX_GRANTS_PER_ADDRESS)\\n\\nIRs:\\nTMP_182(uint256) = INTERNAL_CALL, VestedToken.tokenGrantsCount(address)(_to)\\nTMP_183(bool) = TMP_182 < MAX_GRANTS_PER_ADDRESS\\nTMP_184(None) = SOLIDITY_CALL require(bool)(TMP_183)\\\"];\\n2->7;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntransfer(_to,_value)\\n\\nIRs:\\nTMP_185(bool) = INTERNAL_CALL, LimitedTransferToken.transfer(address,uint256)(_to,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nNewTokenGrant(msg.sender,_to,_value,count - 1)\\n\\nIRs:\\nTMP_186(uint256) = count - 1\\nEmit NewTokenGrant(msg.sender,_to,_value,TMP_186)\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyController()\\n\\nIRs:\\nMODIFIER_CALL, Controlled.onlyController()()\\\"];\\n6->1;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\n_revokable\\n\\nIRs:\\nCONDITION _revokable\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ncount = grants[_to].push(TokenGrant(msg.sender,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke))\\n\\nIRs:\\nREF_62(VestedToken.TokenGrant[]) -> grants[_to]\\nTMP_189(VestedToken.TokenGrant) = new TokenGrant(msg.sender,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke)\\nREF_64 -> LENGTH REF_62\\nTMP_191(uint256) := REF_64(uint256)\\nTMP_192(uint256) = TMP_191 + 1\\nREF_64(uint256) (->grants) := TMP_192(uint256)\\nREF_65(VestedToken.TokenGrant) -> REF_62[TMP_191]\\nREF_65(VestedToken.TokenGrant) (->grants) := TMP_189(VestedToken.TokenGrant)\\ncount(uint256) := TMP_190(None)\\\"];\\n8->10;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ncount = grants[_to].push(TokenGrant(0,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke))\\n\\nIRs:\\nREF_66(VestedToken.TokenGrant[]) -> grants[_to]\\nTMP_193(VestedToken.TokenGrant) = new TokenGrant(0,_value,_cliff,_vesting,_start,_revokable,_burnsOnRevoke)\\nREF_68 -> LENGTH REF_66\\nTMP_195(uint256) := REF_68(uint256)\\nTMP_196(uint256) = TMP_195 + 1\\nREF_68(uint256) (->grants) := TMP_196(uint256)\\nREF_69(VestedToken.TokenGrant) -> REF_66[TMP_195]\\nREF_69(VestedToken.TokenGrant) (->grants) := TMP_193(VestedToken.TokenGrant)\\ncount(uint256) := TMP_194(None)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->4;\\n}\\n// Function: 58.sol-VestedToken-lastTokenIsTransferableDate(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndate = uint64(now)\\n\\nIRs:\\nTMP_237 = CONVERT now to uint64\\ndate(uint64) := TMP_237(uint64)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ngrantIndex = grants[holder].length\\n\\nIRs:\\nREF_113(VestedToken.TokenGrant[]) -> grants[holder]\\nREF_114 -> LENGTH REF_113\\ngrantIndex(uint256) := REF_114(uint256)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->9;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < grantIndex\\n\\nIRs:\\nTMP_238(bool) = i < grantIndex\\nCONDITION TMP_238\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ndate = SafeMath.max64(grants[holder][i].vesting,date)\\n\\nIRs:\\nREF_116(VestedToken.TokenGrant[]) -> grants[holder]\\nREF_117(VestedToken.TokenGrant) -> REF_116[i]\\nREF_118(uint64) -> REF_117.vesting\\nTMP_239(uint64) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.max64(uint64,uint64), arguments:['REF_118', 'date'] \\ndate(uint64) := TMP_239(uint64)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_240(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n8->6;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\ndate\\n\\nIRs:\\nRETURN date\\\"];\\n}\\n// Function: 58.sol-VestedToken-nonVestedTokens(VestedToken.TokenGrant,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ngrant.value.sub(vestedTokens(grant,time))\\n\\nIRs:\\nREF_111(uint256) -> grant.value\\nTMP_235(uint256) = INTERNAL_CALL, VestedToken.vestedTokens(VestedToken.TokenGrant,uint64)(grant,time)\\nTMP_236(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', 'TMP_235'] \\nRETURN TMP_236\\\"];\\n}\\n// Function: 58.sol-VestedToken-onlyController()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == controller)\\n\\nIRs:\\nTMP_241(bool) = msg.sender == controller\\nTMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 58.sol-VestedToken-revokeAllTokenGrants(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ngrantsCount = tokenGrantsCount(_holder)\\n\\nIRs:\\nTMP_207(uint256) = INTERNAL_CALL, VestedToken.tokenGrantsCount(address)(_holder)\\ngrantsCount(uint256) := TMP_207(uint256)\\\"];\\n1->4;\\n2[label=\\\"Node Type: BEGIN_LOOP 2\\n\\\"];\\n2->5;\\n3[label=\\\"Node Type: END_LOOP 3\\n\\\"];\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n4->2;\\n5[label=\\\"Node Type: IF_LOOP 5\\n\\nEXPRESSION:\\ni < grantsCount\\n\\nIRs:\\nTMP_208(bool) = i < grantsCount\\nCONDITION TMP_208\\\"];\\n5->6[label=\\\"True\\\"];\\n5->3[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrevokeTokenGrant(_holder,0)\\n\\nIRs:\\nINTERNAL_CALL, VestedToken.revokeTokenGrant(address,uint256)(_holder,0)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_210(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n7->5;\\n}\\n// Function: 58.sol-VestedToken-revokeTokenGrant(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ngrant = grants[_holder][_grantId]\\n\\nIRs:\\nREF_70(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_71(VestedToken.TokenGrant) -> REF_70[_grantId]\\ngrant(VestedToken.TokenGrant) := REF_71(VestedToken.TokenGrant)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(grant.revokable)\\n\\nIRs:\\nREF_72(bool) -> grant.revokable\\nTMP_197(None) = SOLIDITY_CALL require(bool)(REF_72)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(grant.granter == msg.sender)\\n\\nIRs:\\nREF_73(address) -> grant.granter\\nTMP_198(bool) = REF_73 == msg.sender\\nTMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrequire(bool)(_grantId >= grants[_holder].length)\\n\\nIRs:\\nREF_74(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_75 -> LENGTH REF_74\\nTMP_200(bool) = _grantId >= REF_75\\nTMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)\\\"];\\n4->12;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nnonVested = nonVestedTokens(grant,uint64(now))\\n\\nIRs:\\nTMP_202 = CONVERT now to uint64\\nTMP_203(uint256) = INTERNAL_CALL, VestedToken.nonVestedTokens(VestedToken.TokenGrant,uint64)(grant,TMP_202)\\nnonVested(uint256) := TMP_203(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ndelete grants[_holder][_grantId]\\n\\nIRs:\\nREF_76(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_77(VestedToken.TokenGrant) -> REF_76[_grantId]\\nREF_76 = delete REF_77 \\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ngrants[_holder][_grantId] = grants[_holder][grants[_holder].length - 1]\\n\\nIRs:\\nREF_78(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_79(VestedToken.TokenGrant) -> REF_78[_grantId]\\nREF_80(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_81(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_82 -> LENGTH REF_81\\nTMP_204(uint256) = REF_82 - 1\\nREF_83(VestedToken.TokenGrant) -> REF_80[TMP_204]\\nREF_79(VestedToken.TokenGrant) (->grants) := REF_83(VestedToken.TokenGrant)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ngrants[_holder].length -= 1\\n\\nIRs:\\nREF_84(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_85 -> LENGTH REF_84\\nREF_85(-> grants) = REF_85 - 1\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ndoTransfer(_holder,receiver,nonVested)\\n\\nIRs:\\nTMP_205(bool) = INTERNAL_CALL, ERC20.doTransfer(address,address,uint256)(_holder,receiver,nonVested)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nTransfer(_holder,receiver,nonVested)\\n\\nIRs:\\nEmit Transfer(_holder,receiver,nonVested)\\\"];\\n12[label=\\\"Node Type: IF 12\\n\\nEXPRESSION:\\ngrant.burnsOnRevoke\\n\\nIRs:\\nREF_86(bool) -> grant.burnsOnRevoke\\nCONDITION REF_86\\\"];\\n12->13[label=\\\"True\\\"];\\n12->14[label=\\\"False\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nreceiver = 0xdead\\n\\nIRs:\\nreceiver(address) := 57005(uint256)\\\"];\\n13->15;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nreceiver = msg.sender\\n\\nIRs:\\nreceiver(address) := msg.sender(address)\\\"];\\n14->15;\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->6;\\n}\\n// Function: 58.sol-VestedToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nMAX_GRANTS_PER_ADDRESS = 20\\n\\nIRs:\\nMAX_GRANTS_PER_ADDRESS(uint256) := 20(uint256)\\\"];\\n}\\n// Function: 58.sol-VestedToken-tokenGrant(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ngrant = grants[_holder][_grantId]\\n\\nIRs:\\nREF_98(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_99(VestedToken.TokenGrant) -> REF_98[_grantId]\\ngrant(VestedToken.TokenGrant) := REF_99(VestedToken.TokenGrant)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ngranter = grant.granter\\n\\nIRs:\\nREF_100(address) -> grant.granter\\ngranter(address) := REF_100(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nvalue = grant.value\\n\\nIRs:\\nREF_101(uint256) -> grant.value\\nvalue(uint256) := REF_101(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nstart = grant.start\\n\\nIRs:\\nREF_102(uint64) -> grant.start\\nstart(uint64) := REF_102(uint64)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncliff = grant.cliff\\n\\nIRs:\\nREF_103(uint64) -> grant.cliff\\ncliff(uint64) := REF_103(uint64)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nvesting = grant.vesting\\n\\nIRs:\\nREF_104(uint64) -> grant.vesting\\nvesting(uint64) := REF_104(uint64)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrevokable = grant.revokable\\n\\nIRs:\\nREF_105(bool) -> grant.revokable\\nrevokable(bool) := REF_105(bool)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nburnsOnRevoke = grant.burnsOnRevoke\\n\\nIRs:\\nREF_106(bool) -> grant.burnsOnRevoke\\nburnsOnRevoke(bool) := REF_106(bool)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nvested = vestedTokens(grant,uint64(now))\\n\\nIRs:\\nTMP_228 = CONVERT now to uint64\\nTMP_229(uint256) = INTERNAL_CALL, VestedToken.vestedTokens(VestedToken.TokenGrant,uint64)(grant,TMP_228)\\nvested(uint256) := TMP_229(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\n(granter,value,vested,start,cliff,vesting,revokable,burnsOnRevoke)\\n\\nIRs:\\nRETURN granter,value,vested,start,cliff,vesting,revokable,burnsOnRevoke\\\"];\\n}\\n// Function: 58.sol-VestedToken-tokenGrantsCount(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ngrants[_holder].length\\n\\nIRs:\\nREF_92(VestedToken.TokenGrant[]) -> grants[_holder]\\nREF_93 -> LENGTH REF_92\\nRETURN REF_93\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nindex\\n\\nIRs:\\nRETURN index\\\"];\\n}\\n// Function: 58.sol-VestedToken-totalSupply()\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 58.sol-VestedToken-transferableTokens(address,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ngrantIndex = tokenGrantsCount(holder)\\n\\nIRs:\\nTMP_211(uint256) = INTERNAL_CALL, VestedToken.tokenGrantsCount(address)(holder)\\ngrantIndex(uint256) := TMP_211(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\ngrantIndex == 0\\n\\nIRs:\\nTMP_212(bool) = grantIndex == 0\\nCONDITION TMP_212\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nbalanceOf(holder)\\n\\nIRs:\\nTMP_213(uint256) = INTERNAL_CALL, ERC20Basic.balanceOf(address)(holder)\\nRETURN TMP_213\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nnonVested = 0\\n\\nIRs:\\nnonVested(uint256) := 0(uint256)\\\"];\\n5->8;\\n6[label=\\\"Node Type: BEGIN_LOOP 6\\n\\\"];\\n6->9;\\n7[label=\\\"Node Type: END_LOOP 7\\n\\\"];\\n7->12;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n8->6;\\n9[label=\\\"Node Type: IF_LOOP 9\\n\\nEXPRESSION:\\ni < grantIndex\\n\\nIRs:\\nTMP_214(bool) = i < grantIndex\\nCONDITION TMP_214\\\"];\\n9->10[label=\\\"True\\\"];\\n9->7[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nnonVested = SafeMath.add(nonVested,nonVestedTokens(grants[holder][i],time))\\n\\nIRs:\\nREF_88(VestedToken.TokenGrant[]) -> grants[holder]\\nREF_89(VestedToken.TokenGrant) -> REF_88[i]\\nTMP_215(uint256) = INTERNAL_CALL, VestedToken.nonVestedTokens(VestedToken.TokenGrant,uint64)(REF_89,time)\\nTMP_216(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['nonVested', 'TMP_215'] \\nnonVested(uint256) := TMP_216(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_217(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n11->9;\\n12[label=\\\"Node Type: NEW VARIABLE 12\\n\\nEXPRESSION:\\nvestedTransferable = SafeMath.sub(balanceOf(holder),nonVested)\\n\\nIRs:\\nTMP_218(uint256) = INTERNAL_CALL, ERC20Basic.balanceOf(address)(holder)\\nTMP_219(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_218', 'nonVested'] \\nvestedTransferable(uint256) := TMP_219(uint256)\\\"];\\n12->13;\\n13[label=\\\"Node Type: RETURN 13\\n\\nEXPRESSION:\\nSafeMath.min256(vestedTransferable,super.transferableTokens(holder,time))\\n\\nIRs:\\nTMP_220(uint256) = INTERNAL_CALL, LimitedTransferToken.transferableTokens(address,uint64)(holder,time)\\nTMP_221(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.min256(uint256,uint256), arguments:['vestedTransferable', 'TMP_220'] \\nRETURN TMP_221\\\"];\\n}\\n// Function: 58.sol-VestedToken-vestedTokens(VestedToken.TokenGrant,uint64)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ncalculateVestedTokens(grant.value,uint256(time),uint256(grant.start),uint256(grant.cliff),uint256(grant.vesting))\\n\\nIRs:\\nREF_107(uint256) -> grant.value\\nTMP_230 = CONVERT time to uint256\\nREF_108(uint64) -> grant.start\\nTMP_231 = CONVERT REF_108 to uint256\\nREF_109(uint64) -> grant.cliff\\nTMP_232 = CONVERT REF_109 to uint256\\nREF_110(uint64) -> grant.vesting\\nTMP_233 = CONVERT REF_110 to uint256\\nTMP_234(uint256) = INTERNAL_CALL, VestedToken.calculateVestedTokens(uint256,uint256,uint256,uint256,uint256)(REF_107,TMP_230,TMP_231,TMP_232,TMP_233)\\nRETURN TMP_234\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Block Number Dependency\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 60.sol-CanReclaimToken-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_34 = CONVERT 0 to address\\nTMP_35(bool) = _newOwner != TMP_34\\nTMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 60.sol-CanReclaimToken-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 60.sol-CanReclaimToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_41(bool) = msg.sender == owner\\nTMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 60.sol-CanReclaimToken-reclaimToken(ERC20Basic)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_38(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_38(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntoken.safeTransfer(owner,balance)\\n\\nIRs:\\nLIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', 'owner', 'balance'] \\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 60.sol-CanReclaimToken-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_30 = CONVERT 0 to address\\nowner(address) := TMP_30(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 60.sol-CanReclaimToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 60.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 60.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 60.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 60.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 60.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 60.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-allBalances()\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-allDecimals()\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-allTokens()\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-allTokensDecimalsBalances()\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-bundle(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-bundleFirstTokens(address,uint256,uint256[])\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-tokens(uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-tokensCount()\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-totalSupply()\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-unbundle(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IBasicMultiToken-unbundleSome(address,uint256,ERC20[])\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-allBalances()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-allDecimals()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-allTokens()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-allTokensDecimalsBalances()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-allTokensDecimalsBalancesWeights()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-allWeights()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-bundle(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-bundleFirstTokens(address,uint256,uint256[])\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-change(address,address,uint256,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-getReturn(address,address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-tokens(uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-tokensCount()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-totalSupply()\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-unbundle(address,uint256)\\ndigraph{\\n}\\n// Function: 60.sol-IMultiToken-unbundleSome(address,uint256,ERC20[])\\ndigraph{\\n}\\n// Function: 60.sol-MultiBuyer-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_51 = CONVERT 0 to address\\nTMP_52(bool) = _newOwner != TMP_51\\nTMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 60.sol-MultiBuyer-buy(IMultiToken,uint256,ERC20,address[],bytes,uint256[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(_datasIndexes.length == _exchanges.length + 1,buy: _datasIndexes should start with 0 and end with LENGTH)\\n\\nIRs:\\nREF_7 -> LENGTH _datasIndexes\\nREF_8 -> LENGTH _exchanges\\nTMP_55(uint256) = REF_8 + 1\\nTMP_56(bool) = REF_7 == TMP_55\\nTMP_57(None) = SOLIDITY_CALL require(bool,string)(TMP_56,buy: _datasIndexes should start with 0 and end with LENGTH)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(_values.length == _exchanges.length,buy: _values should have the same length as _exchanges)\\n\\nIRs:\\nREF_9 -> LENGTH _values\\nREF_10 -> LENGTH _exchanges\\nTMP_58(bool) = REF_9 == REF_10\\nTMP_59(None) = SOLIDITY_CALL require(bool,string)(TMP_58,buy: _values should have the same length as _exchanges)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->22;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < _exchanges.length\\n\\nIRs:\\nREF_11 -> LENGTH _exchanges\\nTMP_60(bool) = i < REF_11\\nCONDITION TMP_60\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ndata = new bytes(_datasIndexes[i + 1] - _datasIndexes[i])\\n\\nIRs:\\nTMP_62(uint256) = i + 1\\nREF_12(uint256) -> _datasIndexes[TMP_62]\\nREF_13(uint256) -> _datasIndexes[i]\\nTMP_63(uint256) = REF_12 - REF_13\\nTMP_64 = new bytes(TMP_63)\\ndata(bytes) := TMP_64(bytes)\\\"];\\n7->10;\\n8[label=\\\"Node Type: BEGIN_LOOP 8\\n\\\"];\\n8->11;\\n9[label=\\\"Node Type: END_LOOP 9\\n\\\"];\\n9->14;\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\nj = _datasIndexes[i]\\n\\nIRs:\\nREF_14(uint256) -> _datasIndexes[i]\\nj(uint256) := REF_14(uint256)\\\"];\\n10->8;\\n11[label=\\\"Node Type: IF_LOOP 11\\n\\nEXPRESSION:\\nj < _datasIndexes[i + 1]\\n\\nIRs:\\nTMP_65(uint256) = i + 1\\nREF_15(uint256) -> _datasIndexes[TMP_65]\\nTMP_66(bool) = j < REF_15\\nCONDITION TMP_66\\\"];\\n11->12[label=\\\"True\\\"];\\n11->9[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ndata[j - _datasIndexes[i]] = _datas[j]\\n\\nIRs:\\nREF_16(uint256) -> _datasIndexes[i]\\nTMP_67(uint256) = j - REF_16\\nREF_17(None) -> data[TMP_67]\\nREF_18(None) -> _datas[j]\\nREF_17(None) (->data) := REF_18(None)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nj ++\\n\\nIRs:\\nTMP_68(uint256) := j(uint256)\\nj(uint256) = j + 1\\\"];\\n13->11;\\n14[label=\\\"Node Type: IF 14\\n\\nEXPRESSION:\\n_throughToken != address(0) && i > 0\\n\\nIRs:\\nTMP_69 = CONVERT 0 to address\\nTMP_70(bool) = _throughToken != TMP_69\\nTMP_71(bool) = i > 0\\nTMP_72(bool) = TMP_70 && TMP_71\\nCONDITION TMP_72\\\"];\\n14->15[label=\\\"True\\\"];\\n14->16[label=\\\"False\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\n_throughToken.approve(_exchanges[i],_throughToken.balanceOf(this))\\n\\nIRs:\\nREF_20(address) -> _exchanges[i]\\nTMP_73(uint256) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:balanceOf, arguments:['this']  \\nTMP_74(bool) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:approve, arguments:['REF_20', 'TMP_73']  \\\"];\\n15->16;\\n16[label=\\\"Node Type: END_IF 16\\n\\\"];\\n16->17;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nrequire(bool,string)(_exchanges[i].call.value(_values[i])(data),buy: exchange arbitrary call failed)\\n\\nIRs:\\nREF_22(address) -> _exchanges[i]\\nREF_25(uint256) -> _values[i]\\nTMP_76(bool) = LOW_LEVEL_CALL, dest:REF_22, function:call, arguments:['data'] value:REF_25 \\nTMP_77(None) = SOLIDITY_CALL require(bool,string)(TMP_76,buy: exchange arbitrary call failed)\\\"];\\n17->18;\\n18[label=\\\"Node Type: IF 18\\n\\nEXPRESSION:\\n_throughToken != address(0)\\n\\nIRs:\\nTMP_78 = CONVERT 0 to address\\nTMP_79(bool) = _throughToken != TMP_78\\nCONDITION TMP_79\\\"];\\n18->19[label=\\\"True\\\"];\\n18->20[label=\\\"False\\\"];\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\n_throughToken.approve(_exchanges[i],0)\\n\\nIRs:\\nREF_27(address) -> _exchanges[i]\\nTMP_80(bool) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:approve, arguments:['REF_27', '0']  \\\"];\\n19->20;\\n20[label=\\\"Node Type: END_IF 20\\n\\\"];\\n20->21;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_81(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n21->6;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\nj = _mtkn.totalSupply()\\n\\nIRs:\\nTMP_82(uint256) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:totalSupply, arguments:[]  \\nj(uint256) := TMP_82(uint256)\\\"];\\n22->23;\\n23[label=\\\"Node Type: NEW VARIABLE 23\\n\\nEXPRESSION:\\nbestAmount = uint256(- 1)\\n\\nIRs:\\nTMP_83(uint256) = 0 - 1\\nTMP_84 = CONVERT TMP_83 to uint256\\nbestAmount(uint256) := TMP_84(uint256)\\\"];\\n23->26;\\n24[label=\\\"Node Type: BEGIN_LOOP 24\\n\\\"];\\n24->27;\\n25[label=\\\"Node Type: END_LOOP 25\\n\\\"];\\n25->35;\\n26[label=\\\"Node Type: EXPRESSION 26\\n\\nEXPRESSION:\\ni = _mtkn.tokensCount()\\n\\nIRs:\\nTMP_85(uint256) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:tokensCount, arguments:[]  \\ni(uint256) := TMP_85(uint256)\\\"];\\n26->24;\\n27[label=\\\"Node Type: IF_LOOP 27\\n\\nEXPRESSION:\\ni > 0\\n\\nIRs:\\nTMP_86(bool) = i > 0\\nCONDITION TMP_86\\\"];\\n27->28[label=\\\"True\\\"];\\n27->25[label=\\\"False\\\"];\\n28[label=\\\"Node Type: NEW VARIABLE 28\\n\\nEXPRESSION:\\ntoken = _mtkn.tokens(i - 1)\\n\\nIRs:\\nTMP_87(uint256) = i - 1\\nTMP_88(ERC20) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:tokens, arguments:['TMP_87']  \\ntoken(ERC20) := TMP_88(ERC20)\\\"];\\n28->29;\\n29[label=\\\"Node Type: EXPRESSION 29\\n\\nEXPRESSION:\\ntoken.approve(_mtkn,token.balanceOf(this))\\n\\nIRs:\\nTMP_89(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  \\nTMP_90(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['_mtkn', 'TMP_89']  \\\"];\\n29->30;\\n30[label=\\\"Node Type: NEW VARIABLE 30\\n\\nEXPRESSION:\\namount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn))\\n\\nIRs:\\nTMP_91(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  \\nTMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['j', 'TMP_91'] \\nTMP_93(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['_mtkn']  \\nTMP_94(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_92', 'TMP_93'] \\namount(uint256) := TMP_94(uint256)\\\"];\\n30->31;\\n31[label=\\\"Node Type: IF 31\\n\\nEXPRESSION:\\namount < bestAmount\\n\\nIRs:\\nTMP_95(bool) = amount < bestAmount\\nCONDITION TMP_95\\\"];\\n31->32[label=\\\"True\\\"];\\n31->33[label=\\\"False\\\"];\\n32[label=\\\"Node Type: EXPRESSION 32\\n\\nEXPRESSION:\\nbestAmount = amount\\n\\nIRs:\\nbestAmount(uint256) := amount(uint256)\\\"];\\n32->33;\\n33[label=\\\"Node Type: END_IF 33\\n\\\"];\\n33->34;\\n34[label=\\\"Node Type: EXPRESSION 34\\n\\nEXPRESSION:\\ni --\\n\\nIRs:\\nTMP_96(uint256) := i(uint256)\\ni(uint256) = i - 1\\\"];\\n34->27;\\n35[label=\\\"Node Type: EXPRESSION 35\\n\\nEXPRESSION:\\nrequire(bool,string)(bestAmount >= _minimumReturn,buy: return value is too low)\\n\\nIRs:\\nTMP_97(bool) = bestAmount >= _minimumReturn\\nTMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,buy: return value is too low)\\\"];\\n35->36;\\n36[label=\\\"Node Type: EXPRESSION 36\\n\\nEXPRESSION:\\n_mtkn.bundle(msg.sender,bestAmount)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:bundle, arguments:['msg.sender', 'bestAmount']  \\\"];\\n36->37;\\n37[label=\\\"Node Type: IF 37\\n\\nEXPRESSION:\\naddress(this).balance > 0\\n\\nIRs:\\nTMP_100 = CONVERT this to address\\nTMP_101(uint256) = SOLIDITY_CALL balance(address)(TMP_100)\\nTMP_102(bool) = TMP_101 > 0\\nCONDITION TMP_102\\\"];\\n37->38[label=\\\"True\\\"];\\n37->39[label=\\\"False\\\"];\\n38[label=\\\"Node Type: EXPRESSION 38\\n\\nEXPRESSION:\\nmsg.sender.transfer(address(this).balance)\\n\\nIRs:\\nTMP_103 = CONVERT this to address\\nTMP_104(uint256) = SOLIDITY_CALL balance(address)(TMP_103)\\nTransfer dest:msg.sender value:TMP_104\\\"];\\n38->39;\\n39[label=\\\"Node Type: END_IF 39\\n\\\"];\\n}\\n// Function: 60.sol-MultiBuyer-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 60.sol-MultiBuyer-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_106(bool) = msg.sender == owner\\nTMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 60.sol-MultiBuyer-reclaimToken(ERC20Basic)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_43(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_43(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntoken.safeTransfer(owner,balance)\\n\\nIRs:\\nLIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', 'owner', 'balance'] \\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 60.sol-MultiBuyer-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_47 = CONVERT 0 to address\\nowner(address) := TMP_47(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 60.sol-MultiBuyer-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 60.sol-Ownable-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_23 = CONVERT 0 to address\\nTMP_24(bool) = _newOwner != TMP_23\\nTMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 60.sol-Ownable-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 60.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_27(bool) = msg.sender == owner\\nTMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 60.sol-Ownable-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_19 = CONVERT 0 to address\\nowner(address) := TMP_19(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 60.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 60.sol-SafeERC20-safeApprove(ERC20,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.approve(spender,value))\\n\\nIRs:\\nTMP_16(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['spender', 'value']  \\nTMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)\\\"];\\n}\\n// Function: 60.sol-SafeERC20-safeTransfer(ERC20Basic,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.transfer(to,value))\\n\\nIRs:\\nTMP_12(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['to', 'value']  \\nTMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)\\\"];\\n}\\n// Function: 60.sol-SafeERC20-safeTransferFrom(ERC20,address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.transferFrom(from,to,value))\\n\\nIRs:\\nTMP_14(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['from', 'to', 'value']  \\nTMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)\\\"];\\n}\\n// Function: 60.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 60.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 60.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 60.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Reentrancy\", \"Unchecked External Call\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 61.sol-Aeroneum-Aeroneum(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nsymbol = ARM\\n\\nIRs:\\nsymbol(string) := ARM(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nname = Aeroneum\\n\\nIRs:\\nname(string) := Aeroneum(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrate = 5000000\\n\\nIRs:\\nrate(uint256) := 5000000(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nmintx = 16\\n\\nIRs:\\nmintx(uint8) := 16(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nwallet = _wallet\\n\\nIRs:\\nwallet(address) := _wallet(address)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nowner = _owner\\n\\nIRs:\\nowner(address) := _owner(address)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\n_totalSupply = totalSupply()\\n\\nIRs:\\nTMP_27(uint256) = INTERNAL_CALL, Aeroneum.totalSupply()()\\n_totalSupply(uint256) := TMP_27(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\n_tokenToSale = (_totalSupply.mul(95)).div(100)\\n\\nIRs:\\nTMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_totalSupply', '95'] \\nTMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_28', '100'] \\n_tokenToSale(uint256) := TMP_29(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\n_ownersTokens = _totalSupply - _tokenToSale\\n\\nIRs:\\nTMP_30(uint256) = _totalSupply - _tokenToSale\\n_ownersTokens(uint256) := TMP_30(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nbalances[this] = _tokenToSale\\n\\nIRs:\\nREF_2(uint256) -> balances[this]\\nREF_2(uint256) (->balances) := _tokenToSale(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nbalances[owner] = _ownersTokens\\n\\nIRs:\\nREF_3(uint256) -> balances[owner]\\nREF_3(uint256) (->balances) := _ownersTokens(uint256)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nTransfer(address(0),this,_tokenToSale)\\n\\nIRs:\\nTMP_31 = CONVERT 0 to address\\nEmit Transfer(TMP_31,this,_tokenToSale)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nTransfer(address(0),owner,_ownersTokens)\\n\\nIRs:\\nTMP_33 = CONVERT 0 to address\\nEmit Transfer(TMP_33,owner,_ownersTokens)\\\"];\\n}\\n// Function: 61.sol-Aeroneum-_deliverTokens(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transfer(_beneficiary,_tokenAmount)\\n\\nIRs:\\nTMP_85(bool) = INTERNAL_CALL, Aeroneum._transfer(address,uint256)(_beneficiary,_tokenAmount)\\\"];\\n}\\n// Function: 61.sol-Aeroneum-_forwardFunds()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nwallet.transfer(msg.value)\\n\\nIRs:\\nTransfer dest:wallet value:msg.value\\\"];\\n}\\n// Function: 61.sol-Aeroneum-_getTokenAmount(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_weiAmount < 1 * 10 ** uint256(mintx)\\n\\nIRs:\\nTMP_77 = CONVERT mintx to uint256\\nTMP_78(uint256) = 10 ** TMP_77\\nTMP_79(uint256) = 1 * TMP_78\\nTMP_80(bool) = _weiAmount < TMP_79\\nCONDITION TMP_80\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n50 * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_81 = CONVERT decimals to uint256\\nTMP_82(uint256) = 10 ** TMP_81\\nTMP_83(uint256) = 50 * TMP_82\\nRETURN TMP_83\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\n_weiAmount.mul(rate)\\n\\nIRs:\\nTMP_84(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_weiAmount', 'rate'] \\nRETURN TMP_84\\\"];\\n}\\n// Function: 61.sol-Aeroneum-_preValidatePurchase(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_beneficiary != address(0x0))\\n\\nIRs:\\nTMP_74 = CONVERT 0 to address\\nTMP_75(bool) = _beneficiary != TMP_74\\nTMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)\\\"];\\n}\\n// Function: 61.sol-Aeroneum-_processPurchase(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_deliverTokens(_beneficiary,_tokenAmount)\\n\\nIRs:\\nINTERNAL_CALL, Aeroneum._deliverTokens(address,uint256)(_beneficiary,_tokenAmount)\\\"];\\n}\\n// Function: 61.sol-Aeroneum-_transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != 0x0)\\n\\nIRs:\\nTMP_48(bool) = _to != 0\\nTMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balances[this] >= _tokens)\\n\\nIRs:\\nREF_14(uint256) -> balances[this]\\nTMP_50(bool) = REF_14 >= _tokens\\nTMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balances[_to] + _tokens >= balances[_to])\\n\\nIRs:\\nREF_15(uint256) -> balances[_to]\\nTMP_52(uint256) = REF_15 + _tokens\\nREF_16(uint256) -> balances[_to]\\nTMP_53(bool) = TMP_52 >= REF_16\\nTMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[this] = balances[this].sub(_tokens)\\n\\nIRs:\\nREF_17(uint256) -> balances[this]\\nREF_18(uint256) -> balances[this]\\nTMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_18', '_tokens'] \\nREF_17(uint256) (->balances) := TMP_55(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_tokens)\\n\\nIRs:\\nREF_20(uint256) -> balances[_to]\\nREF_21(uint256) -> balances[_to]\\nTMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_21', '_tokens'] \\nREF_20(uint256) (->balances) := TMP_56(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTransfer(this,_to,_tokens)\\n\\nIRs:\\nEmit Transfer(this,_to,_tokens)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 61.sol-Aeroneum-acceptOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == newOwner)\\n\\nIRs:\\nTMP_23(bool) = msg.sender == newOwner\\nTMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewOwner = address(0)\\n\\nIRs:\\nTMP_26 = CONVERT 0 to address\\nnewOwner(address) := TMP_26(address)\\\"];\\n}\\n// Function: 61.sol-Aeroneum-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[tokenOwner][spender]\\n\\nIRs:\\nREF_39(mapping(address => uint256)) -> allowed[tokenOwner]\\nREF_40(uint256) -> REF_39[spender]\\nRETURN REF_40\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 61.sol-Aeroneum-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][spender] = tokens\\n\\nIRs:\\nREF_23(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_24(uint256) -> REF_23[spender]\\nREF_24(uint256) (->allowed) := tokens(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,spender,tokens)\\n\\nIRs:\\nEmit Approval(msg.sender,spender,tokens)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 61.sol-Aeroneum-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[tokenOwner]\\n\\nIRs:\\nREF_4(uint256) -> balances[tokenOwner]\\nRETURN REF_4\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 61.sol-Aeroneum-buyTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nweiAmount = msg.value\\n\\nIRs:\\nweiAmount(uint256) := msg.value(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_preValidatePurchase(_beneficiary,weiAmount)\\n\\nIRs:\\nINTERNAL_CALL, Aeroneum._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ntokens = _getTokenAmount(weiAmount)\\n\\nIRs:\\nTMP_69(uint256) = INTERNAL_CALL, Aeroneum._getTokenAmount(uint256)(weiAmount)\\ntokens(uint256) := TMP_69(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nweiRaised = weiRaised.add(weiAmount)\\n\\nIRs:\\nTMP_70(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] \\nweiRaised(uint256) := TMP_70(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\n_processPurchase(_beneficiary,tokens)\\n\\nIRs:\\nINTERNAL_CALL, Aeroneum._processPurchase(address,uint256)(_beneficiary,tokens)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTokenPurchase(this,_beneficiary,weiAmount,tokens)\\n\\nIRs:\\nEmit TokenPurchase(this,_beneficiary,weiAmount,tokens)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\n_forwardFunds()\\n\\nIRs:\\nINTERNAL_CALL, Aeroneum._forwardFunds()()\\\"];\\n}\\n// Function: 61.sol-Aeroneum-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbuyTokens(msg.sender)\\n\\nIRs:\\nINTERNAL_CALL, Aeroneum.buyTokens(address)(msg.sender)\\\"];\\n}\\n// Function: 61.sol-Aeroneum-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_88(bool) = msg.sender == owner\\nTMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 61.sol-Aeroneum-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n11000000000 * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_35 = CONVERT decimals to uint256\\nTMP_36(uint256) = 10 ** TMP_35\\nTMP_37(uint256) = 11000000000 * TMP_36\\nRETURN TMP_37\\\"];\\n}\\n// Function: 61.sol-Aeroneum-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(to != 0x0)\\n\\nIRs:\\nTMP_38(bool) = to != 0\\nTMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balances[msg.sender] >= tokens)\\n\\nIRs:\\nREF_5(uint256) -> balances[msg.sender]\\nTMP_40(bool) = REF_5 >= tokens\\nTMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(balances[to] + tokens >= balances[to])\\n\\nIRs:\\nREF_6(uint256) -> balances[to]\\nTMP_42(uint256) = REF_6 + tokens\\nREF_7(uint256) -> balances[to]\\nTMP_43(bool) = TMP_42 >= REF_7\\nTMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(tokens)\\n\\nIRs:\\nREF_8(uint256) -> balances[msg.sender]\\nREF_9(uint256) -> balances[msg.sender]\\nTMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_9', 'tokens'] \\nREF_8(uint256) (->balances) := TMP_45(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[to] = balances[to].add(tokens)\\n\\nIRs:\\nREF_11(uint256) -> balances[to]\\nREF_12(uint256) -> balances[to]\\nTMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_12', 'tokens'] \\nREF_11(uint256) (->balances) := TMP_46(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTransfer(msg.sender,to,tokens)\\n\\nIRs:\\nEmit Transfer(msg.sender,to,tokens)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 61.sol-Aeroneum-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(tokens <= allowed[from][msg.sender])\\n\\nIRs:\\nREF_25(mapping(address => uint256)) -> allowed[from]\\nREF_26(uint256) -> REF_25[msg.sender]\\nTMP_59(bool) = tokens <= REF_26\\nTMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(balances[from] >= tokens)\\n\\nIRs:\\nREF_27(uint256) -> balances[from]\\nTMP_61(bool) = REF_27 >= tokens\\nTMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[from] = balances[from].sub(tokens)\\n\\nIRs:\\nREF_28(uint256) -> balances[from]\\nREF_29(uint256) -> balances[from]\\nTMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', 'tokens'] \\nREF_28(uint256) (->balances) := TMP_63(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[to] = balances[to].add(tokens)\\n\\nIRs:\\nREF_31(uint256) -> balances[to]\\nREF_32(uint256) -> balances[to]\\nTMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', 'tokens'] \\nREF_31(uint256) (->balances) := TMP_64(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens)\\n\\nIRs:\\nREF_34(mapping(address => uint256)) -> allowed[from]\\nREF_35(uint256) -> REF_34[msg.sender]\\nREF_36(mapping(address => uint256)) -> allowed[from]\\nREF_37(uint256) -> REF_36[msg.sender]\\nTMP_65(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_37', 'tokens'] \\nREF_35(uint256) (->allowed) := TMP_65(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nTransfer(from,to,tokens)\\n\\nIRs:\\nEmit Transfer(from,to,tokens)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 61.sol-Aeroneum-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnewOwner = _newOwner\\n\\nIRs:\\nnewOwner(address) := _newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 61.sol-ERC20Interface-allowance(address,address)\\ndigraph{\\n}\\n// Function: 61.sol-ERC20Interface-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 61.sol-ERC20Interface-balanceOf(address)\\ndigraph{\\n}\\n// Function: 61.sol-ERC20Interface-totalSupply()\\ndigraph{\\n}\\n// Function: 61.sol-ERC20Interface-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 61.sol-ERC20Interface-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 61.sol-Owned-acceptOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == newOwner)\\n\\nIRs:\\nTMP_1(bool) = msg.sender == newOwner\\nTMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nnewOwner = address(0)\\n\\nIRs:\\nTMP_4 = CONVERT 0 to address\\nnewOwner(address) := TMP_4(address)\\\"];\\n}\\n// Function: 61.sol-Owned-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_5(bool) = msg.sender == owner\\nTMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 61.sol-Owned-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnewOwner = _newOwner\\n\\nIRs:\\nnewOwner(address) := _newOwner(address)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Owned.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 61.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_7(uint256) = a + b\\nc(uint256) := TMP_7(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(c >= a)\\n\\nIRs:\\nTMP_8(bool) = c >= a\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 61.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b > 0)\\n\\nIRs:\\nTMP_19(bool) = b > 0\\nTMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_21(uint256) = a / b\\nc(uint256) := TMP_21(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 61.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_13(uint256) = a * b\\nc(uint256) := TMP_13(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_14(bool) = a == 0\\nTMP_15(uint256) = c / a\\nTMP_16(bool) = TMP_15 == b\\nTMP_17(bool) = TMP_14 || TMP_16\\nTMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 61.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b <= a)\\n\\nIRs:\\nTMP_10(bool) = b <= a\\nTMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a - b\\n\\nIRs:\\nTMP_12(uint256) = a - b\\nc(uint256) := TMP_12(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 63.sol-ApproveAndCallFallBack-receiveApproval(address,uint256,address,bytes)\\ndigraph{\\n}\\n// Function: 63.sol-ERC20Interface-allowance(address,address)\\ndigraph{\\n}\\n// Function: 63.sol-ERC20Interface-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 63.sol-ERC20Interface-balanceOf(address)\\ndigraph{\\n}\\n// Function: 63.sol-ERC20Interface-totalSupply()\\ndigraph{\\n}\\n// Function: 63.sol-ERC20Interface-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 63.sol-ERC20Interface-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 63.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_44(uint256) = a + b\\nc(uint256) := TMP_44(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(c >= a)\\n\\nIRs:\\nTMP_45(bool) = c >= a\\nTMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 63.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b > 0)\\n\\nIRs:\\nTMP_56(bool) = b > 0\\nTMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a / b\\n\\nIRs:\\nTMP_58(uint256) = a / b\\nc(uint256) := TMP_58(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 63.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_50(uint256) = a * b\\nc(uint256) := TMP_50(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(a == 0 || c / a == b)\\n\\nIRs:\\nTMP_51(bool) = a == 0\\nTMP_52(uint256) = c / a\\nTMP_53(bool) = TMP_52 == b\\nTMP_54(bool) = TMP_51 || TMP_53\\nTMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 63.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(b <= a)\\n\\nIRs:\\nTMP_47(bool) = b <= a\\nTMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nc = a - b\\n\\nIRs:\\nTMP_49(uint256) = a - b\\nc(uint256) := TMP_49(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 63.sol-VerifyToken-activate()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! activated)\\n\\nIRs:\\nTMP_6 = UnaryType.BANG activated \\nTMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == creator)\\n\\nIRs:\\nTMP_8(bool) = msg.sender == creator\\nTMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndayStartTime = now - 60\\n\\nIRs:\\nTMP_10(uint256) = now - 60\\ndayStartTime(uint256) := TMP_10(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nactivated = true\\n\\nIRs:\\nactivated(bool) := True(bool)\\\"];\\n}\\n// Function: 63.sol-VerifyToken-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[tokenOwner][spender]\\n\\nIRs:\\nREF_42(mapping(address => uint256)) -> allowed[tokenOwner]\\nREF_43(uint256) -> REF_42[spender]\\nRETURN REF_43\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 63.sol-VerifyToken-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][spender] = tokens\\n\\nIRs:\\nREF_26(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_27(uint256) -> REF_26[spender]\\nREF_27(uint256) (->allowed) := tokens(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,spender,tokens)\\n\\nIRs:\\nEmit Approval(msg.sender,spender,tokens)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 63.sol-VerifyToken-approveAndCall(address,uint256,bytes)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][spender] = tokens\\n\\nIRs:\\nREF_28(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_29(uint256) -> REF_28[spender]\\nREF_29(uint256) (->allowed) := tokens(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,spender,tokens)\\n\\nIRs:\\nEmit Approval(msg.sender,spender,tokens)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)\\n\\nIRs:\\nTMP_37 = CONVERT spender to ApproveAndCallFallBack\\nHIGH_LEVEL_CALL, dest:TMP_37(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 63.sol-VerifyToken-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[tokenOwner]\\n\\nIRs:\\nREF_19(uint256) -> balances[tokenOwner]\\nRETURN REF_19\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 63.sol-VerifyToken-claimTokens()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(activated)\\n\\nIRs:\\nTMP_11(None) = SOLIDITY_CALL require(bool)(activated)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\ndayStartTime < now.sub(timestep)\\n\\nIRs:\\nTMP_12(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['now', 'timestep'] \\nTMP_13(bool) = dayStartTime < TMP_12\\nCONDITION TMP_13\\\"];\\n2->3[label=\\\"True\\\"];\\n2->7[label=\\\"False\\\"];\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ndaysPassed = (now.sub(dayStartTime)).div(timestep)\\n\\nIRs:\\nTMP_14(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['now', 'dayStartTime'] \\nTMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_14', 'timestep'] \\ndaysPassed(uint256) := TMP_15(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ndayStartTime = dayStartTime.add(daysPassed.mul(timestep))\\n\\nIRs:\\nTMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['daysPassed', 'timestep'] \\nTMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dayStartTime', 'TMP_16'] \\ndayStartTime(uint256) := TMP_17(uint256)\\\"];\\n4->15;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nclaimedToday = 0\\n\\nIRs:\\nclaimedToday(uint256) := 0(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nrequire(bool)(ethVerify.verifiedUsers(msg.sender))\\n\\nIRs:\\nTMP_18(bool) = HIGH_LEVEL_CALL, dest:ethVerify(EthVerifyCore), function:verifiedUsers, arguments:['msg.sender']  \\nTMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nrequire(bool)(lastClaimed[msg.sender] <= dayStartTime)\\n\\nIRs:\\nREF_7(uint256) -> lastClaimed[msg.sender]\\nTMP_20(bool) = REF_7 <= dayStartTime\\nTMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nlastClaimed[msg.sender] = now\\n\\nIRs:\\nREF_8(uint256) -> lastClaimed[msg.sender]\\nREF_8(uint256) (->lastClaimed) := now(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nclaimedToday = claimedToday.add(1)\\n\\nIRs:\\nTMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['claimedToday', '1'] \\nclaimedToday(uint256) := TMP_22(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].add(dailyDistribution.div(claimedYesterday))\\n\\nIRs:\\nREF_10(uint256) -> balances[msg.sender]\\nREF_11(uint256) -> balances[msg.sender]\\nTMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['dailyDistribution', 'claimedYesterday'] \\nTMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_11', 'TMP_23'] \\nREF_10(uint256) (->balances) := TMP_24(uint256)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\n_totalSupply = _totalSupply.add(dailyDistribution.div(claimedYesterday))\\n\\nIRs:\\nTMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['dailyDistribution', 'claimedYesterday'] \\nTMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', 'TMP_25'] \\n_totalSupply(uint256) := TMP_26(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nTokensClaimed(msg.sender,dailyDistribution.div(claimedYesterday))\\n\\nIRs:\\nTMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['dailyDistribution', 'claimedYesterday'] \\nEmit TokensClaimed(msg.sender,TMP_27)\\\"];\\n15[label=\\\"Node Type: IF 15\\n\\nEXPRESSION:\\nclaimedToday > 1\\n\\nIRs:\\nTMP_29(bool) = claimedToday > 1\\nCONDITION TMP_29\\\"];\\n15->16[label=\\\"True\\\"];\\n15->17[label=\\\"False\\\"];\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nclaimedYesterday = claimedToday\\n\\nIRs:\\nclaimedYesterday(uint256) := claimedToday(uint256)\\\"];\\n16->18;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nclaimedYesterday = 1\\n\\nIRs:\\nclaimedYesterday(uint256) := 1(uint256)\\\"];\\n17->18;\\n18[label=\\\"Node Type: END_IF 18\\n\\\"];\\n18->6;\\n}\\n// Function: 63.sol-VerifyToken-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntimestep = 86400\\n\\nIRs:\\ntimestep(uint256) := 86400(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nsymbol = VRF\\n\\nIRs:\\nsymbol(string) := VRF(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = 0xVerify\\n\\nIRs:\\nname(string) := 0xVerify(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ndailyDistribution = 10000000 * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_0 = CONVERT decimals to uint256\\nTMP_1(uint256) = 10 ** TMP_0\\nTMP_2(uint256) = 10000000 * TMP_1\\ndailyDistribution(uint256) := TMP_2(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nclaimedYesterday = 20\\n\\nIRs:\\nclaimedYesterday(uint256) := 20(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nclaimedToday = 0\\n\\nIRs:\\nclaimedToday(uint256) := 0(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ndayStartTime = now\\n\\nIRs:\\ndayStartTime(uint256) := now(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\n_totalSupply = 140000000 * 10 ** uint256(decimals)\\n\\nIRs:\\nTMP_3 = CONVERT decimals to uint256\\nTMP_4(uint256) = 10 ** TMP_3\\nTMP_5(uint256) = 140000000 * TMP_4\\n_totalSupply(uint256) := TMP_5(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nbalances[msg.sender] = _totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balances[msg.sender]\\nREF_0(uint256) (->balances) := _totalSupply(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ncreator = msg.sender\\n\\nIRs:\\ncreator(address) := msg.sender(address)\\\"];\\n}\\n// Function: 63.sol-VerifyToken-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nactivated = false\\n\\nIRs:\\nactivated(bool) := False(bool)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nethVerify = EthVerifyCore(0x1c307A39511C16F74783fCd0091a921ec29A0b51)\\n\\nIRs:\\nTMP_43 = CONVERT 160932824555388883608022629675987911587606956881 to EthVerifyCore\\nethVerify(EthVerifyCore) := TMP_43(EthVerifyCore)\\\"];\\n}\\n// Function: 63.sol-VerifyToken-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n_totalSupply.sub(balances[address(0)])\\n\\nIRs:\\nTMP_30 = CONVERT 0 to address\\nREF_18(uint256) -> balances[TMP_30]\\nTMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_totalSupply', 'REF_18'] \\nRETURN TMP_31\\\"];\\n}\\n// Function: 63.sol-VerifyToken-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(tokens)\\n\\nIRs:\\nREF_20(uint256) -> balances[msg.sender]\\nREF_21(uint256) -> balances[msg.sender]\\nTMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_21', 'tokens'] \\nREF_20(uint256) (->balances) := TMP_32(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[to] = balances[to].add(tokens)\\n\\nIRs:\\nREF_23(uint256) -> balances[to]\\nREF_24(uint256) -> balances[to]\\nTMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_24', 'tokens'] \\nREF_23(uint256) (->balances) := TMP_33(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTransfer(msg.sender,to,tokens)\\n\\nIRs:\\nEmit Transfer(msg.sender,to,tokens)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 63.sol-VerifyToken-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nbalances[from] = balances[from].sub(tokens)\\n\\nIRs:\\nREF_31(uint256) -> balances[from]\\nREF_32(uint256) -> balances[from]\\nTMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_32', 'tokens'] \\nREF_31(uint256) (->balances) := TMP_39(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens)\\n\\nIRs:\\nREF_34(mapping(address => uint256)) -> allowed[from]\\nREF_35(uint256) -> REF_34[msg.sender]\\nREF_36(mapping(address => uint256)) -> allowed[from]\\nREF_37(uint256) -> REF_36[msg.sender]\\nTMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_37', 'tokens'] \\nREF_35(uint256) (->allowed) := TMP_40(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[to] = balances[to].add(tokens)\\n\\nIRs:\\nREF_39(uint256) -> balances[to]\\nREF_40(uint256) -> balances[to]\\nTMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_40', 'tokens'] \\nREF_39(uint256) (->balances) := TMP_41(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(from,to,tokens)\\n\\nIRs:\\nEmit Transfer(from,to,tokens)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 66.sol-ConfigureSale-ADD_TIERS(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n(CROWDSALE_TIERS_ADDED,_exec_id)\\n\\nIRs:\\nRETURN CROWDSALE_TIERS_ADDED,_exec_id\\\"];\\n}\\n// Function: 66.sol-ConfigureSale-MIN_UPDATE(bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n(TIER_MIN_UPDATE,_exec_id,bytes32(_idx))\\n\\nIRs:\\nTMP_269 = CONVERT _idx to bytes32\\nRETURN TIER_MIN_UPDATE,_exec_id,TMP_269\\\"];\\n}\\n// Function: 66.sol-ConfigureSale-createCrowdsaleTiers(bytes32[],uint256[],uint256[],uint256[],uint256[],bool[],bool[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_tier_names.length != _tier_durations.length || _tier_names.length != _tier_prices.length || _tier_names.length != _tier_caps.length || _tier_names.length != _tier_modifiable.length || _tier_names.length != _tier_whitelisted.length || _tier_names.length == 0\\n\\nIRs:\\nREF_33 -> LENGTH _tier_names\\nREF_34 -> LENGTH _tier_durations\\nTMP_270(bool) = REF_33 != REF_34\\nREF_35 -> LENGTH _tier_names\\nREF_36 -> LENGTH _tier_prices\\nTMP_271(bool) = REF_35 != REF_36\\nTMP_272(bool) = TMP_270 || TMP_271\\nREF_37 -> LENGTH _tier_names\\nREF_38 -> LENGTH _tier_caps\\nTMP_273(bool) = REF_37 != REF_38\\nTMP_274(bool) = TMP_272 || TMP_273\\nREF_39 -> LENGTH _tier_names\\nREF_40 -> LENGTH _tier_modifiable\\nTMP_275(bool) = REF_39 != REF_40\\nTMP_276(bool) = TMP_274 || TMP_275\\nREF_41 -> LENGTH _tier_names\\nREF_42 -> LENGTH _tier_whitelisted\\nTMP_277(bool) = REF_41 != REF_42\\nTMP_278(bool) = TMP_276 || TMP_277\\nREF_43 -> LENGTH _tier_names\\nTMP_279(bool) = REF_43 == 0\\nTMP_280(bool) = TMP_278 || TMP_279\\nCONDITION TMP_280\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(array length mismatch)\\n\\nIRs:\\nTMP_281(None) = SOLIDITY_CALL revert(string)(array length mismatch)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ndurations_sum = uint256(Contract.read(SaleManager.totalDuration()))\\n\\nIRs:\\nTMP_282(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.totalDuration(), arguments:[] \\nTMP_283(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_282'] \\nTMP_284 = CONVERT TMP_283 to uint256\\ndurations_sum(uint256) := TMP_284(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nnum_tiers = uint256(Contract.read(SaleManager.saleTierList()))\\n\\nIRs:\\nTMP_285(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.saleTierList(), arguments:[] \\nTMP_286(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_285'] \\nTMP_287 = CONVERT TMP_286 to uint256\\nnum_tiers(uint256) := TMP_287(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nContract.storing()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.storing(), arguments:[] \\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nContract.increase(SaleManager.saleTierList()).by(_tier_names.length)\\n\\nIRs:\\nTMP_289(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.saleTierList(), arguments:[] \\nTMP_290(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.increase(bytes32), arguments:['TMP_289'] \\nREF_52 -> LENGTH _tier_names\\nLIBRARY_CALL, dest:Contract, function:Contract.by(bytes32,uint256), arguments:['TMP_290', 'REF_52'] \\\"];\\n7->10;\\n8[label=\\\"Node Type: BEGIN_LOOP 8\\n\\\"];\\n8->11;\\n9[label=\\\"Node Type: END_LOOP 9\\n\\\"];\\n9->24;\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n10->8;\\n11[label=\\\"Node Type: IF_LOOP 11\\n\\nEXPRESSION:\\ni < _tier_names.length\\n\\nIRs:\\nREF_53 -> LENGTH _tier_names\\nTMP_292(bool) = i < REF_53\\nCONDITION TMP_292\\\"];\\n11->12[label=\\\"True\\\"];\\n11->9[label=\\\"False\\\"];\\n12[label=\\\"Node Type: IF 12\\n\\nEXPRESSION:\\n_tier_caps[i] == 0 || _tier_prices[i] == 0 || _tier_durations[i] == 0\\n\\nIRs:\\nREF_54(uint256) -> _tier_caps[i]\\nTMP_293(bool) = REF_54 == 0\\nREF_55(uint256) -> _tier_prices[i]\\nTMP_294(bool) = REF_55 == 0\\nTMP_295(bool) = TMP_293 || TMP_294\\nREF_56(uint256) -> _tier_durations[i]\\nTMP_296(bool) = REF_56 == 0\\nTMP_297(bool) = TMP_295 || TMP_296\\nCONDITION TMP_297\\\"];\\n12->13[label=\\\"True\\\"];\\n12->14[label=\\\"False\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nrevert(string)(invalid tier vals)\\n\\nIRs:\\nTMP_298(None) = SOLIDITY_CALL revert(string)(invalid tier vals)\\\"];\\n13->14;\\n14[label=\\\"Node Type: END_IF 14\\n\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\ndurations_sum = durations_sum.add(_tier_durations[i])\\n\\nIRs:\\nREF_58(uint256) -> _tier_durations[i]\\nTMP_299(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['durations_sum', 'REF_58'] \\ndurations_sum(uint256) := TMP_299(uint256)\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierName(num_tiers + i)).to(_tier_names[i])\\n\\nIRs:\\nTMP_300(uint256) = num_tiers + i\\nTMP_301(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierName(uint256), arguments:['TMP_300'] \\nTMP_302(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_301'] \\nREF_62(bytes32) -> _tier_names[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bytes32), arguments:['TMP_302', 'REF_62'] \\\"];\\n16->17;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierCap(num_tiers + i)).to(_tier_caps[i])\\n\\nIRs:\\nTMP_304(uint256) = num_tiers + i\\nTMP_305(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierCap(uint256), arguments:['TMP_304'] \\nTMP_306(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_305'] \\nREF_66(uint256) -> _tier_caps[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_306', 'REF_66'] \\\"];\\n17->18;\\n18[label=\\\"Node Type: EXPRESSION 18\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierPrice(num_tiers + i)).to(_tier_prices[i])\\n\\nIRs:\\nTMP_308(uint256) = num_tiers + i\\nTMP_309(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierPrice(uint256), arguments:['TMP_308'] \\nTMP_310(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_309'] \\nREF_70(uint256) -> _tier_prices[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_310', 'REF_70'] \\\"];\\n18->19;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierDuration(num_tiers + i)).to(_tier_durations[i])\\n\\nIRs:\\nTMP_312(uint256) = num_tiers + i\\nTMP_313(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierDuration(uint256), arguments:['TMP_312'] \\nTMP_314(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_313'] \\nREF_74(uint256) -> _tier_durations[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_314', 'REF_74'] \\\"];\\n19->20;\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierMin(num_tiers + i)).to(_tier_minimums[i])\\n\\nIRs:\\nTMP_316(uint256) = num_tiers + i\\nTMP_317(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierMin(uint256), arguments:['TMP_316'] \\nTMP_318(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_317'] \\nREF_78(uint256) -> _tier_minimums[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_318', 'REF_78'] \\\"];\\n20->21;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierModifiable(num_tiers + i)).to(_tier_modifiable[i])\\n\\nIRs:\\nTMP_320(uint256) = num_tiers + i\\nTMP_321(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierModifiable(uint256), arguments:['TMP_320'] \\nTMP_322(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_321'] \\nREF_82(bool) -> _tier_modifiable[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bool), arguments:['TMP_322', 'REF_82'] \\\"];\\n21->22;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierWhitelisted(num_tiers + i)).to(_tier_whitelisted[i])\\n\\nIRs:\\nTMP_324(uint256) = num_tiers + i\\nTMP_325(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierWhitelisted(uint256), arguments:['TMP_324'] \\nTMP_326(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_325'] \\nREF_86(bool) -> _tier_whitelisted[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bool), arguments:['TMP_326', 'REF_86'] \\\"];\\n22->23;\\n23[label=\\\"Node Type: EXPRESSION 23\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_328(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n23->11;\\n24[label=\\\"Node Type: EXPRESSION 24\\n\\nEXPRESSION:\\nContract.set(SaleManager.totalDuration()).to(durations_sum)\\n\\nIRs:\\nTMP_329(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.totalDuration(), arguments:[] \\nTMP_330(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_329'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_330', 'durations_sum'] \\\"];\\n24->25;\\n25[label=\\\"Node Type: EXPRESSION 25\\n\\nEXPRESSION:\\nContract.emitting()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.emitting(), arguments:[] \\\"];\\n25->26;\\n26[label=\\\"Node Type: EXPRESSION 26\\n\\nEXPRESSION:\\nContract.log(ADD_TIERS(Contract.execID()),bytes32(num_tiers.add(_tier_names.length)))\\n\\nIRs:\\nTMP_333(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.execID(), arguments:[] \\nTMP_334(bytes32[2]) = INTERNAL_CALL, ConfigureSale.ADD_TIERS(bytes32)(TMP_333)\\nREF_94 -> LENGTH _tier_names\\nTMP_335(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['num_tiers', 'REF_94'] \\nTMP_336 = CONVERT TMP_335 to bytes32\\nLIBRARY_CALL, dest:Contract, function:Contract.log(bytes32[2],bytes32), arguments:['TMP_334', 'TMP_336'] \\\"];\\n}\\n// Function: 66.sol-ConfigureSale-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nTIER_MIN_UPDATE = keccak256()(TierMinUpdate(bytes32,uint256,uint256))\\n\\nIRs:\\nTMP_461(bytes32) = SOLIDITY_CALL keccak256()(TierMinUpdate(bytes32,uint256,uint256))\\nTIER_MIN_UPDATE(bytes32) := TMP_461(bytes32)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nCROWDSALE_TIERS_ADDED = keccak256()(CrowdsaleTiersAdded(bytes32,uint256))\\n\\nIRs:\\nTMP_462(bytes32) = SOLIDITY_CALL keccak256()(CrowdsaleTiersAdded(bytes32,uint256))\\nCROWDSALE_TIERS_ADDED(bytes32) := TMP_462(bytes32)\\\"];\\n}\\n// Function: 66.sol-ConfigureSale-updateTierDuration(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_new_duration == 0\\n\\nIRs:\\nTMP_375(bool) = _new_duration == 0\\nCONDITION TMP_375\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(invalid duration)\\n\\nIRs:\\nTMP_376(None) = SOLIDITY_CALL revert(string)(invalid duration)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nstarts_at = uint256(Contract.read(SaleManager.startTime()))\\n\\nIRs:\\nTMP_377(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.startTime(), arguments:[] \\nTMP_378(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_377'] \\nTMP_379 = CONVERT TMP_378 to uint256\\nstarts_at(uint256) := TMP_379(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ncurrent_tier = uint256(Contract.read(SaleManager.currentTier()))\\n\\nIRs:\\nTMP_380(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.currentTier(), arguments:[] \\nTMP_381(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_380'] \\nTMP_382 = CONVERT TMP_381 to uint256\\ncurrent_tier(uint256) := TMP_382(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\ntotal_duration = uint256(Contract.read(SaleManager.totalDuration()))\\n\\nIRs:\\nTMP_383(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.totalDuration(), arguments:[] \\nTMP_384(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_383'] \\nTMP_385 = CONVERT TMP_384 to uint256\\ntotal_duration(uint256) := TMP_385(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ncur_ends_at = uint256(Contract.read(SaleManager.currentEndsAt()))\\n\\nIRs:\\nTMP_386(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.currentEndsAt(), arguments:[] \\nTMP_387(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_386'] \\nTMP_388 = CONVERT TMP_387 to uint256\\ncur_ends_at(uint256) := TMP_388(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\nprevious_duration = uint256(Contract.read(SaleManager.tierDuration(_tier_index)))\\n\\nIRs:\\nTMP_389(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierDuration(uint256), arguments:['_tier_index'] \\nTMP_390(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_389'] \\nTMP_391 = CONVERT TMP_390 to uint256\\nprevious_duration(uint256) := TMP_391(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ncurrent_tier = current_tier.sub(1)\\n\\nIRs:\\nTMP_392(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['current_tier', '1'] \\ncurrent_tier(uint256) := TMP_392(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\nprevious_duration == _new_duration\\n\\nIRs:\\nTMP_393(bool) = previous_duration == _new_duration\\nCONDITION TMP_393\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nrevert(string)(duration unchanged)\\n\\nIRs:\\nTMP_394(None) = SOLIDITY_CALL revert(string)(duration unchanged)\\\"];\\n11->12;\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: IF 13\\n\\nEXPRESSION:\\ntotal_duration < previous_duration\\n\\nIRs:\\nTMP_395(bool) = total_duration < previous_duration\\nCONDITION TMP_395\\\"];\\n13->14[label=\\\"True\\\"];\\n13->15[label=\\\"False\\\"];\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nrevert(string)(total duration invalid)\\n\\nIRs:\\nTMP_396(None) = SOLIDITY_CALL revert(string)(total duration invalid)\\\"];\\n14->15;\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: IF 16\\n\\nEXPRESSION:\\nuint256(Contract.read(SaleManager.saleTierList())) <= _tier_index\\n\\nIRs:\\nTMP_397(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.saleTierList(), arguments:[] \\nTMP_398(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_397'] \\nTMP_399 = CONVERT TMP_398 to uint256\\nTMP_400(bool) = TMP_399 <= _tier_index\\nCONDITION TMP_400\\\"];\\n16->17[label=\\\"True\\\"];\\n16->18[label=\\\"False\\\"];\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nrevert(string)(tier does not exist)\\n\\nIRs:\\nTMP_401(None) = SOLIDITY_CALL revert(string)(tier does not exist)\\\"];\\n17->18;\\n18[label=\\\"Node Type: END_IF 18\\n\\\"];\\n18->19;\\n19[label=\\\"Node Type: IF 19\\n\\nEXPRESSION:\\ncurrent_tier > _tier_index\\n\\nIRs:\\nTMP_402(bool) = current_tier > _tier_index\\nCONDITION TMP_402\\\"];\\n19->20[label=\\\"True\\\"];\\n19->21[label=\\\"False\\\"];\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\nrevert(string)(tier has already completed)\\n\\nIRs:\\nTMP_403(None) = SOLIDITY_CALL revert(string)(tier has already completed)\\\"];\\n20->21;\\n21[label=\\\"Node Type: END_IF 21\\n\\\"];\\n21->22;\\n22[label=\\\"Node Type: IF 22\\n\\nEXPRESSION:\\nContract.read(SaleManager.tierModifiable(_tier_index)) == 0\\n\\nIRs:\\nTMP_404(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierModifiable(uint256), arguments:['_tier_index'] \\nTMP_405(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_404'] \\nTMP_406(bool) = TMP_405 == 0\\nCONDITION TMP_406\\\"];\\n22->23[label=\\\"True\\\"];\\n22->24[label=\\\"False\\\"];\\n23[label=\\\"Node Type: EXPRESSION 23\\n\\nEXPRESSION:\\nrevert(string)(tier duration not modifiable)\\n\\nIRs:\\nTMP_407(None) = SOLIDITY_CALL revert(string)(tier duration not modifiable)\\\"];\\n23->24;\\n24[label=\\\"Node Type: END_IF 24\\n\\\"];\\n24->25;\\n25[label=\\\"Node Type: EXPRESSION 25\\n\\nEXPRESSION:\\nContract.storing()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.storing(), arguments:[] \\\"];\\n25->26;\\n26[label=\\\"Node Type: IF 26\\n\\nEXPRESSION:\\n_tier_index == 0\\n\\nIRs:\\nTMP_409(bool) = _tier_index == 0\\nCONDITION TMP_409\\\"];\\n26->27[label=\\\"True\\\"];\\n26->31[label=\\\"False\\\"];\\n27[label=\\\"Node Type: IF 27\\n\\nEXPRESSION:\\nnow >= starts_at\\n\\nIRs:\\nTMP_410(bool) = now >= starts_at\\nCONDITION TMP_410\\\"];\\n27->28[label=\\\"True\\\"];\\n27->29[label=\\\"False\\\"];\\n28[label=\\\"Node Type: EXPRESSION 28\\n\\nEXPRESSION:\\nrevert(string)(cannot modify initial tier once sale has started)\\n\\nIRs:\\nTMP_411(None) = SOLIDITY_CALL revert(string)(cannot modify initial tier once sale has started)\\\"];\\n28->29;\\n29[label=\\\"Node Type: END_IF 29\\n\\\"];\\n29->30;\\n30[label=\\\"Node Type: EXPRESSION 30\\n\\nEXPRESSION:\\nContract.set(SaleManager.currentEndsAt()).to(_new_duration.add(starts_at))\\n\\nIRs:\\nTMP_412(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.currentEndsAt(), arguments:[] \\nTMP_413(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_412'] \\nTMP_414(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_new_duration', 'starts_at'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_413', 'TMP_414'] \\\"];\\n30->46;\\n31[label=\\\"Node Type: IF 31\\n\\nEXPRESSION:\\n_tier_index > current_tier\\n\\nIRs:\\nTMP_416(bool) = _tier_index > current_tier\\nCONDITION TMP_416\\\"];\\n31->32[label=\\\"True\\\"];\\n31->44[label=\\\"False\\\"];\\n32[label=\\\"Node Type: IF 32\\n\\nEXPRESSION:\\n_tier_index - current_tier == 1 && now >= cur_ends_at\\n\\nIRs:\\nTMP_417(uint256) = _tier_index - current_tier\\nTMP_418(bool) = TMP_417 == 1\\nTMP_419(bool) = now >= cur_ends_at\\nTMP_420(bool) = TMP_418 && TMP_419\\nCONDITION TMP_420\\\"];\\n32->33[label=\\\"True\\\"];\\n32->34[label=\\\"False\\\"];\\n33[label=\\\"Node Type: EXPRESSION 33\\n\\nEXPRESSION:\\nrevert(string)(cannot modify tier after it has begun)\\n\\nIRs:\\nTMP_421(None) = SOLIDITY_CALL revert(string)(cannot modify tier after it has begun)\\\"];\\n33->34;\\n34[label=\\\"Node Type: END_IF 34\\n\\\"];\\n34->37;\\n35[label=\\\"Node Type: BEGIN_LOOP 35\\n\\\"];\\n35->38;\\n36[label=\\\"Node Type: END_LOOP 36\\n\\\"];\\n36->41;\\n37[label=\\\"Node Type: NEW VARIABLE 37\\n\\nEXPRESSION:\\ni = current_tier + 1\\n\\nIRs:\\nTMP_422(uint256) = current_tier + 1\\ni(uint256) := TMP_422(uint256)\\\"];\\n37->35;\\n38[label=\\\"Node Type: IF_LOOP 38\\n\\nEXPRESSION:\\ni < _tier_index\\n\\nIRs:\\nTMP_423(bool) = i < _tier_index\\nCONDITION TMP_423\\\"];\\n38->39[label=\\\"True\\\"];\\n38->36[label=\\\"False\\\"];\\n39[label=\\\"Node Type: EXPRESSION 39\\n\\nEXPRESSION:\\ncur_ends_at = cur_ends_at.add(uint256(Contract.read(SaleManager.tierDuration(i))))\\n\\nIRs:\\nTMP_424(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierDuration(uint256), arguments:['i'] \\nTMP_425(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_424'] \\nTMP_426 = CONVERT TMP_425 to uint256\\nTMP_427(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['cur_ends_at', 'TMP_426'] \\ncur_ends_at(uint256) := TMP_427(uint256)\\\"];\\n39->40;\\n40[label=\\\"Node Type: EXPRESSION 40\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_428(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n40->38;\\n41[label=\\\"Node Type: IF 41\\n\\nEXPRESSION:\\ncur_ends_at < now\\n\\nIRs:\\nTMP_429(bool) = cur_ends_at < now\\nCONDITION TMP_429\\\"];\\n41->42[label=\\\"True\\\"];\\n41->43[label=\\\"False\\\"];\\n42[label=\\\"Node Type: EXPRESSION 42\\n\\nEXPRESSION:\\nrevert(string)(cannot modify current tier)\\n\\nIRs:\\nTMP_430(None) = SOLIDITY_CALL revert(string)(cannot modify current tier)\\\"];\\n42->43;\\n43[label=\\\"Node Type: END_IF 43\\n\\\"];\\n43->45;\\n44[label=\\\"Node Type: EXPRESSION 44\\n\\nEXPRESSION:\\nrevert(string)(cannot update tier)\\n\\nIRs:\\nTMP_431(None) = SOLIDITY_CALL revert(string)(cannot update tier)\\\"];\\n44->45;\\n45[label=\\\"Node Type: END_IF 45\\n\\\"];\\n45->46;\\n46[label=\\\"Node Type: END_IF 46\\n\\\"];\\n46->47;\\n47[label=\\\"Node Type: IF 47\\n\\nEXPRESSION:\\nprevious_duration > _new_duration\\n\\nIRs:\\nTMP_432(bool) = previous_duration > _new_duration\\nCONDITION TMP_432\\\"];\\n47->48[label=\\\"True\\\"];\\n47->49[label=\\\"False\\\"];\\n48[label=\\\"Node Type: EXPRESSION 48\\n\\nEXPRESSION:\\ntotal_duration = total_duration.sub(previous_duration - _new_duration)\\n\\nIRs:\\nTMP_433(uint256) = previous_duration - _new_duration\\nTMP_434(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['total_duration', 'TMP_433'] \\ntotal_duration(uint256) := TMP_434(uint256)\\\"];\\n48->50;\\n49[label=\\\"Node Type: EXPRESSION 49\\n\\nEXPRESSION:\\ntotal_duration = total_duration.add(_new_duration - previous_duration)\\n\\nIRs:\\nTMP_435(uint256) = _new_duration - previous_duration\\nTMP_436(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['total_duration', 'TMP_435'] \\ntotal_duration(uint256) := TMP_436(uint256)\\\"];\\n49->50;\\n50[label=\\\"Node Type: END_IF 50\\n\\\"];\\n50->51;\\n51[label=\\\"Node Type: EXPRESSION 51\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierDuration(_tier_index)).to(_new_duration)\\n\\nIRs:\\nTMP_437(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierDuration(uint256), arguments:['_tier_index'] \\nTMP_438(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_437'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_438', '_new_duration'] \\\"];\\n51->52;\\n52[label=\\\"Node Type: EXPRESSION 52\\n\\nEXPRESSION:\\nContract.set(SaleManager.totalDuration()).to(total_duration)\\n\\nIRs:\\nTMP_440(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.totalDuration(), arguments:[] \\nTMP_441(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_440'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_441', 'total_duration'] \\\"];\\n}\\n// Function: 66.sol-ConfigureSale-updateTierMinimum(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nuint256(Contract.read(SaleManager.saleTierList())) <= _tier_index\\n\\nIRs:\\nTMP_443(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.saleTierList(), arguments:[] \\nTMP_444(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_443'] \\nTMP_445 = CONVERT TMP_444 to uint256\\nTMP_446(bool) = TMP_445 <= _tier_index\\nCONDITION TMP_446\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(tier does not exist)\\n\\nIRs:\\nTMP_447(None) = SOLIDITY_CALL revert(string)(tier does not exist)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nContract.read(SaleManager.tierModifiable(_tier_index)) == 0\\n\\nIRs:\\nTMP_448(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierModifiable(uint256), arguments:['_tier_index'] \\nTMP_449(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_448'] \\nTMP_450(bool) = TMP_449 == 0\\nCONDITION TMP_450\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(tier mincap not modifiable)\\n\\nIRs:\\nTMP_451(None) = SOLIDITY_CALL revert(string)(tier mincap not modifiable)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nContract.storing()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.storing(), arguments:[] \\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierMin(_tier_index)).to(_new_minimum)\\n\\nIRs:\\nTMP_453(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierMin(uint256), arguments:['_tier_index'] \\nTMP_454(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_453'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_454', '_new_minimum'] \\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nContract.emitting()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.emitting(), arguments:[] \\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nContract.log(MIN_UPDATE(Contract.execID(),_tier_index),bytes32(_new_minimum))\\n\\nIRs:\\nTMP_457(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.execID(), arguments:[] \\nTMP_458(bytes32[3]) = INTERNAL_CALL, ConfigureSale.MIN_UPDATE(bytes32,uint256)(TMP_457,_tier_index)\\nTMP_459 = CONVERT _new_minimum to bytes32\\nLIBRARY_CALL, dest:Contract, function:Contract.log(bytes32[3],bytes32), arguments:['TMP_458', 'TMP_459'] \\\"];\\n}\\n// Function: 66.sol-ConfigureSale-whitelistMultiForTier(uint256,address[],uint256[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_to_whitelist.length != _min_token_purchase.length || _to_whitelist.length != _max_purchase_amt.length || _to_whitelist.length == 0\\n\\nIRs:\\nREF_95 -> LENGTH _to_whitelist\\nREF_96 -> LENGTH _min_token_purchase\\nTMP_338(bool) = REF_95 != REF_96\\nREF_97 -> LENGTH _to_whitelist\\nREF_98 -> LENGTH _max_purchase_amt\\nTMP_339(bool) = REF_97 != REF_98\\nTMP_340(bool) = TMP_338 || TMP_339\\nREF_99 -> LENGTH _to_whitelist\\nTMP_341(bool) = REF_99 == 0\\nTMP_342(bool) = TMP_340 || TMP_341\\nCONDITION TMP_342\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(mismatched input lengths)\\n\\nIRs:\\nTMP_343(None) = SOLIDITY_CALL revert(string)(mismatched input lengths)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ntier_whitelist_length = uint256(Contract.read(SaleManager.tierWhitelist(_tier_index)))\\n\\nIRs:\\nTMP_344(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierWhitelist(uint256), arguments:['_tier_index'] \\nTMP_345(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_344'] \\nTMP_346 = CONVERT TMP_345 to uint256\\ntier_whitelist_length(uint256) := TMP_346(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.storing()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.storing(), arguments:[] \\\"];\\n5->8;\\n6[label=\\\"Node Type: BEGIN_LOOP 6\\n\\\"];\\n6->9;\\n7[label=\\\"Node Type: END_LOOP 7\\n\\\"];\\n7->17;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n8->6;\\n9[label=\\\"Node Type: IF_LOOP 9\\n\\nEXPRESSION:\\ni < _to_whitelist.length\\n\\nIRs:\\nREF_103 -> LENGTH _to_whitelist\\nTMP_348(bool) = i < REF_103\\nCONDITION TMP_348\\\"];\\n9->10[label=\\\"True\\\"];\\n9->7[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nContract.set(SaleManager.whitelistMinTok(_tier_index,_to_whitelist[i])).to(_min_token_purchase[i])\\n\\nIRs:\\nREF_106(address) -> _to_whitelist[i]\\nTMP_349(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.whitelistMinTok(uint256,address), arguments:['_tier_index', 'REF_106'] \\nTMP_350(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_349'] \\nREF_108(uint256) -> _min_token_purchase[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_350', 'REF_108'] \\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nContract.set(SaleManager.whitelistMaxTok(_tier_index,_to_whitelist[i])).to(_max_purchase_amt[i])\\n\\nIRs:\\nREF_111(address) -> _to_whitelist[i]\\nTMP_352(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.whitelistMaxTok(uint256,address), arguments:['_tier_index', 'REF_111'] \\nTMP_353(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_352'] \\nREF_113(uint256) -> _max_purchase_amt[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_353', 'REF_113'] \\\"];\\n11->12;\\n12[label=\\\"Node Type: IF 12\\n\\nEXPRESSION:\\nContract.read(SaleManager.whitelistMinTok(_tier_index,_to_whitelist[i])) == 0 && Contract.read(SaleManager.whitelistMaxTok(_tier_index,_to_whitelist[i])) == 0\\n\\nIRs:\\nREF_116(address) -> _to_whitelist[i]\\nTMP_355(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.whitelistMinTok(uint256,address), arguments:['_tier_index', 'REF_116'] \\nTMP_356(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_355'] \\nTMP_357(bool) = TMP_356 == 0\\nREF_119(address) -> _to_whitelist[i]\\nTMP_358(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.whitelistMaxTok(uint256,address), arguments:['_tier_index', 'REF_119'] \\nTMP_359(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_358'] \\nTMP_360(bool) = TMP_359 == 0\\nTMP_361(bool) = TMP_357 && TMP_360\\nCONDITION TMP_361\\\"];\\n12->13[label=\\\"True\\\"];\\n12->15[label=\\\"False\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nContract.set(bytes32(32 + (32 * tier_whitelist_length) + uint256(SaleManager.tierWhitelist(_tier_index)))).to(_to_whitelist[i])\\n\\nIRs:\\nTMP_362(uint256) = 32 * tier_whitelist_length\\nTMP_363(uint256) = 32 + TMP_362\\nTMP_364(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierWhitelist(uint256), arguments:['_tier_index'] \\nTMP_365 = CONVERT TMP_364 to uint256\\nTMP_366(uint256) = TMP_363 + TMP_365\\nTMP_367 = CONVERT TMP_366 to bytes32\\nTMP_368(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_367'] \\nREF_123(address) -> _to_whitelist[i]\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,address), arguments:['TMP_368', 'REF_123'] \\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ntier_whitelist_length ++\\n\\nIRs:\\nTMP_370(uint256) := tier_whitelist_length(uint256)\\ntier_whitelist_length(uint256) = tier_whitelist_length + 1\\\"];\\n14->15;\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_371(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n16->9;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nContract.set(SaleManager.tierWhitelist(_tier_index)).to(tier_whitelist_length)\\n\\nIRs:\\nTMP_372(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tierWhitelist(uint256), arguments:['_tier_index'] \\nTMP_373(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_372'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_373', 'tier_whitelist_length'] \\\"];\\n}\\n// Function: 66.sol-Contract-authorize(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ninitialize()\\n\\nIRs:\\nINTERNAL_CALL, Contract.initialize()()\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nperms = EXEC_PERMISSIONS\\n\\nIRs:\\nperms(bytes32) := EXEC_PERMISSIONS(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: IF 6\\n\\nEXPRESSION:\\n! authorized\\n\\nIRs:\\nTMP_13 = UnaryType.BANG authorized \\nCONDITION TMP_13\\\"];\\n6->7[label=\\\"True\\\"];\\n6->8[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrevert(string)(Sender is not authorized as a script exec address)\\n\\nIRs:\\nTMP_14(None) = SOLIDITY_CALL revert(string)(Sender is not authorized as a script exec address)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n}\\n// Function: 66.sol-Contract-buffPtr()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nptr\\n\\nIRs:\\nRETURN ptr\\\"];\\n}\\n// Function: 66.sol-Contract-by(bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->11;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() == NextFunction.VAL_INC\\n\\nIRs:\\nTMP_161(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_7(Contract.NextFunction) -> NextFunction.VAL_INC\\nTMP_162(bool) = TMP_161 == REF_7\\nCONDITION TMP_162\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_amt = _amt.add(uint256(_val))\\n\\nIRs:\\nTMP_163 = CONVERT _val to uint256\\nTMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_amt', 'TMP_163'] \\n_amt(uint256) := TMP_164(uint256)\\\"];\\n2->7;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nexpected() == NextFunction.VAL_DEC\\n\\nIRs:\\nTMP_165(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_9(Contract.NextFunction) -> NextFunction.VAL_DEC\\nTMP_166(bool) = TMP_165 == REF_9\\nCONDITION TMP_166\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_amt = uint256(_val).sub(_amt)\\n\\nIRs:\\nTMP_167 = CONVERT _val to uint256\\nTMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_167', '_amt'] \\n_amt(uint256) := TMP_168(uint256)\\\"];\\n4->6;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Expected VAL_INC or VAL_DEC)\\n\\nIRs:\\nTMP_169(None) = SOLIDITY_CALL revert(string)(Expected VAL_INC or VAL_DEC)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: INLINE ASM 8\\n\\\"];\\n8->9;\\n9[label=\\\"Node Type: END INLINE ASM 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n13->1;\\n}\\n// Function: 66.sol-Contract-byMaximum(bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->11;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() == NextFunction.VAL_DEC\\n\\nIRs:\\nTMP_174(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_11(Contract.NextFunction) -> NextFunction.VAL_DEC\\nTMP_175(bool) = TMP_174 == REF_11\\nCONDITION TMP_175\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_amt >= uint256(_val)\\n\\nIRs:\\nTMP_176 = CONVERT _val to uint256\\nTMP_177(bool) = _amt >= TMP_176\\nCONDITION TMP_177\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_amt = 0\\n\\nIRs:\\n_amt(uint256) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_amt = uint256(_val).sub(_amt)\\n\\nIRs:\\nTMP_178 = CONVERT _val to uint256\\nTMP_179(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_178', '_amt'] \\n_amt(uint256) := TMP_179(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->7;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrevert(string)(Expected VAL_DEC)\\n\\nIRs:\\nTMP_180(None) = SOLIDITY_CALL revert(string)(Expected VAL_DEC)\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: INLINE ASM 8\\n\\\"];\\n8->9;\\n9[label=\\\"Node Type: END INLINE ASM 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n13->1;\\n}\\n// Function: 66.sol-Contract-checks(function())\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_check()\\n\\nIRs:\\nINTERNAL_DYNAMIC_CALL _check()  \\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nconditions(validState,validState)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,validState)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nconditions(validState,validState)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,validState)\\\"];\\n3->1;\\n}\\n// Function: 66.sol-Contract-commit()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nptr = buffPtr()\\n\\nIRs:\\nTMP_29(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nptr(bytes32) := TMP_29(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(ptr >= 0x180,Invalid buffer pointer)\\n\\nIRs:\\nTMP_30(bool) = ptr >= 384\\nTMP_31(None) = SOLIDITY_CALL require(bool,string)(TMP_30,Invalid buffer pointer)\\\"];\\n2->3;\\n3[label=\\\"Node Type: INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: END INLINE ASM 4\\n\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validState,none)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,none)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validState,none)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,none)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validState,none)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,none)\\\"];\\n7->1;\\n}\\n// Function: 66.sol-Contract-conditions(function(),function())\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nfirst()\\n\\nIRs:\\nINTERNAL_DYNAMIC_CALL first()  \\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nlast()\\n\\nIRs:\\nINTERNAL_DYNAMIC_CALL last()  \\\"];\\n}\\n// Function: 66.sol-Contract-currentAction()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_52(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_53 = CONVERT 0 to bytes32\\nTMP_54(bool) = TMP_52 == TMP_53\\nCONDITION TMP_54\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbytes4(0)\\n\\nIRs:\\nTMP_55 = CONVERT 0 to bytes4\\nRETURN TMP_55\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\naction\\n\\nIRs:\\nRETURN action\\\"];\\n}\\n// Function: 66.sol-Contract-decrease(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nval = keccak256()(_field,execID())\\n\\nIRs:\\nTMP_155(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_156(bytes32) = SOLIDITY_CALL keccak256()(_field,TMP_155)\\nval(bytes32) := TMP_156(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n8->1;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n}\\n// Function: 66.sol-Contract-emitted()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_216(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_217 = CONVERT 0 to bytes32\\nTMP_218(bool) = TMP_216 == TMP_217\\nCONDITION TMP_218\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nnum_emitted\\n\\nIRs:\\nRETURN num_emitted\\\"];\\n}\\n// Function: 66.sol-Contract-emitting()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\naction_req = EMITS\\n\\nIRs:\\naction_req(bytes4) := EMITS(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEmitBuff,isEmitting)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEmitBuff,isEmitting)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validEmitBuff,isEmitting)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEmitBuff,isEmitting)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validEmitBuff,isEmitting)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEmitBuff,isEmitting)\\\"];\\n7->1;\\n}\\n// Function: 66.sol-Contract-execID()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool,string)(exec_id != bytes32(0),Execution id overwritten, or not read)\\n\\nIRs:\\nTMP_95 = CONVERT 0 to bytes32\\nTMP_96(bool) = exec_id != TMP_95\\nTMP_97(None) = SOLIDITY_CALL require(bool,string)(TMP_96,Execution id overwritten, or not read)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nexec_id\\n\\nIRs:\\nRETURN exec_id\\\"];\\n}\\n// Function: 66.sol-Contract-expected()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nnext\\n\\nIRs:\\nRETURN next\\\"];\\n}\\n// Function: 66.sol-Contract-freeMem()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nptr\\n\\nIRs:\\nRETURN ptr\\\"];\\n}\\n// Function: 66.sol-Contract-increase(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nval = keccak256()(_field,execID())\\n\\nIRs:\\nTMP_149(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_150(bytes32) = SOLIDITY_CALL keccak256()(_field,TMP_149)\\nval(bytes32) := TMP_150(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n8->1;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n}\\n// Function: 66.sol-Contract-initialize()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(freeMem() == 0x80,Memory allocated prior to execution)\\n\\nIRs:\\nTMP_15(bytes32) = INTERNAL_CALL, Contract.freeMem()()\\nTMP_16(bool) = TMP_15 == 128\\nTMP_17(None) = SOLIDITY_CALL require(bool,string)(TMP_16,Memory allocated prior to execution)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nassert(bool)(execID() != bytes32(0) && sender() != address(0))\\n\\nIRs:\\nTMP_18(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_19 = CONVERT 0 to bytes32\\nTMP_20(bool) = TMP_18 != TMP_19\\nTMP_21(address) = INTERNAL_CALL, Contract.sender()()\\nTMP_22 = CONVERT 0 to address\\nTMP_23(bool) = TMP_21 != TMP_22\\nTMP_24(bool) = TMP_20 && TMP_23\\nTMP_25(None) = SOLIDITY_CALL assert(bool)(TMP_24)\\\"];\\n}\\n// Function: 66.sol-Contract-isEmitting()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncurrentAction() != EMITS\\n\\nIRs:\\nTMP_59(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_60(bool) = TMP_59 != EMITS\\nCONDITION TMP_60\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Invalid current action - expected EMITS)\\n\\nIRs:\\nTMP_61(None) = SOLIDITY_CALL revert(string)(Invalid current action - expected EMITS)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 66.sol-Contract-isPaying()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncurrentAction() != PAYS\\n\\nIRs:\\nTMP_62(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_63(bool) = TMP_62 != PAYS\\nCONDITION TMP_63\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Invalid current action - expected PAYS)\\n\\nIRs:\\nTMP_64(None) = SOLIDITY_CALL revert(string)(Invalid current action - expected PAYS)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 66.sol-Contract-isStoring()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncurrentAction() != STORES\\n\\nIRs:\\nTMP_56(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_57(bool) = TMP_56 != STORES\\nCONDITION TMP_57\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Invalid current action - expected STORES)\\n\\nIRs:\\nTMP_58(None) = SOLIDITY_CALL revert(string)(Invalid current action - expected STORES)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 66.sol-Contract-log(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 66.sol-Contract-log(bytes32[1],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 66.sol-Contract-log(bytes32[2],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 66.sol-Contract-log(bytes32[3],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 66.sol-Contract-log(bytes32[4],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 66.sol-Contract-none()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n}\\n// Function: 66.sol-Contract-paid()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_222(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_223 = CONVERT 0 to bytes32\\nTMP_224(bool) = TMP_222 == TMP_223\\nCONDITION TMP_224\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nnum_paid\\n\\nIRs:\\nRETURN num_paid\\\"];\\n}\\n// Function: 66.sol-Contract-pay(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n_amount\\n\\nIRs:\\nRETURN _amount\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validPayAmt,validPayDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayAmt,validPayDest)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validPayAmt,validPayDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayAmt,validPayDest)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validPayAmt,validPayDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayAmt,validPayDest)\\\"];\\n7->1;\\n}\\n// Function: 66.sol-Contract-paying()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\naction_req = PAYS\\n\\nIRs:\\naction_req(bytes4) := PAYS(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validPayBuff,isPaying)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayBuff,isPaying)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validPayBuff,isPaying)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayBuff,isPaying)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validPayBuff,isPaying)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayBuff,isPaying)\\\"];\\n7->1;\\n}\\n// Function: 66.sol-Contract-read(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndata = keccak256()(_location,execID())\\n\\nIRs:\\nTMP_101(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_102(bytes32) = SOLIDITY_CALL keccak256()(_location,TMP_101)\\ndata(bytes32) := TMP_102(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ndata\\n\\nIRs:\\nRETURN data\\\"];\\n}\\n// Function: 66.sol-Contract-sender()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool,string)(addr != address(0),Sender address overwritten, or not read)\\n\\nIRs:\\nTMP_98 = CONVERT 0 to address\\nTMP_99(bool) = addr != TMP_98\\nTMP_100(None) = SOLIDITY_CALL require(bool,string)(TMP_99,Sender address overwritten, or not read)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\naddr\\n\\nIRs:\\nRETURN addr\\\"];\\n}\\n// Function: 66.sol-Contract-set(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n_field\\n\\nIRs:\\nRETURN _field\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n7->1;\\n}\\n// Function: 66.sol-Contract-setFreeMem()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n}\\n// Function: 66.sol-Contract-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nEXEC_PERMISSIONS = keccak256()(script_exec_permissions)\\n\\nIRs:\\nTMP_225(bytes32) = SOLIDITY_CALL keccak256()(script_exec_permissions)\\nEXEC_PERMISSIONS(bytes32) := TMP_225(bytes32)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nEMITS = bytes4(keccak256()(Emit((bytes32[],bytes)[])))\\n\\nIRs:\\nTMP_226(bytes32) = SOLIDITY_CALL keccak256()(Emit((bytes32[],bytes)[]))\\nTMP_227 = CONVERT TMP_226 to bytes4\\nEMITS(bytes4) := TMP_227(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nSTORES = bytes4(keccak256()(Store(bytes32[])))\\n\\nIRs:\\nTMP_228(bytes32) = SOLIDITY_CALL keccak256()(Store(bytes32[]))\\nTMP_229 = CONVERT TMP_228 to bytes4\\nSTORES(bytes4) := TMP_229(bytes4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nPAYS = bytes4(keccak256()(Pay(bytes32[])))\\n\\nIRs:\\nTMP_230(bytes32) = SOLIDITY_CALL keccak256()(Pay(bytes32[]))\\nTMP_231 = CONVERT TMP_230 to bytes4\\nPAYS(bytes4) := TMP_231(bytes4)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nTHROWS = bytes4(keccak256()(Error(string)))\\n\\nIRs:\\nTMP_232(bytes32) = SOLIDITY_CALL keccak256()(Error(string))\\nTMP_233 = CONVERT TMP_232 to bytes4\\nTHROWS(bytes4) := TMP_233(bytes4)\\\"];\\n}\\n// Function: 66.sol-Contract-startBuffer()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n}\\n// Function: 66.sol-Contract-stored()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_219(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_220 = CONVERT 0 to bytes32\\nTMP_221(bool) = TMP_219 == TMP_220\\nCONDITION TMP_221\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nnum_stored\\n\\nIRs:\\nRETURN num_stored\\\"];\\n}\\n// Function: 66.sol-Contract-storing()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\naction_req = STORES\\n\\nIRs:\\naction_req(bytes4) := STORES(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validStoreBuff,isStoring)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreBuff,isStoring)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreBuff,isStoring)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreBuff,isStoring)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreBuff,isStoring)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreBuff,isStoring)\\\"];\\n7->1;\\n}\\n// Function: 66.sol-Contract-to(bytes32,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nto(_field,bytes32(_val))\\n\\nIRs:\\nTMP_143 = CONVERT _val to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_143)\\\"];\\n}\\n// Function: 66.sol-Contract-to(bytes32,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_val\\n\\nIRs:\\nCONDITION _val\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nto(_field,bytes32(1))\\n\\nIRs:\\nTMP_145 = CONVERT 1 to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_145)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nto(_field,bytes32(0))\\n\\nIRs:\\nTMP_147 = CONVERT 0 to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_147)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n}\\n// Function: 66.sol-Contract-to(bytes32,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n6->1;\\n}\\n// Function: 66.sol-Contract-to(bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nto(_field,bytes32(_val))\\n\\nIRs:\\nTMP_141 = CONVERT _val to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_141)\\\"];\\n}\\n// Function: 66.sol-Contract-toAcc(uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validPayDest,validPayAmt)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayDest,validPayAmt)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validPayDest,validPayAmt)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayDest,validPayAmt)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validPayDest,validPayAmt)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayDest,validPayAmt)\\\"];\\n6->1;\\n}\\n// Function: 66.sol-Contract-validEmitBuff()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_75(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_76 = CONVERT 0 to bytes32\\nTMP_77(bool) = TMP_75 == TMP_76\\nCONDITION TMP_77\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstartBuffer()\\n\\nIRs:\\nINTERNAL_CALL, Contract.startBuffer()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nemitted() != 0 || currentAction() == EMITS\\n\\nIRs:\\nTMP_79(uint256) = INTERNAL_CALL, Contract.emitted()()\\nTMP_80(bool) = TMP_79 != 0\\nTMP_81(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_82(bool) = TMP_81 == EMITS\\nTMP_83(bool) = TMP_80 || TMP_82\\nCONDITION TMP_83\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Duplicate request - emits)\\n\\nIRs:\\nTMP_84(None) = SOLIDITY_CALL revert(string)(Duplicate request - emits)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 66.sol-Contract-validEvent()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.EMIT_LOG\\n\\nIRs:\\nTMP_125(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_6(Contract.NextFunction) -> NextFunction.EMIT_LOG\\nTMP_126(bool) = TMP_125 != REF_6\\nCONDITION TMP_126\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected event to be pushed)\\n\\nIRs:\\nTMP_127(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected event to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisEmitting()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isEmitting()()\\\"];\\n}\\n// Function: 66.sol-Contract-validPayAmt()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.PAY_AMT\\n\\nIRs:\\nTMP_121(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_5(Contract.NextFunction) -> NextFunction.PAY_AMT\\nTMP_122(bool) = TMP_121 != REF_5\\nCONDITION TMP_122\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected payment amount to be pushed)\\n\\nIRs:\\nTMP_123(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected payment amount to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisPaying()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isPaying()()\\\"];\\n}\\n// Function: 66.sol-Contract-validPayBuff()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_85(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_86 = CONVERT 0 to bytes32\\nTMP_87(bool) = TMP_85 == TMP_86\\nCONDITION TMP_87\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstartBuffer()\\n\\nIRs:\\nINTERNAL_CALL, Contract.startBuffer()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\npaid() != 0 || currentAction() == PAYS\\n\\nIRs:\\nTMP_89(uint256) = INTERNAL_CALL, Contract.paid()()\\nTMP_90(bool) = TMP_89 != 0\\nTMP_91(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_92(bool) = TMP_91 == PAYS\\nTMP_93(bool) = TMP_90 || TMP_92\\nCONDITION TMP_93\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Duplicate request - pays)\\n\\nIRs:\\nTMP_94(None) = SOLIDITY_CALL revert(string)(Duplicate request - pays)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 66.sol-Contract-validPayDest()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.PAY_DEST\\n\\nIRs:\\nTMP_117(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_4(Contract.NextFunction) -> NextFunction.PAY_DEST\\nTMP_118(bool) = TMP_117 != REF_4\\nCONDITION TMP_118\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected payment destination to be pushed)\\n\\nIRs:\\nTMP_119(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected payment destination to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisPaying()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isPaying()()\\\"];\\n}\\n// Function: 66.sol-Contract-validState()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nfreeMem() < 0x180\\n\\nIRs:\\nTMP_35(bytes32) = INTERNAL_CALL, Contract.freeMem()()\\nTMP_36(bool) = TMP_35 < 384\\nCONDITION TMP_36\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Expected Contract.execute())\\n\\nIRs:\\nTMP_37(None) = SOLIDITY_CALL revert(string)(Expected Contract.execute())\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nbuffPtr() != 0 && buffPtr() < 0x180\\n\\nIRs:\\nTMP_38(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_39(bool) = TMP_38 != 0\\nTMP_40(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_41(bool) = TMP_40 < 384\\nTMP_42(bool) = TMP_39 && TMP_41\\nCONDITION TMP_42\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Invalid buffer pointer)\\n\\nIRs:\\nTMP_43(None) = SOLIDITY_CALL revert(string)(Invalid buffer pointer)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nassert(bool)(execID() != bytes32(0) && sender() != address(0))\\n\\nIRs:\\nTMP_44(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_45 = CONVERT 0 to bytes32\\nTMP_46(bool) = TMP_44 != TMP_45\\nTMP_47(address) = INTERNAL_CALL, Contract.sender()()\\nTMP_48 = CONVERT 0 to address\\nTMP_49(bool) = TMP_47 != TMP_48\\nTMP_50(bool) = TMP_46 && TMP_49\\nTMP_51(None) = SOLIDITY_CALL assert(bool)(TMP_50)\\\"];\\n}\\n// Function: 66.sol-Contract-validStoreBuff()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_65(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_66 = CONVERT 0 to bytes32\\nTMP_67(bool) = TMP_65 == TMP_66\\nCONDITION TMP_67\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstartBuffer()\\n\\nIRs:\\nINTERNAL_CALL, Contract.startBuffer()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nstored() != 0 || currentAction() == STORES\\n\\nIRs:\\nTMP_69(uint256) = INTERNAL_CALL, Contract.stored()()\\nTMP_70(bool) = TMP_69 != 0\\nTMP_71(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_72(bool) = TMP_71 == STORES\\nTMP_73(bool) = TMP_70 || TMP_72\\nCONDITION TMP_73\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Duplicate request - stores)\\n\\nIRs:\\nTMP_74(None) = SOLIDITY_CALL revert(string)(Duplicate request - stores)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 66.sol-Contract-validStoreDest()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.STORE_DEST\\n\\nIRs:\\nTMP_103(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_0(Contract.NextFunction) -> NextFunction.STORE_DEST\\nTMP_104(bool) = TMP_103 != REF_0\\nCONDITION TMP_104\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected storage destination to be pushed)\\n\\nIRs:\\nTMP_105(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected storage destination to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisStoring()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isStoring()()\\\"];\\n}\\n// Function: 66.sol-Contract-validStoreVal()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.VAL_SET && expected() != NextFunction.VAL_INC && expected() != NextFunction.VAL_DEC\\n\\nIRs:\\nTMP_107(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_1(Contract.NextFunction) -> NextFunction.VAL_SET\\nTMP_108(bool) = TMP_107 != REF_1\\nTMP_109(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_2(Contract.NextFunction) -> NextFunction.VAL_INC\\nTMP_110(bool) = TMP_109 != REF_2\\nTMP_111(bool) = TMP_108 && TMP_110\\nTMP_112(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_3(Contract.NextFunction) -> NextFunction.VAL_DEC\\nTMP_113(bool) = TMP_112 != REF_3\\nTMP_114(bool) = TMP_111 && TMP_113\\nCONDITION TMP_114\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected storage value to be pushed)\\n\\nIRs:\\nTMP_115(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected storage value to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisStoring()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isStoring()()\\\"];\\n}\\n// Function: 66.sol-ManageSale-CONFIGURE(bytes32,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n(CROWDSALE_CONFIGURED,_exec_id,_name)\\n\\nIRs:\\nRETURN CROWDSALE_CONFIGURED,_exec_id,_name\\\"];\\n}\\n// Function: 66.sol-ManageSale-FINALIZE(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n(CROWDSALE_FINALIZED,_exec_id)\\n\\nIRs:\\nRETURN CROWDSALE_FINALIZED,_exec_id\\\"];\\n}\\n// Function: 66.sol-ManageSale-finalizeCrowdsale()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nContract.read(SaleManager.isConfigured()) == 0\\n\\nIRs:\\nTMP_254(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.isConfigured(), arguments:[] \\nTMP_255(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_254'] \\nTMP_256(bool) = TMP_255 == 0\\nCONDITION TMP_256\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(crowdsale has not been configured)\\n\\nIRs:\\nTMP_257(None) = SOLIDITY_CALL revert(string)(crowdsale has not been configured)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nContract.storing()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.storing(), arguments:[] \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.set(SaleManager.isFinished()).to(true)\\n\\nIRs:\\nTMP_259(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.isFinished(), arguments:[] \\nTMP_260(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_259'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bool), arguments:['TMP_260', 'True'] \\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nContract.emitting()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.emitting(), arguments:[] \\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nContract.log(FINALIZE(Contract.execID()),bytes32(0))\\n\\nIRs:\\nTMP_263(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.execID(), arguments:[] \\nTMP_264(bytes32[2]) = INTERNAL_CALL, ManageSale.FINALIZE(bytes32)(TMP_263)\\nTMP_265 = CONVERT 0 to bytes32\\nLIBRARY_CALL, dest:Contract, function:Contract.log(bytes32[2],bytes32), arguments:['TMP_264', 'TMP_265'] \\\"];\\n}\\n// Function: 66.sol-ManageSale-initializeCrowdsale()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nstart_time = uint256(Contract.read(SaleManager.startTime()))\\n\\nIRs:\\nTMP_236(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.startTime(), arguments:[] \\nTMP_237(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_236'] \\nTMP_238 = CONVERT TMP_237 to uint256\\nstart_time(uint256) := TMP_238(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ntoken_name = Contract.read(SaleManager.tokenName())\\n\\nIRs:\\nTMP_239(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.tokenName(), arguments:[] \\nTMP_240(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_239'] \\ntoken_name(bytes32) := TMP_240(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nstart_time < now\\n\\nIRs:\\nTMP_241(bool) = start_time < now\\nCONDITION TMP_241\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nrevert(string)(crowdsale already started)\\n\\nIRs:\\nTMP_242(None) = SOLIDITY_CALL revert(string)(crowdsale already started)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: IF 6\\n\\nEXPRESSION:\\ntoken_name == 0\\n\\nIRs:\\nTMP_243(bool) = token_name == 0\\nCONDITION TMP_243\\\"];\\n6->7[label=\\\"True\\\"];\\n6->8[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrevert(string)(token not init)\\n\\nIRs:\\nTMP_244(None) = SOLIDITY_CALL revert(string)(token not init)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nContract.storing()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.storing(), arguments:[] \\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nContract.set(SaleManager.isConfigured()).to(true)\\n\\nIRs:\\nTMP_246(bytes32) = LIBRARY_CALL, dest:SaleManager, function:SaleManager.isConfigured(), arguments:[] \\nTMP_247(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_246'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bool), arguments:['TMP_247', 'True'] \\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nContract.emitting()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.emitting(), arguments:[] \\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nContract.log(CONFIGURE(Contract.execID(),token_name),bytes32(start_time))\\n\\nIRs:\\nTMP_250(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.execID(), arguments:[] \\nTMP_251(bytes32[3]) = INTERNAL_CALL, ManageSale.CONFIGURE(bytes32,bytes32)(TMP_250,token_name)\\nTMP_252 = CONVERT start_time to bytes32\\nLIBRARY_CALL, dest:Contract, function:Contract.log(bytes32[3],bytes32), arguments:['TMP_251', 'TMP_252'] \\\"];\\n}\\n// Function: 66.sol-ManageSale-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nCROWDSALE_CONFIGURED = keccak256()(CrowdsaleConfigured(bytes32,bytes32,uint256))\\n\\nIRs:\\nTMP_267(bytes32) = SOLIDITY_CALL keccak256()(CrowdsaleConfigured(bytes32,bytes32,uint256))\\nCROWDSALE_CONFIGURED(bytes32) := TMP_267(bytes32)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nCROWDSALE_FINALIZED = keccak256()(CrowdsaleFinalized(bytes32))\\n\\nIRs:\\nTMP_268(bytes32) = SOLIDITY_CALL keccak256()(CrowdsaleFinalized(bytes32))\\nCROWDSALE_FINALIZED(bytes32) := TMP_268(bytes32)\\\"];\\n}\\n// Function: 66.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(c >= a,Overflow - Addition)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL require(bool,string)(TMP_10,Overflow - Addition)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 66.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 66.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool,string)(c / a == b,Overflow - Multiplication)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL require(bool,string)(TMP_3,Overflow - Multiplication)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 66.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(b <= a,Underflow - Subtraction)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL require(bool,string)(TMP_6,Underflow - Subtraction)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n// Function: 66.sol-SaleManager-admin()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_admin)\\n\\nIRs:\\nTMP_463(bytes32) = SOLIDITY_CALL keccak256()(sale_admin)\\nRETURN TMP_463\\\"];\\n}\\n// Function: 66.sol-SaleManager-balances(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_owner,TOKEN_BALANCES)\\n\\nIRs:\\nTMP_494(bytes32) = SOLIDITY_CALL keccak256()(_owner,TOKEN_BALANCES)\\nRETURN TMP_494\\\"];\\n}\\n// Function: 66.sol-SaleManager-createCrowdsaleTiers(bytes32[],uint256[],uint256[],uint256[],uint256[],bool[],bool[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nContract.authorize(msg.sender)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.authorize(address), arguments:['msg.sender'] \\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nContract.checks(onlyAdminAndNotInit)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyAdminAndNotInit'] \\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nConfigureSale.createCrowdsaleTiers(_tier_names,_tier_durations,_tier_prices,_tier_caps,_tier_minimums,_tier_modifiable,_tier_whitelisted)\\n\\nIRs:\\nLIBRARY_CALL, dest:ConfigureSale, function:ConfigureSale.createCrowdsaleTiers(bytes32[],uint256[],uint256[],uint256[],uint256[],bool[],bool[]), arguments:['_tier_names', '_tier_durations', '_tier_prices', '_tier_caps', '_tier_minimums', '_tier_modifiable', '_tier_whitelisted'] \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nContract.checks(emitAndStore)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['emitAndStore'] \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.commit()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.commit(), arguments:[] \\\"];\\n}\\n// Function: 66.sol-SaleManager-currentEndsAt()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(current_tier_ends_at)\\n\\nIRs:\\nTMP_484(bytes32) = SOLIDITY_CALL keccak256()(current_tier_ends_at)\\nRETURN TMP_484\\\"];\\n}\\n// Function: 66.sol-SaleManager-currentTier()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_current_tier)\\n\\nIRs:\\nTMP_483(bytes32) = SOLIDITY_CALL keccak256()(sale_current_tier)\\nRETURN TMP_483\\\"];\\n}\\n// Function: 66.sol-SaleManager-emitAndStore()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nContract.emitted() == 0 || Contract.stored() == 0\\n\\nIRs:\\nTMP_522(uint256) = LIBRARY_CALL, dest:Contract, function:Contract.emitted(), arguments:[] \\nTMP_523(bool) = TMP_522 == 0\\nTMP_524(uint256) = LIBRARY_CALL, dest:Contract, function:Contract.stored(), arguments:[] \\nTMP_525(bool) = TMP_524 == 0\\nTMP_526(bool) = TMP_523 || TMP_525\\nCONDITION TMP_526\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(invalid state change)\\n\\nIRs:\\nTMP_527(None) = SOLIDITY_CALL revert(string)(invalid state change)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 66.sol-SaleManager-finalizeCrowdsale()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nContract.authorize(msg.sender)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.authorize(address), arguments:['msg.sender'] \\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nContract.checks(onlyAdminAndNotFinal)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyAdminAndNotFinal'] \\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nManageSale.finalizeCrowdsale()\\n\\nIRs:\\nLIBRARY_CALL, dest:ManageSale, function:ManageSale.finalizeCrowdsale(), arguments:[] \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nContract.checks(emitAndStore)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['emitAndStore'] \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.commit()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.commit(), arguments:[] \\\"];\\n}\\n// Function: 66.sol-SaleManager-initializeCrowdsale()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nContract.authorize(msg.sender)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.authorize(address), arguments:['msg.sender'] \\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nContract.checks(onlyAdminAndNotInit)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyAdminAndNotInit'] \\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nManageSale.initializeCrowdsale()\\n\\nIRs:\\nLIBRARY_CALL, dest:ManageSale, function:ManageSale.initializeCrowdsale(), arguments:[] \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nContract.checks(emitAndStore)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['emitAndStore'] \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.commit()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.commit(), arguments:[] \\\"];\\n}\\n// Function: 66.sol-SaleManager-isConfigured()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_is_configured)\\n\\nIRs:\\nTMP_464(bytes32) = SOLIDITY_CALL keccak256()(sale_is_configured)\\nRETURN TMP_464\\\"];\\n}\\n// Function: 66.sol-SaleManager-isFinished()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_is_completed)\\n\\nIRs:\\nTMP_465(bytes32) = SOLIDITY_CALL keccak256()(sale_is_completed)\\nRETURN TMP_465\\\"];\\n}\\n// Function: 66.sol-SaleManager-onlyAdmin()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\naddress(Contract.read(admin())) != Contract.sender()\\n\\nIRs:\\nTMP_516(bytes32) = INTERNAL_CALL, SaleManager.admin()()\\nTMP_517(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_516'] \\nTMP_518 = CONVERT TMP_517 to address\\nTMP_519(address) = LIBRARY_CALL, dest:Contract, function:Contract.sender(), arguments:[] \\nTMP_520(bool) = TMP_518 != TMP_519\\nCONDITION TMP_520\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(sender is not admin)\\n\\nIRs:\\nTMP_521(None) = SOLIDITY_CALL revert(string)(sender is not admin)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 66.sol-SaleManager-onlyAdminAndNotFinal()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\naddress(Contract.read(admin())) != Contract.sender()\\n\\nIRs:\\nTMP_506(bytes32) = INTERNAL_CALL, SaleManager.admin()()\\nTMP_507(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_506'] \\nTMP_508 = CONVERT TMP_507 to address\\nTMP_509(address) = LIBRARY_CALL, dest:Contract, function:Contract.sender(), arguments:[] \\nTMP_510(bool) = TMP_508 != TMP_509\\nCONDITION TMP_510\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(sender is not admin)\\n\\nIRs:\\nTMP_511(None) = SOLIDITY_CALL revert(string)(sender is not admin)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nContract.read(isFinished()) != 0\\n\\nIRs:\\nTMP_512(bytes32) = INTERNAL_CALL, SaleManager.isFinished()()\\nTMP_513(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_512'] \\nTMP_514(bool) = TMP_513 != 0\\nCONDITION TMP_514\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(sale has already been finalized)\\n\\nIRs:\\nTMP_515(None) = SOLIDITY_CALL revert(string)(sale has already been finalized)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 66.sol-SaleManager-onlyAdminAndNotInit()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\naddress(Contract.read(admin())) != Contract.sender()\\n\\nIRs:\\nTMP_496(bytes32) = INTERNAL_CALL, SaleManager.admin()()\\nTMP_497(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_496'] \\nTMP_498 = CONVERT TMP_497 to address\\nTMP_499(address) = LIBRARY_CALL, dest:Contract, function:Contract.sender(), arguments:[] \\nTMP_500(bool) = TMP_498 != TMP_499\\nCONDITION TMP_500\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(sender is not admin)\\n\\nIRs:\\nTMP_501(None) = SOLIDITY_CALL revert(string)(sender is not admin)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nContract.read(isConfigured()) != 0\\n\\nIRs:\\nTMP_502(bytes32) = INTERNAL_CALL, SaleManager.isConfigured()()\\nTMP_503(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.read(bytes32), arguments:['TMP_502'] \\nTMP_504(bool) = TMP_503 != 0\\nCONDITION TMP_504\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(sale has already been configured)\\n\\nIRs:\\nTMP_505(None) = SOLIDITY_CALL revert(string)(sale has already been configured)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 66.sol-SaleManager-onlyStores()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nContract.paid() != 0 || Contract.emitted() != 0\\n\\nIRs:\\nTMP_528(uint256) = LIBRARY_CALL, dest:Contract, function:Contract.paid(), arguments:[] \\nTMP_529(bool) = TMP_528 != 0\\nTMP_530(uint256) = LIBRARY_CALL, dest:Contract, function:Contract.emitted(), arguments:[] \\nTMP_531(bool) = TMP_530 != 0\\nTMP_532(bool) = TMP_529 || TMP_531\\nCONDITION TMP_532\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(expected only storage)\\n\\nIRs:\\nTMP_533(None) = SOLIDITY_CALL revert(string)(expected only storage)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nContract.stored() == 0\\n\\nIRs:\\nTMP_534(uint256) = LIBRARY_CALL, dest:Contract, function:Contract.stored(), arguments:[] \\nTMP_535(bool) = TMP_534 == 0\\nCONDITION TMP_535\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(expected storage)\\n\\nIRs:\\nTMP_536(None) = SOLIDITY_CALL revert(string)(expected storage)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 66.sol-SaleManager-saleTierList()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_tier_list)\\n\\nIRs:\\nTMP_468(bytes32) = SOLIDITY_CALL keccak256()(sale_tier_list)\\nRETURN TMP_468\\\"];\\n}\\n// Function: 66.sol-SaleManager-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nTOKEN_BALANCES = keccak256()(token_balances)\\n\\nIRs:\\nTMP_567(bytes32) = SOLIDITY_CALL keccak256()(token_balances)\\nTOKEN_BALANCES(bytes32) := TMP_567(bytes32)\\\"];\\n}\\n// Function: 66.sol-SaleManager-startTime()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_start_time)\\n\\nIRs:\\nTMP_466(bytes32) = SOLIDITY_CALL keccak256()(sale_start_time)\\nRETURN TMP_466\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierCap(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,cap,saleTierList())\\n\\nIRs:\\nTMP_471(bytes32) = INTERNAL_CALL, SaleManager.saleTierList()()\\nTMP_472(bytes32) = SOLIDITY_CALL keccak256()(_idx,cap,TMP_471)\\nRETURN TMP_472\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierDuration(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,duration,saleTierList())\\n\\nIRs:\\nTMP_477(bytes32) = INTERNAL_CALL, SaleManager.saleTierList()()\\nTMP_478(bytes32) = SOLIDITY_CALL keccak256()(_idx,duration,TMP_477)\\nRETURN TMP_478\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierMin(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,minimum,saleTierList())\\n\\nIRs:\\nTMP_475(bytes32) = INTERNAL_CALL, SaleManager.saleTierList()()\\nTMP_476(bytes32) = SOLIDITY_CALL keccak256()(_idx,minimum,TMP_475)\\nRETURN TMP_476\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierModifiable(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,mod_stat,saleTierList())\\n\\nIRs:\\nTMP_479(bytes32) = INTERNAL_CALL, SaleManager.saleTierList()()\\nTMP_480(bytes32) = SOLIDITY_CALL keccak256()(_idx,mod_stat,TMP_479)\\nRETURN TMP_480\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierName(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,name,saleTierList())\\n\\nIRs:\\nTMP_469(bytes32) = INTERNAL_CALL, SaleManager.saleTierList()()\\nTMP_470(bytes32) = SOLIDITY_CALL keccak256()(_idx,name,TMP_469)\\nRETURN TMP_470\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierPrice(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,price,saleTierList())\\n\\nIRs:\\nTMP_473(bytes32) = INTERNAL_CALL, SaleManager.saleTierList()()\\nTMP_474(bytes32) = SOLIDITY_CALL keccak256()(_idx,price,TMP_473)\\nRETURN TMP_474\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierWhitelist(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,tier_whitelists)\\n\\nIRs:\\nTMP_485(bytes32) = SOLIDITY_CALL keccak256()(_idx,tier_whitelists)\\nRETURN TMP_485\\\"];\\n}\\n// Function: 66.sol-SaleManager-tierWhitelisted(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,wl_stat,saleTierList())\\n\\nIRs:\\nTMP_481(bytes32) = INTERNAL_CALL, SaleManager.saleTierList()()\\nTMP_482(bytes32) = SOLIDITY_CALL keccak256()(_idx,wl_stat,TMP_481)\\nRETURN TMP_482\\\"];\\n}\\n// Function: 66.sol-SaleManager-tokenDecimals()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_decimals)\\n\\nIRs:\\nTMP_492(bytes32) = SOLIDITY_CALL keccak256()(token_decimals)\\nRETURN TMP_492\\\"];\\n}\\n// Function: 66.sol-SaleManager-tokenName()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_name)\\n\\nIRs:\\nTMP_490(bytes32) = SOLIDITY_CALL keccak256()(token_name)\\nRETURN TMP_490\\\"];\\n}\\n// Function: 66.sol-SaleManager-tokenSymbol()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_symbol)\\n\\nIRs:\\nTMP_491(bytes32) = SOLIDITY_CALL keccak256()(token_symbol)\\nRETURN TMP_491\\\"];\\n}\\n// Function: 66.sol-SaleManager-tokenTotalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_total_supply)\\n\\nIRs:\\nTMP_493(bytes32) = SOLIDITY_CALL keccak256()(token_total_supply)\\nRETURN TMP_493\\\"];\\n}\\n// Function: 66.sol-SaleManager-tokensUnlocked()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_tokens_unlocked)\\n\\nIRs:\\nTMP_495(bytes32) = SOLIDITY_CALL keccak256()(sale_tokens_unlocked)\\nRETURN TMP_495\\\"];\\n}\\n// Function: 66.sol-SaleManager-totalDuration()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_total_duration)\\n\\nIRs:\\nTMP_467(bytes32) = SOLIDITY_CALL keccak256()(sale_total_duration)\\nRETURN TMP_467\\\"];\\n}\\n// Function: 66.sol-SaleManager-updateTierDuration(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nContract.authorize(msg.sender)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.authorize(address), arguments:['msg.sender'] \\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nContract.checks(onlyAdminAndNotFinal)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyAdminAndNotFinal'] \\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nConfigureSale.updateTierDuration(_tier_index,_new_duration)\\n\\nIRs:\\nLIBRARY_CALL, dest:ConfigureSale, function:ConfigureSale.updateTierDuration(uint256,uint256), arguments:['_tier_index', '_new_duration'] \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nContract.checks(onlyStores)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyStores'] \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.commit()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.commit(), arguments:[] \\\"];\\n}\\n// Function: 66.sol-SaleManager-updateTierMinimum(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nContract.authorize(msg.sender)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.authorize(address), arguments:['msg.sender'] \\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nContract.checks(onlyAdminAndNotFinal)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyAdminAndNotFinal'] \\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nConfigureSale.updateTierMinimum(_tier_index,_new_minimum)\\n\\nIRs:\\nLIBRARY_CALL, dest:ConfigureSale, function:ConfigureSale.updateTierMinimum(uint256,uint256), arguments:['_tier_index', '_new_minimum'] \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nContract.checks(emitAndStore)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['emitAndStore'] \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.commit()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.commit(), arguments:[] \\\"];\\n}\\n// Function: 66.sol-SaleManager-whitelistMaxTok(uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_spender,max_tok,tierWhitelist(_idx))\\n\\nIRs:\\nTMP_486(bytes32) = INTERNAL_CALL, SaleManager.tierWhitelist(uint256)(_idx)\\nTMP_487(bytes32) = SOLIDITY_CALL keccak256()(_spender,max_tok,TMP_486)\\nRETURN TMP_487\\\"];\\n}\\n// Function: 66.sol-SaleManager-whitelistMinTok(uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_spender,min_tok,tierWhitelist(_idx))\\n\\nIRs:\\nTMP_488(bytes32) = INTERNAL_CALL, SaleManager.tierWhitelist(uint256)(_idx)\\nTMP_489(bytes32) = SOLIDITY_CALL keccak256()(_spender,min_tok,TMP_488)\\nRETURN TMP_489\\\"];\\n}\\n// Function: 66.sol-SaleManager-whitelistMultiForTier(uint256,address[],uint256[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nContract.authorize(msg.sender)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.authorize(address), arguments:['msg.sender'] \\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nContract.checks(onlyAdmin)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyAdmin'] \\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nConfigureSale.whitelistMultiForTier(_tier_index,_to_whitelist,_min_token_purchase,_max_purchase_amt)\\n\\nIRs:\\nLIBRARY_CALL, dest:ConfigureSale, function:ConfigureSale.whitelistMultiForTier(uint256,address[],uint256[],uint256[]), arguments:['_tier_index', '_to_whitelist', '_min_token_purchase', '_max_purchase_amt'] \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nContract.checks(onlyStores)\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.checks(function()), arguments:['onlyStores'] \\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.commit()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.commit(), arguments:[] \\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 68.sol-ArrayUtils-toAddressArr(bytes32[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\n_conv\\n\\nIRs:\\nRETURN _conv\\\"];\\n}\\n// Function: 68.sol-ArrayUtils-toBytes4Arr(bytes32[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\n_conv\\n\\nIRs:\\nRETURN _conv\\\"];\\n}\\n// Function: 68.sol-ArrayUtils-toUintArr(bytes32[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\n_conv\\n\\nIRs:\\nRETURN _conv\\\"];\\n}\\n// Function: 68.sol-Contract-authorize(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ninitialize()\\n\\nIRs:\\nINTERNAL_CALL, Contract.initialize()()\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nperms = EXEC_PERMISSIONS\\n\\nIRs:\\nperms(bytes32) := EXEC_PERMISSIONS(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: IF 6\\n\\nEXPRESSION:\\n! authorized\\n\\nIRs:\\nTMP_13 = UnaryType.BANG authorized \\nCONDITION TMP_13\\\"];\\n6->7[label=\\\"True\\\"];\\n6->8[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nrevert(string)(Sender is not authorized as a script exec address)\\n\\nIRs:\\nTMP_14(None) = SOLIDITY_CALL revert(string)(Sender is not authorized as a script exec address)\\\"];\\n7->8;\\n8[label=\\\"Node Type: END_IF 8\\n\\\"];\\n}\\n// Function: 68.sol-Contract-buffPtr()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nptr\\n\\nIRs:\\nRETURN ptr\\\"];\\n}\\n// Function: 68.sol-Contract-by(bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->11;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() == NextFunction.VAL_INC\\n\\nIRs:\\nTMP_161(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_7(Contract.NextFunction) -> NextFunction.VAL_INC\\nTMP_162(bool) = TMP_161 == REF_7\\nCONDITION TMP_162\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\n_amt = _amt.add(uint256(_val))\\n\\nIRs:\\nTMP_163 = CONVERT _val to uint256\\nTMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_amt', 'TMP_163'] \\n_amt(uint256) := TMP_164(uint256)\\\"];\\n2->7;\\n3[label=\\\"Node Type: IF 3\\n\\nEXPRESSION:\\nexpected() == NextFunction.VAL_DEC\\n\\nIRs:\\nTMP_165(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_9(Contract.NextFunction) -> NextFunction.VAL_DEC\\nTMP_166(bool) = TMP_165 == REF_9\\nCONDITION TMP_166\\\"];\\n3->4[label=\\\"True\\\"];\\n3->5[label=\\\"False\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_amt = uint256(_val).sub(_amt)\\n\\nIRs:\\nTMP_167 = CONVERT _val to uint256\\nTMP_168(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_167', '_amt'] \\n_amt(uint256) := TMP_168(uint256)\\\"];\\n4->6;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Expected VAL_INC or VAL_DEC)\\n\\nIRs:\\nTMP_169(None) = SOLIDITY_CALL revert(string)(Expected VAL_INC or VAL_DEC)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: INLINE ASM 8\\n\\\"];\\n8->9;\\n9[label=\\\"Node Type: END INLINE ASM 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n13->1;\\n}\\n// Function: 68.sol-Contract-byMaximum(bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->11;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() == NextFunction.VAL_DEC\\n\\nIRs:\\nTMP_174(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_11(Contract.NextFunction) -> NextFunction.VAL_DEC\\nTMP_175(bool) = TMP_174 == REF_11\\nCONDITION TMP_175\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_amt >= uint256(_val)\\n\\nIRs:\\nTMP_176 = CONVERT _val to uint256\\nTMP_177(bool) = _amt >= TMP_176\\nCONDITION TMP_177\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\n_amt = 0\\n\\nIRs:\\n_amt(uint256) := 0(uint256)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_amt = uint256(_val).sub(_amt)\\n\\nIRs:\\nTMP_178 = CONVERT _val to uint256\\nTMP_179(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_178', '_amt'] \\n_amt(uint256) := TMP_179(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n5->7;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nrevert(string)(Expected VAL_DEC)\\n\\nIRs:\\nTMP_180(None) = SOLIDITY_CALL revert(string)(Expected VAL_DEC)\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: INLINE ASM 8\\n\\\"];\\n8->9;\\n9[label=\\\"Node Type: END INLINE ASM 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n13->1;\\n}\\n// Function: 68.sol-Contract-checks(function())\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_check()\\n\\nIRs:\\nINTERNAL_DYNAMIC_CALL _check()  \\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nconditions(validState,validState)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,validState)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nconditions(validState,validState)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,validState)\\\"];\\n3->1;\\n}\\n// Function: 68.sol-Contract-commit()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nptr = buffPtr()\\n\\nIRs:\\nTMP_29(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nptr(bytes32) := TMP_29(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(ptr >= 0x180,Invalid buffer pointer)\\n\\nIRs:\\nTMP_30(bool) = ptr >= 384\\nTMP_31(None) = SOLIDITY_CALL require(bool,string)(TMP_30,Invalid buffer pointer)\\\"];\\n2->3;\\n3[label=\\\"Node Type: INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: END INLINE ASM 4\\n\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validState,none)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,none)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validState,none)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,none)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validState,none)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validState,none)\\\"];\\n7->1;\\n}\\n// Function: 68.sol-Contract-conditions(function(),function())\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nfirst()\\n\\nIRs:\\nINTERNAL_DYNAMIC_CALL first()  \\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nlast()\\n\\nIRs:\\nINTERNAL_DYNAMIC_CALL last()  \\\"];\\n}\\n// Function: 68.sol-Contract-currentAction()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_52(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_53 = CONVERT 0 to bytes32\\nTMP_54(bool) = TMP_52 == TMP_53\\nCONDITION TMP_54\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbytes4(0)\\n\\nIRs:\\nTMP_55 = CONVERT 0 to bytes4\\nRETURN TMP_55\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\naction\\n\\nIRs:\\nRETURN action\\\"];\\n}\\n// Function: 68.sol-Contract-decrease(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nval = keccak256()(_field,execID())\\n\\nIRs:\\nTMP_155(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_156(bytes32) = SOLIDITY_CALL keccak256()(_field,TMP_155)\\nval(bytes32) := TMP_156(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n8->1;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n}\\n// Function: 68.sol-Contract-emitted()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_216(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_217 = CONVERT 0 to bytes32\\nTMP_218(bool) = TMP_216 == TMP_217\\nCONDITION TMP_218\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nnum_emitted\\n\\nIRs:\\nRETURN num_emitted\\\"];\\n}\\n// Function: 68.sol-Contract-emitting()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\naction_req = EMITS\\n\\nIRs:\\naction_req(bytes4) := EMITS(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEmitBuff,isEmitting)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEmitBuff,isEmitting)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validEmitBuff,isEmitting)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEmitBuff,isEmitting)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validEmitBuff,isEmitting)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEmitBuff,isEmitting)\\\"];\\n7->1;\\n}\\n// Function: 68.sol-Contract-execID()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool,string)(exec_id != bytes32(0),Execution id overwritten, or not read)\\n\\nIRs:\\nTMP_95 = CONVERT 0 to bytes32\\nTMP_96(bool) = exec_id != TMP_95\\nTMP_97(None) = SOLIDITY_CALL require(bool,string)(TMP_96,Execution id overwritten, or not read)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nexec_id\\n\\nIRs:\\nRETURN exec_id\\\"];\\n}\\n// Function: 68.sol-Contract-expected()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nnext\\n\\nIRs:\\nRETURN next\\\"];\\n}\\n// Function: 68.sol-Contract-freeMem()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nptr\\n\\nIRs:\\nRETURN ptr\\\"];\\n}\\n// Function: 68.sol-Contract-increase(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nval = keccak256()(_field,execID())\\n\\nIRs:\\nTMP_149(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_150(bytes32) = SOLIDITY_CALL keccak256()(_field,TMP_149)\\nval(bytes32) := TMP_150(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n8->1;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nval\\n\\nIRs:\\nRETURN val\\\"];\\n}\\n// Function: 68.sol-Contract-initialize()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(freeMem() == 0x80,Memory allocated prior to execution)\\n\\nIRs:\\nTMP_15(bytes32) = INTERNAL_CALL, Contract.freeMem()()\\nTMP_16(bool) = TMP_15 == 128\\nTMP_17(None) = SOLIDITY_CALL require(bool,string)(TMP_16,Memory allocated prior to execution)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nassert(bool)(execID() != bytes32(0) && sender() != address(0))\\n\\nIRs:\\nTMP_18(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_19 = CONVERT 0 to bytes32\\nTMP_20(bool) = TMP_18 != TMP_19\\nTMP_21(address) = INTERNAL_CALL, Contract.sender()()\\nTMP_22 = CONVERT 0 to address\\nTMP_23(bool) = TMP_21 != TMP_22\\nTMP_24(bool) = TMP_20 && TMP_23\\nTMP_25(None) = SOLIDITY_CALL assert(bool)(TMP_24)\\\"];\\n}\\n// Function: 68.sol-Contract-isEmitting()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncurrentAction() != EMITS\\n\\nIRs:\\nTMP_59(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_60(bool) = TMP_59 != EMITS\\nCONDITION TMP_60\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Invalid current action - expected EMITS)\\n\\nIRs:\\nTMP_61(None) = SOLIDITY_CALL revert(string)(Invalid current action - expected EMITS)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 68.sol-Contract-isPaying()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncurrentAction() != PAYS\\n\\nIRs:\\nTMP_62(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_63(bool) = TMP_62 != PAYS\\nCONDITION TMP_63\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Invalid current action - expected PAYS)\\n\\nIRs:\\nTMP_64(None) = SOLIDITY_CALL revert(string)(Invalid current action - expected PAYS)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 68.sol-Contract-isStoring()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ncurrentAction() != STORES\\n\\nIRs:\\nTMP_56(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_57(bool) = TMP_56 != STORES\\nCONDITION TMP_57\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Invalid current action - expected STORES)\\n\\nIRs:\\nTMP_58(None) = SOLIDITY_CALL revert(string)(Invalid current action - expected STORES)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n}\\n// Function: 68.sol-Contract-log(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 68.sol-Contract-log(bytes32[1],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 68.sol-Contract-log(bytes32[2],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 68.sol-Contract-log(bytes32[3],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 68.sol-Contract-log(bytes32[4],bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validEvent,validEvent)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validEvent,validEvent)\\\"];\\n5->1;\\n}\\n// Function: 68.sol-Contract-none()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n}\\n// Function: 68.sol-Contract-paid()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_222(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_223 = CONVERT 0 to bytes32\\nTMP_224(bool) = TMP_222 == TMP_223\\nCONDITION TMP_224\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nnum_paid\\n\\nIRs:\\nRETURN num_paid\\\"];\\n}\\n// Function: 68.sol-Contract-pay(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n_amount\\n\\nIRs:\\nRETURN _amount\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validPayAmt,validPayDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayAmt,validPayDest)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validPayAmt,validPayDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayAmt,validPayDest)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validPayAmt,validPayDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayAmt,validPayDest)\\\"];\\n7->1;\\n}\\n// Function: 68.sol-Contract-paying()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\naction_req = PAYS\\n\\nIRs:\\naction_req(bytes4) := PAYS(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validPayBuff,isPaying)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayBuff,isPaying)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validPayBuff,isPaying)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayBuff,isPaying)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validPayBuff,isPaying)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayBuff,isPaying)\\\"];\\n7->1;\\n}\\n// Function: 68.sol-Contract-read(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndata = keccak256()(_location,execID())\\n\\nIRs:\\nTMP_101(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_102(bytes32) = SOLIDITY_CALL keccak256()(_location,TMP_101)\\ndata(bytes32) := TMP_102(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ndata\\n\\nIRs:\\nRETURN data\\\"];\\n}\\n// Function: 68.sol-Contract-sender()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool,string)(addr != address(0),Sender address overwritten, or not read)\\n\\nIRs:\\nTMP_98 = CONVERT 0 to address\\nTMP_99(bool) = addr != TMP_98\\nTMP_100(None) = SOLIDITY_CALL require(bool,string)(TMP_99,Sender address overwritten, or not read)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\naddr\\n\\nIRs:\\nRETURN addr\\\"];\\n}\\n// Function: 68.sol-Contract-set(bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n_field\\n\\nIRs:\\nRETURN _field\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreDest,validStoreVal)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreDest,validStoreVal)\\\"];\\n7->1;\\n}\\n// Function: 68.sol-Contract-setFreeMem()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n}\\n// Function: 68.sol-Contract-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nEXEC_PERMISSIONS = keccak256()(script_exec_permissions)\\n\\nIRs:\\nTMP_225(bytes32) = SOLIDITY_CALL keccak256()(script_exec_permissions)\\nEXEC_PERMISSIONS(bytes32) := TMP_225(bytes32)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nEMITS = bytes4(keccak256()(Emit((bytes32[],bytes)[])))\\n\\nIRs:\\nTMP_226(bytes32) = SOLIDITY_CALL keccak256()(Emit((bytes32[],bytes)[]))\\nTMP_227 = CONVERT TMP_226 to bytes4\\nEMITS(bytes4) := TMP_227(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nSTORES = bytes4(keccak256()(Store(bytes32[])))\\n\\nIRs:\\nTMP_228(bytes32) = SOLIDITY_CALL keccak256()(Store(bytes32[]))\\nTMP_229 = CONVERT TMP_228 to bytes4\\nSTORES(bytes4) := TMP_229(bytes4)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nPAYS = bytes4(keccak256()(Pay(bytes32[])))\\n\\nIRs:\\nTMP_230(bytes32) = SOLIDITY_CALL keccak256()(Pay(bytes32[]))\\nTMP_231 = CONVERT TMP_230 to bytes4\\nPAYS(bytes4) := TMP_231(bytes4)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nTHROWS = bytes4(keccak256()(Error(string)))\\n\\nIRs:\\nTMP_232(bytes32) = SOLIDITY_CALL keccak256()(Error(string))\\nTMP_233 = CONVERT TMP_232 to bytes4\\nTHROWS(bytes4) := TMP_233(bytes4)\\\"];\\n}\\n// Function: 68.sol-Contract-startBuffer()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n}\\n// Function: 68.sol-Contract-stored()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_219(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_220 = CONVERT 0 to bytes32\\nTMP_221(bool) = TMP_219 == TMP_220\\nCONDITION TMP_221\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: INLINE ASM 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: END INLINE ASM 5\\n\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nnum_stored\\n\\nIRs:\\nRETURN num_stored\\\"];\\n}\\n// Function: 68.sol-Contract-storing()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\naction_req = STORES\\n\\nIRs:\\naction_req(bytes4) := STORES(bytes4)\\\"];\\n1->2;\\n2[label=\\\"Node Type: INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: END INLINE ASM 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validStoreBuff,isStoring)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreBuff,isStoring)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreBuff,isStoring)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreBuff,isStoring)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nconditions(validStoreBuff,isStoring)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreBuff,isStoring)\\\"];\\n7->1;\\n}\\n// Function: 68.sol-Contract-to(bytes32,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nto(_field,bytes32(_val))\\n\\nIRs:\\nTMP_143 = CONVERT _val to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_143)\\\"];\\n}\\n// Function: 68.sol-Contract-to(bytes32,bool)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_val\\n\\nIRs:\\nCONDITION _val\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nto(_field,bytes32(1))\\n\\nIRs:\\nTMP_145 = CONVERT 1 to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_145)\\\"];\\n3->5;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nto(_field,bytes32(0))\\n\\nIRs:\\nTMP_147 = CONVERT 0 to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_147)\\\"];\\n4->5;\\n5[label=\\\"Node Type: END_IF 5\\n\\\"];\\n}\\n// Function: 68.sol-Contract-to(bytes32,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validStoreVal,validStoreDest)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validStoreVal,validStoreDest)\\\"];\\n6->1;\\n}\\n// Function: 68.sol-Contract-to(bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nto(_field,bytes32(_val))\\n\\nIRs:\\nTMP_141 = CONVERT _val to bytes32\\nINTERNAL_CALL, Contract.to(bytes32,bytes32)(_field,TMP_141)\\\"];\\n}\\n// Function: 68.sol-Contract-toAcc(uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: INLINE ASM 1\\n\\\"];\\n1->2;\\n2[label=\\\"Node Type: END INLINE ASM 2\\n\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nsetFreeMem()\\n\\nIRs:\\nINTERNAL_CALL, Contract.setFreeMem()()\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nconditions(validPayDest,validPayAmt)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayDest,validPayAmt)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nconditions(validPayDest,validPayAmt)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayDest,validPayAmt)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nconditions(validPayDest,validPayAmt)\\n\\nIRs:\\nMODIFIER_CALL, Contract.conditions(function(),function())(validPayDest,validPayAmt)\\\"];\\n6->1;\\n}\\n// Function: 68.sol-Contract-validEmitBuff()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_75(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_76 = CONVERT 0 to bytes32\\nTMP_77(bool) = TMP_75 == TMP_76\\nCONDITION TMP_77\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstartBuffer()\\n\\nIRs:\\nINTERNAL_CALL, Contract.startBuffer()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nemitted() != 0 || currentAction() == EMITS\\n\\nIRs:\\nTMP_79(uint256) = INTERNAL_CALL, Contract.emitted()()\\nTMP_80(bool) = TMP_79 != 0\\nTMP_81(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_82(bool) = TMP_81 == EMITS\\nTMP_83(bool) = TMP_80 || TMP_82\\nCONDITION TMP_83\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Duplicate request - emits)\\n\\nIRs:\\nTMP_84(None) = SOLIDITY_CALL revert(string)(Duplicate request - emits)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 68.sol-Contract-validEvent()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.EMIT_LOG\\n\\nIRs:\\nTMP_125(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_6(Contract.NextFunction) -> NextFunction.EMIT_LOG\\nTMP_126(bool) = TMP_125 != REF_6\\nCONDITION TMP_126\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected event to be pushed)\\n\\nIRs:\\nTMP_127(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected event to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisEmitting()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isEmitting()()\\\"];\\n}\\n// Function: 68.sol-Contract-validPayAmt()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.PAY_AMT\\n\\nIRs:\\nTMP_121(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_5(Contract.NextFunction) -> NextFunction.PAY_AMT\\nTMP_122(bool) = TMP_121 != REF_5\\nCONDITION TMP_122\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected payment amount to be pushed)\\n\\nIRs:\\nTMP_123(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected payment amount to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisPaying()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isPaying()()\\\"];\\n}\\n// Function: 68.sol-Contract-validPayBuff()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_85(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_86 = CONVERT 0 to bytes32\\nTMP_87(bool) = TMP_85 == TMP_86\\nCONDITION TMP_87\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstartBuffer()\\n\\nIRs:\\nINTERNAL_CALL, Contract.startBuffer()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\npaid() != 0 || currentAction() == PAYS\\n\\nIRs:\\nTMP_89(uint256) = INTERNAL_CALL, Contract.paid()()\\nTMP_90(bool) = TMP_89 != 0\\nTMP_91(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_92(bool) = TMP_91 == PAYS\\nTMP_93(bool) = TMP_90 || TMP_92\\nCONDITION TMP_93\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Duplicate request - pays)\\n\\nIRs:\\nTMP_94(None) = SOLIDITY_CALL revert(string)(Duplicate request - pays)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 68.sol-Contract-validPayDest()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.PAY_DEST\\n\\nIRs:\\nTMP_117(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_4(Contract.NextFunction) -> NextFunction.PAY_DEST\\nTMP_118(bool) = TMP_117 != REF_4\\nCONDITION TMP_118\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected payment destination to be pushed)\\n\\nIRs:\\nTMP_119(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected payment destination to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisPaying()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isPaying()()\\\"];\\n}\\n// Function: 68.sol-Contract-validState()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nfreeMem() < 0x180\\n\\nIRs:\\nTMP_35(bytes32) = INTERNAL_CALL, Contract.freeMem()()\\nTMP_36(bool) = TMP_35 < 384\\nCONDITION TMP_36\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Expected Contract.execute())\\n\\nIRs:\\nTMP_37(None) = SOLIDITY_CALL revert(string)(Expected Contract.execute())\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nbuffPtr() != 0 && buffPtr() < 0x180\\n\\nIRs:\\nTMP_38(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_39(bool) = TMP_38 != 0\\nTMP_40(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_41(bool) = TMP_40 < 384\\nTMP_42(bool) = TMP_39 && TMP_41\\nCONDITION TMP_42\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Invalid buffer pointer)\\n\\nIRs:\\nTMP_43(None) = SOLIDITY_CALL revert(string)(Invalid buffer pointer)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nassert(bool)(execID() != bytes32(0) && sender() != address(0))\\n\\nIRs:\\nTMP_44(bytes32) = INTERNAL_CALL, Contract.execID()()\\nTMP_45 = CONVERT 0 to bytes32\\nTMP_46(bool) = TMP_44 != TMP_45\\nTMP_47(address) = INTERNAL_CALL, Contract.sender()()\\nTMP_48 = CONVERT 0 to address\\nTMP_49(bool) = TMP_47 != TMP_48\\nTMP_50(bool) = TMP_46 && TMP_49\\nTMP_51(None) = SOLIDITY_CALL assert(bool)(TMP_50)\\\"];\\n}\\n// Function: 68.sol-Contract-validStoreBuff()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbuffPtr() == bytes32(0)\\n\\nIRs:\\nTMP_65(bytes32) = INTERNAL_CALL, Contract.buffPtr()()\\nTMP_66 = CONVERT 0 to bytes32\\nTMP_67(bool) = TMP_65 == TMP_66\\nCONDITION TMP_67\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nstartBuffer()\\n\\nIRs:\\nINTERNAL_CALL, Contract.startBuffer()()\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: IF 4\\n\\nEXPRESSION:\\nstored() != 0 || currentAction() == STORES\\n\\nIRs:\\nTMP_69(uint256) = INTERNAL_CALL, Contract.stored()()\\nTMP_70(bool) = TMP_69 != 0\\nTMP_71(bytes4) = INTERNAL_CALL, Contract.currentAction()()\\nTMP_72(bool) = TMP_71 == STORES\\nTMP_73(bool) = TMP_70 || TMP_72\\nCONDITION TMP_73\\\"];\\n4->5[label=\\\"True\\\"];\\n4->6[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrevert(string)(Duplicate request - stores)\\n\\nIRs:\\nTMP_74(None) = SOLIDITY_CALL revert(string)(Duplicate request - stores)\\\"];\\n5->6;\\n6[label=\\\"Node Type: END_IF 6\\n\\\"];\\n}\\n// Function: 68.sol-Contract-validStoreDest()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.STORE_DEST\\n\\nIRs:\\nTMP_103(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_0(Contract.NextFunction) -> NextFunction.STORE_DEST\\nTMP_104(bool) = TMP_103 != REF_0\\nCONDITION TMP_104\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected storage destination to be pushed)\\n\\nIRs:\\nTMP_105(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected storage destination to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisStoring()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isStoring()()\\\"];\\n}\\n// Function: 68.sol-Contract-validStoreVal()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nexpected() != NextFunction.VAL_SET && expected() != NextFunction.VAL_INC && expected() != NextFunction.VAL_DEC\\n\\nIRs:\\nTMP_107(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_1(Contract.NextFunction) -> NextFunction.VAL_SET\\nTMP_108(bool) = TMP_107 != REF_1\\nTMP_109(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_2(Contract.NextFunction) -> NextFunction.VAL_INC\\nTMP_110(bool) = TMP_109 != REF_2\\nTMP_111(bool) = TMP_108 && TMP_110\\nTMP_112(Contract.NextFunction) = INTERNAL_CALL, Contract.expected()()\\nREF_3(Contract.NextFunction) -> NextFunction.VAL_DEC\\nTMP_113(bool) = TMP_112 != REF_3\\nTMP_114(bool) = TMP_111 && TMP_113\\nCONDITION TMP_114\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrevert(string)(Unexpected function order - expected storage value to be pushed)\\n\\nIRs:\\nTMP_115(None) = SOLIDITY_CALL revert(string)(Unexpected function order - expected storage value to be pushed)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nisStoring()\\n\\nIRs:\\nINTERNAL_CALL, Contract.isStoring()()\\\"];\\n}\\n// Function: 68.sol-GetterInterface-read(bytes32,bytes32)\\ndigraph{\\n}\\n// Function: 68.sol-GetterInterface-readMulti(bytes32,bytes32[])\\ndigraph{\\n}\\n// Function: 68.sol-MintedCappedIdx-admin()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_admin)\\n\\nIRs:\\nTMP_237(bytes32) = SOLIDITY_CALL keccak256()(sale_admin)\\nRETURN TMP_237\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-allowance(address,bytes32,address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nuint256(GetterInterface(_storage).read(_exec_id,allowed(_owner,_spender)))\\n\\nIRs:\\nTMP_564 = CONVERT _storage to GetterInterface\\nTMP_565(bytes32) = INTERNAL_CALL, MintedCappedIdx.allowed(address,address)(_owner,_spender)\\nTMP_566(bytes32) = HIGH_LEVEL_CALL, dest:TMP_564(GetterInterface), function:read, arguments:['_exec_id', 'TMP_565']  \\nTMP_567 = CONVERT TMP_566 to uint256\\nRETURN TMP_567\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-allowed(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_spender,keccak256()(_owner,TOKEN_ALLOWANCES))\\n\\nIRs:\\nTMP_276(bytes32) = SOLIDITY_CALL keccak256()(_owner,TOKEN_ALLOWANCES)\\nTMP_277(bytes32) = SOLIDITY_CALL keccak256()(_spender,TMP_276)\\nRETURN TMP_277\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-balanceOf(address,bytes32,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nuint256(GetterInterface(_storage).read(_exec_id,balances(_owner)))\\n\\nIRs:\\nTMP_560 = CONVERT _storage to GetterInterface\\nTMP_561(bytes32) = INTERNAL_CALL, MintedCappedIdx.balances(address)(_owner)\\nTMP_562(bytes32) = HIGH_LEVEL_CALL, dest:TMP_560(GetterInterface), function:read, arguments:['_exec_id', 'TMP_561']  \\nTMP_563 = CONVERT TMP_562 to uint256\\nRETURN TMP_563\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-balances(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_owner,TOKEN_BALANCES)\\n\\nIRs:\\nTMP_275(bytes32) = SOLIDITY_CALL keccak256()(_owner,TOKEN_BALANCES)\\nRETURN TMP_275\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-contributors()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_contributors)\\n\\nIRs:\\nTMP_243(bytes32) = SOLIDITY_CALL keccak256()(sale_contributors)\\nRETURN TMP_243\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-currentEndsAt()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(current_tier_ends_at)\\n\\nIRs:\\nTMP_262(bytes32) = SOLIDITY_CALL keccak256()(current_tier_ends_at)\\nRETURN TMP_262\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-currentTier()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_current_tier)\\n\\nIRs:\\nTMP_261(bytes32) = SOLIDITY_CALL keccak256()(sale_current_tier)\\nRETURN TMP_261\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-currentTokensRemaining()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(current_tier_tokens_remaining)\\n\\nIRs:\\nTMP_263(bytes32) = SOLIDITY_CALL keccak256()(current_tier_tokens_remaining)\\nRETURN TMP_263\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-decimals(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nuint256(GetterInterface(_storage).read(_exec_id,tokenDecimals()))\\n\\nIRs:\\nTMP_568 = CONVERT _storage to GetterInterface\\nTMP_569(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenDecimals()()\\nTMP_570(bytes32) = HIGH_LEVEL_CALL, dest:TMP_568(GetterInterface), function:read, arguments:['_exec_id', 'TMP_569']  \\nTMP_571 = CONVERT TMP_570 to uint256\\nRETURN TMP_571\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-destIndex(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_destination,index,reservedDestinations())\\n\\nIRs:\\nTMP_281(bytes32) = INTERNAL_CALL, MintedCappedIdx.reservedDestinations()()\\nTMP_282(bytes32) = SOLIDITY_CALL keccak256()(_destination,index,TMP_281)\\nRETURN TMP_282\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-destPercent(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_destination,numpercent,reservedDestinations())\\n\\nIRs:\\nTMP_285(bytes32) = INTERNAL_CALL, MintedCappedIdx.reservedDestinations()()\\nTMP_286(bytes32) = SOLIDITY_CALL keccak256()(_destination,numpercent,TMP_285)\\nRETURN TMP_286\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-destPrecision(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_destination,precision,reservedDestinations())\\n\\nIRs:\\nTMP_287(bytes32) = INTERNAL_CALL, MintedCappedIdx.reservedDestinations()()\\nTMP_288(bytes32) = SOLIDITY_CALL keccak256()(_destination,precision,TMP_287)\\nRETURN TMP_288\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-destTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_destination,numtokens,reservedDestinations())\\n\\nIRs:\\nTMP_283(bytes32) = INTERNAL_CALL, MintedCappedIdx.reservedDestinations()()\\nTMP_284(bytes32) = SOLIDITY_CALL keccak256()(_destination,numtokens,TMP_283)\\nRETURN TMP_284\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-execPermissions(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_exec,EXEC_PERMISSIONS)\\n\\nIRs:\\nTMP_236(bytes32) = SOLIDITY_CALL keccak256()(_exec,EXEC_PERMISSIONS)\\nRETURN TMP_236\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getAdmin(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\naddress(GetterInterface(_storage).read(_exec_id,admin()))\\n\\nIRs:\\nTMP_364 = CONVERT _storage to GetterInterface\\nTMP_365(bytes32) = INTERNAL_CALL, MintedCappedIdx.admin()()\\nTMP_366(bytes32) = HIGH_LEVEL_CALL, dest:TMP_364(GetterInterface), function:read, arguments:['_exec_id', 'TMP_365']  \\nTMP_367 = CONVERT TMP_366 to address\\nRETURN TMP_367\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getCrowdsaleInfo(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntarget = GetterInterface(_storage)\\n\\nIRs:\\nTMP_368 = CONVERT _storage to GetterInterface\\ntarget(GetterInterface) := TMP_368(GetterInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\narr_indices = new bytes32[](4)\\n\\nIRs:\\nTMP_370(bytes32[])  = new bytes32[](4)\\narr_indices(bytes32[]) = ['TMP_370(bytes32[])']\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narr_indices[0] = totalWeiRaised()\\n\\nIRs:\\nREF_50(bytes32) -> arr_indices[0]\\nTMP_371(bytes32) = INTERNAL_CALL, MintedCappedIdx.totalWeiRaised()()\\nREF_50(bytes32) (->arr_indices) := TMP_371(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\narr_indices[1] = wallet()\\n\\nIRs:\\nREF_51(bytes32) -> arr_indices[1]\\nTMP_372(bytes32) = INTERNAL_CALL, MintedCappedIdx.wallet()()\\nREF_51(bytes32) (->arr_indices) := TMP_372(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\narr_indices[2] = isConfigured()\\n\\nIRs:\\nREF_52(bytes32) -> arr_indices[2]\\nTMP_373(bytes32) = INTERNAL_CALL, MintedCappedIdx.isConfigured()()\\nREF_52(bytes32) (->arr_indices) := TMP_373(bytes32)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\narr_indices[3] = isFinished()\\n\\nIRs:\\nREF_53(bytes32) -> arr_indices[3]\\nTMP_374(bytes32) = INTERNAL_CALL, MintedCappedIdx.isFinished()()\\nREF_53(bytes32) (->arr_indices) := TMP_374(bytes32)\\\"];\\n6->7;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,arr_indices)\\n\\nIRs:\\nTMP_375(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nread_values(bytes32[]) = ['TMP_375(bytes32[])']\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nwei_raised = uint256(read_values[0])\\n\\nIRs:\\nREF_55(bytes32) -> read_values[0]\\nTMP_376 = CONVERT REF_55 to uint256\\nwei_raised(uint256) := TMP_376(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nteam_wallet = address(read_values[1])\\n\\nIRs:\\nREF_56(bytes32) -> read_values[1]\\nTMP_377 = CONVERT REF_56 to address\\nteam_wallet(address) := TMP_377(address)\\\"];\\n9->12;\\n12[label=\\\"Node Type: IF 12\\n\\nEXPRESSION:\\nread_values[2] == 0\\n\\nIRs:\\nREF_57(bytes32) -> read_values[2]\\nTMP_378(bool) = REF_57 == 0\\nCONDITION TMP_378\\\"];\\n12->13[label=\\\"True\\\"];\\n12->14[label=\\\"False\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nis_initialized = false\\n\\nIRs:\\nis_initialized(bool) := False(bool)\\\"];\\n13->15;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nis_initialized = true\\n\\nIRs:\\nis_initialized(bool) := True(bool)\\\"];\\n14->15;\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: IF 16\\n\\nEXPRESSION:\\nread_values[3] == 0\\n\\nIRs:\\nREF_58(bytes32) -> read_values[3]\\nTMP_379(bool) = REF_58 == 0\\nCONDITION TMP_379\\\"];\\n16->17[label=\\\"True\\\"];\\n16->18[label=\\\"False\\\"];\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nis_finalized = false\\n\\nIRs:\\nis_finalized(bool) := False(bool)\\\"];\\n17->19;\\n18[label=\\\"Node Type: EXPRESSION 18\\n\\nEXPRESSION:\\nis_finalized = true\\n\\nIRs:\\nis_finalized(bool) := True(bool)\\\"];\\n18->19;\\n19[label=\\\"Node Type: END_IF 19\\n\\\"];\\n19->20;\\n20[label=\\\"Node Type: RETURN 20\\n\\nEXPRESSION:\\n(wei_raised,team_wallet,is_initialized,is_finalized)\\n\\nIRs:\\nRETURN wei_raised,team_wallet,is_initialized,is_finalized\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getCrowdsaleMaxRaise(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntarget = GetterInterface(_storage)\\n\\nIRs:\\nTMP_467 = CONVERT _storage to GetterInterface\\ntarget(GetterInterface) := TMP_467(GetterInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\narr_indices = new bytes32[](3)\\n\\nIRs:\\nTMP_469(bytes32[])  = new bytes32[](3)\\narr_indices(bytes32[]) = ['TMP_469(bytes32[])']\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narr_indices[0] = saleTierList()\\n\\nIRs:\\nREF_122(bytes32) -> arr_indices[0]\\nTMP_470(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nREF_122(bytes32) (->arr_indices) := TMP_470(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\narr_indices[1] = tokenDecimals()\\n\\nIRs:\\nREF_123(bytes32) -> arr_indices[1]\\nTMP_471(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenDecimals()()\\nREF_123(bytes32) (->arr_indices) := TMP_471(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\narr_indices[2] = tokenName()\\n\\nIRs:\\nREF_124(bytes32) -> arr_indices[2]\\nTMP_472(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenName()()\\nREF_124(bytes32) (->arr_indices) := TMP_472(bytes32)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,arr_indices).toUintArr()\\n\\nIRs:\\nTMP_473(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nTMP_474(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_473'] \\nread_values(uint256[]) = ['TMP_474(uint256[])']\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == 3)\\n\\nIRs:\\nREF_127 -> LENGTH read_values\\nTMP_475(bool) = REF_127 == 3\\nTMP_476(None) = SOLIDITY_CALL assert(bool)(TMP_475)\\\"];\\n7->8;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\nnum_tiers = read_values[0]\\n\\nIRs:\\nREF_128(uint256) -> read_values[0]\\nnum_tiers(uint256) := REF_128(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: NEW VARIABLE 9\\n\\nEXPRESSION:\\nnum_decimals = read_values[1]\\n\\nIRs:\\nREF_129(uint256) -> read_values[1]\\nnum_decimals(uint256) := REF_129(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: IF 10\\n\\nEXPRESSION:\\nread_values[2] == 0\\n\\nIRs:\\nREF_130(uint256) -> read_values[2]\\nTMP_477(bool) = REF_130 == 0\\nCONDITION TMP_477\\\"];\\n10->11[label=\\\"True\\\"];\\n10->12[label=\\\"False\\\"];\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\n(0,0)\\n\\nIRs:\\nRETURN 0,0\\\"];\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n12->13;\\n13[label=\\\"Node Type: NEW VARIABLE 13\\n\\nEXPRESSION:\\nlast_arr = new bytes32[](2 * num_tiers)\\n\\nIRs:\\nTMP_479(uint256) = 2 * num_tiers\\nTMP_480(bytes32[])  = new bytes32[](TMP_479)\\nlast_arr(bytes32[]) = ['TMP_480(bytes32[])']\\\"];\\n13->16;\\n14[label=\\\"Node Type: BEGIN_LOOP 14\\n\\\"];\\n14->17;\\n15[label=\\\"Node Type: END_LOOP 15\\n\\\"];\\n15->21;\\n16[label=\\\"Node Type: NEW VARIABLE 16\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n16->14;\\n17[label=\\\"Node Type: IF_LOOP 17\\n\\nEXPRESSION:\\ni < 2 * num_tiers\\n\\nIRs:\\nTMP_481(uint256) = 2 * num_tiers\\nTMP_482(bool) = i < TMP_481\\nCONDITION TMP_482\\\"];\\n17->18[label=\\\"True\\\"];\\n17->15[label=\\\"False\\\"];\\n18[label=\\\"Node Type: EXPRESSION 18\\n\\nEXPRESSION:\\nlast_arr[i] = tierCap(i / 2)\\n\\nIRs:\\nREF_131(bytes32) -> last_arr[i]\\nTMP_483(uint256) = i / 2\\nTMP_484(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierCap(uint256)(TMP_483)\\nREF_131(bytes32) (->last_arr) := TMP_484(bytes32)\\\"];\\n18->19;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\nlast_arr[i + 1] = tierPrice(i / 2)\\n\\nIRs:\\nTMP_485(uint256) = i + 1\\nREF_132(bytes32) -> last_arr[TMP_485]\\nTMP_486(uint256) = i / 2\\nTMP_487(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierPrice(uint256)(TMP_486)\\nREF_132(bytes32) (->last_arr) := TMP_487(bytes32)\\\"];\\n19->20;\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\ni += 2\\n\\nIRs:\\ni(uint256) = i + 2\\\"];\\n20->17;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,last_arr).toUintArr()\\n\\nIRs:\\nTMP_488(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'last_arr']  \\nTMP_489(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_488'] \\nread_values(uint256[]) = ['TMP_489(uint256[])']\\\"];\\n21->22;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == 2 * num_tiers)\\n\\nIRs:\\nREF_135 -> LENGTH read_values\\nTMP_490(uint256) = 2 * num_tiers\\nTMP_491(bool) = REF_135 == TMP_490\\nTMP_492(None) = SOLIDITY_CALL assert(bool)(TMP_491)\\\"];\\n22->25;\\n23[label=\\\"Node Type: BEGIN_LOOP 23\\n\\\"];\\n23->26;\\n24[label=\\\"Node Type: END_LOOP 24\\n\\\"];\\n24->30;\\n25[label=\\\"Node Type: EXPRESSION 25\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n25->23;\\n26[label=\\\"Node Type: IF_LOOP 26\\n\\nEXPRESSION:\\ni < read_values.length\\n\\nIRs:\\nREF_136 -> LENGTH read_values\\nTMP_493(bool) = i < REF_136\\nCONDITION TMP_493\\\"];\\n26->27[label=\\\"True\\\"];\\n26->24[label=\\\"False\\\"];\\n27[label=\\\"Node Type: EXPRESSION 27\\n\\nEXPRESSION:\\ntotal_sell_cap += read_values[i]\\n\\nIRs:\\nREF_137(uint256) -> read_values[i]\\ntotal_sell_cap(uint256) = total_sell_cap + REF_137\\\"];\\n27->28;\\n28[label=\\\"Node Type: EXPRESSION 28\\n\\nEXPRESSION:\\nwei_raise_cap += (read_values[i] * read_values[i + 1]) / (10 ** num_decimals)\\n\\nIRs:\\nREF_138(uint256) -> read_values[i]\\nTMP_494(uint256) = i + 1\\nREF_139(uint256) -> read_values[TMP_494]\\nTMP_495(uint256) = REF_138 * REF_139\\nTMP_496(uint256) = 10 ** num_decimals\\nTMP_497(uint256) = TMP_495 / TMP_496\\nwei_raise_cap(uint256) = wei_raise_cap + TMP_497\\\"];\\n28->29;\\n29[label=\\\"Node Type: EXPRESSION 29\\n\\nEXPRESSION:\\ni += 2\\n\\nIRs:\\ni(uint256) = i + 2\\\"];\\n29->26;\\n30[label=\\\"Node Type: RETURN 30\\n\\nEXPRESSION:\\n(wei_raise_cap,total_sell_cap)\\n\\nIRs:\\nRETURN wei_raise_cap,total_sell_cap\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getCrowdsaleStartAndEndTimes(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\narr_indices = new bytes32[](2)\\n\\nIRs:\\nTMP_404(bytes32[])  = new bytes32[](2)\\narr_indices(bytes32[]) = ['TMP_404(bytes32[])']\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\narr_indices[0] = startTime()\\n\\nIRs:\\nREF_72(bytes32) -> arr_indices[0]\\nTMP_405(bytes32) = INTERNAL_CALL, MintedCappedIdx.startTime()()\\nREF_72(bytes32) (->arr_indices) := TMP_405(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narr_indices[1] = totalDuration()\\n\\nIRs:\\nREF_73(bytes32) -> arr_indices[1]\\nTMP_406(bytes32) = INTERNAL_CALL, MintedCappedIdx.totalDuration()()\\nREF_73(bytes32) (->arr_indices) := TMP_406(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\nread_values = GetterInterface(_storage).readMulti(_exec_id,arr_indices).toUintArr()\\n\\nIRs:\\nTMP_407 = CONVERT _storage to GetterInterface\\nTMP_408(bytes32[]) = HIGH_LEVEL_CALL, dest:TMP_407(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nTMP_409(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_408'] \\nread_values(uint256[]) = ['TMP_409(uint256[])']\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nstart_time = read_values[0]\\n\\nIRs:\\nREF_76(uint256) -> read_values[0]\\nstart_time(uint256) := REF_76(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nend_time = start_time + read_values[1]\\n\\nIRs:\\nREF_77(uint256) -> read_values[1]\\nTMP_410(uint256) = start_time + REF_77\\nend_time(uint256) := TMP_410(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\n(start_time,end_time)\\n\\nIRs:\\nRETURN start_time,end_time\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getCrowdsaleTier(address,bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntarget = GetterInterface(_storage)\\n\\nIRs:\\nTMP_448 = CONVERT _storage to GetterInterface\\ntarget(GetterInterface) := TMP_448(GetterInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\narr_indices = new bytes32[](7)\\n\\nIRs:\\nTMP_450(bytes32[])  = new bytes32[](7)\\narr_indices(bytes32[]) = ['TMP_450(bytes32[])']\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narr_indices[0] = tierName(_index)\\n\\nIRs:\\nREF_106(bytes32) -> arr_indices[0]\\nTMP_451(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierName(uint256)(_index)\\nREF_106(bytes32) (->arr_indices) := TMP_451(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\narr_indices[1] = tierCap(_index)\\n\\nIRs:\\nREF_107(bytes32) -> arr_indices[1]\\nTMP_452(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierCap(uint256)(_index)\\nREF_107(bytes32) (->arr_indices) := TMP_452(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\narr_indices[2] = tierPrice(_index)\\n\\nIRs:\\nREF_108(bytes32) -> arr_indices[2]\\nTMP_453(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierPrice(uint256)(_index)\\nREF_108(bytes32) (->arr_indices) := TMP_453(bytes32)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\narr_indices[3] = tierDuration(_index)\\n\\nIRs:\\nREF_109(bytes32) -> arr_indices[3]\\nTMP_454(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierDuration(uint256)(_index)\\nREF_109(bytes32) (->arr_indices) := TMP_454(bytes32)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\narr_indices[4] = tierModifiable(_index)\\n\\nIRs:\\nREF_110(bytes32) -> arr_indices[4]\\nTMP_455(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierModifiable(uint256)(_index)\\nREF_110(bytes32) (->arr_indices) := TMP_455(bytes32)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\narr_indices[5] = tierWhitelisted(_index)\\n\\nIRs:\\nREF_111(bytes32) -> arr_indices[5]\\nTMP_456(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierWhitelisted(uint256)(_index)\\nREF_111(bytes32) (->arr_indices) := TMP_456(bytes32)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\narr_indices[6] = tierMin(_index)\\n\\nIRs:\\nREF_112(bytes32) -> arr_indices[6]\\nTMP_457(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierMin(uint256)(_index)\\nREF_112(bytes32) (->arr_indices) := TMP_457(bytes32)\\\"];\\n9->10;\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,arr_indices)\\n\\nIRs:\\nTMP_458(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nread_values(bytes32[]) = ['TMP_458(bytes32[])']\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == 7)\\n\\nIRs:\\nREF_114 -> LENGTH read_values\\nTMP_459(bool) = REF_114 == 7\\nTMP_460(None) = SOLIDITY_CALL assert(bool)(TMP_459)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ntier_name = read_values[0]\\n\\nIRs:\\nREF_115(bytes32) -> read_values[0]\\ntier_name(bytes32) := REF_115(bytes32)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\ntier_sell_cap = uint256(read_values[1])\\n\\nIRs:\\nREF_116(bytes32) -> read_values[1]\\nTMP_461 = CONVERT REF_116 to uint256\\ntier_sell_cap(uint256) := TMP_461(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ntier_price = uint256(read_values[2])\\n\\nIRs:\\nREF_117(bytes32) -> read_values[2]\\nTMP_462 = CONVERT REF_117 to uint256\\ntier_price(uint256) := TMP_462(uint256)\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\ntier_duration = uint256(read_values[3])\\n\\nIRs:\\nREF_118(bytes32) -> read_values[3]\\nTMP_463 = CONVERT REF_118 to uint256\\ntier_duration(uint256) := TMP_463(uint256)\\\"];\\n15->19;\\n18[label=\\\"Node Type: EXPRESSION 18\\n\\nEXPRESSION:\\ntier_min = uint256(read_values[6])\\n\\nIRs:\\nREF_119(bytes32) -> read_values[6]\\nTMP_464 = CONVERT REF_119 to uint256\\ntier_min(uint256) := TMP_464(uint256)\\\"];\\n18->27;\\n19[label=\\\"Node Type: IF 19\\n\\nEXPRESSION:\\nread_values[4] == 0\\n\\nIRs:\\nREF_120(bytes32) -> read_values[4]\\nTMP_465(bool) = REF_120 == 0\\nCONDITION TMP_465\\\"];\\n19->20[label=\\\"True\\\"];\\n19->21[label=\\\"False\\\"];\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\nduration_is_modifiable = false\\n\\nIRs:\\nduration_is_modifiable(bool) := False(bool)\\\"];\\n20->22;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\nduration_is_modifiable = true\\n\\nIRs:\\nduration_is_modifiable(bool) := True(bool)\\\"];\\n21->22;\\n22[label=\\\"Node Type: END_IF 22\\n\\\"];\\n22->23;\\n23[label=\\\"Node Type: IF 23\\n\\nEXPRESSION:\\nread_values[5] == 0\\n\\nIRs:\\nREF_121(bytes32) -> read_values[5]\\nTMP_466(bool) = REF_121 == 0\\nCONDITION TMP_466\\\"];\\n23->24[label=\\\"True\\\"];\\n23->25[label=\\\"False\\\"];\\n24[label=\\\"Node Type: EXPRESSION 24\\n\\nEXPRESSION:\\nis_whitelisted = false\\n\\nIRs:\\nis_whitelisted(bool) := False(bool)\\\"];\\n24->26;\\n25[label=\\\"Node Type: EXPRESSION 25\\n\\nEXPRESSION:\\nis_whitelisted = true\\n\\nIRs:\\nis_whitelisted(bool) := True(bool)\\\"];\\n25->26;\\n26[label=\\\"Node Type: END_IF 26\\n\\\"];\\n26->18;\\n27[label=\\\"Node Type: RETURN 27\\n\\nEXPRESSION:\\n(tier_name,tier_sell_cap,tier_price,tier_min,tier_duration,duration_is_modifiable,is_whitelisted)\\n\\nIRs:\\nRETURN tier_name,tier_sell_cap,tier_price,tier_min,tier_duration,duration_is_modifiable,is_whitelisted\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getCrowdsaleTierList(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntarget = GetterInterface(_storage)\\n\\nIRs:\\nTMP_498 = CONVERT _storage to GetterInterface\\ntarget(GetterInterface) := TMP_498(GetterInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nlist_length = uint256(target.read(_exec_id,saleTierList()))\\n\\nIRs:\\nTMP_499(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_500(bytes32) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:read, arguments:['_exec_id', 'TMP_499']  \\nTMP_501 = CONVERT TMP_500 to uint256\\nlist_length(uint256) := TMP_501(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\narr_indices = new bytes32[](list_length)\\n\\nIRs:\\nTMP_503(bytes32[])  = new bytes32[](list_length)\\narr_indices(bytes32[]) = ['TMP_503(bytes32[])']\\\"];\\n3->6;\\n4[label=\\\"Node Type: BEGIN_LOOP 4\\n\\\"];\\n4->7;\\n5[label=\\\"Node Type: END_LOOP 5\\n\\\"];\\n5->10;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n6->4;\\n7[label=\\\"Node Type: IF_LOOP 7\\n\\nEXPRESSION:\\ni < list_length\\n\\nIRs:\\nTMP_504(bool) = i < list_length\\nCONDITION TMP_504\\\"];\\n7->8[label=\\\"True\\\"];\\n7->5[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\narr_indices[i] = tierName(i)\\n\\nIRs:\\nREF_141(bytes32) -> arr_indices[i]\\nTMP_505(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierName(uint256)(i)\\nREF_141(bytes32) (->arr_indices) := TMP_505(bytes32)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_506(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n9->7;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ncrowdsale_tiers = target.readMulti(_exec_id,arr_indices)\\n\\nIRs:\\nTMP_507(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\ncrowdsale_tiers(bytes32[]) = ['TMP_507(bytes32[])']\\\"];\\n10->11;\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\ncrowdsale_tiers\\n\\nIRs:\\nRETURN crowdsale_tiers\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getCrowdsaleUniqueBuyers(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nuint256(GetterInterface(_storage).read(_exec_id,contributors()))\\n\\nIRs:\\nTMP_399 = CONVERT _storage to GetterInterface\\nTMP_400(bytes32) = INTERNAL_CALL, MintedCappedIdx.contributors()()\\nTMP_401(bytes32) = HIGH_LEVEL_CALL, dest:TMP_399(GetterInterface), function:read, arguments:['_exec_id', 'TMP_400']  \\nTMP_402 = CONVERT TMP_401 to uint256\\nRETURN TMP_402\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getCurrentTierInfo(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ninitial_arr = new bytes32[](4)\\n\\nIRs:\\nTMP_412(bytes32[])  = new bytes32[](4)\\ninitial_arr(bytes32[]) = ['TMP_412(bytes32[])']\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ninitial_arr[0] = currentEndsAt()\\n\\nIRs:\\nREF_78(bytes32) -> initial_arr[0]\\nTMP_413(bytes32) = INTERNAL_CALL, MintedCappedIdx.currentEndsAt()()\\nREF_78(bytes32) (->initial_arr) := TMP_413(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ninitial_arr[1] = currentTier()\\n\\nIRs:\\nREF_79(bytes32) -> initial_arr[1]\\nTMP_414(bytes32) = INTERNAL_CALL, MintedCappedIdx.currentTier()()\\nREF_79(bytes32) (->initial_arr) := TMP_414(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ninitial_arr[2] = currentTokensRemaining()\\n\\nIRs:\\nREF_80(bytes32) -> initial_arr[2]\\nTMP_415(bytes32) = INTERNAL_CALL, MintedCappedIdx.currentTokensRemaining()()\\nREF_80(bytes32) (->initial_arr) := TMP_415(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ninitial_arr[3] = saleTierList()\\n\\nIRs:\\nREF_81(bytes32) -> initial_arr[3]\\nTMP_416(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nREF_81(bytes32) (->initial_arr) := TMP_416(bytes32)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nread_values = GetterInterface(_storage).readMulti(_exec_id,initial_arr).toUintArr()\\n\\nIRs:\\nTMP_417 = CONVERT _storage to GetterInterface\\nTMP_418(bytes32[]) = HIGH_LEVEL_CALL, dest:TMP_417(GetterInterface), function:readMulti, arguments:['_exec_id', 'initial_arr']  \\nTMP_419(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_418'] \\nread_values(uint256[]) = ['TMP_419(uint256[])']\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == 4)\\n\\nIRs:\\nREF_84 -> LENGTH read_values\\nTMP_420(bool) = REF_84 == 4\\nTMP_421(None) = SOLIDITY_CALL assert(bool)(TMP_420)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\nread_values[1] == 0\\n\\nIRs:\\nREF_85(uint256) -> read_values[1]\\nTMP_422(bool) = REF_85 == 0\\nCONDITION TMP_422\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: RETURN 9\\n\\\"];\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ntier_ends_at = read_values[0]\\n\\nIRs:\\nREF_86(uint256) -> read_values[0]\\ntier_ends_at(uint256) := REF_86(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ntier_index = read_values[1] - 1\\n\\nIRs:\\nREF_87(uint256) -> read_values[1]\\nTMP_423(uint256) = REF_87 - 1\\ntier_index(uint256) := TMP_423(uint256)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\ntier_tokens_remaining = read_values[2]\\n\\nIRs:\\nREF_88(uint256) -> read_values[2]\\ntier_tokens_remaining(uint256) := REF_88(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: NEW VARIABLE 14\\n\\nEXPRESSION:\\nnum_tiers = read_values[3]\\n\\nIRs:\\nREF_89(uint256) -> read_values[3]\\nnum_tiers(uint256) := REF_89(uint256)\\\"];\\n14->15;\\n15[label=\\\"Node Type: NEW VARIABLE 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: BEGIN_LOOP 16\\n\\\"];\\n16->17;\\n17[label=\\\"Node Type: IF_LOOP 17\\n\\nEXPRESSION:\\nnow >= tier_ends_at && ++ tier_index < num_tiers\\n\\nIRs:\\nTMP_424(bool) = now >= tier_ends_at\\ntier_index(uint256) = tier_index + 1\\nTMP_425(bool) = tier_index < num_tiers\\nTMP_426(bool) = TMP_424 && TMP_425\\nCONDITION TMP_426\\\"];\\n17->18[label=\\\"True\\\"];\\n17->20[label=\\\"False\\\"];\\n18[label=\\\"Node Type: EXPRESSION 18\\n\\nEXPRESSION:\\ntier_ends_at += uint256(GetterInterface(_storage).read(_exec_id,tierDuration(tier_index)))\\n\\nIRs:\\nTMP_427 = CONVERT _storage to GetterInterface\\nTMP_428(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierDuration(uint256)(tier_index)\\nTMP_429(bytes32) = HIGH_LEVEL_CALL, dest:TMP_427(GetterInterface), function:read, arguments:['_exec_id', 'TMP_428']  \\nTMP_430 = CONVERT TMP_429 to uint256\\ntier_ends_at(uint256) = tier_ends_at + TMP_430\\\"];\\n18->19;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\nupdated_tier = true\\n\\nIRs:\\nupdated_tier(bool) := True(bool)\\\"];\\n19->17;\\n20[label=\\\"Node Type: END_LOOP 20\\n\\\"];\\n20->21;\\n21[label=\\\"Node Type: IF 21\\n\\nEXPRESSION:\\ntier_index >= num_tiers\\n\\nIRs:\\nTMP_431(bool) = tier_index >= num_tiers\\nCONDITION TMP_431\\\"];\\n21->22[label=\\\"True\\\"];\\n21->23[label=\\\"False\\\"];\\n22[label=\\\"Node Type: RETURN 22\\n\\nEXPRESSION:\\n(0,0,0,0,0,0,false,false)\\n\\nIRs:\\nRETURN 0,0,0,0,0,0,False,False\\\"];\\n23[label=\\\"Node Type: END_IF 23\\n\\\"];\\n23->24;\\n24[label=\\\"Node Type: EXPRESSION 24\\n\\nEXPRESSION:\\ninitial_arr = new bytes32[](6)\\n\\nIRs:\\nTMP_433(bytes32[])  = new bytes32[](6)\\ninitial_arr(bytes32[]) = ['TMP_433(bytes32[])']\\\"];\\n24->25;\\n25[label=\\\"Node Type: EXPRESSION 25\\n\\nEXPRESSION:\\ninitial_arr[0] = tierName(tier_index)\\n\\nIRs:\\nREF_91(bytes32) -> initial_arr[0]\\nTMP_434(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierName(uint256)(tier_index)\\nREF_91(bytes32) (->initial_arr) := TMP_434(bytes32)\\\"];\\n25->26;\\n26[label=\\\"Node Type: EXPRESSION 26\\n\\nEXPRESSION:\\ninitial_arr[1] = tierPrice(tier_index)\\n\\nIRs:\\nREF_92(bytes32) -> initial_arr[1]\\nTMP_435(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierPrice(uint256)(tier_index)\\nREF_92(bytes32) (->initial_arr) := TMP_435(bytes32)\\\"];\\n26->27;\\n27[label=\\\"Node Type: EXPRESSION 27\\n\\nEXPRESSION:\\ninitial_arr[2] = tierModifiable(tier_index)\\n\\nIRs:\\nREF_93(bytes32) -> initial_arr[2]\\nTMP_436(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierModifiable(uint256)(tier_index)\\nREF_93(bytes32) (->initial_arr) := TMP_436(bytes32)\\\"];\\n27->28;\\n28[label=\\\"Node Type: EXPRESSION 28\\n\\nEXPRESSION:\\ninitial_arr[3] = tierWhitelisted(tier_index)\\n\\nIRs:\\nREF_94(bytes32) -> initial_arr[3]\\nTMP_437(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierWhitelisted(uint256)(tier_index)\\nREF_94(bytes32) (->initial_arr) := TMP_437(bytes32)\\\"];\\n28->29;\\n29[label=\\\"Node Type: EXPRESSION 29\\n\\nEXPRESSION:\\ninitial_arr[4] = tierMin(tier_index)\\n\\nIRs:\\nREF_95(bytes32) -> initial_arr[4]\\nTMP_438(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierMin(uint256)(tier_index)\\nREF_95(bytes32) (->initial_arr) := TMP_438(bytes32)\\\"];\\n29->30;\\n30[label=\\\"Node Type: EXPRESSION 30\\n\\nEXPRESSION:\\ninitial_arr[5] = tierCap(tier_index)\\n\\nIRs:\\nREF_96(bytes32) -> initial_arr[5]\\nTMP_439(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierCap(uint256)(tier_index)\\nREF_96(bytes32) (->initial_arr) := TMP_439(bytes32)\\\"];\\n30->31;\\n31[label=\\\"Node Type: EXPRESSION 31\\n\\nEXPRESSION:\\nread_values = GetterInterface(_storage).readMulti(_exec_id,initial_arr).toUintArr()\\n\\nIRs:\\nTMP_440 = CONVERT _storage to GetterInterface\\nTMP_441(bytes32[]) = HIGH_LEVEL_CALL, dest:TMP_440(GetterInterface), function:readMulti, arguments:['_exec_id', 'initial_arr']  \\nTMP_442(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_441'] \\nread_values(uint256[]) = ['TMP_442(uint256[])']\\\"];\\n31->32;\\n32[label=\\\"Node Type: EXPRESSION 32\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == 6)\\n\\nIRs:\\nREF_99 -> LENGTH read_values\\nTMP_443(bool) = REF_99 == 6\\nTMP_444(None) = SOLIDITY_CALL assert(bool)(TMP_443)\\\"];\\n32->33;\\n33[label=\\\"Node Type: EXPRESSION 33\\n\\nEXPRESSION:\\ntier_name = bytes32(read_values[0])\\n\\nIRs:\\nREF_100(uint256) -> read_values[0]\\nTMP_445 = CONVERT REF_100 to bytes32\\ntier_name(bytes32) := TMP_445(bytes32)\\\"];\\n33->34;\\n34[label=\\\"Node Type: EXPRESSION 34\\n\\nEXPRESSION:\\ntier_price = read_values[1]\\n\\nIRs:\\nREF_101(uint256) -> read_values[1]\\ntier_price(uint256) := REF_101(uint256)\\\"];\\n34->41;\\n37[label=\\\"Node Type: EXPRESSION 37\\n\\nEXPRESSION:\\ntier_min = read_values[4]\\n\\nIRs:\\nREF_102(uint256) -> read_values[4]\\ntier_min(uint256) := REF_102(uint256)\\\"];\\n37->38;\\n38[label=\\\"Node Type: IF 38\\n\\nEXPRESSION:\\nupdated_tier\\n\\nIRs:\\nCONDITION updated_tier\\\"];\\n38->39[label=\\\"True\\\"];\\n38->40[label=\\\"False\\\"];\\n39[label=\\\"Node Type: EXPRESSION 39\\n\\nEXPRESSION:\\ntier_tokens_remaining = read_values[5]\\n\\nIRs:\\nREF_103(uint256) -> read_values[5]\\ntier_tokens_remaining(uint256) := REF_103(uint256)\\\"];\\n39->40;\\n40[label=\\\"Node Type: END_IF 40\\n\\\"];\\n40->49;\\n41[label=\\\"Node Type: IF 41\\n\\nEXPRESSION:\\nread_values[2] == 0\\n\\nIRs:\\nREF_104(uint256) -> read_values[2]\\nTMP_446(bool) = REF_104 == 0\\nCONDITION TMP_446\\\"];\\n41->42[label=\\\"True\\\"];\\n41->43[label=\\\"False\\\"];\\n42[label=\\\"Node Type: EXPRESSION 42\\n\\nEXPRESSION:\\nduration_is_modifiable = false\\n\\nIRs:\\nduration_is_modifiable(bool) := False(bool)\\\"];\\n42->44;\\n43[label=\\\"Node Type: EXPRESSION 43\\n\\nEXPRESSION:\\nduration_is_modifiable = true\\n\\nIRs:\\nduration_is_modifiable(bool) := True(bool)\\\"];\\n43->44;\\n44[label=\\\"Node Type: END_IF 44\\n\\\"];\\n44->45;\\n45[label=\\\"Node Type: IF 45\\n\\nEXPRESSION:\\nread_values[3] == 0\\n\\nIRs:\\nREF_105(uint256) -> read_values[3]\\nTMP_447(bool) = REF_105 == 0\\nCONDITION TMP_447\\\"];\\n45->46[label=\\\"True\\\"];\\n45->47[label=\\\"False\\\"];\\n46[label=\\\"Node Type: EXPRESSION 46\\n\\nEXPRESSION:\\nis_whitelisted = false\\n\\nIRs:\\nis_whitelisted(bool) := False(bool)\\\"];\\n46->48;\\n47[label=\\\"Node Type: EXPRESSION 47\\n\\nEXPRESSION:\\nis_whitelisted = true\\n\\nIRs:\\nis_whitelisted(bool) := True(bool)\\\"];\\n47->48;\\n48[label=\\\"Node Type: END_IF 48\\n\\\"];\\n48->37;\\n49[label=\\\"Node Type: RETURN 49\\n\\nEXPRESSION:\\n(tier_name,tier_index,tier_ends_at,tier_tokens_remaining,tier_price,tier_min,duration_is_modifiable,is_whitelisted)\\n\\nIRs:\\nRETURN tier_name,tier_index,tier_ends_at,tier_tokens_remaining,tier_price,tier_min,duration_is_modifiable,is_whitelisted\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getReservedDestinationInfo(address,bytes32,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\narr_indices = new bytes32[](4)\\n\\nIRs:\\nTMP_615(bytes32[])  = new bytes32[](4)\\narr_indices(bytes32[]) = ['TMP_615(bytes32[])']\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\narr_indices[0] = destIndex(_destination)\\n\\nIRs:\\nREF_186(bytes32) -> arr_indices[0]\\nTMP_616(bytes32) = INTERNAL_CALL, MintedCappedIdx.destIndex(address)(_destination)\\nREF_186(bytes32) (->arr_indices) := TMP_616(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narr_indices[1] = destTokens(_destination)\\n\\nIRs:\\nREF_187(bytes32) -> arr_indices[1]\\nTMP_617(bytes32) = INTERNAL_CALL, MintedCappedIdx.destTokens(address)(_destination)\\nREF_187(bytes32) (->arr_indices) := TMP_617(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\narr_indices[2] = destPercent(_destination)\\n\\nIRs:\\nREF_188(bytes32) -> arr_indices[2]\\nTMP_618(bytes32) = INTERNAL_CALL, MintedCappedIdx.destPercent(address)(_destination)\\nREF_188(bytes32) (->arr_indices) := TMP_618(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\narr_indices[3] = destPrecision(_destination)\\n\\nIRs:\\nREF_189(bytes32) -> arr_indices[3]\\nTMP_619(bytes32) = INTERNAL_CALL, MintedCappedIdx.destPrecision(address)(_destination)\\nREF_189(bytes32) (->arr_indices) := TMP_619(bytes32)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nread_values = GetterInterface(_storage).readMulti(_exec_id,arr_indices)\\n\\nIRs:\\nTMP_620 = CONVERT _storage to GetterInterface\\nTMP_621(bytes32[]) = HIGH_LEVEL_CALL, dest:TMP_620(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nread_values(bytes32[]) = ['TMP_621(bytes32[])']\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ndestination_list_index = uint256(read_values[0])\\n\\nIRs:\\nREF_191(bytes32) -> read_values[0]\\nTMP_622 = CONVERT REF_191 to uint256\\ndestination_list_index(uint256) := TMP_622(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: IF 8\\n\\nEXPRESSION:\\ndestination_list_index == 0\\n\\nIRs:\\nTMP_623(bool) = destination_list_index == 0\\nCONDITION TMP_623\\\"];\\n8->9[label=\\\"True\\\"];\\n8->10[label=\\\"False\\\"];\\n9[label=\\\"Node Type: RETURN 9\\n\\\"];\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ndestination_list_index --\\n\\nIRs:\\nTMP_624(uint256) := destination_list_index(uint256)\\ndestination_list_index(uint256) = destination_list_index - 1\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nnum_tokens = uint256(read_values[1])\\n\\nIRs:\\nREF_192(bytes32) -> read_values[1]\\nTMP_625 = CONVERT REF_192 to uint256\\nnum_tokens(uint256) := TMP_625(uint256)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nnum_percent = uint256(read_values[2])\\n\\nIRs:\\nREF_193(bytes32) -> read_values[2]\\nTMP_626 = CONVERT REF_193 to uint256\\nnum_percent(uint256) := TMP_626(uint256)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\npercent_decimals = uint256(read_values[3])\\n\\nIRs:\\nREF_194(bytes32) -> read_values[3]\\nTMP_627 = CONVERT REF_194 to uint256\\npercent_decimals(uint256) := TMP_627(uint256)\\\"];\\n14->15;\\n15[label=\\\"Node Type: RETURN 15\\n\\nEXPRESSION:\\n(destination_list_index,num_tokens,num_percent,percent_decimals)\\n\\nIRs:\\nRETURN destination_list_index,num_tokens,num_percent,percent_decimals\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getReservedTokenDestinationList(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnum_destinations = uint256(GetterInterface(_storage).read(_exec_id,reservedDestinations()))\\n\\nIRs:\\nTMP_596 = CONVERT _storage to GetterInterface\\nTMP_597(bytes32) = INTERNAL_CALL, MintedCappedIdx.reservedDestinations()()\\nTMP_598(bytes32) = HIGH_LEVEL_CALL, dest:TMP_596(GetterInterface), function:read, arguments:['_exec_id', 'TMP_597']  \\nTMP_599 = CONVERT TMP_598 to uint256\\nnum_destinations(uint256) := TMP_599(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nnum_destinations == 0\\n\\nIRs:\\nTMP_600(bool) = num_destinations == 0\\nCONDITION TMP_600\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\n(num_destinations,reserved_destinations)\\n\\nIRs:\\nRETURN num_destinations,reserved_destinations\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\narr_indices = new bytes32[](num_destinations)\\n\\nIRs:\\nTMP_602(bytes32[])  = new bytes32[](num_destinations)\\narr_indices(bytes32[]) = ['TMP_602(bytes32[])']\\\"];\\n5->8;\\n6[label=\\\"Node Type: BEGIN_LOOP 6\\n\\\"];\\n6->9;\\n7[label=\\\"Node Type: END_LOOP 7\\n\\\"];\\n7->12;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\ni = 1\\n\\nIRs:\\ni(uint256) := 1(uint256)\\\"];\\n8->6;\\n9[label=\\\"Node Type: IF_LOOP 9\\n\\nEXPRESSION:\\ni <= num_destinations\\n\\nIRs:\\nTMP_603(bool) = i <= num_destinations\\nCONDITION TMP_603\\\"];\\n9->10[label=\\\"True\\\"];\\n9->7[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\narr_indices[i - 1] = bytes32((32 * i) + uint256(reservedDestinations()))\\n\\nIRs:\\nTMP_604(uint256) = i - 1\\nREF_183(bytes32) -> arr_indices[TMP_604]\\nTMP_605(uint256) = 32 * i\\nTMP_606(bytes32) = INTERNAL_CALL, MintedCappedIdx.reservedDestinations()()\\nTMP_607 = CONVERT TMP_606 to uint256\\nTMP_608(uint256) = TMP_605 + TMP_607\\nTMP_609 = CONVERT TMP_608 to bytes32\\nREF_183(bytes32) (->arr_indices) := TMP_609(bytes32)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_610(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n11->9;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nreserved_destinations = GetterInterface(_storage).readMulti(_exec_id,arr_indices).toAddressArr()\\n\\nIRs:\\nTMP_611 = CONVERT _storage to GetterInterface\\nTMP_612(bytes32[]) = HIGH_LEVEL_CALL, dest:TMP_611(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nTMP_613(address[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toAddressArr(bytes32[]), arguments:['TMP_612'] \\nreserved_destinations(address[]) = ['TMP_613(address[])']\\\"];\\n12->13;\\n13[label=\\\"Node Type: RETURN 13\\n\\nEXPRESSION:\\n(num_destinations,reserved_destinations)\\n\\nIRs:\\nRETURN num_destinations,reserved_destinations\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getTierStartAndEndDates(address,bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntarget = GetterInterface(_storage)\\n\\nIRs:\\nTMP_508 = CONVERT _storage to GetterInterface\\ntarget(GetterInterface) := TMP_508(GetterInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\narr_indices = new bytes32[](3 + _index)\\n\\nIRs:\\nTMP_510(uint256) = 3 + _index\\nTMP_511(bytes32[])  = new bytes32[](TMP_510)\\narr_indices(bytes32[]) = ['TMP_511(bytes32[])']\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narr_indices[0] = saleTierList()\\n\\nIRs:\\nREF_143(bytes32) -> arr_indices[0]\\nTMP_512(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nREF_143(bytes32) (->arr_indices) := TMP_512(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\narr_indices[1] = startTime()\\n\\nIRs:\\nREF_144(bytes32) -> arr_indices[1]\\nTMP_513(bytes32) = INTERNAL_CALL, MintedCappedIdx.startTime()()\\nREF_144(bytes32) (->arr_indices) := TMP_513(bytes32)\\\"];\\n4->7;\\n5[label=\\\"Node Type: BEGIN_LOOP 5\\n\\\"];\\n5->8;\\n6[label=\\\"Node Type: END_LOOP 6\\n\\\"];\\n6->11;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n7->5;\\n8[label=\\\"Node Type: IF_LOOP 8\\n\\nEXPRESSION:\\ni <= _index\\n\\nIRs:\\nTMP_514(bool) = i <= _index\\nCONDITION TMP_514\\\"];\\n8->9[label=\\\"True\\\"];\\n8->6[label=\\\"False\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\narr_indices[2 + i] = tierDuration(i)\\n\\nIRs:\\nTMP_515(uint256) = 2 + i\\nREF_145(bytes32) -> arr_indices[TMP_515]\\nTMP_516(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierDuration(uint256)(i)\\nREF_145(bytes32) (->arr_indices) := TMP_516(bytes32)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_517(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n10->8;\\n11[label=\\\"Node Type: NEW VARIABLE 11\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,arr_indices).toUintArr()\\n\\nIRs:\\nTMP_518(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nTMP_519(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_518'] \\nread_values(uint256[]) = ['TMP_519(uint256[])']\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == 3 + _index)\\n\\nIRs:\\nREF_148 -> LENGTH read_values\\nTMP_520(uint256) = 3 + _index\\nTMP_521(bool) = REF_148 == TMP_520\\nTMP_522(None) = SOLIDITY_CALL assert(bool)(TMP_521)\\\"];\\n12->13;\\n13[label=\\\"Node Type: IF 13\\n\\nEXPRESSION:\\nread_values[0] <= _index\\n\\nIRs:\\nREF_149(uint256) -> read_values[0]\\nTMP_523(bool) = REF_149 <= _index\\nCONDITION TMP_523\\\"];\\n13->14[label=\\\"True\\\"];\\n13->15[label=\\\"False\\\"];\\n14[label=\\\"Node Type: RETURN 14\\n\\nEXPRESSION:\\n(0,0)\\n\\nIRs:\\nRETURN 0,0\\\"];\\n15[label=\\\"Node Type: END_IF 15\\n\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\ntier_start = read_values[1]\\n\\nIRs:\\nREF_150(uint256) -> read_values[1]\\ntier_start(uint256) := REF_150(uint256)\\\"];\\n16->19;\\n17[label=\\\"Node Type: BEGIN_LOOP 17\\n\\\"];\\n17->20;\\n18[label=\\\"Node Type: END_LOOP 18\\n\\\"];\\n18->23;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n19->17;\\n20[label=\\\"Node Type: IF_LOOP 20\\n\\nEXPRESSION:\\ni < _index\\n\\nIRs:\\nTMP_524(bool) = i < _index\\nCONDITION TMP_524\\\"];\\n20->21[label=\\\"True\\\"];\\n20->18[label=\\\"False\\\"];\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\ntier_start += read_values[2 + i]\\n\\nIRs:\\nTMP_525(uint256) = 2 + i\\nREF_151(uint256) -> read_values[TMP_525]\\ntier_start(uint256) = tier_start + REF_151\\\"];\\n21->22;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_526(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n22->20;\\n23[label=\\\"Node Type: EXPRESSION 23\\n\\nEXPRESSION:\\ntier_end = tier_start + read_values[read_values.length - 1]\\n\\nIRs:\\nREF_152 -> LENGTH read_values\\nTMP_527(uint256) = REF_152 - 1\\nREF_153(uint256) -> read_values[TMP_527]\\nTMP_528(uint256) = tier_start + REF_153\\ntier_end(uint256) := TMP_528(uint256)\\\"];\\n23->24;\\n24[label=\\\"Node Type: RETURN 24\\n\\nEXPRESSION:\\n(tier_start,tier_end)\\n\\nIRs:\\nRETURN tier_start,tier_end\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getTierWhitelist(address,bytes32,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nnum_whitelisted = uint256(GetterInterface(_storage).read(_exec_id,tierWhitelist(_tier_index)))\\n\\nIRs:\\nTMP_542 = CONVERT _storage to GetterInterface\\nTMP_543(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierWhitelist(uint256)(_tier_index)\\nTMP_544(bytes32) = HIGH_LEVEL_CALL, dest:TMP_542(GetterInterface), function:read, arguments:['_exec_id', 'TMP_543']  \\nTMP_545 = CONVERT TMP_544 to uint256\\nnum_whitelisted(uint256) := TMP_545(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nnum_whitelisted == 0\\n\\nIRs:\\nTMP_546(bool) = num_whitelisted == 0\\nCONDITION TMP_546\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\\"];\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\narr_indices = new bytes32[](num_whitelisted)\\n\\nIRs:\\nTMP_548(bytes32[])  = new bytes32[](num_whitelisted)\\narr_indices(bytes32[]) = ['TMP_548(bytes32[])']\\\"];\\n5->8;\\n6[label=\\\"Node Type: BEGIN_LOOP 6\\n\\\"];\\n6->9;\\n7[label=\\\"Node Type: END_LOOP 7\\n\\\"];\\n7->12;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n8->6;\\n9[label=\\\"Node Type: IF_LOOP 9\\n\\nEXPRESSION:\\ni < num_whitelisted\\n\\nIRs:\\nTMP_549(bool) = i < num_whitelisted\\nCONDITION TMP_549\\\"];\\n9->10[label=\\\"True\\\"];\\n9->7[label=\\\"False\\\"];\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\narr_indices[i] = bytes32(32 + (32 * i) + uint256(tierWhitelist(_tier_index)))\\n\\nIRs:\\nREF_163(bytes32) -> arr_indices[i]\\nTMP_550(uint256) = 32 * i\\nTMP_551(uint256) = 32 + TMP_550\\nTMP_552(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierWhitelist(uint256)(_tier_index)\\nTMP_553 = CONVERT TMP_552 to uint256\\nTMP_554(uint256) = TMP_551 + TMP_553\\nTMP_555 = CONVERT TMP_554 to bytes32\\nREF_163(bytes32) (->arr_indices) := TMP_555(bytes32)\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_556(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n11->9;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nwhitelist = GetterInterface(_storage).readMulti(_exec_id,arr_indices).toAddressArr()\\n\\nIRs:\\nTMP_557 = CONVERT _storage to GetterInterface\\nTMP_558(bytes32[]) = HIGH_LEVEL_CALL, dest:TMP_557(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nTMP_559(address[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toAddressArr(bytes32[]), arguments:['TMP_558'] \\nwhitelist(address[]) = ['TMP_559(address[])']\\\"];\\n12->13;\\n13[label=\\\"Node Type: RETURN 13\\n\\nEXPRESSION:\\n(num_whitelisted,whitelist)\\n\\nIRs:\\nRETURN num_whitelisted,whitelist\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getTokenInfo(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nseed_arr = new bytes32[](4)\\n\\nIRs:\\nTMP_583(bytes32[])  = new bytes32[](4)\\nseed_arr(bytes32[]) = ['TMP_583(bytes32[])']\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nseed_arr[0] = tokenName()\\n\\nIRs:\\nREF_172(bytes32) -> seed_arr[0]\\nTMP_584(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenName()()\\nREF_172(bytes32) (->seed_arr) := TMP_584(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nseed_arr[1] = tokenSymbol()\\n\\nIRs:\\nREF_173(bytes32) -> seed_arr[1]\\nTMP_585(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenSymbol()()\\nREF_173(bytes32) (->seed_arr) := TMP_585(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nseed_arr[2] = tokenDecimals()\\n\\nIRs:\\nREF_174(bytes32) -> seed_arr[2]\\nTMP_586(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenDecimals()()\\nREF_174(bytes32) (->seed_arr) := TMP_586(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nseed_arr[3] = tokenTotalSupply()\\n\\nIRs:\\nREF_175(bytes32) -> seed_arr[3]\\nTMP_587(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenTotalSupply()()\\nREF_175(bytes32) (->seed_arr) := TMP_587(bytes32)\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nvalues_arr = GetterInterface(_storage).readMulti(_exec_id,seed_arr)\\n\\nIRs:\\nTMP_588 = CONVERT _storage to GetterInterface\\nTMP_589(bytes32[]) = HIGH_LEVEL_CALL, dest:TMP_588(GetterInterface), function:readMulti, arguments:['_exec_id', 'seed_arr']  \\nvalues_arr(bytes32[]) = ['TMP_589(bytes32[])']\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\ntoken_name = values_arr[0]\\n\\nIRs:\\nREF_177(bytes32) -> values_arr[0]\\ntoken_name(bytes32) := REF_177(bytes32)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ntoken_symbol = values_arr[1]\\n\\nIRs:\\nREF_178(bytes32) -> values_arr[1]\\ntoken_symbol(bytes32) := REF_178(bytes32)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\ntoken_decimals = uint256(values_arr[2])\\n\\nIRs:\\nREF_179(bytes32) -> values_arr[2]\\nTMP_590 = CONVERT REF_179 to uint256\\ntoken_decimals(uint256) := TMP_590(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ntotal_supply = uint256(values_arr[3])\\n\\nIRs:\\nREF_180(bytes32) -> values_arr[3]\\nTMP_591 = CONVERT REF_180 to uint256\\ntotal_supply(uint256) := TMP_591(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: RETURN 11\\n\\nEXPRESSION:\\n(token_name,token_symbol,token_decimals,total_supply)\\n\\nIRs:\\nRETURN token_name,token_symbol,token_decimals,total_supply\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getTokensSold(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nuint256(GetterInterface(_storage).read(_exec_id,tokensSold()))\\n\\nIRs:\\nTMP_529 = CONVERT _storage to GetterInterface\\nTMP_530(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokensSold()()\\nTMP_531(bytes32) = HIGH_LEVEL_CALL, dest:TMP_529(GetterInterface), function:read, arguments:['_exec_id', 'TMP_530']  \\nTMP_532 = CONVERT TMP_531 to uint256\\nRETURN TMP_532\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getTransferAgentStatus(address,bytes32,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\nGetterInterface(_storage).read(_exec_id,transferAgents(_agent)) != 0\\n\\nIRs:\\nTMP_592 = CONVERT _storage to GetterInterface\\nTMP_593(bytes32) = INTERNAL_CALL, MintedCappedIdx.transferAgents(address)(_agent)\\nTMP_594(bytes32) = HIGH_LEVEL_CALL, dest:TMP_592(GetterInterface), function:read, arguments:['_exec_id', 'TMP_593']  \\nTMP_595(bool) = TMP_594 != 0\\nCONDITION TMP_595\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-getWhitelistStatus(address,bytes32,uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntarget = GetterInterface(_storage)\\n\\nIRs:\\nTMP_533 = CONVERT _storage to GetterInterface\\ntarget(GetterInterface) := TMP_533(GetterInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\narr_indices = new bytes32[](2)\\n\\nIRs:\\nTMP_535(bytes32[])  = new bytes32[](2)\\narr_indices(bytes32[]) = ['TMP_535(bytes32[])']\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\narr_indices[0] = whitelistMinTok(_tier_index,_buyer)\\n\\nIRs:\\nREF_155(bytes32) -> arr_indices[0]\\nTMP_536(bytes32) = INTERNAL_CALL, MintedCappedIdx.whitelistMinTok(uint256,address)(_tier_index,_buyer)\\nREF_155(bytes32) (->arr_indices) := TMP_536(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\narr_indices[1] = whitelistMaxTok(_tier_index,_buyer)\\n\\nIRs:\\nREF_156(bytes32) -> arr_indices[1]\\nTMP_537(bytes32) = INTERNAL_CALL, MintedCappedIdx.whitelistMaxTok(uint256,address)(_tier_index,_buyer)\\nREF_156(bytes32) (->arr_indices) := TMP_537(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,arr_indices).toUintArr()\\n\\nIRs:\\nTMP_538(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nTMP_539(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_538'] \\nread_values(uint256[]) = ['TMP_539(uint256[])']\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == 2)\\n\\nIRs:\\nREF_159 -> LENGTH read_values\\nTMP_540(bool) = REF_159 == 2\\nTMP_541(None) = SOLIDITY_CALL assert(bool)(TMP_540)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nminimum_purchase_amt = read_values[0]\\n\\nIRs:\\nREF_160(uint256) -> read_values[0]\\nminimum_purchase_amt(uint256) := REF_160(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nmax_tokens_remaining = read_values[1]\\n\\nIRs:\\nREF_161(uint256) -> read_values[1]\\nmax_tokens_remaining(uint256) := REF_161(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\n(minimum_purchase_amt,max_tokens_remaining)\\n\\nIRs:\\nRETURN minimum_purchase_amt,max_tokens_remaining\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-hasContributed(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_purchaser,contributors())\\n\\nIRs:\\nTMP_244(bytes32) = INTERNAL_CALL, MintedCappedIdx.contributors()()\\nTMP_245(bytes32) = SOLIDITY_CALL keccak256()(_purchaser,TMP_244)\\nRETURN TMP_245\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-init(address,uint256,bytes32,uint256,uint256,uint256,uint256,bool,bool,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nContract.initialize()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.initialize(), arguments:[] \\\"];\\n1->2;\\n2[label=\\\"Node Type: IF 2\\n\\nEXPRESSION:\\n_team_wallet == 0 || _initial_tier_price == 0 || _start_time < now || _start_time + _initial_tier_duration <= _start_time || _initial_tier_token_sell_cap == 0 || _admin == address(0)\\n\\nIRs:\\nTMP_290(bool) = _team_wallet == 0\\nTMP_291(bool) = _initial_tier_price == 0\\nTMP_292(bool) = TMP_290 || TMP_291\\nTMP_293(bool) = _start_time < now\\nTMP_294(bool) = TMP_292 || TMP_293\\nTMP_295(uint256) = _start_time + _initial_tier_duration\\nTMP_296(bool) = TMP_295 <= _start_time\\nTMP_297(bool) = TMP_294 || TMP_296\\nTMP_298(bool) = _initial_tier_token_sell_cap == 0\\nTMP_299(bool) = TMP_297 || TMP_298\\nTMP_300 = CONVERT 0 to address\\nTMP_301(bool) = _admin == TMP_300\\nTMP_302(bool) = TMP_299 || TMP_301\\nCONDITION TMP_302\\\"];\\n2->3[label=\\\"True\\\"];\\n2->4[label=\\\"False\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrevert(string)(improper initialization)\\n\\nIRs:\\nTMP_303(None) = SOLIDITY_CALL revert(string)(improper initialization)\\\"];\\n3->4;\\n4[label=\\\"Node Type: END_IF 4\\n\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nContract.storing()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.storing(), arguments:[] \\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nContract.set(execPermissions(msg.sender)).to(true)\\n\\nIRs:\\nTMP_305(bytes32) = INTERNAL_CALL, MintedCappedIdx.execPermissions(address)(msg.sender)\\nTMP_306(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_305'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bool), arguments:['TMP_306', 'True'] \\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nContract.set(admin()).to(_admin)\\n\\nIRs:\\nTMP_308(bytes32) = INTERNAL_CALL, MintedCappedIdx.admin()()\\nTMP_309(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_308'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,address), arguments:['TMP_309', '_admin'] \\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nContract.set(wallet()).to(_team_wallet)\\n\\nIRs:\\nTMP_311(bytes32) = INTERNAL_CALL, MintedCappedIdx.wallet()()\\nTMP_312(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_311'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,address), arguments:['TMP_312', '_team_wallet'] \\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nContract.set(totalDuration()).to(_initial_tier_duration)\\n\\nIRs:\\nTMP_314(bytes32) = INTERNAL_CALL, MintedCappedIdx.totalDuration()()\\nTMP_315(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_314'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_315', '_initial_tier_duration'] \\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nContract.set(startTime()).to(_start_time)\\n\\nIRs:\\nTMP_317(bytes32) = INTERNAL_CALL, MintedCappedIdx.startTime()()\\nTMP_318(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_317'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_318', '_start_time'] \\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nContract.set(saleTierList()).to(uint256(1))\\n\\nIRs:\\nTMP_320(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_321(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_320'] \\nTMP_322 = CONVERT 1 to uint256\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_321', 'TMP_322'] \\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\nContract.set(tierName(uint256(0))).to(_initial_tier_name)\\n\\nIRs:\\nTMP_324 = CONVERT 0 to uint256\\nTMP_325(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierName(uint256)(TMP_324)\\nTMP_326(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_325'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bytes32), arguments:['TMP_326', '_initial_tier_name'] \\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nContract.set(tierCap(uint256(0))).to(_initial_tier_token_sell_cap)\\n\\nIRs:\\nTMP_328 = CONVERT 0 to uint256\\nTMP_329(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierCap(uint256)(TMP_328)\\nTMP_330(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_329'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_330', '_initial_tier_token_sell_cap'] \\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\nContract.set(tierPrice(uint256(0))).to(_initial_tier_price)\\n\\nIRs:\\nTMP_332 = CONVERT 0 to uint256\\nTMP_333(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierPrice(uint256)(TMP_332)\\nTMP_334(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_333'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_334', '_initial_tier_price'] \\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nContract.set(tierDuration(uint256(0))).to(_initial_tier_duration)\\n\\nIRs:\\nTMP_336 = CONVERT 0 to uint256\\nTMP_337(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierDuration(uint256)(TMP_336)\\nTMP_338(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_337'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_338', '_initial_tier_duration'] \\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nContract.set(tierMin(uint256(0))).to(_initial_tier_min_purchase)\\n\\nIRs:\\nTMP_340 = CONVERT 0 to uint256\\nTMP_341(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierMin(uint256)(TMP_340)\\nTMP_342(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_341'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_342', '_initial_tier_min_purchase'] \\\"];\\n16->17;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nContract.set(tierModifiable(uint256(0))).to(_initial_tier_duration_is_modifiable)\\n\\nIRs:\\nTMP_344 = CONVERT 0 to uint256\\nTMP_345(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierModifiable(uint256)(TMP_344)\\nTMP_346(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_345'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bool), arguments:['TMP_346', '_initial_tier_duration_is_modifiable'] \\\"];\\n17->18;\\n18[label=\\\"Node Type: EXPRESSION 18\\n\\nEXPRESSION:\\nContract.set(tierWhitelisted(uint256(0))).to(_initial_tier_is_whitelisted)\\n\\nIRs:\\nTMP_348 = CONVERT 0 to uint256\\nTMP_349(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierWhitelisted(uint256)(TMP_348)\\nTMP_350(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_349'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,bool), arguments:['TMP_350', '_initial_tier_is_whitelisted'] \\\"];\\n18->19;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\nContract.set(currentTier()).to(uint256(1))\\n\\nIRs:\\nTMP_352(bytes32) = INTERNAL_CALL, MintedCappedIdx.currentTier()()\\nTMP_353(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_352'] \\nTMP_354 = CONVERT 1 to uint256\\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_353', 'TMP_354'] \\\"];\\n19->20;\\n20[label=\\\"Node Type: EXPRESSION 20\\n\\nEXPRESSION:\\nContract.set(currentEndsAt()).to(_initial_tier_duration.add(_start_time))\\n\\nIRs:\\nTMP_356(bytes32) = INTERNAL_CALL, MintedCappedIdx.currentEndsAt()()\\nTMP_357(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_356'] \\nTMP_358(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_initial_tier_duration', '_start_time'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_357', 'TMP_358'] \\\"];\\n20->21;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\nContract.set(currentTokensRemaining()).to(_initial_tier_token_sell_cap)\\n\\nIRs:\\nTMP_360(bytes32) = INTERNAL_CALL, MintedCappedIdx.currentTokensRemaining()()\\nTMP_361(bytes32) = LIBRARY_CALL, dest:Contract, function:Contract.set(bytes32), arguments:['TMP_360'] \\nLIBRARY_CALL, dest:Contract, function:Contract.to(bytes32,uint256), arguments:['TMP_361', '_initial_tier_token_sell_cap'] \\\"];\\n21->22;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\nContract.commit()\\n\\nIRs:\\nLIBRARY_CALL, dest:Contract, function:Contract.commit(), arguments:[] \\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-isConfigured()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_is_configured)\\n\\nIRs:\\nTMP_238(bytes32) = SOLIDITY_CALL keccak256()(sale_is_configured)\\nRETURN TMP_238\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-isCrowdsaleFull(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntarget = GetterInterface(_storage)\\n\\nIRs:\\nTMP_380 = CONVERT _storage to GetterInterface\\ntarget(GetterInterface) := TMP_380(GetterInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ninitial_arr = new bytes32[](2)\\n\\nIRs:\\nTMP_382(bytes32[])  = new bytes32[](2)\\ninitial_arr(bytes32[]) = ['TMP_382(bytes32[])']\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ninitial_arr[0] = saleTierList()\\n\\nIRs:\\nREF_59(bytes32) -> initial_arr[0]\\nTMP_383(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nREF_59(bytes32) (->initial_arr) := TMP_383(bytes32)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ninitial_arr[1] = tokensSold()\\n\\nIRs:\\nREF_60(bytes32) -> initial_arr[1]\\nTMP_384(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokensSold()()\\nREF_60(bytes32) (->initial_arr) := TMP_384(bytes32)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,initial_arr).toUintArr()\\n\\nIRs:\\nTMP_385(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'initial_arr']  \\nTMP_386(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_385'] \\nread_values(uint256[]) = ['TMP_386(uint256[])']\\\"];\\n5->6;\\n6[label=\\\"Node Type: NEW VARIABLE 6\\n\\nEXPRESSION:\\nnum_tiers = read_values[0]\\n\\nIRs:\\nREF_63(uint256) -> read_values[0]\\nnum_tiers(uint256) := REF_63(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\n_tokens_sold = read_values[1]\\n\\nIRs:\\nREF_64(uint256) -> read_values[1]\\n_tokens_sold(uint256) := REF_64(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: NEW VARIABLE 8\\n\\nEXPRESSION:\\narr_indices = new bytes32[](num_tiers)\\n\\nIRs:\\nTMP_388(bytes32[])  = new bytes32[](num_tiers)\\narr_indices(bytes32[]) = ['TMP_388(bytes32[])']\\\"];\\n8->11;\\n9[label=\\\"Node Type: BEGIN_LOOP 9\\n\\\"];\\n9->12;\\n10[label=\\\"Node Type: END_LOOP 10\\n\\\"];\\n10->15;\\n11[label=\\\"Node Type: NEW VARIABLE 11\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n11->9;\\n12[label=\\\"Node Type: IF_LOOP 12\\n\\nEXPRESSION:\\ni < num_tiers\\n\\nIRs:\\nTMP_389(bool) = i < num_tiers\\nCONDITION TMP_389\\\"];\\n12->13[label=\\\"True\\\"];\\n12->10[label=\\\"False\\\"];\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\narr_indices[i] = tierCap(i)\\n\\nIRs:\\nREF_65(bytes32) -> arr_indices[i]\\nTMP_390(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierCap(uint256)(i)\\nREF_65(bytes32) (->arr_indices) := TMP_390(bytes32)\\\"];\\n13->14;\\n14[label=\\\"Node Type: EXPRESSION 14\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_391(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n14->12;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nread_values = target.readMulti(_exec_id,arr_indices).toUintArr()\\n\\nIRs:\\nTMP_392(bytes32[]) = HIGH_LEVEL_CALL, dest:target(GetterInterface), function:readMulti, arguments:['_exec_id', 'arr_indices']  \\nTMP_393(uint256[]) = LIBRARY_CALL, dest:ArrayUtils, function:ArrayUtils.toUintArr(bytes32[]), arguments:['TMP_392'] \\nread_values(uint256[]) = ['TMP_393(uint256[])']\\\"];\\n15->16;\\n16[label=\\\"Node Type: EXPRESSION 16\\n\\nEXPRESSION:\\nassert(bool)(read_values.length == num_tiers)\\n\\nIRs:\\nREF_68 -> LENGTH read_values\\nTMP_394(bool) = REF_68 == num_tiers\\nTMP_395(None) = SOLIDITY_CALL assert(bool)(TMP_394)\\\"];\\n16->19;\\n17[label=\\\"Node Type: BEGIN_LOOP 17\\n\\\"];\\n17->20;\\n18[label=\\\"Node Type: END_LOOP 18\\n\\\"];\\n18->24;\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n19->17;\\n20[label=\\\"Node Type: IF_LOOP 20\\n\\nEXPRESSION:\\ni < read_values.length\\n\\nIRs:\\nREF_69 -> LENGTH read_values\\nTMP_396(bool) = i < REF_69\\nCONDITION TMP_396\\\"];\\n20->21[label=\\\"True\\\"];\\n20->18[label=\\\"False\\\"];\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\nmax_sellable += read_values[i]\\n\\nIRs:\\nREF_70(uint256) -> read_values[i]\\nmax_sellable(uint256) = max_sellable + REF_70\\\"];\\n21->22;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_397(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n22->20;\\n24[label=\\\"Node Type: IF 24\\n\\nEXPRESSION:\\n_tokens_sold >= max_sellable\\n\\nIRs:\\nTMP_398(bool) = _tokens_sold >= max_sellable\\nCONDITION TMP_398\\\"];\\n24->25[label=\\\"True\\\"];\\n24->26[label=\\\"False\\\"];\\n25[label=\\\"Node Type: EXPRESSION 25\\n\\nEXPRESSION:\\nis_crowdsale_full = true\\n\\nIRs:\\nis_crowdsale_full(bool) := True(bool)\\\"];\\n25->27;\\n26[label=\\\"Node Type: EXPRESSION 26\\n\\nEXPRESSION:\\nis_crowdsale_full = false\\n\\nIRs:\\nis_crowdsale_full(bool) := False(bool)\\\"];\\n26->27;\\n27[label=\\\"Node Type: END_IF 27\\n\\\"];\\n27->28;\\n28[label=\\\"Node Type: RETURN 28\\n\\nEXPRESSION:\\n(is_crowdsale_full,max_sellable)\\n\\nIRs:\\nRETURN is_crowdsale_full,max_sellable\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-isFinished()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_is_completed)\\n\\nIRs:\\nTMP_239(bytes32) = SOLIDITY_CALL keccak256()(sale_is_completed)\\nRETURN TMP_239\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-name(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nGetterInterface(_storage).read(_exec_id,tokenName())\\n\\nIRs:\\nTMP_576 = CONVERT _storage to GetterInterface\\nTMP_577(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenName()()\\nTMP_578(bytes32) = HIGH_LEVEL_CALL, dest:TMP_576(GetterInterface), function:read, arguments:['_exec_id', 'TMP_577']  \\nRETURN TMP_578\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-reservedDestinations()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(reserved_token_dest_list)\\n\\nIRs:\\nTMP_280(bytes32) = SOLIDITY_CALL keccak256()(reserved_token_dest_list)\\nRETURN TMP_280\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-saleTierList()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_tier_list)\\n\\nIRs:\\nTMP_246(bytes32) = SOLIDITY_CALL keccak256()(sale_tier_list)\\nRETURN TMP_246\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nEXEC_PERMISSIONS = keccak256()(script_exec_permissions)\\n\\nIRs:\\nTMP_628(bytes32) = SOLIDITY_CALL keccak256()(script_exec_permissions)\\nEXEC_PERMISSIONS(bytes32) := TMP_628(bytes32)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nTOKEN_BALANCES = keccak256()(token_balances)\\n\\nIRs:\\nTMP_629(bytes32) = SOLIDITY_CALL keccak256()(token_balances)\\nTOKEN_BALANCES(bytes32) := TMP_629(bytes32)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\nTOKEN_ALLOWANCES = keccak256()(token_allowances)\\n\\nIRs:\\nTMP_630(bytes32) = SOLIDITY_CALL keccak256()(token_allowances)\\nTOKEN_ALLOWANCES(bytes32) := TMP_630(bytes32)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nTOKEN_TRANSFER_AGENTS = keccak256()(token_transfer_agents)\\n\\nIRs:\\nTMP_631(bytes32) = SOLIDITY_CALL keccak256()(token_transfer_agents)\\nTOKEN_TRANSFER_AGENTS(bytes32) := TMP_631(bytes32)\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-startTime()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_start_time)\\n\\nIRs:\\nTMP_240(bytes32) = SOLIDITY_CALL keccak256()(sale_start_time)\\nRETURN TMP_240\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-symbol(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nGetterInterface(_storage).read(_exec_id,tokenSymbol())\\n\\nIRs:\\nTMP_579 = CONVERT _storage to GetterInterface\\nTMP_580(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenSymbol()()\\nTMP_581(bytes32) = HIGH_LEVEL_CALL, dest:TMP_579(GetterInterface), function:read, arguments:['_exec_id', 'TMP_580']  \\nRETURN TMP_581\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierCap(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,cap,saleTierList())\\n\\nIRs:\\nTMP_249(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_250(bytes32) = SOLIDITY_CALL keccak256()(_idx,cap,TMP_249)\\nRETURN TMP_250\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierDuration(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,duration,saleTierList())\\n\\nIRs:\\nTMP_255(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_256(bytes32) = SOLIDITY_CALL keccak256()(_idx,duration,TMP_255)\\nRETURN TMP_256\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierMin(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,minimum,saleTierList())\\n\\nIRs:\\nTMP_253(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_254(bytes32) = SOLIDITY_CALL keccak256()(_idx,minimum,TMP_253)\\nRETURN TMP_254\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierModifiable(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,mod_stat,saleTierList())\\n\\nIRs:\\nTMP_257(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_258(bytes32) = SOLIDITY_CALL keccak256()(_idx,mod_stat,TMP_257)\\nRETURN TMP_258\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierName(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,name,saleTierList())\\n\\nIRs:\\nTMP_247(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_248(bytes32) = SOLIDITY_CALL keccak256()(_idx,name,TMP_247)\\nRETURN TMP_248\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierPrice(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,price,saleTierList())\\n\\nIRs:\\nTMP_251(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_252(bytes32) = SOLIDITY_CALL keccak256()(_idx,price,TMP_251)\\nRETURN TMP_252\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierWhitelist(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,tier_whitelists)\\n\\nIRs:\\nTMP_266(bytes32) = SOLIDITY_CALL keccak256()(_idx,tier_whitelists)\\nRETURN TMP_266\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tierWhitelisted(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_idx,wl_stat,saleTierList())\\n\\nIRs:\\nTMP_259(bytes32) = INTERNAL_CALL, MintedCappedIdx.saleTierList()()\\nTMP_260(bytes32) = SOLIDITY_CALL keccak256()(_idx,wl_stat,TMP_259)\\nRETURN TMP_260\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tokenDecimals()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_decimals)\\n\\nIRs:\\nTMP_273(bytes32) = SOLIDITY_CALL keccak256()(token_decimals)\\nRETURN TMP_273\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tokenName()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_name)\\n\\nIRs:\\nTMP_271(bytes32) = SOLIDITY_CALL keccak256()(token_name)\\nRETURN TMP_271\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tokenSymbol()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_symbol)\\n\\nIRs:\\nTMP_272(bytes32) = SOLIDITY_CALL keccak256()(token_symbol)\\nRETURN TMP_272\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tokenTotalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(token_total_supply)\\n\\nIRs:\\nTMP_274(bytes32) = SOLIDITY_CALL keccak256()(token_total_supply)\\nRETURN TMP_274\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tokensSold()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_tokens_sold)\\n\\nIRs:\\nTMP_242(bytes32) = SOLIDITY_CALL keccak256()(sale_tokens_sold)\\nRETURN TMP_242\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-tokensUnlocked()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_tokens_unlocked)\\n\\nIRs:\\nTMP_279(bytes32) = SOLIDITY_CALL keccak256()(sale_tokens_unlocked)\\nRETURN TMP_279\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-totalDuration()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_total_duration)\\n\\nIRs:\\nTMP_241(bytes32) = SOLIDITY_CALL keccak256()(sale_total_duration)\\nRETURN TMP_241\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-totalSupply(address,bytes32)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nuint256(GetterInterface(_storage).read(_exec_id,tokenTotalSupply()))\\n\\nIRs:\\nTMP_572 = CONVERT _storage to GetterInterface\\nTMP_573(bytes32) = INTERNAL_CALL, MintedCappedIdx.tokenTotalSupply()()\\nTMP_574(bytes32) = HIGH_LEVEL_CALL, dest:TMP_572(GetterInterface), function:read, arguments:['_exec_id', 'TMP_573']  \\nTMP_575 = CONVERT TMP_574 to uint256\\nRETURN TMP_575\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-totalWeiRaised()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_tot_wei_raised)\\n\\nIRs:\\nTMP_265(bytes32) = SOLIDITY_CALL keccak256()(sale_tot_wei_raised)\\nRETURN TMP_265\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-transferAgents(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_agent,TOKEN_TRANSFER_AGENTS)\\n\\nIRs:\\nTMP_278(bytes32) = SOLIDITY_CALL keccak256()(_agent,TOKEN_TRANSFER_AGENTS)\\nRETURN TMP_278\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-wallet()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(sale_destination_wallet)\\n\\nIRs:\\nTMP_264(bytes32) = SOLIDITY_CALL keccak256()(sale_destination_wallet)\\nRETURN TMP_264\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-whitelistMaxTok(uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_spender,max_tok,tierWhitelist(_idx))\\n\\nIRs:\\nTMP_269(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierWhitelist(uint256)(_idx)\\nTMP_270(bytes32) = SOLIDITY_CALL keccak256()(_spender,max_tok,TMP_269)\\nRETURN TMP_270\\\"];\\n}\\n// Function: 68.sol-MintedCappedIdx-whitelistMinTok(uint256,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nkeccak256()(_spender,min_tok,tierWhitelist(_idx))\\n\\nIRs:\\nTMP_267(bytes32) = INTERNAL_CALL, MintedCappedIdx.tierWhitelist(uint256)(_idx)\\nTMP_268(bytes32) = SOLIDITY_CALL keccak256()(_spender,min_tok,TMP_267)\\nRETURN TMP_268\\\"];\\n}\\n// Function: 68.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(c >= a,Overflow - Addition)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL require(bool,string)(TMP_10,Overflow - Addition)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 68.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 68.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nrequire(bool,string)(c / a == b,Overflow - Multiplication)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL require(bool,string)(TMP_3,Overflow - Multiplication)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 68.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(b <= a,Underflow - Subtraction)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL require(bool,string)(TMP_6,Underflow - Subtraction)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 73.sol-AltcoinToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 73.sol-AltcoinToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 73.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 73.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 73.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 73.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 73.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 73.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 73.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 73.sol-Instantium-Instantium()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ndevTokens = 4300000e8\\n\\nIRs:\\ndevTokens(uint256) := 430000000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ndistr(owner,devTokens)\\n\\nIRs:\\nTMP_12(bool) = INTERNAL_CALL, Instantium.distr(address,uint256)(owner,devTokens)\\\"];\\n}\\n// Function: 73.sol-Instantium-adminClaimAirdrop(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndoAirdrop(_participant,_amount)\\n\\nIRs:\\nINTERNAL_CALL, Instantium.doAirdrop(address,uint256)(_participant,_amount)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 73.sol-Instantium-adminClaimAirdropMultiple(address[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: BEGIN_LOOP 1\\n\\\"];\\n1->4;\\n2[label=\\\"Node Type: END_LOOP 2\\n\\\"];\\n3[label=\\\"Node Type: NEW VARIABLE 3\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n3->1;\\n4[label=\\\"Node Type: IF_LOOP 4\\n\\nEXPRESSION:\\ni < _addresses.length\\n\\nIRs:\\nREF_9 -> LENGTH _addresses\\nTMP_38(bool) = i < REF_9\\nCONDITION TMP_38\\\"];\\n4->5[label=\\\"True\\\"];\\n4->2[label=\\\"False\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ndoAirdrop(_addresses[i],_amount)\\n\\nIRs:\\nREF_10(address) -> _addresses[i]\\nINTERNAL_CALL, Instantium.doAirdrop(address,uint256)(REF_10,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_40(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n6->4;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.onlyOwner()()\\\"];\\n7->3;\\n}\\n// Function: 73.sol-Instantium-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_38(mapping(address => uint256)) -> allowed[_owner]\\nREF_39(uint256) -> REF_38[_spender]\\nRETURN REF_39\\\"];\\n}\\n// Function: 73.sol-Instantium-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_value != 0 && allowed[msg.sender][_spender] != 0\\n\\nIRs:\\nTMP_81(bool) = _value != 0\\nREF_34(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_35(uint256) -> REF_34[_spender]\\nTMP_82(bool) = REF_35 != 0\\nTMP_83(bool) = TMP_81 && TMP_82\\nCONDITION TMP_83\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _value\\n\\nIRs:\\nREF_36(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_37(uint256) -> REF_36[_spender]\\nREF_37(uint256) (->allowed) := _value(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_value)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_value)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 73.sol-Instantium-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_12(uint256) -> balances[_owner]\\nRETURN REF_12\\\"];\\n}\\n// Function: 73.sol-Instantium-canDistr()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! distributionFinished)\\n\\nIRs:\\nTMP_97 = UnaryType.BANG distributionFinished \\nTMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 73.sol-Instantium-distr(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.add(_amount)\\n\\nIRs:\\nTMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDistributed', '_amount'] \\ntotalDistributed(uint256) := TMP_19(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_1(uint256) -> balances[_to]\\nREF_2(uint256) -> balances[_to]\\nTMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_2', '_amount'] \\nREF_1(uint256) (->balances) := TMP_20(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nDistr(_to,_amount)\\n\\nIRs:\\nEmit Distr(_to,_amount)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(address(0),_to,_amount)\\n\\nIRs:\\nTMP_22 = CONVERT 0 to address\\nEmit Transfer(TMP_22,_to,_amount)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.canDistr()()\\\"];\\n6->1;\\n}\\n// Function: 73.sol-Instantium-doAirdrop(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_amount > 0)\\n\\nIRs:\\nTMP_25(bool) = _amount > 0\\nTMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(totalDistributed + _amount <= totalSupply)\\n\\nIRs:\\nTMP_27(uint256) = totalDistributed + _amount\\nTMP_28(bool) = TMP_27 <= totalSupply\\nTMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_participant] = balances[_participant].add(_amount)\\n\\nIRs:\\nREF_4(uint256) -> balances[_participant]\\nREF_5(uint256) -> balances[_participant]\\nTMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_amount'] \\nREF_4(uint256) (->balances) := TMP_30(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntotalDistributed = totalDistributed.add(_amount)\\n\\nIRs:\\nTMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDistributed', '_amount'] \\ntotalDistributed(uint256) := TMP_31(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: IF 5\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_32(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_32\\\"];\\n5->6[label=\\\"True\\\"];\\n5->7[label=\\\"False\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n6->7;\\n7[label=\\\"Node Type: END_IF 7\\n\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nAirdrop(_participant,_amount,balances[_participant])\\n\\nIRs:\\nREF_8(uint256) -> balances[_participant]\\nEmit Airdrop(_participant,_amount,REF_8)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nTransfer(address(0),_participant,_amount)\\n\\nIRs:\\nTMP_34 = CONVERT 0 to address\\nEmit Transfer(TMP_34,_participant,_amount)\\\"];\\n}\\n// Function: 73.sol-Instantium-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ngetTokens()\\n\\nIRs:\\nINTERNAL_CALL, Instantium.getTokens()()\\\"];\\n}\\n// Function: 73.sol-Instantium-finishDistribution()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nDistrFinished()\\n\\nIRs:\\nEmit DistrFinished()\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.onlyOwner()()\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.canDistr()()\\\"];\\n5->1;\\n}\\n// Function: 73.sol-Instantium-getTokenBalance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nt = AltcoinToken(tokenAddress)\\n\\nIRs:\\nTMP_85 = CONVERT tokenAddress to AltcoinToken\\nt(AltcoinToken) := TMP_85(AltcoinToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\nbal = t.balanceOf(who)\\n\\nIRs:\\nTMP_86(uint256) = HIGH_LEVEL_CALL, dest:t(AltcoinToken), function:balanceOf, arguments:['who']  \\nbal(uint256) := TMP_86(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nbal\\n\\nIRs:\\nRETURN bal\\\"];\\n}\\n// Function: 73.sol-Instantium-getTokens()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->17;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntokens = 0\\n\\nIRs:\\ntokens(uint256) := 0(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(msg.value >= minContribution)\\n\\nIRs:\\nTMP_45(bool) = msg.value >= minContribution\\nTMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(msg.value > 0)\\n\\nIRs:\\nTMP_47(bool) = msg.value > 0\\nTMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\ntokens = tokensPerEth.mul(msg.value) / 1000000000000000000\\n\\nIRs:\\nTMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] \\nTMP_50(uint256) = TMP_49 / 1000000000000000000\\ntokens(uint256) := TMP_50(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ninvestor = msg.sender\\n\\nIRs:\\ninvestor(address) := msg.sender(address)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbonus = 0\\n\\nIRs:\\nbonus(uint256) := 0(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\nmsg.value >= extraBonus\\n\\nIRs:\\nTMP_51(bool) = msg.value >= extraBonus\\nCONDITION TMP_51\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nbonus = tokens / 2\\n\\nIRs:\\nTMP_52(uint256) = tokens / 2\\nbonus(uint256) := TMP_52(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ntokens = tokens + bonus\\n\\nIRs:\\nTMP_53(uint256) = tokens + bonus\\ntokens(uint256) := TMP_53(uint256)\\\"];\\n10->11;\\n11[label=\\\"Node Type: IF 11\\n\\nEXPRESSION:\\ntokens > 0\\n\\nIRs:\\nTMP_54(bool) = tokens > 0\\nCONDITION TMP_54\\\"];\\n11->12[label=\\\"True\\\"];\\n11->13[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ndistr(investor,tokens)\\n\\nIRs:\\nTMP_55(bool) = INTERNAL_CALL, Instantium.distr(address,uint256)(investor,tokens)\\\"];\\n12->13;\\n13[label=\\\"Node Type: END_IF 13\\n\\\"];\\n13->14;\\n14[label=\\\"Node Type: IF 14\\n\\nEXPRESSION:\\ntotalDistributed >= totalSupply\\n\\nIRs:\\nTMP_56(bool) = totalDistributed >= totalSupply\\nCONDITION TMP_56\\\"];\\n14->15[label=\\\"True\\\"];\\n14->16[label=\\\"False\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\ndistributionFinished = true\\n\\nIRs:\\ndistributionFinished(bool) := True(bool)\\\"];\\n15->16;\\n16[label=\\\"Node Type: END_IF 16\\n\\\"];\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\ncanDistr()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.canDistr()()\\\"];\\n17->1;\\n}\\n// Function: 73.sol-Instantium-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_99(bool) = msg.sender == owner\\nTMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 73.sol-Instantium-onlyPayloadSize(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(msg.data.length >= size + 4)\\n\\nIRs:\\nREF_44 -> LENGTH msg.data\\nTMP_101(uint256) = size + 4\\nTMP_102(bool) = REF_44 >= TMP_101\\nTMP_103(None) = SOLIDITY_CALL assert(bool)(TMP_102)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 73.sol-Instantium-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nname = Instantium TX\\n\\nIRs:\\nname(string) := Instantium TX(string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nsymbol = ITX\\n\\nIRs:\\nsymbol(string) := ITX(string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ndecimals = 8\\n\\nIRs:\\ndecimals(uint256) := 8(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nminContribution = 1000000000000000000 / 1000\\n\\nIRs:\\nTMP_95(uint256) = 1000000000000000000 / 1000\\nminContribution(uint256) := TMP_95(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nextraBonus = 1000000000000000000 / 10\\n\\nIRs:\\nTMP_96(uint256) = 1000000000000000000 / 10\\nextraBonus(uint256) := TMP_96(uint256)\\\"];\\n}\\n// Function: 73.sol-Instantium-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ntotalSupply = 86000000e8\\n\\nIRs:\\ntotalSupply(uint256) := 8600000000000000(uint256)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\ntotalDistributed = 0\\n\\nIRs:\\ntotalDistributed(uint256) := 0(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\ntokensPerEth = 86000e8\\n\\nIRs:\\ntokensPerEth(uint256) := 8600000000000(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\nbonus = 0\\n\\nIRs:\\nbonus(uint256) := 0(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: OTHER_ENTRYPOINT 5\\n\\nEXPRESSION:\\ndistributionFinished = false\\n\\nIRs:\\ndistributionFinished(bool) := False(bool)\\\"];\\n}\\n// Function: 73.sol-Instantium-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_58 = CONVERT 0 to address\\nTMP_59(bool) = _to != TMP_58\\nTMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[msg.sender])\\n\\nIRs:\\nREF_13(uint256) -> balances[msg.sender]\\nTMP_61(bool) = _amount <= REF_13\\nTMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[msg.sender] = balances[msg.sender].sub(_amount)\\n\\nIRs:\\nREF_14(uint256) -> balances[msg.sender]\\nREF_15(uint256) -> balances[msg.sender]\\nTMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_15', '_amount'] \\nREF_14(uint256) (->balances) := TMP_63(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_17(uint256) -> balances[_to]\\nREF_18(uint256) -> balances[_to]\\nTMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_18', '_amount'] \\nREF_17(uint256) (->balances) := TMP_64(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_amount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyPayloadSize(2 * 32)\\n\\nIRs:\\nTMP_66(uint256) = 2 * 32\\nMODIFIER_CALL, Instantium.onlyPayloadSize(uint256)(TMP_66)\\\"];\\n7->1;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 73.sol-Instantium-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->9;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_to != address(0))\\n\\nIRs:\\nTMP_68 = CONVERT 0 to address\\nTMP_69(bool) = _to != TMP_68\\nTMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= balances[_from])\\n\\nIRs:\\nREF_20(uint256) -> balances[_from]\\nTMP_71(bool) = _amount <= REF_20\\nTMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrequire(bool)(_amount <= allowed[_from][msg.sender])\\n\\nIRs:\\nREF_21(mapping(address => uint256)) -> allowed[_from]\\nREF_22(uint256) -> REF_21[msg.sender]\\nTMP_73(bool) = _amount <= REF_22\\nTMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_from] = balances[_from].sub(_amount)\\n\\nIRs:\\nREF_23(uint256) -> balances[_from]\\nREF_24(uint256) -> balances[_from]\\nTMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_24', '_amount'] \\nREF_23(uint256) (->balances) := TMP_75(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount)\\n\\nIRs:\\nREF_26(mapping(address => uint256)) -> allowed[_from]\\nREF_27(uint256) -> REF_26[msg.sender]\\nREF_28(mapping(address => uint256)) -> allowed[_from]\\nREF_29(uint256) -> REF_28[msg.sender]\\nTMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', '_amount'] \\nREF_27(uint256) (->allowed) := TMP_76(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nbalances[_to] = balances[_to].add(_amount)\\n\\nIRs:\\nREF_31(uint256) -> balances[_to]\\nREF_32(uint256) -> balances[_to]\\nTMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', '_amount'] \\nREF_31(uint256) (->balances) := TMP_77(uint256)\\\"];\\n6->7;\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n7->8;\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nonlyPayloadSize(3 * 32)\\n\\nIRs:\\nTMP_79(uint256) = 3 * 32\\nMODIFIER_CALL, Instantium.onlyPayloadSize(uint256)(TMP_79)\\\"];\\n9->1;\\n10[label=\\\"Node Type: RETURN 10\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 73.sol-Instantium-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nnewOwner != address(0)\\n\\nIRs:\\nTMP_13 = CONVERT 0 to address\\nTMP_14(bool) = newOwner != TMP_13\\nCONDITION TMP_14\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = newOwner\\n\\nIRs:\\nowner(address) := newOwner(address)\\\"];\\n2->3;\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 73.sol-Instantium-updateTokensPerEth(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\ntokensPerEth = _tokensPerEth\\n\\nIRs:\\ntokensPerEth(uint256) := _tokensPerEth(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nTokensPerEthUpdated(_tokensPerEth)\\n\\nIRs:\\nEmit TokensPerEthUpdated(_tokensPerEth)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 73.sol-Instantium-withdraw()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nmyAddress = this\\n\\nIRs:\\nmyAddress(address) := this(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\netherBalance = myAddress.balance\\n\\nIRs:\\nTMP_87(uint256) = SOLIDITY_CALL balance(address)(myAddress)\\netherBalance(uint256) := TMP_87(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner.transfer(etherBalance)\\n\\nIRs:\\nTransfer dest:owner value:etherBalance\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 73.sol-Instantium-withdrawAltcoinTokens(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntoken = AltcoinToken(_tokenContract)\\n\\nIRs:\\nTMP_90 = CONVERT _tokenContract to AltcoinToken\\ntoken(AltcoinToken) := TMP_90(AltcoinToken)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\namount = token.balanceOf(address(this))\\n\\nIRs:\\nTMP_91 = CONVERT this to address\\nTMP_92(uint256) = HIGH_LEVEL_CALL, dest:token(AltcoinToken), function:balanceOf, arguments:['TMP_91']  \\namount(uint256) := TMP_92(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntoken.transfer(owner,amount)\\n\\nIRs:\\nTMP_93(bool) = HIGH_LEVEL_CALL, dest:token(AltcoinToken), function:transfer, arguments:['owner', 'amount']  \\nRETURN TMP_93\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Instantium.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 73.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 73.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 73.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 73.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 77.sol-BlocktekUniversity-BlocktekUniversity(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = adr\\n\\nIRs:\\nowner(address) := adr(address)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nsymbol = BKU\\n\\nIRs:\\nsymbol(string) := BKU(string)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nname = Blocktek University Credits\\n\\nIRs:\\nname(string) := Blocktek University Credits(string)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\n_totalSupply = 150000000 * 10 ** 18\\n\\nIRs:\\nTMP_0(uint256) = 10 ** 18\\nTMP_1(uint256) = 150000000 * TMP_0\\n_totalSupply(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nbalances[owner] = _totalSupply\\n\\nIRs:\\nREF_0(uint256) -> balances[owner]\\nREF_0(uint256) (->balances) := _totalSupply(uint256)\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-allowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nallowed[_owner][_spender]\\n\\nIRs:\\nREF_18(mapping(address => uint256)) -> allowed[_owner]\\nREF_19(uint256) -> REF_18[_spender]\\nRETURN REF_19\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nremaining\\n\\nIRs:\\nRETURN remaining\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-approve(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nallowed[msg.sender][_spender] = _amount\\n\\nIRs:\\nREF_16(mapping(address => uint256)) -> allowed[msg.sender]\\nREF_17(uint256) -> REF_16[_spender]\\nREF_17(uint256) (->allowed) := _amount(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nApproval(msg.sender,_spender,_amount)\\n\\nIRs:\\nEmit Approval(msg.sender,_spender,_amount)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-balanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbalances[_owner]\\n\\nIRs:\\nREF_1(uint256) -> balances[_owner]\\nRETURN REF_1\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nbalance\\n\\nIRs:\\nRETURN balance\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\ndecimals = 18\\n\\nIRs:\\ndecimals(uint8) := 18(uint256)\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-slitherConstructorVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nsymbol = \\n\\nIRs:\\nsymbol(string) := (string)\\\"];\\n0->1;\\n1[label=\\\"Node Type: OTHER_ENTRYPOINT 1\\n\\nEXPRESSION:\\nname = \\n\\nIRs:\\nname(string) := (string)\\\"];\\n1->2;\\n2[label=\\\"Node Type: OTHER_ENTRYPOINT 2\\n\\nEXPRESSION:\\n_totalSupply = 0\\n\\nIRs:\\n_totalSupply(uint256) := 0(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: OTHER_ENTRYPOINT 3\\n\\nEXPRESSION:\\nowner = 0\\n\\nIRs:\\nowner(address) := 0(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: OTHER_ENTRYPOINT 4\\n\\nEXPRESSION:\\ncertificateAuthoirty = 0xC3334De449a1dD1B0FEc7304339371646be8a0c9\\n\\nIRs:\\ncertificateAuthoirty(address) := 1114397323644044260561776723157053768564946280649(address)\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-totalSupply()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n_totalSupply\\n\\nIRs:\\nRETURN _totalSupply\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntotalSupply\\n\\nIRs:\\nRETURN totalSupply\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-transfer(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]\\n\\nIRs:\\nREF_2(uint256) -> balances[msg.sender]\\nTMP_2(bool) = REF_2 >= _amount\\nTMP_3(bool) = _amount > 0\\nTMP_4(bool) = TMP_2 && TMP_3\\nREF_3(uint256) -> balances[_to]\\nTMP_5(uint256) = REF_3 + _amount\\nREF_4(uint256) -> balances[_to]\\nTMP_6(bool) = TMP_5 > REF_4\\nTMP_7(bool) = TMP_4 && TMP_6\\nCONDITION TMP_7\\\"];\\n1->2[label=\\\"True\\\"];\\n1->6[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[msg.sender] -= _amount\\n\\nIRs:\\nREF_5(uint256) -> balances[msg.sender]\\nREF_5(-> balances) = REF_5 - _amount\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbalances[_to] += _amount\\n\\nIRs:\\nREF_6(uint256) -> balances[_to]\\nREF_6(-> balances) = REF_6 + _amount\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nTransfer(msg.sender,_to,_amount)\\n\\nIRs:\\nEmit Transfer(msg.sender,_to,_amount)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n8[label=\\\"Node Type: RETURN 8\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n// Function: 77.sol-BlocktekUniversity-transferFrom(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\nbalances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]\\n\\nIRs:\\nREF_7(uint256) -> balances[_from]\\nTMP_9(bool) = REF_7 >= _amount\\nREF_8(mapping(address => uint256)) -> allowed[_from]\\nREF_9(uint256) -> REF_8[msg.sender]\\nTMP_10(bool) = REF_9 >= _amount\\nTMP_11(bool) = TMP_9 && TMP_10\\nTMP_12(bool) = _amount > 0\\nTMP_13(bool) = TMP_11 && TMP_12\\nREF_10(uint256) -> balances[_to]\\nTMP_14(uint256) = REF_10 + _amount\\nREF_11(uint256) -> balances[_to]\\nTMP_15(bool) = TMP_14 > REF_11\\nTMP_16(bool) = TMP_13 && TMP_15\\nCONDITION TMP_16\\\"];\\n1->2[label=\\\"True\\\"];\\n1->7[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbalances[_from] -= _amount\\n\\nIRs:\\nREF_12(uint256) -> balances[_from]\\nREF_12(-> balances) = REF_12 - _amount\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nallowed[_from][msg.sender] -= _amount\\n\\nIRs:\\nREF_13(mapping(address => uint256)) -> allowed[_from]\\nREF_14(uint256) -> REF_13[msg.sender]\\nREF_14(-> allowed) = REF_14 - _amount\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nbalances[_to] += _amount\\n\\nIRs:\\nREF_15(uint256) -> balances[_to]\\nREF_15(-> balances) = REF_15 + _amount\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nTransfer(_from,_to,_amount)\\n\\nIRs:\\nEmit Transfer(_from,_to,_amount)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nfalse\\n\\nIRs:\\nRETURN False\\\"];\\n9[label=\\\"Node Type: RETURN 9\\n\\nEXPRESSION:\\nsuccess\\n\\nIRs:\\nRETURN success\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 79.sol-DappleAirdrops-DappleAirdrops()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrate = 10000\\n\\nIRs:\\nrate(uint256) := 10000(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ndropUnitPrice = 1e14\\n\\nIRs:\\ndropUnitPrice(uint256) := 100000000000000(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbonus = 20\\n\\nIRs:\\nbonus(uint256) := 20(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nmaxDropsPerTx = 1000000\\n\\nIRs:\\nmaxDropsPerTx(uint256) := 1000000(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nmaxTrialDrops = 1000000\\n\\nIRs:\\nmaxTrialDrops(uint256) := 1000000(uint256)\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-banToken(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(! tokenIsBanned[_tokenAddr])\\n\\nIRs:\\nREF_17(bool) -> tokenIsBanned[_tokenAddr]\\nTMP_68 = UnaryType.BANG REF_17 \\nTMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntokenIsBanned[_tokenAddr] = true\\n\\nIRs:\\nREF_18(bool) -> tokenIsBanned[_tokenAddr]\\nREF_18(bool) (->tokenIsBanned) := True(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTokenBanned(_tokenAddr)\\n\\nIRs:\\nEmit TokenBanned(_tokenAddr)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 79.sol-DappleAirdrops-fallback()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(msg.value)\\n\\nIRs:\\nREF_22(uint256) -> ethBalanceOf[msg.sender]\\nREF_23(uint256) -> ethBalanceOf[msg.sender]\\nTMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_23', 'msg.value'] \\nREF_22(uint256) (->ethBalanceOf) := TMP_78(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nCreditPurchased(msg.sender,msg.value,msg.value.mul(rate))\\n\\nIRs:\\nTMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'rate'] \\nEmit CreditPurchased(msg.sender,msg.value,TMP_79)\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getBonusDropsOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nbonusDropsOf[_addr]\\n\\nIRs:\\nREF_14(uint256) -> bonusDropsOf[_addr]\\nRETURN REF_14\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getDropsOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\n(ethBalanceOf[_addr].mul(rate)).div(10 ** 18)\\n\\nIRs:\\nREF_11(uint256) -> ethBalanceOf[_addr]\\nTMP_62(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_11', 'rate'] \\nTMP_63(uint256) = 10 ** 18\\nTMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_62', 'TMP_63'] \\nRETURN TMP_64\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getEthBalanceOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nethBalanceOf[_addr]\\n\\nIRs:\\nREF_16(uint256) -> ethBalanceOf[_addr]\\nRETURN REF_16\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getMaxDropsPerTx()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nmaxDropsPerTx\\n\\nIRs:\\nRETURN maxDropsPerTx\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getRate()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\nrate\\n\\nIRs:\\nRETURN rate\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getRemainingTrialDrops(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\ntokenHasFreeTrial(_addressOfToken)\\n\\nIRs:\\nTMP_29(bool) = INTERNAL_CALL, DappleAirdrops.tokenHasFreeTrial(address)(_addressOfToken)\\nCONDITION TMP_29\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\nmaxTrialDrops.sub(trialDrops[_addressOfToken])\\n\\nIRs:\\nREF_2(uint256) -> trialDrops[_addressOfToken]\\nTMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['maxTrialDrops', 'REF_2'] \\nRETURN TMP_30\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getTokenAllowance(address,address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntoken = ERCInterface(_addressOfToken)\\n\\nIRs:\\nTMP_75 = CONVERT _addressOfToken to ERCInterface\\ntoken(ERCInterface) := TMP_75(ERCInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\ntoken.allowance(_addr,address(this))\\n\\nIRs:\\nTMP_76 = CONVERT this to address\\nTMP_77(uint256) = HIGH_LEVEL_CALL, dest:token(ERCInterface), function:allowance, arguments:['_addr', 'TMP_76']  \\nRETURN TMP_77\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-getTotalDropsOf(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ngetDropsOf(_addr).add(getBonusDropsOf(_addr))\\n\\nIRs:\\nTMP_65(uint256) = INTERNAL_CALL, DappleAirdrops.getDropsOf(address)(_addr)\\nTMP_66(uint256) = INTERNAL_CALL, DappleAirdrops.getBonusDropsOf(address)(_addr)\\nTMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_65', 'TMP_66'] \\nRETURN TMP_67\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-grantBonusDrops(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_addr != address(0) && _bonusDrops > 0)\\n\\nIRs:\\nTMP_46 = CONVERT 0 to address\\nTMP_47(bool) = _addr != TMP_46\\nTMP_48(bool) = _bonusDrops > 0\\nTMP_49(bool) = TMP_47 && TMP_48\\nTMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbonusDropsOf[_addr] = bonusDropsOf[_addr].add(_bonusDrops)\\n\\nIRs:\\nREF_4(uint256) -> bonusDropsOf[_addr]\\nREF_5(uint256) -> bonusDropsOf[_addr]\\nTMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_bonusDrops'] \\nREF_4(uint256) (->bonusDropsOf) := TMP_51(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nBonusCreditGranted(_addr,_bonusDrops)\\n\\nIRs:\\nEmit BonusCreditGranted(_addr,_bonusDrops)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 79.sol-DappleAirdrops-issueRefunds(address[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->13;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_addrs.length <= maxDropsPerTx)\\n\\nIRs:\\nREF_31 -> LENGTH _addrs\\nTMP_88(bool) = REF_31 <= maxDropsPerTx\\nTMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)\\\"];\\n1->4;\\n2[label=\\\"Node Type: BEGIN_LOOP 2\\n\\\"];\\n2->5;\\n3[label=\\\"Node Type: END_LOOP 3\\n\\\"];\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n4->2;\\n5[label=\\\"Node Type: IF_LOOP 5\\n\\nEXPRESSION:\\ni < _addrs.length\\n\\nIRs:\\nREF_32 -> LENGTH _addrs\\nTMP_90(bool) = i < REF_32\\nCONDITION TMP_90\\\"];\\n5->6[label=\\\"True\\\"];\\n5->3[label=\\\"False\\\"];\\n6[label=\\\"Node Type: IF 6\\n\\nEXPRESSION:\\n_addrs[i] != address(0) && ethBalanceOf[_addrs[i]] > 0\\n\\nIRs:\\nREF_33(address) -> _addrs[i]\\nTMP_91 = CONVERT 0 to address\\nTMP_92(bool) = REF_33 != TMP_91\\nREF_34(address) -> _addrs[i]\\nREF_35(uint256) -> ethBalanceOf[REF_34]\\nTMP_93(bool) = REF_35 > 0\\nTMP_94(bool) = TMP_92 && TMP_93\\nCONDITION TMP_94\\\"];\\n6->7[label=\\\"True\\\"];\\n6->11[label=\\\"False\\\"];\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ntoRefund = ethBalanceOf[_addrs[i]]\\n\\nIRs:\\nREF_36(address) -> _addrs[i]\\nREF_37(uint256) -> ethBalanceOf[REF_36]\\ntoRefund(uint256) := REF_37(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nethBalanceOf[_addrs[i]] = 0\\n\\nIRs:\\nREF_38(address) -> _addrs[i]\\nREF_39(uint256) -> ethBalanceOf[REF_38]\\nREF_39(uint256) (->ethBalanceOf) := 0(uint256)\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\n_addrs[i].transfer(toRefund)\\n\\nIRs:\\nREF_40(address) -> _addrs[i]\\nTransfer dest:REF_40 value:toRefund\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\nRefundIssued(_addrs[i],toRefund)\\n\\nIRs:\\nREF_42(address) -> _addrs[i]\\nEmit RefundIssued(REF_42,toRefund)\\\"];\\n10->11;\\n11[label=\\\"Node Type: END_IF 11\\n\\\"];\\n11->12;\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_97(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n12->5;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n13->1;\\n}\\n// Function: 79.sol-DappleAirdrops-multiValueAirdrop(address,address[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntoken = ERCInterface(_addressOfToken)\\n\\nIRs:\\nTMP_118 = CONVERT _addressOfToken to ERCInterface\\ntoken(ERCInterface) := TMP_118(ERCInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_recipients.length <= maxDropsPerTx && _recipients.length == _values.length && (getTotalDropsOf(msg.sender) >= _recipients.length || tokenHasFreeTrial(_addressOfToken)) && ! tokenIsBanned[_addressOfToken])\\n\\nIRs:\\nREF_56 -> LENGTH _recipients\\nTMP_119(bool) = REF_56 <= maxDropsPerTx\\nREF_57 -> LENGTH _recipients\\nREF_58 -> LENGTH _values\\nTMP_120(bool) = REF_57 == REF_58\\nTMP_121(bool) = TMP_119 && TMP_120\\nTMP_122(uint256) = INTERNAL_CALL, DappleAirdrops.getTotalDropsOf(address)(msg.sender)\\nREF_59 -> LENGTH _recipients\\nTMP_123(bool) = TMP_122 >= REF_59\\nTMP_124(bool) = INTERNAL_CALL, DappleAirdrops.tokenHasFreeTrial(address)(_addressOfToken)\\nTMP_125(bool) = TMP_123 || TMP_124\\nTMP_126(bool) = TMP_121 && TMP_125\\nREF_60(bool) -> tokenIsBanned[_addressOfToken]\\nTMP_127 = UnaryType.BANG REF_60 \\nTMP_128(bool) = TMP_126 && TMP_127\\nTMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->11;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < _recipients.length\\n\\nIRs:\\nREF_61 -> LENGTH _recipients\\nTMP_130(bool) = i < REF_61\\nCONDITION TMP_130\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\n_recipients[i] != address(0) && _values[i] > 0\\n\\nIRs:\\nREF_62(address) -> _recipients[i]\\nTMP_131 = CONVERT 0 to address\\nTMP_132(bool) = REF_62 != TMP_131\\nREF_63(uint256) -> _values[i]\\nTMP_133(bool) = REF_63 > 0\\nTMP_134(bool) = TMP_132 && TMP_133\\nCONDITION TMP_134\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ntoken.transferFrom(msg.sender,_recipients[i],_values[i])\\n\\nIRs:\\nREF_65(address) -> _recipients[i]\\nREF_66(uint256) -> _values[i]\\nHIGH_LEVEL_CALL, dest:token(ERCInterface), function:transferFrom, arguments:['msg.sender', 'REF_65', 'REF_66']  \\\"];\\n8->9;\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_136(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n10->6;\\n11[label=\\\"Node Type: IF 11\\n\\nEXPRESSION:\\ntokenHasFreeTrial(_addressOfToken)\\n\\nIRs:\\nTMP_137(bool) = INTERNAL_CALL, DappleAirdrops.tokenHasFreeTrial(address)(_addressOfToken)\\nCONDITION TMP_137\\\"];\\n11->12[label=\\\"True\\\"];\\n11->13[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ntrialDrops[_addressOfToken] = trialDrops[_addressOfToken].add(_recipients.length)\\n\\nIRs:\\nREF_67(uint256) -> trialDrops[_addressOfToken]\\nREF_68(uint256) -> trialDrops[_addressOfToken]\\nREF_70 -> LENGTH _recipients\\nTMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_68', 'REF_70'] \\nREF_67(uint256) (->trialDrops) := TMP_138(uint256)\\\"];\\n12->14;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nupdateMsgSenderBonusDrops(_recipients.length)\\n\\nIRs:\\nREF_71 -> LENGTH _recipients\\nINTERNAL_CALL, DappleAirdrops.updateMsgSenderBonusDrops(uint256)(REF_71)\\\"];\\n13->14;\\n14[label=\\\"Node Type: END_IF 14\\n\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nAirdropInvoked(msg.sender,_recipients.length)\\n\\nIRs:\\nREF_72 -> LENGTH _recipients\\nEmit AirdropInvoked(msg.sender,REF_72)\\\"];\\n15->16;\\n16[label=\\\"Node Type: RETURN 16\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_171(bool) = msg.sender == owner\\nTMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-revokeBonusCreditOf(address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_addr != address(0) && bonusDropsOf[_addr] >= _bonusDrops)\\n\\nIRs:\\nTMP_54 = CONVERT 0 to address\\nTMP_55(bool) = _addr != TMP_54\\nREF_7(uint256) -> bonusDropsOf[_addr]\\nTMP_56(bool) = REF_7 >= _bonusDrops\\nTMP_57(bool) = TMP_55 && TMP_56\\nTMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbonusDropsOf[_addr] = bonusDropsOf[_addr].sub(_bonusDrops)\\n\\nIRs:\\nREF_8(uint256) -> bonusDropsOf[_addr]\\nREF_9(uint256) -> bonusDropsOf[_addr]\\nTMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_9', '_bonusDrops'] \\nREF_8(uint256) (->bonusDropsOf) := TMP_59(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nBonusCreditRevoked(_addr,_bonusDrops)\\n\\nIRs:\\nEmit BonusCreditRevoked(_addr,_bonusDrops)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 79.sol-DappleAirdrops-setBonus(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(bonus != _newBonus)\\n\\nIRs:\\nTMP_42(bool) = bonus != _newBonus\\nTMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nBonustChanged(bonus,_newBonus)\\n\\nIRs:\\nEmit BonustChanged(bonus,_newBonus)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nbonus = _newBonus\\n\\nIRs:\\nbonus(uint256) := _newBonus(uint256)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 79.sol-DappleAirdrops-setMaxDrops(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_maxDrops >= 1000000)\\n\\nIRs:\\nTMP_38(bool) = _maxDrops >= 1000000\\nTMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nMaxDropsChanged(maxDropsPerTx,_maxDrops)\\n\\nIRs:\\nEmit MaxDropsChanged(maxDropsPerTx,_maxDrops)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nmaxDropsPerTx = _maxDrops\\n\\nIRs:\\nmaxDropsPerTx(uint256) := _maxDrops(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 79.sol-DappleAirdrops-setRate(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->7;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newRate != rate && _newRate > 0)\\n\\nIRs:\\nTMP_31(bool) = _newRate != rate\\nTMP_32(bool) = _newRate > 0\\nTMP_33(bool) = TMP_31 && TMP_32\\nTMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nRateChanged(rate,_newRate)\\n\\nIRs:\\nEmit RateChanged(rate,_newRate)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nrate = _newRate\\n\\nIRs:\\nrate(uint256) := _newRate(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: NEW VARIABLE 4\\n\\nEXPRESSION:\\neth = 1000000000000000000\\n\\nIRs:\\neth(uint256) := 1000000000000000000(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\ndropUnitPrice = eth.div(rate)\\n\\nIRs:\\nTMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['eth', 'rate'] \\ndropUnitPrice(uint256) := TMP_36(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n7->1;\\n}\\n// Function: 79.sol-DappleAirdrops-singleValueAirdrop(address,address[],uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\ntoken = ERCInterface(_addressOfToken)\\n\\nIRs:\\nTMP_99 = CONVERT _addressOfToken to ERCInterface\\ntoken(ERCInterface) := TMP_99(ERCInterface)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool)(_recipients.length <= maxDropsPerTx && (getTotalDropsOf(msg.sender) >= _recipients.length || tokenHasFreeTrial(_addressOfToken)) && ! tokenIsBanned[_addressOfToken])\\n\\nIRs:\\nREF_43 -> LENGTH _recipients\\nTMP_100(bool) = REF_43 <= maxDropsPerTx\\nTMP_101(uint256) = INTERNAL_CALL, DappleAirdrops.getTotalDropsOf(address)(msg.sender)\\nREF_44 -> LENGTH _recipients\\nTMP_102(bool) = TMP_101 >= REF_44\\nTMP_103(bool) = INTERNAL_CALL, DappleAirdrops.tokenHasFreeTrial(address)(_addressOfToken)\\nTMP_104(bool) = TMP_102 || TMP_103\\nTMP_105(bool) = TMP_100 && TMP_104\\nREF_45(bool) -> tokenIsBanned[_addressOfToken]\\nTMP_106 = UnaryType.BANG REF_45 \\nTMP_107(bool) = TMP_105 && TMP_106\\nTMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->11;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < _recipients.length\\n\\nIRs:\\nREF_46 -> LENGTH _recipients\\nTMP_109(bool) = i < REF_46\\nCONDITION TMP_109\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: IF 7\\n\\nEXPRESSION:\\n_recipients[i] != address(0)\\n\\nIRs:\\nREF_47(address) -> _recipients[i]\\nTMP_110 = CONVERT 0 to address\\nTMP_111(bool) = REF_47 != TMP_110\\nCONDITION TMP_111\\\"];\\n7->8[label=\\\"True\\\"];\\n7->9[label=\\\"False\\\"];\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\ntoken.transferFrom(msg.sender,_recipients[i],_value)\\n\\nIRs:\\nREF_49(address) -> _recipients[i]\\nHIGH_LEVEL_CALL, dest:token(ERCInterface), function:transferFrom, arguments:['msg.sender', 'REF_49', '_value']  \\\"];\\n8->9;\\n9[label=\\\"Node Type: END_IF 9\\n\\\"];\\n9->10;\\n10[label=\\\"Node Type: EXPRESSION 10\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_113(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n10->6;\\n11[label=\\\"Node Type: IF 11\\n\\nEXPRESSION:\\ntokenHasFreeTrial(_addressOfToken)\\n\\nIRs:\\nTMP_114(bool) = INTERNAL_CALL, DappleAirdrops.tokenHasFreeTrial(address)(_addressOfToken)\\nCONDITION TMP_114\\\"];\\n11->12[label=\\\"True\\\"];\\n11->13[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ntrialDrops[_addressOfToken] = trialDrops[_addressOfToken].add(_recipients.length)\\n\\nIRs:\\nREF_50(uint256) -> trialDrops[_addressOfToken]\\nREF_51(uint256) -> trialDrops[_addressOfToken]\\nREF_53 -> LENGTH _recipients\\nTMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_51', 'REF_53'] \\nREF_50(uint256) (->trialDrops) := TMP_115(uint256)\\\"];\\n12->14;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nupdateMsgSenderBonusDrops(_recipients.length)\\n\\nIRs:\\nREF_54 -> LENGTH _recipients\\nINTERNAL_CALL, DappleAirdrops.updateMsgSenderBonusDrops(uint256)(REF_54)\\\"];\\n13->14;\\n14[label=\\\"Node Type: END_IF 14\\n\\\"];\\n14->15;\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\nAirdropInvoked(msg.sender,_recipients.length)\\n\\nIRs:\\nREF_55 -> LENGTH _recipients\\nEmit AirdropInvoked(msg.sender,REF_55)\\\"];\\n15->16;\\n16[label=\\\"Node Type: RETURN 16\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-slitherConstructorConstantVariables()\\ndigraph{\\n0[label=\\\"Node Type: OTHER_ENTRYPOINT 0\\n\\nEXPRESSION:\\nwebsite = www.dappleairdrops.com\\n\\nIRs:\\nwebsite(string) := www.dappleairdrops.com(string)\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-tokenHasFreeTrial(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\ntrialDrops[_addressOfToken] < maxTrialDrops\\n\\nIRs:\\nREF_0(uint256) -> trialDrops[_addressOfToken]\\nTMP_28(bool) = REF_0 < maxTrialDrops\\nRETURN TMP_28\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0) && _newOwner != owner)\\n\\nIRs:\\nTMP_21 = CONVERT 0 to address\\nTMP_22(bool) = _newOwner != TMP_21\\nTMP_23(bool) = _newOwner != owner\\nTMP_24(bool) = TMP_22 && TMP_23\\nTMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 79.sol-DappleAirdrops-unbanToken(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->5;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(tokenIsBanned[_tokenAddr])\\n\\nIRs:\\nREF_19(bool) -> tokenIsBanned[_tokenAddr]\\nTMP_72(None) = SOLIDITY_CALL require(bool)(REF_19)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntokenIsBanned[_tokenAddr] = false\\n\\nIRs:\\nREF_20(bool) -> tokenIsBanned[_tokenAddr]\\nREF_20(bool) (->tokenIsBanned) := False(bool)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nTokenUnbanned(_tokenAddr)\\n\\nIRs:\\nEmit TokenUnbanned(_tokenAddr)\\\"];\\n3->4;\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n5->1;\\n}\\n// Function: 79.sol-DappleAirdrops-updateMsgSenderBonusDrops(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\n_drops <= getDropsOf(msg.sender)\\n\\nIRs:\\nTMP_141(uint256) = INTERNAL_CALL, DappleAirdrops.getDropsOf(address)(msg.sender)\\nTMP_142(bool) = _drops <= TMP_141\\nCONDITION TMP_142\\\"];\\n1->2[label=\\\"True\\\"];\\n1->5[label=\\\"False\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nbonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].add(_drops.mul(bonus).div(100))\\n\\nIRs:\\nREF_73(uint256) -> bonusDropsOf[msg.sender]\\nREF_74(uint256) -> bonusDropsOf[msg.sender]\\nTMP_143(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_drops', 'bonus'] \\nTMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_143', '100'] \\nTMP_145(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_74', 'TMP_144'] \\nREF_73(uint256) (->bonusDropsOf) := TMP_145(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].sub(_drops.mul(dropUnitPrice))\\n\\nIRs:\\nREF_78(uint256) -> ethBalanceOf[msg.sender]\\nREF_79(uint256) -> ethBalanceOf[msg.sender]\\nTMP_146(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_drops', 'dropUnitPrice'] \\nTMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_79', 'TMP_146'] \\nREF_78(uint256) (->ethBalanceOf) := TMP_147(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nowner.transfer(_drops.mul(dropUnitPrice))\\n\\nIRs:\\nTMP_148(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_drops', 'dropUnitPrice'] \\nTransfer dest:owner value:TMP_148\\\"];\\n4->12;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\nremainder = _drops.sub(getDropsOf(msg.sender))\\n\\nIRs:\\nTMP_150(uint256) = INTERNAL_CALL, DappleAirdrops.getDropsOf(address)(msg.sender)\\nTMP_151(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_drops', 'TMP_150'] \\nremainder(uint256) := TMP_151(uint256)\\\"];\\n5->6;\\n6[label=\\\"Node Type: IF 6\\n\\nEXPRESSION:\\nethBalanceOf[msg.sender] > 0\\n\\nIRs:\\nREF_85(uint256) -> ethBalanceOf[msg.sender]\\nTMP_152(bool) = REF_85 > 0\\nCONDITION TMP_152\\\"];\\n6->7[label=\\\"True\\\"];\\n6->10[label=\\\"False\\\"];\\n7[label=\\\"Node Type: EXPRESSION 7\\n\\nEXPRESSION:\\nbonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].add(getDropsOf(msg.sender).mul(bonus).div(100))\\n\\nIRs:\\nREF_86(uint256) -> bonusDropsOf[msg.sender]\\nREF_87(uint256) -> bonusDropsOf[msg.sender]\\nTMP_153(uint256) = INTERNAL_CALL, DappleAirdrops.getDropsOf(address)(msg.sender)\\nTMP_154(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_153', 'bonus'] \\nTMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_154', '100'] \\nTMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_87', 'TMP_155'] \\nREF_86(uint256) (->bonusDropsOf) := TMP_156(uint256)\\\"];\\n7->8;\\n8[label=\\\"Node Type: EXPRESSION 8\\n\\nEXPRESSION:\\nowner.transfer(ethBalanceOf[msg.sender])\\n\\nIRs:\\nREF_92(uint256) -> ethBalanceOf[msg.sender]\\nTransfer dest:owner value:REF_92\\\"];\\n8->9;\\n9[label=\\\"Node Type: EXPRESSION 9\\n\\nEXPRESSION:\\nethBalanceOf[msg.sender] = 0\\n\\nIRs:\\nREF_93(uint256) -> ethBalanceOf[msg.sender]\\nREF_93(uint256) (->ethBalanceOf) := 0(uint256)\\\"];\\n9->10;\\n10[label=\\\"Node Type: END_IF 10\\n\\\"];\\n10->11;\\n11[label=\\\"Node Type: EXPRESSION 11\\n\\nEXPRESSION:\\nbonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].sub(remainder)\\n\\nIRs:\\nREF_94(uint256) -> bonusDropsOf[msg.sender]\\nREF_95(uint256) -> bonusDropsOf[msg.sender]\\nTMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_95', 'remainder'] \\nREF_94(uint256) (->bonusDropsOf) := TMP_158(uint256)\\\"];\\n11->12;\\n12[label=\\\"Node Type: END_IF 12\\n\\\"];\\n}\\n// Function: 79.sol-DappleAirdrops-withdrawERC20Tokens(address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->6;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_addressOfToken != address(0) && _recipient != address(0) && _value > 0)\\n\\nIRs:\\nTMP_159 = CONVERT 0 to address\\nTMP_160(bool) = _addressOfToken != TMP_159\\nTMP_161 = CONVERT 0 to address\\nTMP_162(bool) = _recipient != TMP_161\\nTMP_163(bool) = TMP_160 && TMP_162\\nTMP_164(bool) = _value > 0\\nTMP_165(bool) = TMP_163 && TMP_164\\nTMP_166(None) = SOLIDITY_CALL require(bool)(TMP_165)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ntoken = ERCInterface(_addressOfToken)\\n\\nIRs:\\nTMP_167 = CONVERT _addressOfToken to ERCInterface\\ntoken(ERCInterface) := TMP_167(ERCInterface)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\ntoken.transfer(_recipient,_value)\\n\\nIRs:\\nTMP_168(bool) = HIGH_LEVEL_CALL, dest:token(ERCInterface), function:transfer, arguments:['_recipient', '_value']  \\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nERC20TokensWithdrawn(_addressOfToken,_recipient,_value)\\n\\nIRs:\\nEmit ERC20TokensWithdrawn(_addressOfToken,_recipient,_value)\\\"];\\n4->5;\\n5[label=\\\"Node Type: RETURN 5\\n\\nEXPRESSION:\\ntrue\\n\\nIRs:\\nRETURN True\\\"];\\n6[label=\\\"Node Type: EXPRESSION 6\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n6->1;\\n}\\n// Function: 79.sol-DappleAirdrops-withdrawEth(uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(ethBalanceOf[msg.sender] >= _eth && _eth > 0)\\n\\nIRs:\\nREF_26(uint256) -> ethBalanceOf[msg.sender]\\nTMP_81(bool) = REF_26 >= _eth\\nTMP_82(bool) = _eth > 0\\nTMP_83(bool) = TMP_81 && TMP_82\\nTMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)\\\"];\\n1->2;\\n2[label=\\\"Node Type: NEW VARIABLE 2\\n\\nEXPRESSION:\\ntoTransfer = _eth\\n\\nIRs:\\ntoTransfer(uint256) := _eth(uint256)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].sub(_eth)\\n\\nIRs:\\nREF_27(uint256) -> ethBalanceOf[msg.sender]\\nREF_28(uint256) -> ethBalanceOf[msg.sender]\\nTMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_eth'] \\nREF_27(uint256) (->ethBalanceOf) := TMP_85(uint256)\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nmsg.sender.transfer(toTransfer)\\n\\nIRs:\\nTransfer dest:msg.sender value:toTransfer\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nEthWithdrawn(msg.sender,toTransfer)\\n\\nIRs:\\nEmit EthWithdrawn(msg.sender,toTransfer)\\\"];\\n}\\n// Function: 79.sol-ERCInterface-allowance(address,address)\\ndigraph{\\n}\\n// Function: 79.sol-ERCInterface-balanceOf(address)\\ndigraph{\\n}\\n// Function: 79.sol-ERCInterface-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 79.sol-ERCInterface-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 79.sol-Ownable-Ownable()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 79.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_19(bool) = msg.sender == owner\\nTMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 79.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->4;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0) && _newOwner != owner)\\n\\nIRs:\\nTMP_12 = CONVERT 0 to address\\nTMP_13(bool) = _newOwner != TMP_12\\nTMP_14(bool) = _newOwner != owner\\nTMP_15(bool) = TMP_13 && TMP_14\\nTMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n4->1;\\n}\\n// Function: 79.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 79.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 79.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 79.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Integer Overflow/Underflow\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 80.sol-CanReclaimToken-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_34 = CONVERT 0 to address\\nTMP_35(bool) = _newOwner != TMP_34\\nTMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 80.sol-CanReclaimToken-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 80.sol-CanReclaimToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_41(bool) = msg.sender == owner\\nTMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 80.sol-CanReclaimToken-reclaimToken(ERC20Basic)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_38(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_38(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntoken.safeTransfer(owner,balance)\\n\\nIRs:\\nLIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', 'owner', 'balance'] \\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 80.sol-CanReclaimToken-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_30 = CONVERT 0 to address\\nowner(address) := TMP_30(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 80.sol-CanReclaimToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 80.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 80.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 80.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 80.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 80.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 80.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-allBalances()\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-allDecimals()\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-allTokens()\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-allTokensDecimalsBalances()\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-bundle(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-bundleFirstTokens(address,uint256,uint256[])\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-tokens(uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-tokensCount()\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-totalSupply()\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-unbundle(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IBasicMultiToken-unbundleSome(address,uint256,ERC20[])\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-allBalances()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-allDecimals()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-allTokens()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-allTokensDecimalsBalances()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-allTokensDecimalsBalancesWeights()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-allWeights()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-bundle(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-bundleFirstTokens(address,uint256,uint256[])\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-change(address,address,uint256,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-getReturn(address,address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-tokens(uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-tokensCount()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-totalSupply()\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-unbundle(address,uint256)\\ndigraph{\\n}\\n// Function: 80.sol-IMultiToken-unbundleSome(address,uint256,ERC20[])\\ndigraph{\\n}\\n// Function: 80.sol-MultiBuyer-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_51 = CONVERT 0 to address\\nTMP_52(bool) = _newOwner != TMP_51\\nTMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 80.sol-MultiBuyer-buy(IMultiToken,uint256,ERC20,address[],bytes,uint256[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(_datasIndexes.length == _exchanges.length + 1,buy: _datasIndexes should start with 0 and end with LENGTH)\\n\\nIRs:\\nREF_7 -> LENGTH _datasIndexes\\nREF_8 -> LENGTH _exchanges\\nTMP_55(uint256) = REF_8 + 1\\nTMP_56(bool) = REF_7 == TMP_55\\nTMP_57(None) = SOLIDITY_CALL require(bool,string)(TMP_56,buy: _datasIndexes should start with 0 and end with LENGTH)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(_values.length == _exchanges.length,buy: _values should have the same length as _exchanges)\\n\\nIRs:\\nREF_9 -> LENGTH _values\\nREF_10 -> LENGTH _exchanges\\nTMP_58(bool) = REF_9 == REF_10\\nTMP_59(None) = SOLIDITY_CALL require(bool,string)(TMP_58,buy: _values should have the same length as _exchanges)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->22;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < _exchanges.length\\n\\nIRs:\\nREF_11 -> LENGTH _exchanges\\nTMP_60(bool) = i < REF_11\\nCONDITION TMP_60\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ndata = new bytes(_datasIndexes[i + 1] - _datasIndexes[i])\\n\\nIRs:\\nTMP_62(uint256) = i + 1\\nREF_12(uint256) -> _datasIndexes[TMP_62]\\nREF_13(uint256) -> _datasIndexes[i]\\nTMP_63(uint256) = REF_12 - REF_13\\nTMP_64 = new bytes(TMP_63)\\ndata(bytes) := TMP_64(bytes)\\\"];\\n7->10;\\n8[label=\\\"Node Type: BEGIN_LOOP 8\\n\\\"];\\n8->11;\\n9[label=\\\"Node Type: END_LOOP 9\\n\\\"];\\n9->14;\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\nj = _datasIndexes[i]\\n\\nIRs:\\nREF_14(uint256) -> _datasIndexes[i]\\nj(uint256) := REF_14(uint256)\\\"];\\n10->8;\\n11[label=\\\"Node Type: IF_LOOP 11\\n\\nEXPRESSION:\\nj < _datasIndexes[i + 1]\\n\\nIRs:\\nTMP_65(uint256) = i + 1\\nREF_15(uint256) -> _datasIndexes[TMP_65]\\nTMP_66(bool) = j < REF_15\\nCONDITION TMP_66\\\"];\\n11->12[label=\\\"True\\\"];\\n11->9[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ndata[j - _datasIndexes[i]] = _datas[j]\\n\\nIRs:\\nREF_16(uint256) -> _datasIndexes[i]\\nTMP_67(uint256) = j - REF_16\\nREF_17(None) -> data[TMP_67]\\nREF_18(None) -> _datas[j]\\nREF_17(None) (->data) := REF_18(None)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nj ++\\n\\nIRs:\\nTMP_68(uint256) := j(uint256)\\nj(uint256) = j + 1\\\"];\\n13->11;\\n14[label=\\\"Node Type: IF 14\\n\\nEXPRESSION:\\n_throughToken != address(0) && i > 0\\n\\nIRs:\\nTMP_69 = CONVERT 0 to address\\nTMP_70(bool) = _throughToken != TMP_69\\nTMP_71(bool) = i > 0\\nTMP_72(bool) = TMP_70 && TMP_71\\nCONDITION TMP_72\\\"];\\n14->15[label=\\\"True\\\"];\\n14->16[label=\\\"False\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\n_throughToken.approve(_exchanges[i],_throughToken.balanceOf(this))\\n\\nIRs:\\nREF_20(address) -> _exchanges[i]\\nTMP_73(uint256) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:balanceOf, arguments:['this']  \\nTMP_74(bool) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:approve, arguments:['REF_20', 'TMP_73']  \\\"];\\n15->16;\\n16[label=\\\"Node Type: END_IF 16\\n\\\"];\\n16->17;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nrequire(bool,string)(_exchanges[i].call.value(_values[i])(data),buy: exchange arbitrary call failed)\\n\\nIRs:\\nREF_22(address) -> _exchanges[i]\\nREF_25(uint256) -> _values[i]\\nTMP_76(bool) = LOW_LEVEL_CALL, dest:REF_22, function:call, arguments:['data'] value:REF_25 \\nTMP_77(None) = SOLIDITY_CALL require(bool,string)(TMP_76,buy: exchange arbitrary call failed)\\\"];\\n17->18;\\n18[label=\\\"Node Type: IF 18\\n\\nEXPRESSION:\\n_throughToken != address(0)\\n\\nIRs:\\nTMP_78 = CONVERT 0 to address\\nTMP_79(bool) = _throughToken != TMP_78\\nCONDITION TMP_79\\\"];\\n18->19[label=\\\"True\\\"];\\n18->20[label=\\\"False\\\"];\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\n_throughToken.approve(_exchanges[i],0)\\n\\nIRs:\\nREF_27(address) -> _exchanges[i]\\nTMP_80(bool) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:approve, arguments:['REF_27', '0']  \\\"];\\n19->20;\\n20[label=\\\"Node Type: END_IF 20\\n\\\"];\\n20->21;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_81(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n21->6;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\nj = _mtkn.totalSupply()\\n\\nIRs:\\nTMP_82(uint256) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:totalSupply, arguments:[]  \\nj(uint256) := TMP_82(uint256)\\\"];\\n22->23;\\n23[label=\\\"Node Type: NEW VARIABLE 23\\n\\nEXPRESSION:\\nbestAmount = uint256(- 1)\\n\\nIRs:\\nTMP_83(uint256) = 0 - 1\\nTMP_84 = CONVERT TMP_83 to uint256\\nbestAmount(uint256) := TMP_84(uint256)\\\"];\\n23->26;\\n24[label=\\\"Node Type: BEGIN_LOOP 24\\n\\\"];\\n24->27;\\n25[label=\\\"Node Type: END_LOOP 25\\n\\\"];\\n25->35;\\n26[label=\\\"Node Type: EXPRESSION 26\\n\\nEXPRESSION:\\ni = _mtkn.tokensCount()\\n\\nIRs:\\nTMP_85(uint256) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:tokensCount, arguments:[]  \\ni(uint256) := TMP_85(uint256)\\\"];\\n26->24;\\n27[label=\\\"Node Type: IF_LOOP 27\\n\\nEXPRESSION:\\ni > 0\\n\\nIRs:\\nTMP_86(bool) = i > 0\\nCONDITION TMP_86\\\"];\\n27->28[label=\\\"True\\\"];\\n27->25[label=\\\"False\\\"];\\n28[label=\\\"Node Type: NEW VARIABLE 28\\n\\nEXPRESSION:\\ntoken = _mtkn.tokens(i - 1)\\n\\nIRs:\\nTMP_87(uint256) = i - 1\\nTMP_88(ERC20) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:tokens, arguments:['TMP_87']  \\ntoken(ERC20) := TMP_88(ERC20)\\\"];\\n28->29;\\n29[label=\\\"Node Type: EXPRESSION 29\\n\\nEXPRESSION:\\ntoken.approve(_mtkn,token.balanceOf(this))\\n\\nIRs:\\nTMP_89(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  \\nTMP_90(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['_mtkn', 'TMP_89']  \\\"];\\n29->30;\\n30[label=\\\"Node Type: NEW VARIABLE 30\\n\\nEXPRESSION:\\namount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn))\\n\\nIRs:\\nTMP_91(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  \\nTMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['j', 'TMP_91'] \\nTMP_93(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['_mtkn']  \\nTMP_94(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_92', 'TMP_93'] \\namount(uint256) := TMP_94(uint256)\\\"];\\n30->31;\\n31[label=\\\"Node Type: IF 31\\n\\nEXPRESSION:\\namount < bestAmount\\n\\nIRs:\\nTMP_95(bool) = amount < bestAmount\\nCONDITION TMP_95\\\"];\\n31->32[label=\\\"True\\\"];\\n31->33[label=\\\"False\\\"];\\n32[label=\\\"Node Type: EXPRESSION 32\\n\\nEXPRESSION:\\nbestAmount = amount\\n\\nIRs:\\nbestAmount(uint256) := amount(uint256)\\\"];\\n32->33;\\n33[label=\\\"Node Type: END_IF 33\\n\\\"];\\n33->34;\\n34[label=\\\"Node Type: EXPRESSION 34\\n\\nEXPRESSION:\\ni --\\n\\nIRs:\\nTMP_96(uint256) := i(uint256)\\ni(uint256) = i - 1\\\"];\\n34->27;\\n35[label=\\\"Node Type: EXPRESSION 35\\n\\nEXPRESSION:\\nrequire(bool,string)(bestAmount >= _minimumReturn,buy: return value is too low)\\n\\nIRs:\\nTMP_97(bool) = bestAmount >= _minimumReturn\\nTMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,buy: return value is too low)\\\"];\\n35->36;\\n36[label=\\\"Node Type: EXPRESSION 36\\n\\nEXPRESSION:\\n_mtkn.bundle(msg.sender,bestAmount)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:bundle, arguments:['msg.sender', 'bestAmount']  \\\"];\\n36->37;\\n37[label=\\\"Node Type: IF 37\\n\\nEXPRESSION:\\naddress(this).balance > 0\\n\\nIRs:\\nTMP_100 = CONVERT this to address\\nTMP_101(uint256) = SOLIDITY_CALL balance(address)(TMP_100)\\nTMP_102(bool) = TMP_101 > 0\\nCONDITION TMP_102\\\"];\\n37->38[label=\\\"True\\\"];\\n37->39[label=\\\"False\\\"];\\n38[label=\\\"Node Type: EXPRESSION 38\\n\\nEXPRESSION:\\nmsg.sender.transfer(address(this).balance)\\n\\nIRs:\\nTMP_103 = CONVERT this to address\\nTMP_104(uint256) = SOLIDITY_CALL balance(address)(TMP_103)\\nTransfer dest:msg.sender value:TMP_104\\\"];\\n38->39;\\n39[label=\\\"Node Type: END_IF 39\\n\\\"];\\n}\\n// Function: 80.sol-MultiBuyer-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 80.sol-MultiBuyer-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_106(bool) = msg.sender == owner\\nTMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 80.sol-MultiBuyer-reclaimToken(ERC20Basic)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_43(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_43(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntoken.safeTransfer(owner,balance)\\n\\nIRs:\\nLIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', 'owner', 'balance'] \\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 80.sol-MultiBuyer-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_47 = CONVERT 0 to address\\nowner(address) := TMP_47(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 80.sol-MultiBuyer-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 80.sol-Ownable-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_23 = CONVERT 0 to address\\nTMP_24(bool) = _newOwner != TMP_23\\nTMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 80.sol-Ownable-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 80.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_27(bool) = msg.sender == owner\\nTMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 80.sol-Ownable-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_19 = CONVERT 0 to address\\nowner(address) := TMP_19(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 80.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 80.sol-SafeERC20-safeApprove(ERC20,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.approve(spender,value))\\n\\nIRs:\\nTMP_16(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['spender', 'value']  \\nTMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)\\\"];\\n}\\n// Function: 80.sol-SafeERC20-safeTransfer(ERC20Basic,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.transfer(to,value))\\n\\nIRs:\\nTMP_12(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['to', 'value']  \\nTMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)\\\"];\\n}\\n// Function: 80.sol-SafeERC20-safeTransferFrom(ERC20,address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.transferFrom(from,to,value))\\n\\nIRs:\\nTMP_14(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['from', 'to', 'value']  \\nTMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)\\\"];\\n}\\n// Function: 80.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 80.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 80.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 80.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Reentrancy\", \"Ether Strict Equality\"]"}]}
{"messages": [{"role": "system", "content": "You are an expert in identifying vulnerabilities in smart contracts."}, {"role": "user", "content": "{\"binarycode\": \"digraph G {\\n// Function: 81.sol-CanReclaimToken-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_34 = CONVERT 0 to address\\nTMP_35(bool) = _newOwner != TMP_34\\nTMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 81.sol-CanReclaimToken-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 81.sol-CanReclaimToken-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_41(bool) = msg.sender == owner\\nTMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 81.sol-CanReclaimToken-reclaimToken(ERC20Basic)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_38(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_38(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntoken.safeTransfer(owner,balance)\\n\\nIRs:\\nLIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', 'owner', 'balance'] \\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 81.sol-CanReclaimToken-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_30 = CONVERT 0 to address\\nowner(address) := TMP_30(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 81.sol-CanReclaimToken-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 81.sol-ERC20-allowance(address,address)\\ndigraph{\\n}\\n// Function: 81.sol-ERC20-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-ERC20-balanceOf(address)\\ndigraph{\\n}\\n// Function: 81.sol-ERC20-totalSupply()\\ndigraph{\\n}\\n// Function: 81.sol-ERC20-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-ERC20-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-ERC20Basic-balanceOf(address)\\ndigraph{\\n}\\n// Function: 81.sol-ERC20Basic-totalSupply()\\ndigraph{\\n}\\n// Function: 81.sol-ERC20Basic-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-allBalances()\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-allDecimals()\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-allTokens()\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-allTokensDecimalsBalances()\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-bundle(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-bundleFirstTokens(address,uint256,uint256[])\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-tokens(uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-tokensCount()\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-totalSupply()\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-unbundle(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IBasicMultiToken-unbundleSome(address,uint256,ERC20[])\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-allBalances()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-allDecimals()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-allTokens()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-allTokensDecimalsBalances()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-allTokensDecimalsBalancesWeights()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-allWeights()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-allowance(address,address)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-approve(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-balanceOf(address)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-bundle(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-bundleFirstTokens(address,uint256,uint256[])\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-change(address,address,uint256,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-getReturn(address,address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-tokens(uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-tokensCount()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-totalSupply()\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-transfer(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-transferFrom(address,address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-unbundle(address,uint256)\\ndigraph{\\n}\\n// Function: 81.sol-IMultiToken-unbundleSome(address,uint256,ERC20[])\\ndigraph{\\n}\\n// Function: 81.sol-MultiBuyer-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_51 = CONVERT 0 to address\\nTMP_52(bool) = _newOwner != TMP_51\\nTMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 81.sol-MultiBuyer-buy(IMultiToken,uint256,ERC20,address[],bytes,uint256[],uint256[])\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool,string)(_datasIndexes.length == _exchanges.length + 1,buy: _datasIndexes should start with 0 and end with LENGTH)\\n\\nIRs:\\nREF_7 -> LENGTH _datasIndexes\\nREF_8 -> LENGTH _exchanges\\nTMP_55(uint256) = REF_8 + 1\\nTMP_56(bool) = REF_7 == TMP_55\\nTMP_57(None) = SOLIDITY_CALL require(bool,string)(TMP_56,buy: _datasIndexes should start with 0 and end with LENGTH)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nrequire(bool,string)(_values.length == _exchanges.length,buy: _values should have the same length as _exchanges)\\n\\nIRs:\\nREF_9 -> LENGTH _values\\nREF_10 -> LENGTH _exchanges\\nTMP_58(bool) = REF_9 == REF_10\\nTMP_59(None) = SOLIDITY_CALL require(bool,string)(TMP_58,buy: _values should have the same length as _exchanges)\\\"];\\n2->5;\\n3[label=\\\"Node Type: BEGIN_LOOP 3\\n\\\"];\\n3->6;\\n4[label=\\\"Node Type: END_LOOP 4\\n\\\"];\\n4->22;\\n5[label=\\\"Node Type: NEW VARIABLE 5\\n\\nEXPRESSION:\\ni = 0\\n\\nIRs:\\ni(uint256) := 0(uint256)\\\"];\\n5->3;\\n6[label=\\\"Node Type: IF_LOOP 6\\n\\nEXPRESSION:\\ni < _exchanges.length\\n\\nIRs:\\nREF_11 -> LENGTH _exchanges\\nTMP_60(bool) = i < REF_11\\nCONDITION TMP_60\\\"];\\n6->7[label=\\\"True\\\"];\\n6->4[label=\\\"False\\\"];\\n7[label=\\\"Node Type: NEW VARIABLE 7\\n\\nEXPRESSION:\\ndata = new bytes(_datasIndexes[i + 1] - _datasIndexes[i])\\n\\nIRs:\\nTMP_62(uint256) = i + 1\\nREF_12(uint256) -> _datasIndexes[TMP_62]\\nREF_13(uint256) -> _datasIndexes[i]\\nTMP_63(uint256) = REF_12 - REF_13\\nTMP_64 = new bytes(TMP_63)\\ndata(bytes) := TMP_64(bytes)\\\"];\\n7->10;\\n8[label=\\\"Node Type: BEGIN_LOOP 8\\n\\\"];\\n8->11;\\n9[label=\\\"Node Type: END_LOOP 9\\n\\\"];\\n9->14;\\n10[label=\\\"Node Type: NEW VARIABLE 10\\n\\nEXPRESSION:\\nj = _datasIndexes[i]\\n\\nIRs:\\nREF_14(uint256) -> _datasIndexes[i]\\nj(uint256) := REF_14(uint256)\\\"];\\n10->8;\\n11[label=\\\"Node Type: IF_LOOP 11\\n\\nEXPRESSION:\\nj < _datasIndexes[i + 1]\\n\\nIRs:\\nTMP_65(uint256) = i + 1\\nREF_15(uint256) -> _datasIndexes[TMP_65]\\nTMP_66(bool) = j < REF_15\\nCONDITION TMP_66\\\"];\\n11->12[label=\\\"True\\\"];\\n11->9[label=\\\"False\\\"];\\n12[label=\\\"Node Type: EXPRESSION 12\\n\\nEXPRESSION:\\ndata[j - _datasIndexes[i]] = _datas[j]\\n\\nIRs:\\nREF_16(uint256) -> _datasIndexes[i]\\nTMP_67(uint256) = j - REF_16\\nREF_17(None) -> data[TMP_67]\\nREF_18(None) -> _datas[j]\\nREF_17(None) (->data) := REF_18(None)\\\"];\\n12->13;\\n13[label=\\\"Node Type: EXPRESSION 13\\n\\nEXPRESSION:\\nj ++\\n\\nIRs:\\nTMP_68(uint256) := j(uint256)\\nj(uint256) = j + 1\\\"];\\n13->11;\\n14[label=\\\"Node Type: IF 14\\n\\nEXPRESSION:\\n_throughToken != address(0) && i > 0\\n\\nIRs:\\nTMP_69 = CONVERT 0 to address\\nTMP_70(bool) = _throughToken != TMP_69\\nTMP_71(bool) = i > 0\\nTMP_72(bool) = TMP_70 && TMP_71\\nCONDITION TMP_72\\\"];\\n14->15[label=\\\"True\\\"];\\n14->16[label=\\\"False\\\"];\\n15[label=\\\"Node Type: EXPRESSION 15\\n\\nEXPRESSION:\\n_throughToken.approve(_exchanges[i],_throughToken.balanceOf(this))\\n\\nIRs:\\nREF_20(address) -> _exchanges[i]\\nTMP_73(uint256) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:balanceOf, arguments:['this']  \\nTMP_74(bool) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:approve, arguments:['REF_20', 'TMP_73']  \\\"];\\n15->16;\\n16[label=\\\"Node Type: END_IF 16\\n\\\"];\\n16->17;\\n17[label=\\\"Node Type: EXPRESSION 17\\n\\nEXPRESSION:\\nrequire(bool,string)(_exchanges[i].call.value(_values[i])(data),buy: exchange arbitrary call failed)\\n\\nIRs:\\nREF_22(address) -> _exchanges[i]\\nREF_25(uint256) -> _values[i]\\nTMP_76(bool) = LOW_LEVEL_CALL, dest:REF_22, function:call, arguments:['data'] value:REF_25 \\nTMP_77(None) = SOLIDITY_CALL require(bool,string)(TMP_76,buy: exchange arbitrary call failed)\\\"];\\n17->18;\\n18[label=\\\"Node Type: IF 18\\n\\nEXPRESSION:\\n_throughToken != address(0)\\n\\nIRs:\\nTMP_78 = CONVERT 0 to address\\nTMP_79(bool) = _throughToken != TMP_78\\nCONDITION TMP_79\\\"];\\n18->19[label=\\\"True\\\"];\\n18->20[label=\\\"False\\\"];\\n19[label=\\\"Node Type: EXPRESSION 19\\n\\nEXPRESSION:\\n_throughToken.approve(_exchanges[i],0)\\n\\nIRs:\\nREF_27(address) -> _exchanges[i]\\nTMP_80(bool) = HIGH_LEVEL_CALL, dest:_throughToken(ERC20), function:approve, arguments:['REF_27', '0']  \\\"];\\n19->20;\\n20[label=\\\"Node Type: END_IF 20\\n\\\"];\\n20->21;\\n21[label=\\\"Node Type: EXPRESSION 21\\n\\nEXPRESSION:\\ni ++\\n\\nIRs:\\nTMP_81(uint256) := i(uint256)\\ni(uint256) = i + 1\\\"];\\n21->6;\\n22[label=\\\"Node Type: EXPRESSION 22\\n\\nEXPRESSION:\\nj = _mtkn.totalSupply()\\n\\nIRs:\\nTMP_82(uint256) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:totalSupply, arguments:[]  \\nj(uint256) := TMP_82(uint256)\\\"];\\n22->23;\\n23[label=\\\"Node Type: NEW VARIABLE 23\\n\\nEXPRESSION:\\nbestAmount = uint256(- 1)\\n\\nIRs:\\nTMP_83(uint256) = 0 - 1\\nTMP_84 = CONVERT TMP_83 to uint256\\nbestAmount(uint256) := TMP_84(uint256)\\\"];\\n23->26;\\n24[label=\\\"Node Type: BEGIN_LOOP 24\\n\\\"];\\n24->27;\\n25[label=\\\"Node Type: END_LOOP 25\\n\\\"];\\n25->35;\\n26[label=\\\"Node Type: EXPRESSION 26\\n\\nEXPRESSION:\\ni = _mtkn.tokensCount()\\n\\nIRs:\\nTMP_85(uint256) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:tokensCount, arguments:[]  \\ni(uint256) := TMP_85(uint256)\\\"];\\n26->24;\\n27[label=\\\"Node Type: IF_LOOP 27\\n\\nEXPRESSION:\\ni > 0\\n\\nIRs:\\nTMP_86(bool) = i > 0\\nCONDITION TMP_86\\\"];\\n27->28[label=\\\"True\\\"];\\n27->25[label=\\\"False\\\"];\\n28[label=\\\"Node Type: NEW VARIABLE 28\\n\\nEXPRESSION:\\ntoken = _mtkn.tokens(i - 1)\\n\\nIRs:\\nTMP_87(uint256) = i - 1\\nTMP_88(ERC20) = HIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:tokens, arguments:['TMP_87']  \\ntoken(ERC20) := TMP_88(ERC20)\\\"];\\n28->29;\\n29[label=\\\"Node Type: EXPRESSION 29\\n\\nEXPRESSION:\\ntoken.approve(_mtkn,token.balanceOf(this))\\n\\nIRs:\\nTMP_89(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  \\nTMP_90(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['_mtkn', 'TMP_89']  \\\"];\\n29->30;\\n30[label=\\\"Node Type: NEW VARIABLE 30\\n\\nEXPRESSION:\\namount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn))\\n\\nIRs:\\nTMP_91(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  \\nTMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['j', 'TMP_91'] \\nTMP_93(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['_mtkn']  \\nTMP_94(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_92', 'TMP_93'] \\namount(uint256) := TMP_94(uint256)\\\"];\\n30->31;\\n31[label=\\\"Node Type: IF 31\\n\\nEXPRESSION:\\namount < bestAmount\\n\\nIRs:\\nTMP_95(bool) = amount < bestAmount\\nCONDITION TMP_95\\\"];\\n31->32[label=\\\"True\\\"];\\n31->33[label=\\\"False\\\"];\\n32[label=\\\"Node Type: EXPRESSION 32\\n\\nEXPRESSION:\\nbestAmount = amount\\n\\nIRs:\\nbestAmount(uint256) := amount(uint256)\\\"];\\n32->33;\\n33[label=\\\"Node Type: END_IF 33\\n\\\"];\\n33->34;\\n34[label=\\\"Node Type: EXPRESSION 34\\n\\nEXPRESSION:\\ni --\\n\\nIRs:\\nTMP_96(uint256) := i(uint256)\\ni(uint256) = i - 1\\\"];\\n34->27;\\n35[label=\\\"Node Type: EXPRESSION 35\\n\\nEXPRESSION:\\nrequire(bool,string)(bestAmount >= _minimumReturn,buy: return value is too low)\\n\\nIRs:\\nTMP_97(bool) = bestAmount >= _minimumReturn\\nTMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,buy: return value is too low)\\\"];\\n35->36;\\n36[label=\\\"Node Type: EXPRESSION 36\\n\\nEXPRESSION:\\n_mtkn.bundle(msg.sender,bestAmount)\\n\\nIRs:\\nHIGH_LEVEL_CALL, dest:_mtkn(IMultiToken), function:bundle, arguments:['msg.sender', 'bestAmount']  \\\"];\\n36->37;\\n37[label=\\\"Node Type: IF 37\\n\\nEXPRESSION:\\naddress(this).balance > 0\\n\\nIRs:\\nTMP_100 = CONVERT this to address\\nTMP_101(uint256) = SOLIDITY_CALL balance(address)(TMP_100)\\nTMP_102(bool) = TMP_101 > 0\\nCONDITION TMP_102\\\"];\\n37->38[label=\\\"True\\\"];\\n37->39[label=\\\"False\\\"];\\n38[label=\\\"Node Type: EXPRESSION 38\\n\\nEXPRESSION:\\nmsg.sender.transfer(address(this).balance)\\n\\nIRs:\\nTMP_103 = CONVERT this to address\\nTMP_104(uint256) = SOLIDITY_CALL balance(address)(TMP_103)\\nTransfer dest:msg.sender value:TMP_104\\\"];\\n38->39;\\n39[label=\\\"Node Type: END_IF 39\\n\\\"];\\n}\\n// Function: 81.sol-MultiBuyer-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 81.sol-MultiBuyer-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_106(bool) = msg.sender == owner\\nTMP_107(None) = SOLIDITY_CALL require(bool)(TMP_106)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 81.sol-MultiBuyer-reclaimToken(ERC20Basic)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: NEW VARIABLE 1\\n\\nEXPRESSION:\\nbalance = token.balanceOf(this)\\n\\nIRs:\\nTMP_43(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  \\nbalance(uint256) := TMP_43(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\ntoken.safeTransfer(owner,balance)\\n\\nIRs:\\nLIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransfer(ERC20Basic,address,uint256), arguments:['token', 'owner', 'balance'] \\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 81.sol-MultiBuyer-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_47 = CONVERT 0 to address\\nowner(address) := TMP_47(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 81.sol-MultiBuyer-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 81.sol-Ownable-_transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(_newOwner != address(0))\\n\\nIRs:\\nTMP_23 = CONVERT 0 to address\\nTMP_24(bool) = _newOwner != TMP_23\\nTMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nOwnershipTransferred(owner,_newOwner)\\n\\nIRs:\\nEmit OwnershipTransferred(owner,_newOwner)\\\"];\\n2->3;\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nowner = _newOwner\\n\\nIRs:\\nowner(address) := _newOwner(address)\\\"];\\n}\\n// Function: 81.sol-Ownable-constructor()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nowner = msg.sender\\n\\nIRs:\\nowner(address) := msg.sender(address)\\\"];\\n}\\n// Function: 81.sol-Ownable-onlyOwner()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(msg.sender == owner)\\n\\nIRs:\\nTMP_27(bool) = msg.sender == owner\\nTMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)\\\"];\\n1->2;\\n2[label=\\\"Node Type: _ 2\\n\\\"];\\n}\\n// Function: 81.sol-Ownable-renounceOwnership()\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->3;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nOwnershipRenounced(owner)\\n\\nIRs:\\nEmit OwnershipRenounced(owner)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nowner = address(0)\\n\\nIRs:\\nTMP_19 = CONVERT 0 to address\\nowner(address) := TMP_19(address)\\\"];\\n3[label=\\\"Node Type: EXPRESSION 3\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n3->1;\\n}\\n// Function: 81.sol-Ownable-transferOwnership(address)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->2;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\n_transferOwnership(_newOwner)\\n\\nIRs:\\nINTERNAL_CALL, Ownable._transferOwnership(address)(_newOwner)\\\"];\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nonlyOwner()\\n\\nIRs:\\nMODIFIER_CALL, Ownable.onlyOwner()()\\\"];\\n2->1;\\n}\\n// Function: 81.sol-SafeERC20-safeApprove(ERC20,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.approve(spender,value))\\n\\nIRs:\\nTMP_16(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:approve, arguments:['spender', 'value']  \\nTMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)\\\"];\\n}\\n// Function: 81.sol-SafeERC20-safeTransfer(ERC20Basic,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.transfer(to,value))\\n\\nIRs:\\nTMP_12(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['to', 'value']  \\nTMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)\\\"];\\n}\\n// Function: 81.sol-SafeERC20-safeTransferFrom(ERC20,address,address,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nrequire(bool)(token.transferFrom(from,to,value))\\n\\nIRs:\\nTMP_14(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['from', 'to', 'value']  \\nTMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)\\\"];\\n}\\n// Function: 81.sol-SafeMath-add(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nc = a + b\\n\\nIRs:\\nTMP_9(uint256) = a + b\\nc(uint256) := TMP_9(uint256)\\\"];\\n1->2;\\n2[label=\\\"Node Type: EXPRESSION 2\\n\\nEXPRESSION:\\nassert(bool)(c >= a)\\n\\nIRs:\\nTMP_10(bool) = c >= a\\nTMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)\\\"];\\n2->3;\\n3[label=\\\"Node Type: RETURN 3\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n4[label=\\\"Node Type: RETURN 4\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 81.sol-SafeMath-div(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: RETURN 1\\n\\nEXPRESSION:\\na / b\\n\\nIRs:\\nTMP_5(uint256) = a / b\\nRETURN TMP_5\\\"];\\n}\\n// Function: 81.sol-SafeMath-mul(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: IF 1\\n\\nEXPRESSION:\\na == 0\\n\\nIRs:\\nTMP_0(bool) = a == 0\\nCONDITION TMP_0\\\"];\\n1->2[label=\\\"True\\\"];\\n1->3[label=\\\"False\\\"];\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\n0\\n\\nIRs:\\nRETURN 0\\\"];\\n3[label=\\\"Node Type: END_IF 3\\n\\\"];\\n3->4;\\n4[label=\\\"Node Type: EXPRESSION 4\\n\\nEXPRESSION:\\nc = a * b\\n\\nIRs:\\nTMP_1(uint256) = a * b\\nc(uint256) := TMP_1(uint256)\\\"];\\n4->5;\\n5[label=\\\"Node Type: EXPRESSION 5\\n\\nEXPRESSION:\\nassert(bool)(c / a == b)\\n\\nIRs:\\nTMP_2(uint256) = c / a\\nTMP_3(bool) = TMP_2 == b\\nTMP_4(None) = SOLIDITY_CALL assert(bool)(TMP_3)\\\"];\\n5->6;\\n6[label=\\\"Node Type: RETURN 6\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n7[label=\\\"Node Type: RETURN 7\\n\\nEXPRESSION:\\nc\\n\\nIRs:\\nRETURN c\\\"];\\n}\\n// Function: 81.sol-SafeMath-sub(uint256,uint256)\\ndigraph{\\n0[label=\\\"Node Type: ENTRY_POINT 0\\n\\\"];\\n0->1;\\n1[label=\\\"Node Type: EXPRESSION 1\\n\\nEXPRESSION:\\nassert(bool)(b <= a)\\n\\nIRs:\\nTMP_6(bool) = b <= a\\nTMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)\\\"];\\n1->2;\\n2[label=\\\"Node Type: RETURN 2\\n\\nEXPRESSION:\\na - b\\n\\nIRs:\\nTMP_8(uint256) = a - b\\nRETURN TMP_8\\\"];\\n}\\n}\\n\"}"}, {"role": "assistant", "content": "[\"Reentrancy\", \"Ether Strict Equality\"]"}]}
